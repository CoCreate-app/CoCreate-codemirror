/*! For license information please see CoCreate-codemirror.js.LICENSE.txt */
!function(n,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.CoCreate=t():(n.CoCreate=n.CoCreate||{},n.CoCreate.codemirror=t())}(this,(function(){return(()=>{var __webpack_modules__={"./node_modules/@cocreate/action/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// -testing1\nconst CoCreateAction = {\n  attribute: 'data-actions',\n  actions: {},\n  selectedStage: [],\n  stageIndex: 0,\n  selectedElement: null,\n  \n  completedEventName: 'completedEvent',\n  \n  __init: function() {\n    this.actionButtonEvent()\n  },\n\n  actionButtonEvent: function() {\n    const self = this;\n    document.addEventListener('click', function(event) {\n      let btn = event.target;\n      if (!btn.getAttribute('data-actions')) {\n        btn = event.target.closest('[data-actions]');\n      }\n      if (!btn) return;\n      event.preventDefault();\n\n      let actions = (btn.getAttribute(self.attribute) || \"\").replace(/\\s/g, '').split(',');\n      if (actions.length == 0) return;\n      self.stageIndex = 0;\n      self.selectedStage = actions;\n      \n      //. run function\n      self.selectedElement = btn;\n      self.__runActionFunc();\n    })\n  },\n  \n  init: function({action, callback, endEvent}) {\n    this.registerEvent(action, callback, null, endEvent);\n  },\n  \n  /**\n   * key: string\n   * runFunc: function\n   * instance: object\n   * endEvent: string\n   **/\n  registerEvent: function(key, runFunc, instance, endEvent) {\n    if (this.actions[key]) {\n      return;\n    }\n    \n    this.actions[key] = {\n      key: key,\n      runFunc: runFunc,\n      instance: instance || window,\n      endEvent: endEvent\n    }\n    //. register events\n    \n    for (let __key in this.actions) {\n      if (__key != key && this.actions[__key]['endEvent'] === endEvent) {\n        return;\n      }\n    }\n    \n    //. register events\n    const _this = this;\n    document.addEventListener(endEvent, function(e) {\n      _this.__nextAction(endEvent, e.detail)\n    });\n  },\n  \n  __runActionFunc: function(data) {\n\n    if (this.stageIndex >= this.selectedStage.length) {\n\n      //. if latest case, it will be run aTag\n      if (this.stageIndex == this.selectedStage.length) {\n        this.__runAtag(this.selectedElement);        \n      }\n      return;\n    }\n    \n    const actionName = this.selectedStage[this.stageIndex];\n    //. run function\n    const action = this.actions[actionName];\n    if (action) {\n      if (action.runFunc) {\n        action.runFunc.call(null, this.selectedElement, data);\n      } else {\n        this.__nextAction(action.endEvent, {});\n      }\n    } else {\n      let status = this.__runSpecialAction(actionName, data);\n      if (status === \"next\") {\n        this.__moveNextAction();\n      }\n    }\n  },\n  \n  __nextAction: function(eventName, data) {\n    const key = this.selectedStage[this.stageIndex];\n    if (!key) {\n      return ;\n    }\n    if (eventName !== this.actions[key].endEvent) {\n      return;\n    }\n    this.__moveNextAction(data);\n  },\n  \n  __runAtag: function(button) {\n    var aTag = button.querySelector('a');\n          \n    if (aTag) {\n      // CoCreate.logic.setLinkProcess(aTag)\n    }\n  },\n  \n  //. special action\n  \n  __runSpecialAction: function(actionName, data) {\n    let matches = /(\\w+)\\{([a-zA-Z0-9_ \\-#$.]+)\\}/gm.exec(actionName)\n    \n    if (!matches || matches.length < 3) {\n      return \"next\";\n    }\n    \n    let type = matches[1], param = matches[2].trim()\n    if (!param) return \"next\";\n    \n    const self = this;\n    switch (type) {\n      case 'event':\n        console.log(\"Waiting Event....\");\n        document.addEventListener(param, (eventData) => {\n          console.log('Event Action (Received event from other section) ====== ' + param);\n          self.__moveNextAction(eventData);\n        }, { once: true })\n        break;\n      case 'timeout':\n        let delayTime = parseInt(param);\n        if (delayTime > 0) {\n          setTimeout(function() {\n            console.log(\"Timeout ======= \" + param)\n            self.__moveNextAction(data);\n          }, parseInt(param));\n        }\n        break;\n      case 'action':\n        let btn = document.querySelector(param);\n        if (btn) {\n          btn.click();\n        }\n        break;\n      default:\n        return \"next\";\n    }\n  },\n  \n  __moveNextAction: function(data) {\n    this.stageIndex ++;\n    this.__runActionFunc(data);\n  },\n}\n\n\nCoCreateAction.__init();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateAction);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9hY3Rpb24vc3JjL2luZGV4LmpzP2RjNDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVILGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDZDQUE2QztBQUM3QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLDBCQUEwQix1QkFBdUI7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQSxpRUFBZSxjQUFjIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9hY3Rpb24vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gLXRlc3RpbmcxXG5jb25zdCBDb0NyZWF0ZUFjdGlvbiA9IHtcbiAgYXR0cmlidXRlOiAnZGF0YS1hY3Rpb25zJyxcbiAgYWN0aW9uczoge30sXG4gIHNlbGVjdGVkU3RhZ2U6IFtdLFxuICBzdGFnZUluZGV4OiAwLFxuICBzZWxlY3RlZEVsZW1lbnQ6IG51bGwsXG4gIFxuICBjb21wbGV0ZWRFdmVudE5hbWU6ICdjb21wbGV0ZWRFdmVudCcsXG4gIFxuICBfX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWN0aW9uQnV0dG9uRXZlbnQoKVxuICB9LFxuXG4gIGFjdGlvbkJ1dHRvbkV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBsZXQgYnRuID0gZXZlbnQudGFyZ2V0O1xuICAgICAgaWYgKCFidG4uZ2V0QXR0cmlidXRlKCdkYXRhLWFjdGlvbnMnKSkge1xuICAgICAgICBidG4gPSBldmVudC50YXJnZXQuY2xvc2VzdCgnW2RhdGEtYWN0aW9uc10nKTtcbiAgICAgIH1cbiAgICAgIGlmICghYnRuKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBsZXQgYWN0aW9ucyA9IChidG4uZ2V0QXR0cmlidXRlKHNlbGYuYXR0cmlidXRlKSB8fCBcIlwiKS5yZXBsYWNlKC9cXHMvZywgJycpLnNwbGl0KCcsJyk7XG4gICAgICBpZiAoYWN0aW9ucy5sZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgc2VsZi5zdGFnZUluZGV4ID0gMDtcbiAgICAgIHNlbGYuc2VsZWN0ZWRTdGFnZSA9IGFjdGlvbnM7XG4gICAgICBcbiAgICAgIC8vLiBydW4gZnVuY3Rpb25cbiAgICAgIHNlbGYuc2VsZWN0ZWRFbGVtZW50ID0gYnRuO1xuICAgICAgc2VsZi5fX3J1bkFjdGlvbkZ1bmMoKTtcbiAgICB9KVxuICB9LFxuICBcbiAgaW5pdDogZnVuY3Rpb24oe2FjdGlvbiwgY2FsbGJhY2ssIGVuZEV2ZW50fSkge1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudChhY3Rpb24sIGNhbGxiYWNrLCBudWxsLCBlbmRFdmVudCk7XG4gIH0sXG4gIFxuICAvKipcbiAgICoga2V5OiBzdHJpbmdcbiAgICogcnVuRnVuYzogZnVuY3Rpb25cbiAgICogaW5zdGFuY2U6IG9iamVjdFxuICAgKiBlbmRFdmVudDogc3RyaW5nXG4gICAqKi9cbiAgcmVnaXN0ZXJFdmVudDogZnVuY3Rpb24oa2V5LCBydW5GdW5jLCBpbnN0YW5jZSwgZW5kRXZlbnQpIHtcbiAgICBpZiAodGhpcy5hY3Rpb25zW2tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5hY3Rpb25zW2tleV0gPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJ1bkZ1bmM6IHJ1bkZ1bmMsXG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UgfHwgd2luZG93LFxuICAgICAgZW5kRXZlbnQ6IGVuZEV2ZW50XG4gICAgfVxuICAgIC8vLiByZWdpc3RlciBldmVudHNcbiAgICBcbiAgICBmb3IgKGxldCBfX2tleSBpbiB0aGlzLmFjdGlvbnMpIHtcbiAgICAgIGlmIChfX2tleSAhPSBrZXkgJiYgdGhpcy5hY3Rpb25zW19fa2V5XVsnZW5kRXZlbnQnXSA9PT0gZW5kRXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLy4gcmVnaXN0ZXIgZXZlbnRzXG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZW5kRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIF90aGlzLl9fbmV4dEFjdGlvbihlbmRFdmVudCwgZS5kZXRhaWwpXG4gICAgfSk7XG4gIH0sXG4gIFxuICBfX3J1bkFjdGlvbkZ1bmM6IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIGlmICh0aGlzLnN0YWdlSW5kZXggPj0gdGhpcy5zZWxlY3RlZFN0YWdlLmxlbmd0aCkge1xuXG4gICAgICAvLy4gaWYgbGF0ZXN0IGNhc2UsIGl0IHdpbGwgYmUgcnVuIGFUYWdcbiAgICAgIGlmICh0aGlzLnN0YWdlSW5kZXggPT0gdGhpcy5zZWxlY3RlZFN0YWdlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9fcnVuQXRhZyh0aGlzLnNlbGVjdGVkRWxlbWVudCk7ICAgICAgICBcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgYWN0aW9uTmFtZSA9IHRoaXMuc2VsZWN0ZWRTdGFnZVt0aGlzLnN0YWdlSW5kZXhdO1xuICAgIC8vLiBydW4gZnVuY3Rpb25cbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgaWYgKGFjdGlvbi5ydW5GdW5jKSB7XG4gICAgICAgIGFjdGlvbi5ydW5GdW5jLmNhbGwobnVsbCwgdGhpcy5zZWxlY3RlZEVsZW1lbnQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX25leHRBY3Rpb24oYWN0aW9uLmVuZEV2ZW50LCB7fSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBzdGF0dXMgPSB0aGlzLl9fcnVuU3BlY2lhbEFjdGlvbihhY3Rpb25OYW1lLCBkYXRhKTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIHRoaXMuX19tb3ZlTmV4dEFjdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXG4gIF9fbmV4dEFjdGlvbjogZnVuY3Rpb24oZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5zZWxlY3RlZFN0YWdlW3RoaXMuc3RhZ2VJbmRleF07XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiA7XG4gICAgfVxuICAgIGlmIChldmVudE5hbWUgIT09IHRoaXMuYWN0aW9uc1trZXldLmVuZEV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19tb3ZlTmV4dEFjdGlvbihkYXRhKTtcbiAgfSxcbiAgXG4gIF9fcnVuQXRhZzogZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgdmFyIGFUYWcgPSBidXR0b24ucXVlcnlTZWxlY3RvcignYScpO1xuICAgICAgICAgIFxuICAgIGlmIChhVGFnKSB7XG4gICAgICAvLyBDb0NyZWF0ZS5sb2dpYy5zZXRMaW5rUHJvY2VzcyhhVGFnKVxuICAgIH1cbiAgfSxcbiAgXG4gIC8vLiBzcGVjaWFsIGFjdGlvblxuICBcbiAgX19ydW5TcGVjaWFsQWN0aW9uOiBmdW5jdGlvbihhY3Rpb25OYW1lLCBkYXRhKSB7XG4gICAgbGV0IG1hdGNoZXMgPSAvKFxcdyspXFx7KFthLXpBLVowLTlfIFxcLSMkLl0rKVxcfS9nbS5leGVjKGFjdGlvbk5hbWUpXG4gICAgXG4gICAgaWYgKCFtYXRjaGVzIHx8IG1hdGNoZXMubGVuZ3RoIDwgMykge1xuICAgICAgcmV0dXJuIFwibmV4dFwiO1xuICAgIH1cbiAgICBcbiAgICBsZXQgdHlwZSA9IG1hdGNoZXNbMV0sIHBhcmFtID0gbWF0Y2hlc1syXS50cmltKClcbiAgICBpZiAoIXBhcmFtKSByZXR1cm4gXCJuZXh0XCI7XG4gICAgXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdldmVudCc6XG4gICAgICAgIGNvbnNvbGUubG9nKFwiV2FpdGluZyBFdmVudC4uLi5cIik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIocGFyYW0sIChldmVudERhdGEpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRXZlbnQgQWN0aW9uIChSZWNlaXZlZCBldmVudCBmcm9tIG90aGVyIHNlY3Rpb24pID09PT09PSAnICsgcGFyYW0pO1xuICAgICAgICAgIHNlbGYuX19tb3ZlTmV4dEFjdGlvbihldmVudERhdGEpO1xuICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aW1lb3V0JzpcbiAgICAgICAgbGV0IGRlbGF5VGltZSA9IHBhcnNlSW50KHBhcmFtKTtcbiAgICAgICAgaWYgKGRlbGF5VGltZSA+IDApIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJUaW1lb3V0ID09PT09PT0gXCIgKyBwYXJhbSlcbiAgICAgICAgICAgIHNlbGYuX19tb3ZlTmV4dEFjdGlvbihkYXRhKTtcbiAgICAgICAgICB9LCBwYXJzZUludChwYXJhbSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWN0aW9uJzpcbiAgICAgICAgbGV0IGJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW0pO1xuICAgICAgICBpZiAoYnRuKSB7XG4gICAgICAgICAgYnRuLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJuZXh0XCI7XG4gICAgfVxuICB9LFxuICBcbiAgX19tb3ZlTmV4dEFjdGlvbjogZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMuc3RhZ2VJbmRleCArKztcbiAgICB0aGlzLl9fcnVuQWN0aW9uRnVuYyhkYXRhKTtcbiAgfSxcbn1cblxuXG5Db0NyZWF0ZUFjdGlvbi5fX2luaXQoKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVBY3Rpb247Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/action/src/index.js\n")},"./node_modules/@cocreate/crdt/src/core.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var y_websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-websocket */ \"./node_modules/y-websocket/src/y-websocket.js\");\n/* harmony import */ var y_indexeddb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-indexeddb */ \"./node_modules/y-indexeddb/src/y-indexeddb.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _cocreate_cursors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/cursors */ \"./node_modules/@cocreate/cursors/src/index.js\");\n\n\n\n\n\n\nconst debug = false;\n\nclass CoCreateYSocket {\n\tconstructor(org, ydoc) {\n\t\tthis.doc = ydoc;\n\t\tthis.orgName = org;\n\t\tthis.docs = {};\n\t\tthis._awarenessListener = null;\n\t\tthis.character = '_';\n\t\tthis.listenAwereness = function(){}\n\t}\n\t\n\tcreateDoc(id, element) {\n\t\tif (!id || id == \"\") {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tlet newInfo = this.parseType(id)\n\t\t// if(debug)\n\t\t// \tconsole.log(newInfo);\n\t\t\n\t\tconst newId = newInfo.id;\n\t\t\n\t\tif (this.docs[newId]) { \n\t\t\tif (element && !this.__checkExistElement(this.docs[newId].elements, element)) {\n\t\t\t\tthis.docs[newId].elements.push(element);\n\t\t\t}\n\n\t\t\tif (!this.docs[newId].types.some((type) => type === id)) {\n\t\t\t\t// register event\n\t\t\t\tthis.docs[newId].types.push(id);\n\t\t\t\tthis.registerUpdateEvent(this.docs[newId], id)\n\t\t\t\t\n\t\t\t}\n\t\t\treturn false;\n\t\t} \n\t\t\n\t\tconst yDoc = this.doc\n\t\t\n\t\tconst url_socket = this.__getSocketUrl();\n\t\t//draw cursor dinamially\n\t\t// new UserCursor(socketProvider);\n\n\t\t\t\n\t\tvar socketProvider = new y_websocket__WEBPACK_IMPORTED_MODULE_2__.WebsocketProvider(url_socket, newId, yDoc);\n\t\tlet indexeddbProvider = null;\n\t\tif (newInfo.document_id != \"null\") {\n\t\t\tindexeddbProvider = new y_indexeddb__WEBPACK_IMPORTED_MODULE_3__.IndexeddbPersistence(newId, this.doc)\n\t\t\tindexeddbProvider.whenSynced.then(() => {\n\t\t\t  console.log('loaded data from indexed db')\n\t\t\t})\n\t\t}\t\n\t\t\n\t\tlet awareness = socketProvider.awareness;\n\t\t\n\t\tthis._cursors = new Map();\n\t\t\n\t\tthis._awarenessListener = event => {\n\t\t  const f = clientId => {\n\t\t\tif (clientId !== this.doc.clientID) {\n\t\t\t  this.updateRemoteSelection(yDoc, id, yDoc.getText(id), this._cursors, clientId, awareness)\n\t\t\t}\n\t\t  }\n\t\t  event.added.forEach(f)\n\t\t  event.removed.forEach(f)\n\t\t  event.updated.forEach(f)\n\t\t}\n\t\t\n\t\tawareness.on('change', this._awarenessListener);\n\t\t/*\n\t\tawareness.getStates().forEach((aw, clientId) => {\n\t\t\tconsole.log(\"Update --\")\n        })\n        */\n        \n        this.docs[newId] = {\n\t\t\tid: newId,\n\t\t\tdoc: yDoc,\n\t\t\tsocket: socketProvider,\n\t\t\tawareness: awareness,\n\t\t\telements: element ? [element] : [],\n\t\t\ttypes: [id],\n\t\t\tindexeddb: indexeddbProvider\n\t\t}\n\t\tthis.registerUpdateEvent(this.docs[newId], id)\n\n\t\treturn true;\n\t}\n\t\n\tregisterUpdateEvent(docObject, id) {\n\t\tconst yDoc = docObject.doc;\n\t\tconst shardType = yDoc.getText(id)\n\t\tlet _this = this;\n\t\t\n\t\tshardType.observe((event) => {\n\t\t\t_this.__setTypeObserveEvent(event, docObject.elements, id);\n\t\t})\n\t}\n\t\n\t__checkExistElement(elements, element) {\n\t\tfor (var i = 0; i < elements.length; i++) {\n\t\t\tif (elements[i].isSameNode(element)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t__getSocketUrl() {\n\t\tconsole.log(\"get_socket url\")\n\t\tlet w_location = window.location || window.parent.location;\n\t\tlet w_protocol = w_location.protocol;\n\t\tlet w_host = w_location.host;\n\t\tif (w_location.protocol === \"about:\") {\n\t\t\tw_protocol = w_location.protocol;\n\t\t\tw_host = document.referrer;\n\t\t}\n\t\tlet protocol = w_protocol === 'http:' ? 'ws' : 'wss';\n\n\t\tlet url_socket = `${protocol}://${w_host}:8080/`;\n\t\tif (window.config && window.config.host) {\n\t\t\tif (window.config.host.includes(\"://\")) {\n\t\t\t\turl_socket = `${window.config.host}/`;\n\t\t\t} else {\n\t\t\t\turl_socket = `${protocol}://${window.config.host}/`;\n\t\t\t}\n\t\t}\n\t\t\n\t\tconsole.log(url_socket)\n\t\turl_socket += \"crdt/\";\n\t\t\n\t\treturn url_socket;\n\n\t}\n\t\n\t__setTypeObserveEvent(event, elements, id) {\n\t\tconsole.log('set crdt event', event.delta)\n\t\tif (!id) return;\n\n\t\tconst eventDelta = event.delta;\n\t\t\n\t\tif (eventDelta.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = JSON.parse(atob(id));\n\t\tlet is_save_value = false\n\t\t\n\t\t// let is_crud = eventDelta.attributes && eventDelta.attributes.crud === false ? false : true;\n\t\t\n\t\tconst wholestring = event.target.toString()\n\t\tconst store_event = new CustomEvent('store-content-db', {\n\t\t\tdetail: wholestring\n\t\t})\n\t\t\n\t\tconst update_event = new CustomEvent('cocreate-crdt-update', {\n\t\t\tdetail: eventDelta\n\t\t})\n\t\telements.forEach((el) => {\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().isReadAttr(el) && el.getAttribute('name') === info.name) {\n\t\t\t\tel.dispatchEvent(update_event)\n\t\t\t}\n\t\t})\n\t\t\t\n\t\t\n\t\tif (typeof info !== 'object') {\n\t\t\treturn;\n\t\t}\n\n\t\tif (event.transaction.local) {\n\t\t\tif (elements.length == 0) {\n\t\t\t\tis_save_value = true;\n\t\t\t}\n\t\t\telements.forEach((el) => {\n\t\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().isSaveAttr(el) && el.getAttribute('name') === info.name && info.document_id != \"null\") {\n\t\t\t\t\tis_save_value = true;\n\t\t\t\t\tel.dispatchEvent(store_event)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// if (is_save_value && is_crud) {\n\t\t\t// \tcrud.updateDocument({\n\t\t\t// \t\tcollection: info.collection,\n\t\t\t// \t\tdocument_id: info.document_id,\n\t\t\t// \t\tdata: {\n\t\t\t// \t\t\t[info.name]: wholestring\n\t\t\t// \t\t},\n\t\t\t// \t\tmetadata: 'yjs-change'\n\t\t\t// \t})\n\t\t\t// }\n\t\t} else {\n\n\t\t}\n\t}\n\t\n\tdeleteDoc(id) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tdelete this.docs[info.id];\n\t\t}\n\t}\n\t\n\tgenerateDocName(collection, document_id, name) {\n\t\tconst info = {org: this.orgName, collection, document_id, name}\n\t\treturn btoa(JSON.stringify(info)); \n\t\t// return this.orgName + \"_\" + collection + \"_\" + document_id + \"_\" + name;\n\t}\n\t\n\tinsertData(id, index, content, attribute) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tif (attribute) {\n\t\t\t\tthis.docs[info.id].doc.getText(id).insert(index, content, attribute);\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tthis.docs[info.id].doc.getText(id).insert(index, content);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdeleteData(id, index, length) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tthis.docs[info.id].doc.getText(id).delete(index, length);\n\t\t}\n\t}\n\t\n\tgetWholeString(id) {\n\t\tconst info = this.parseType(id)\n\t\tif (this.docs[info.id]) {\n\t\t\tconsole.log(\"!Get data\")\n\t\t\treturn this.docs[info.id].doc.getText(id).toString();\n\t\t} else {\n\t\t\treturn \"--\";\n\t\t}\n\t}\n\t\n\tupdateRemoteSelection (y, cm, type, cursors, clientId, awareness)  {\n\t\tif(debug)\n\t\t\t\tconsole.log(\"CHANGE ---- DOCID \",this.doc.clientID,' OTHER CLIENTEID ',clientId)\n\t\tif(clientId !== this.doc.clientID){\n\t\t\t\n\t\t\t\t\t//console.log(\"TEXT -> updateRemoteSelection \",clientId,awareness,cursor)\n\t\t\t\t\t//console.log(\"AW status\",awareness.getLocalState())\n\t\t\t\t\t  // destroy current text mark\n\t\t\t\t\t  const m = cursors.get(clientId)\n\t\t\t\t\t  if (m !== undefined) {\n\t\t\t\t\t\tm.caret.clear()\n\t\t\t\t\t\tif (m.sel !== null) {\n\t\t\t\t\t\t  m.sel.clear()\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcursors.delete(clientId)\n\t\t\t\t\t  }\n\t\t\t\t\t  // redraw caret and selection for clientId\n\t\t\t\t\t  const aw = awareness.getStates().get(clientId);\n\t\t\t\t\t  if(debug)\n\t\t\t\t\t\tconsole.log(aw)\n\t\t\t\t\t  if (aw === undefined) {\n\t\t\t\t\t\t  if(debug)\n\t\t\t\t\t\t\tconsole.log(\" Cursor OUT \",clientId)\n\t\t\t\t\t\t   //awareness.setLocalStateField('cursor', null);\n\t\t\t\t\t\t   let elements = document.querySelectorAll('[id*=\"socket_'+clientId+'\"]');\n\t\t\t\t\t\t\telements.forEach(function (element, index, array) {\n\t\t\t\t\t\t\t\telement.parentNode.removeChild(element);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tlet sel_elements = document.querySelectorAll('[id*=\"sel-'+clientId+'\"]');\n\t\t\t\t\t\t\t  sel_elements.forEach(function (sel_element, index, array) {\n\t\t\t\t\t\t\t\tsel_element.parentNode.removeChild(sel_element);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t  /*\n\t\t\t\t\t\t   let element = document.getElementById(\"socket_\"+clientId)\n\t\t\t\t\t\t   let sel_element = document.getElementById(\"sel-\"+clientId)\n\t\t\t\t\t\t   if(element)\n\t\t\t\t\t\t\telement.parentNode.removeChild(element);\n\t\t\t\t\t\t\tif(sel_element)\n\t\t\t\t\t\t\tsel_element.parentNode.removeChild(sel_element);\n\t\t\t\t\t\t   */\n\t\t\t\t\t\treturn\n\t\t\t\t\t  }\n\t\t\t\t\t  const user = aw.user || {}\n\t\t\t\t\t  if (user.color == null) {\n\t\t\t\t\t\tuser.color = '#ffa500'\n\t\t\t\t\t  }\n\t\t\t\t\t  if (user.name == null) {\n\t\t\t\t\t\tuser.name = `User: ${clientId}`\n\t\t\t\t\t  }\n\t\t\t\t\t  const cursor = aw.cursor\n\t\t\t\t\t  if(debug)\n\t\t\t\t\t\tconsole.log(\"Cursor \",cursor)\n\t\t\t\t\t  if (cursor == null || cursor.anchor == null || cursor.head == null) {\n\t\t\t\t\t\t  //let element = document.getElementById(\"socket_\"+clientId)\n\t\t\t\t\t\t  let elements = document.querySelectorAll('[id*=\"socket_'+clientId+'\"]');\n\t\t\t\t\t\t  elements.forEach(function (element, index, array) {\n\t\t\t\t\t\t\telement.parentNode.removeChild(element);\n\t\t\t\t\t\t  })\n\t\t\t\t\t\t\n\t\t\t\t\t\t//let sel_element = document.getElementById(\"sel-\"+clientId)  \n\t\t\t\t\t\tlet sel_elements = document.querySelectorAll('[id*=\"sel-'+clientId+'\"]');\n\t\t\t\t\t\t  sel_elements.forEach(function (sel_element, index, array) {\n\t\t\t\t\t\t\tsel_element.parentNode.removeChild(sel_element);\n\t\t\t\t\t\t})\n\t\t\t\t\t\treturn\n\t\t\t\t\t  }\n\t\t\t\t\n\t\t\t\t\t  const anchor = yjs__WEBPACK_IMPORTED_MODULE_4__.createAbsolutePositionFromRelativePosition(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(cursor.anchor), y)\n\t\t\t\t\t  const head = yjs__WEBPACK_IMPORTED_MODULE_4__.createAbsolutePositionFromRelativePosition(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(cursor.head), y)\n\t\t\t\t\t  //CoCreate.cursors.draw_cursor(1,11,12,66,{},true);\n\t\t\t\t\t  if(debug){\n\t\t\t\t\t\t  console.log(\"PRE Draw Cursor \")\n\t\t\t\t\t\t  console.log(\"anchor  \",anchor , \" head \",head,' Type ',type)\n\t\t\t\t\t\t  console.log(\"anchor  Type\",anchor.type === type)\n\t\t\t\t\t\t  console.log(\"anchor  Type\",head.type === type)\n\t\t\t\t\t  }\n\t\t\t\t\t  //if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n\t\t\t\t\t  if (anchor !== null && head !== null ) {\n\t\t\t\t\t\tlet from, to;\n\t\t\t\t\t\tif (head.index < anchor.index) {\n\t\t\t\t\t\t  from = head.index\n\t\t\t\t\t\t  to = anchor.index\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(debug)\n\t\t\t\t\t\t\t\tconsole.log(anchor.index)\n\t\t\t\t\t\t  from = anchor.index\n\t\t\t\t\t\t  to = head.index\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(debug)\n\t\t\t\t\t\t\tconsole.log(\"Draw Cursor \",from,to,clientId,aw.user)\n\t\t\t\t\t\tlet t_info = this.parseTypeName(cursor.anchor['tname']);\n\t\t\t\t\t\tlet id_mirror = t_info.document_id + t_info.name+'--mirror-div';\n\t\t\t\t\t\tlet json = {};\n\t\t\t\t\t\tlet selector = '[data-collection=\"'+t_info.collection+'\"][data-document_id=\"'+t_info.document_id+'\"][name=\"'+t_info.name+'\"]'\n\t\t\t\t\t\tselector += ':not(.codemirror):not(.quill):not(.monaco)';\n\t\t\t\t\t\tlet elements = document.querySelectorAll(selector);\n\t\t\t\t\t\tlet that = this;\n\t\t\t\t\t\telements.forEach(function (element, index, array) {\n\t\t\t\t\t\t\tjson = {\n\t\t\t\t\t\t\t\telement:element,\n\t\t\t\t\t\t\t\tstartPosition:from,\n\t\t\t\t\t\t\t\tselector:selector,\n\t\t\t\t\t\t\t\tendPositon:to,\n\t\t\t\t\t\t\t\tclientId : clientId,\n\t\t\t\t\t\t\t\tuser:{\n\t\t\t\t\t\t\t\t\t'color':user.color,\n\t\t\t\t\t\t\t\t\t'name':user.name\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tconsole.log(json)\n\t\t\t\t\t\t\t_cocreate_cursors__WEBPACK_IMPORTED_MODULE_1__.default.draw_cursor(json);\n\t\t\t\t\t\t\t//sent custom position\n\t\t\t\t\t\t\tthat.listen(json);\n\t\t\t\t\t\t});\n\t\t\t\t\t  }\n\t\t}\n\t}\n\t\n\tchangeListenAwereness(callback){\n\t\tthis.listenAwereness = callback;\n\t}\n\t\n\tlisten(json){\n\t\tthis.listenAwereness.apply(this,[json])\n\t}\n\t\n\tdestroyObserver(id, element) {\n\t\tconst info = this.parseType(id)\n\t\tthis.docs[info.id].doc.getText(id).unobserve((event) => {});\n\t\t\n\t\tthis.docs[info.id].socket.awareness.off('change', this._awarenessListener);\n\t}\n\t\n\tgetProvider(id){\n\t\tconst info = this.parseType(id)\n\t\tif (!this.docs[info.id]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.docs[info.id].socket;\n\t}\n\t\n\tgetType(id){\n\t\tconst info = this.parseType(id)\n\t\tif (!this.docs[info.id]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.docs[info.id].doc.getText(id);\n\t}\n\n\tsetCursorNull(id){\n\t\tconst info = this.parseType(id)\n\t\tif (!this.docs[info.id]) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tthis.docs[info.id].socket.awareness.setLocalStateField('cursor', null);\n\t}\n\t\n\tsetPositionYJS(id, from, to) {\n\t\tconst info = this.parseType(id)\n\t\tconst type = this.getType(id);\n\t\t//console.log(\"Type \",type)\n\t\tif (!type) {\n\t\t\treturn;\n\t\t}\n\t\tvar anchor = yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromTypeIndex(type, from)\n\t\tvar head = yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromTypeIndex(type, to)\n\t\t\n\t\tif(debug)\n\t\t\tconsole.log(\"Sending Cursor \",{\n\t\t\t\tanchor,\n\t\t\t\thead\n\t\t\t},{'to':to,'from':from,'info.id':info.id})\n\t\t\n\t\tthis.docs[info.id].socket.awareness.setLocalStateField('cursor', {\n\t\t\tanchor,\n\t\t\thead\n\t\t})\n\t\t/*\n\t\tif(debug)\n\t\t\tconsole.log(\"Cursor Send\")\n\t\t\t*/\n\t}\n\t\n\t//send Position Custom\n\tsendPosition(json) {\n\t\tlet collection = json['collection'];\n\t\tlet document_id = json['document_id'];\n\t\tlet name = json['name'];\n\t\tlet from = json['startPosition'];\n\t\tlet to = json['endPositon'];\n\t\tlet id = this.generateID(config.organization_Id, collection, document_id, name);\n\t\tthis.setPositionYJS(id,from,to);\n\t}\n\t\n\tgenerateID(org, collection, document_id, name) {\n\t\tconst info = {org, collection, document_id, name}\n\t\treturn btoa(JSON.stringify(info));        \n\t}\n\t\n\tparseTypeName(name) {\n\t\tconst data = JSON.parse(atob(name));\n\t\treturn data;\n\t}\n\t\n\tparseType(id) {\n\t\tlet data = JSON.parse(atob(id));\n\t\t\n\t\tlet newId = {org: data.org, collection: data.collection, document_id: data.document_id}\n\t\treturn {\n\t\t\tid: btoa(JSON.stringify(newId)),\n\t\t\tname: data.name,\n\t\t\tdocument_id: data.document_id\n\t\t}\n\t}\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateYSocket);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcmR0L3NyYy9jb3JlLmpzPzJkZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3QjtBQUN1QjtBQUM2QjtBQUNuQztBQUNNOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsMkJBQTJCLDBEQUFpQjtBQUM1QztBQUNBO0FBQ0EsMkJBQTJCLDZEQUFvQjtBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKLEc7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVMsS0FBSyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLElBQUk7QUFDSixvQkFBb0IsU0FBUyxLQUFLLG1CQUFtQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsT0FBTyx1RUFBZTtBQUN0QjtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVFQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLHNCQUFzQiwyRUFBNEMsQ0FBQywrREFBZ0M7QUFDbkcsb0JBQW9CLDJFQUE0QyxDQUFDLCtEQUFnQztBQUNqRyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLE9BQU8sa0VBQTJCO0FBQ2xDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9FQUFxQztBQUNwRCxhQUFhLG9FQUFxQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsc0NBQXNDOztBQUU1QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQixvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLGVBQWUsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3JkdC9zcmMvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgV2Vic29ja2V0UHJvdmlkZXIgfSBmcm9tICd5LXdlYnNvY2tldCdcbmltcG9ydCB7IGZldGNoVXBkYXRlcywgc3RvcmVTdGF0ZSwgSW5kZXhlZGRiUGVyc2lzdGVuY2UgfSBmcm9tICd5LWluZGV4ZWRkYidcbmltcG9ydCBjcnVkIGZyb20gJ0Bjb2NyZWF0ZS9jcnVkLWNsaWVudCc7XG5pbXBvcnQgQ29DcmVhdGVDdXJzb3JzIGZyb20gJ0Bjb2NyZWF0ZS9jdXJzb3JzJ1xuXG5jb25zdCBkZWJ1ZyA9IGZhbHNlO1xuXG5jbGFzcyBDb0NyZWF0ZVlTb2NrZXQge1xuXHRjb25zdHJ1Y3RvcihvcmcsIHlkb2MpIHtcblx0XHR0aGlzLmRvYyA9IHlkb2M7XG5cdFx0dGhpcy5vcmdOYW1lID0gb3JnO1xuXHRcdHRoaXMuZG9jcyA9IHt9O1xuXHRcdHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyID0gbnVsbDtcblx0XHR0aGlzLmNoYXJhY3RlciA9ICdfJztcblx0XHR0aGlzLmxpc3RlbkF3ZXJlbmVzcyA9IGZ1bmN0aW9uKCl7fVxuXHR9XG5cdFxuXHRjcmVhdGVEb2MoaWQsIGVsZW1lbnQpIHtcblx0XHRpZiAoIWlkIHx8IGlkID09IFwiXCIpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHRsZXQgbmV3SW5mbyA9IHRoaXMucGFyc2VUeXBlKGlkKVxuXHRcdC8vIGlmKGRlYnVnKVxuXHRcdC8vIFx0Y29uc29sZS5sb2cobmV3SW5mbyk7XG5cdFx0XG5cdFx0Y29uc3QgbmV3SWQgPSBuZXdJbmZvLmlkO1xuXHRcdFxuXHRcdGlmICh0aGlzLmRvY3NbbmV3SWRdKSB7IFxuXHRcdFx0aWYgKGVsZW1lbnQgJiYgIXRoaXMuX19jaGVja0V4aXN0RWxlbWVudCh0aGlzLmRvY3NbbmV3SWRdLmVsZW1lbnRzLCBlbGVtZW50KSkge1xuXHRcdFx0XHR0aGlzLmRvY3NbbmV3SWRdLmVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdGhpcy5kb2NzW25ld0lkXS50eXBlcy5zb21lKCh0eXBlKSA9PiB0eXBlID09PSBpZCkpIHtcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgZXZlbnRcblx0XHRcdFx0dGhpcy5kb2NzW25ld0lkXS50eXBlcy5wdXNoKGlkKTtcblx0XHRcdFx0dGhpcy5yZWdpc3RlclVwZGF0ZUV2ZW50KHRoaXMuZG9jc1tuZXdJZF0sIGlkKVxuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IFxuXHRcdFxuXHRcdGNvbnN0IHlEb2MgPSB0aGlzLmRvY1xuXHRcdFxuXHRcdGNvbnN0IHVybF9zb2NrZXQgPSB0aGlzLl9fZ2V0U29ja2V0VXJsKCk7XG5cdFx0Ly9kcmF3IGN1cnNvciBkaW5hbWlhbGx5XG5cdFx0Ly8gbmV3IFVzZXJDdXJzb3Ioc29ja2V0UHJvdmlkZXIpO1xuXG5cdFx0XHRcblx0XHR2YXIgc29ja2V0UHJvdmlkZXIgPSBuZXcgV2Vic29ja2V0UHJvdmlkZXIodXJsX3NvY2tldCwgbmV3SWQsIHlEb2MpO1xuXHRcdGxldCBpbmRleGVkZGJQcm92aWRlciA9IG51bGw7XG5cdFx0aWYgKG5ld0luZm8uZG9jdW1lbnRfaWQgIT0gXCJudWxsXCIpIHtcblx0XHRcdGluZGV4ZWRkYlByb3ZpZGVyID0gbmV3IEluZGV4ZWRkYlBlcnNpc3RlbmNlKG5ld0lkLCB0aGlzLmRvYylcblx0XHRcdGluZGV4ZWRkYlByb3ZpZGVyLndoZW5TeW5jZWQudGhlbigoKSA9PiB7XG5cdFx0XHQgIGNvbnNvbGUubG9nKCdsb2FkZWQgZGF0YSBmcm9tIGluZGV4ZWQgZGInKVxuXHRcdFx0fSlcblx0XHR9XHRcblx0XHRcblx0XHRsZXQgYXdhcmVuZXNzID0gc29ja2V0UHJvdmlkZXIuYXdhcmVuZXNzO1xuXHRcdFxuXHRcdHRoaXMuX2N1cnNvcnMgPSBuZXcgTWFwKCk7XG5cdFx0XG5cdFx0dGhpcy5fYXdhcmVuZXNzTGlzdGVuZXIgPSBldmVudCA9PiB7XG5cdFx0ICBjb25zdCBmID0gY2xpZW50SWQgPT4ge1xuXHRcdFx0aWYgKGNsaWVudElkICE9PSB0aGlzLmRvYy5jbGllbnRJRCkge1xuXHRcdFx0ICB0aGlzLnVwZGF0ZVJlbW90ZVNlbGVjdGlvbih5RG9jLCBpZCwgeURvYy5nZXRUZXh0KGlkKSwgdGhpcy5fY3Vyc29ycywgY2xpZW50SWQsIGF3YXJlbmVzcylcblx0XHRcdH1cblx0XHQgIH1cblx0XHQgIGV2ZW50LmFkZGVkLmZvckVhY2goZilcblx0XHQgIGV2ZW50LnJlbW92ZWQuZm9yRWFjaChmKVxuXHRcdCAgZXZlbnQudXBkYXRlZC5mb3JFYWNoKGYpXG5cdFx0fVxuXHRcdFxuXHRcdGF3YXJlbmVzcy5vbignY2hhbmdlJywgdGhpcy5fYXdhcmVuZXNzTGlzdGVuZXIpO1xuXHRcdC8qXG5cdFx0YXdhcmVuZXNzLmdldFN0YXRlcygpLmZvckVhY2goKGF3LCBjbGllbnRJZCkgPT4ge1xuXHRcdFx0Y29uc29sZS5sb2coXCJVcGRhdGUgLS1cIilcbiAgICAgICAgfSlcbiAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIHRoaXMuZG9jc1tuZXdJZF0gPSB7XG5cdFx0XHRpZDogbmV3SWQsXG5cdFx0XHRkb2M6IHlEb2MsXG5cdFx0XHRzb2NrZXQ6IHNvY2tldFByb3ZpZGVyLFxuXHRcdFx0YXdhcmVuZXNzOiBhd2FyZW5lc3MsXG5cdFx0XHRlbGVtZW50czogZWxlbWVudCA/IFtlbGVtZW50XSA6IFtdLFxuXHRcdFx0dHlwZXM6IFtpZF0sXG5cdFx0XHRpbmRleGVkZGI6IGluZGV4ZWRkYlByb3ZpZGVyXG5cdFx0fVxuXHRcdHRoaXMucmVnaXN0ZXJVcGRhdGVFdmVudCh0aGlzLmRvY3NbbmV3SWRdLCBpZClcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdFxuXHRyZWdpc3RlclVwZGF0ZUV2ZW50KGRvY09iamVjdCwgaWQpIHtcblx0XHRjb25zdCB5RG9jID0gZG9jT2JqZWN0LmRvYztcblx0XHRjb25zdCBzaGFyZFR5cGUgPSB5RG9jLmdldFRleHQoaWQpXG5cdFx0bGV0IF90aGlzID0gdGhpcztcblx0XHRcblx0XHRzaGFyZFR5cGUub2JzZXJ2ZSgoZXZlbnQpID0+IHtcblx0XHRcdF90aGlzLl9fc2V0VHlwZU9ic2VydmVFdmVudChldmVudCwgZG9jT2JqZWN0LmVsZW1lbnRzLCBpZCk7XG5cdFx0fSlcblx0fVxuXHRcblx0X19jaGVja0V4aXN0RWxlbWVudChlbGVtZW50cywgZWxlbWVudCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChlbGVtZW50c1tpXS5pc1NhbWVOb2RlKGVsZW1lbnQpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0XG5cdF9fZ2V0U29ja2V0VXJsKCkge1xuXHRcdGNvbnNvbGUubG9nKFwiZ2V0X3NvY2tldCB1cmxcIilcblx0XHRsZXQgd19sb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbiB8fCB3aW5kb3cucGFyZW50LmxvY2F0aW9uO1xuXHRcdGxldCB3X3Byb3RvY29sID0gd19sb2NhdGlvbi5wcm90b2NvbDtcblx0XHRsZXQgd19ob3N0ID0gd19sb2NhdGlvbi5ob3N0O1xuXHRcdGlmICh3X2xvY2F0aW9uLnByb3RvY29sID09PSBcImFib3V0OlwiKSB7XG5cdFx0XHR3X3Byb3RvY29sID0gd19sb2NhdGlvbi5wcm90b2NvbDtcblx0XHRcdHdfaG9zdCA9IGRvY3VtZW50LnJlZmVycmVyO1xuXHRcdH1cblx0XHRsZXQgcHJvdG9jb2wgPSB3X3Byb3RvY29sID09PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xuXG5cdFx0bGV0IHVybF9zb2NrZXQgPSBgJHtwcm90b2NvbH06Ly8ke3dfaG9zdH06ODA4MC9gO1xuXHRcdGlmICh3aW5kb3cuY29uZmlnICYmIHdpbmRvdy5jb25maWcuaG9zdCkge1xuXHRcdFx0aWYgKHdpbmRvdy5jb25maWcuaG9zdC5pbmNsdWRlcyhcIjovL1wiKSkge1xuXHRcdFx0XHR1cmxfc29ja2V0ID0gYCR7d2luZG93LmNvbmZpZy5ob3N0fS9gO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dXJsX3NvY2tldCA9IGAke3Byb3RvY29sfTovLyR7d2luZG93LmNvbmZpZy5ob3N0fS9gO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRjb25zb2xlLmxvZyh1cmxfc29ja2V0KVxuXHRcdHVybF9zb2NrZXQgKz0gXCJjcmR0L1wiO1xuXHRcdFxuXHRcdHJldHVybiB1cmxfc29ja2V0O1xuXG5cdH1cblx0XG5cdF9fc2V0VHlwZU9ic2VydmVFdmVudChldmVudCwgZWxlbWVudHMsIGlkKSB7XG5cdFx0Y29uc29sZS5sb2coJ3NldCBjcmR0IGV2ZW50JywgZXZlbnQuZGVsdGEpXG5cdFx0aWYgKCFpZCkgcmV0dXJuO1xuXG5cdFx0Y29uc3QgZXZlbnREZWx0YSA9IGV2ZW50LmRlbHRhO1xuXHRcdFxuXHRcdGlmIChldmVudERlbHRhLmxlbmd0aCA9PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKGF0b2IoaWQpKTtcblx0XHRsZXQgaXNfc2F2ZV92YWx1ZSA9IGZhbHNlXG5cdFx0XG5cdFx0Ly8gbGV0IGlzX2NydWQgPSBldmVudERlbHRhLmF0dHJpYnV0ZXMgJiYgZXZlbnREZWx0YS5hdHRyaWJ1dGVzLmNydWQgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuXHRcdFxuXHRcdGNvbnN0IHdob2xlc3RyaW5nID0gZXZlbnQudGFyZ2V0LnRvU3RyaW5nKClcblx0XHRjb25zdCBzdG9yZV9ldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc3RvcmUtY29udGVudC1kYicsIHtcblx0XHRcdGRldGFpbDogd2hvbGVzdHJpbmdcblx0XHR9KVxuXHRcdFxuXHRcdGNvbnN0IHVwZGF0ZV9ldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29jcmVhdGUtY3JkdC11cGRhdGUnLCB7XG5cdFx0XHRkZXRhaWw6IGV2ZW50RGVsdGFcblx0XHR9KVxuXHRcdGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG5cdFx0XHRpZiAoY3J1ZC5pc1JlYWRBdHRyKGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSA9PT0gaW5mby5uYW1lKSB7XG5cdFx0XHRcdGVsLmRpc3BhdGNoRXZlbnQodXBkYXRlX2V2ZW50KVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0XHRcblx0XHRcblx0XHRpZiAodHlwZW9mIGluZm8gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LnRyYW5zYWN0aW9uLmxvY2FsKSB7XG5cdFx0XHRpZiAoZWxlbWVudHMubGVuZ3RoID09IDApIHtcblx0XHRcdFx0aXNfc2F2ZV92YWx1ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuXHRcdFx0XHRpZiAoY3J1ZC5pc1NhdmVBdHRyKGVsKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSA9PT0gaW5mby5uYW1lICYmIGluZm8uZG9jdW1lbnRfaWQgIT0gXCJudWxsXCIpIHtcblx0XHRcdFx0XHRpc19zYXZlX3ZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KHN0b3JlX2V2ZW50KVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXG5cdFx0XHQvLyBpZiAoaXNfc2F2ZV92YWx1ZSAmJiBpc19jcnVkKSB7XG5cdFx0XHQvLyBcdGNydWQudXBkYXRlRG9jdW1lbnQoe1xuXHRcdFx0Ly8gXHRcdGNvbGxlY3Rpb246IGluZm8uY29sbGVjdGlvbixcblx0XHRcdC8vIFx0XHRkb2N1bWVudF9pZDogaW5mby5kb2N1bWVudF9pZCxcblx0XHRcdC8vIFx0XHRkYXRhOiB7XG5cdFx0XHQvLyBcdFx0XHRbaW5mby5uYW1lXTogd2hvbGVzdHJpbmdcblx0XHRcdC8vIFx0XHR9LFxuXHRcdFx0Ly8gXHRcdG1ldGFkYXRhOiAneWpzLWNoYW5nZSdcblx0XHRcdC8vIFx0fSlcblx0XHRcdC8vIH1cblx0XHR9IGVsc2Uge1xuXG5cdFx0fVxuXHR9XG5cdFxuXHRkZWxldGVEb2MoaWQpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKHRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuZG9jc1tpbmZvLmlkXTtcblx0XHR9XG5cdH1cblx0XG5cdGdlbmVyYXRlRG9jTmFtZShjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSkge1xuXHRcdGNvbnN0IGluZm8gPSB7b3JnOiB0aGlzLm9yZ05hbWUsIGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lfVxuXHRcdHJldHVybiBidG9hKEpTT04uc3RyaW5naWZ5KGluZm8pKTsgXG5cdFx0Ly8gcmV0dXJuIHRoaXMub3JnTmFtZSArIFwiX1wiICsgY29sbGVjdGlvbiArIFwiX1wiICsgZG9jdW1lbnRfaWQgKyBcIl9cIiArIG5hbWU7XG5cdH1cblx0XG5cdGluc2VydERhdGEoaWQsIGluZGV4LCBjb250ZW50LCBhdHRyaWJ1dGUpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKHRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0aWYgKGF0dHJpYnV0ZSkge1xuXHRcdFx0XHR0aGlzLmRvY3NbaW5mby5pZF0uZG9jLmdldFRleHQoaWQpLmluc2VydChpbmRleCwgY29udGVudCwgYXR0cmlidXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFxuXHRcdFx0XHR0aGlzLmRvY3NbaW5mby5pZF0uZG9jLmdldFRleHQoaWQpLmluc2VydChpbmRleCwgY29udGVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdFxuXHRkZWxldGVEYXRhKGlkLCBpbmRleCwgbGVuZ3RoKSB7XG5cdFx0Y29uc3QgaW5mbyA9IHRoaXMucGFyc2VUeXBlKGlkKVxuXHRcdGlmICh0aGlzLmRvY3NbaW5mby5pZF0pIHtcblx0XHRcdHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCkuZGVsZXRlKGluZGV4LCBsZW5ndGgpO1xuXHRcdH1cblx0fVxuXHRcblx0Z2V0V2hvbGVTdHJpbmcoaWQpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKHRoaXMuZG9jc1tpbmZvLmlkXSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCIhR2V0IGRhdGFcIilcblx0XHRcdHJldHVybiB0aGlzLmRvY3NbaW5mby5pZF0uZG9jLmdldFRleHQoaWQpLnRvU3RyaW5nKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcIi0tXCI7XG5cdFx0fVxuXHR9XG5cdFxuXHR1cGRhdGVSZW1vdGVTZWxlY3Rpb24gKHksIGNtLCB0eXBlLCBjdXJzb3JzLCBjbGllbnRJZCwgYXdhcmVuZXNzKSAge1xuXHRcdGlmKGRlYnVnKVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkNIQU5HRSAtLS0tIERPQ0lEIFwiLHRoaXMuZG9jLmNsaWVudElELCcgT1RIRVIgQ0xJRU5URUlEICcsY2xpZW50SWQpXG5cdFx0aWYoY2xpZW50SWQgIT09IHRoaXMuZG9jLmNsaWVudElEKXtcblx0XHRcdFxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJURVhUIC0+IHVwZGF0ZVJlbW90ZVNlbGVjdGlvbiBcIixjbGllbnRJZCxhd2FyZW5lc3MsY3Vyc29yKVxuXHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJBVyBzdGF0dXNcIixhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpKVxuXHRcdFx0XHRcdCAgLy8gZGVzdHJveSBjdXJyZW50IHRleHQgbWFya1xuXHRcdFx0XHRcdCAgY29uc3QgbSA9IGN1cnNvcnMuZ2V0KGNsaWVudElkKVxuXHRcdFx0XHRcdCAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0bS5jYXJldC5jbGVhcigpXG5cdFx0XHRcdFx0XHRpZiAobS5zZWwgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdCAgbS5zZWwuY2xlYXIoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3Vyc29ycy5kZWxldGUoY2xpZW50SWQpXG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICAvLyByZWRyYXcgY2FyZXQgYW5kIHNlbGVjdGlvbiBmb3IgY2xpZW50SWRcblx0XHRcdFx0XHQgIGNvbnN0IGF3ID0gYXdhcmVuZXNzLmdldFN0YXRlcygpLmdldChjbGllbnRJZCk7XG5cdFx0XHRcdFx0ICBpZihkZWJ1Zylcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGF3KVxuXHRcdFx0XHRcdCAgaWYgKGF3ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdCAgaWYoZGVidWcpXG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiIEN1cnNvciBPVVQgXCIsY2xpZW50SWQpXG5cdFx0XHRcdFx0XHQgICAvL2F3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIG51bGwpO1xuXHRcdFx0XHRcdFx0ICAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2lkKj1cInNvY2tldF8nK2NsaWVudElkKydcIl0nKTtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0bGV0IHNlbF9lbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJzZWwtJytjbGllbnRJZCsnXCJdJyk7XG5cdFx0XHRcdFx0XHRcdCAgc2VsX2VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlbF9lbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcblx0XHRcdFx0XHRcdFx0XHRzZWxfZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbF9lbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdCAgLypcblx0XHRcdFx0XHRcdCAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb2NrZXRfXCIrY2xpZW50SWQpXG5cdFx0XHRcdFx0XHQgICBsZXQgc2VsX2VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlbC1cIitjbGllbnRJZClcblx0XHRcdFx0XHRcdCAgIGlmKGVsZW1lbnQpXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0aWYoc2VsX2VsZW1lbnQpXG5cdFx0XHRcdFx0XHRcdHNlbF9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2VsX2VsZW1lbnQpO1xuXHRcdFx0XHRcdFx0ICAgKi9cblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgY29uc3QgdXNlciA9IGF3LnVzZXIgfHwge31cblx0XHRcdFx0XHQgIGlmICh1c2VyLmNvbG9yID09IG51bGwpIHtcblx0XHRcdFx0XHRcdHVzZXIuY29sb3IgPSAnI2ZmYTUwMCdcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIGlmICh1c2VyLm5hbWUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0dXNlci5uYW1lID0gYFVzZXI6ICR7Y2xpZW50SWR9YFxuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgY29uc3QgY3Vyc29yID0gYXcuY3Vyc29yXG5cdFx0XHRcdFx0ICBpZihkZWJ1Zylcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQ3Vyc29yIFwiLGN1cnNvcilcblx0XHRcdFx0XHQgIGlmIChjdXJzb3IgPT0gbnVsbCB8fCBjdXJzb3IuYW5jaG9yID09IG51bGwgfHwgY3Vyc29yLmhlYWQgPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0ICAvL2xldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb2NrZXRfXCIrY2xpZW50SWQpXG5cdFx0XHRcdFx0XHQgIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZCo9XCJzb2NrZXRfJytjbGllbnRJZCsnXCJdJyk7XG5cdFx0XHRcdFx0XHQgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG5cdFx0XHRcdFx0XHQgIH0pXG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vbGV0IHNlbF9lbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWwtXCIrY2xpZW50SWQpICBcblx0XHRcdFx0XHRcdGxldCBzZWxfZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWQqPVwic2VsLScrY2xpZW50SWQrJ1wiXScpO1xuXHRcdFx0XHRcdFx0ICBzZWxfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VsX2VsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuXHRcdFx0XHRcdFx0XHRzZWxfZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlbF9lbGVtZW50KTtcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XG5cdFx0XHRcdFx0ICBjb25zdCBhbmNob3IgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJzb3IuYW5jaG9yKSwgeSlcblx0XHRcdFx0XHQgIGNvbnN0IGhlYWQgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJzb3IuaGVhZCksIHkpXG5cdFx0XHRcdFx0ICAvL0NvQ3JlYXRlLmN1cnNvcnMuZHJhd19jdXJzb3IoMSwxMSwxMiw2Nix7fSx0cnVlKTtcblx0XHRcdFx0XHQgIGlmKGRlYnVnKXtcblx0XHRcdFx0XHRcdCAgY29uc29sZS5sb2coXCJQUkUgRHJhdyBDdXJzb3IgXCIpXG5cdFx0XHRcdFx0XHQgIGNvbnNvbGUubG9nKFwiYW5jaG9yICBcIixhbmNob3IgLCBcIiBoZWFkIFwiLGhlYWQsJyBUeXBlICcsdHlwZSlcblx0XHRcdFx0XHRcdCAgY29uc29sZS5sb2coXCJhbmNob3IgIFR5cGVcIixhbmNob3IudHlwZSA9PT0gdHlwZSlcblx0XHRcdFx0XHRcdCAgY29uc29sZS5sb2coXCJhbmNob3IgIFR5cGVcIixoZWFkLnR5cGUgPT09IHR5cGUpXG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0ICAvL2lmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCAmJiBhbmNob3IudHlwZSA9PT0gdHlwZSAmJiBoZWFkLnR5cGUgPT09IHR5cGUpIHtcblx0XHRcdFx0XHQgIGlmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGxldCBmcm9tLCB0bztcblx0XHRcdFx0XHRcdGlmIChoZWFkLmluZGV4IDwgYW5jaG9yLmluZGV4KSB7XG5cdFx0XHRcdFx0XHQgIGZyb20gPSBoZWFkLmluZGV4XG5cdFx0XHRcdFx0XHQgIHRvID0gYW5jaG9yLmluZGV4XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZihkZWJ1Zylcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhhbmNob3IuaW5kZXgpXG5cdFx0XHRcdFx0XHQgIGZyb20gPSBhbmNob3IuaW5kZXhcblx0XHRcdFx0XHRcdCAgdG8gPSBoZWFkLmluZGV4XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZihkZWJ1Zylcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJEcmF3IEN1cnNvciBcIixmcm9tLHRvLGNsaWVudElkLGF3LnVzZXIpXG5cdFx0XHRcdFx0XHRsZXQgdF9pbmZvID0gdGhpcy5wYXJzZVR5cGVOYW1lKGN1cnNvci5hbmNob3JbJ3RuYW1lJ10pO1xuXHRcdFx0XHRcdFx0bGV0IGlkX21pcnJvciA9IHRfaW5mby5kb2N1bWVudF9pZCArIHRfaW5mby5uYW1lKyctLW1pcnJvci1kaXYnO1xuXHRcdFx0XHRcdFx0bGV0IGpzb24gPSB7fTtcblx0XHRcdFx0XHRcdGxldCBzZWxlY3RvciA9ICdbZGF0YS1jb2xsZWN0aW9uPVwiJyt0X2luZm8uY29sbGVjdGlvbisnXCJdW2RhdGEtZG9jdW1lbnRfaWQ9XCInK3RfaW5mby5kb2N1bWVudF9pZCsnXCJdW25hbWU9XCInK3RfaW5mby5uYW1lKydcIl0nXG5cdFx0XHRcdFx0XHRzZWxlY3RvciArPSAnOm5vdCguY29kZW1pcnJvcik6bm90KC5xdWlsbCk6bm90KC5tb25hY28pJztcblx0XHRcdFx0XHRcdGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0XHRcdFx0bGV0IHRoYXQgPSB0aGlzO1xuXHRcdFx0XHRcdFx0ZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgsIGFycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGpzb24gPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDplbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0UG9zaXRpb246ZnJvbSxcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3RvcjpzZWxlY3Rvcixcblx0XHRcdFx0XHRcdFx0XHRlbmRQb3NpdG9uOnRvLFxuXHRcdFx0XHRcdFx0XHRcdGNsaWVudElkIDogY2xpZW50SWQsXG5cdFx0XHRcdFx0XHRcdFx0dXNlcjp7XG5cdFx0XHRcdFx0XHRcdFx0XHQnY29sb3InOnVzZXIuY29sb3IsXG5cdFx0XHRcdFx0XHRcdFx0XHQnbmFtZSc6dXNlci5uYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhqc29uKVxuXHRcdFx0XHRcdFx0XHRDb0NyZWF0ZUN1cnNvcnMuZHJhd19jdXJzb3IoanNvbik7XG5cdFx0XHRcdFx0XHRcdC8vc2VudCBjdXN0b20gcG9zaXRpb25cblx0XHRcdFx0XHRcdFx0dGhhdC5saXN0ZW4oanNvbik7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHQgIH1cblx0XHR9XG5cdH1cblx0XG5cdGNoYW5nZUxpc3RlbkF3ZXJlbmVzcyhjYWxsYmFjayl7XG5cdFx0dGhpcy5saXN0ZW5Bd2VyZW5lc3MgPSBjYWxsYmFjaztcblx0fVxuXHRcblx0bGlzdGVuKGpzb24pe1xuXHRcdHRoaXMubGlzdGVuQXdlcmVuZXNzLmFwcGx5KHRoaXMsW2pzb25dKVxuXHR9XG5cdFxuXHRkZXN0cm95T2JzZXJ2ZXIoaWQsIGVsZW1lbnQpIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0dGhpcy5kb2NzW2luZm8uaWRdLmRvYy5nZXRUZXh0KGlkKS51bm9ic2VydmUoKGV2ZW50KSA9PiB7fSk7XG5cdFx0XG5cdFx0dGhpcy5kb2NzW2luZm8uaWRdLnNvY2tldC5hd2FyZW5lc3Mub2ZmKCdjaGFuZ2UnLCB0aGlzLl9hd2FyZW5lc3NMaXN0ZW5lcik7XG5cdH1cblx0XG5cdGdldFByb3ZpZGVyKGlkKXtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKCF0aGlzLmRvY3NbaW5mby5pZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5kb2NzW2luZm8uaWRdLnNvY2tldDtcblx0fVxuXHRcblx0Z2V0VHlwZShpZCl7XG5cdFx0Y29uc3QgaW5mbyA9IHRoaXMucGFyc2VUeXBlKGlkKVxuXHRcdGlmICghdGhpcy5kb2NzW2luZm8uaWRdKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZG9jc1tpbmZvLmlkXS5kb2MuZ2V0VGV4dChpZCk7XG5cdH1cblxuXHRzZXRDdXJzb3JOdWxsKGlkKXtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0aWYgKCF0aGlzLmRvY3NbaW5mby5pZF0pIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRcblx0XHR0aGlzLmRvY3NbaW5mby5pZF0uc29ja2V0LmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIG51bGwpO1xuXHR9XG5cdFxuXHRzZXRQb3NpdGlvbllKUyhpZCwgZnJvbSwgdG8pIHtcblx0XHRjb25zdCBpbmZvID0gdGhpcy5wYXJzZVR5cGUoaWQpXG5cdFx0Y29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZShpZCk7XG5cdFx0Ly9jb25zb2xlLmxvZyhcIlR5cGUgXCIsdHlwZSlcblx0XHRpZiAoIXR5cGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGFuY2hvciA9IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgodHlwZSwgZnJvbSlcblx0XHR2YXIgaGVhZCA9IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgodHlwZSwgdG8pXG5cdFx0XG5cdFx0aWYoZGVidWcpXG5cdFx0XHRjb25zb2xlLmxvZyhcIlNlbmRpbmcgQ3Vyc29yIFwiLHtcblx0XHRcdFx0YW5jaG9yLFxuXHRcdFx0XHRoZWFkXG5cdFx0XHR9LHsndG8nOnRvLCdmcm9tJzpmcm9tLCdpbmZvLmlkJzppbmZvLmlkfSlcblx0XHRcblx0XHR0aGlzLmRvY3NbaW5mby5pZF0uc29ja2V0LmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIHtcblx0XHRcdGFuY2hvcixcblx0XHRcdGhlYWRcblx0XHR9KVxuXHRcdC8qXG5cdFx0aWYoZGVidWcpXG5cdFx0XHRjb25zb2xlLmxvZyhcIkN1cnNvciBTZW5kXCIpXG5cdFx0XHQqL1xuXHR9XG5cdFxuXHQvL3NlbmQgUG9zaXRpb24gQ3VzdG9tXG5cdHNlbmRQb3NpdGlvbihqc29uKSB7XG5cdFx0bGV0IGNvbGxlY3Rpb24gPSBqc29uWydjb2xsZWN0aW9uJ107XG5cdFx0bGV0IGRvY3VtZW50X2lkID0ganNvblsnZG9jdW1lbnRfaWQnXTtcblx0XHRsZXQgbmFtZSA9IGpzb25bJ25hbWUnXTtcblx0XHRsZXQgZnJvbSA9IGpzb25bJ3N0YXJ0UG9zaXRpb24nXTtcblx0XHRsZXQgdG8gPSBqc29uWydlbmRQb3NpdG9uJ107XG5cdFx0bGV0IGlkID0gdGhpcy5nZW5lcmF0ZUlEKGNvbmZpZy5vcmdhbml6YXRpb25fSWQsIGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKTtcblx0XHR0aGlzLnNldFBvc2l0aW9uWUpTKGlkLGZyb20sdG8pO1xuXHR9XG5cdFxuXHRnZW5lcmF0ZUlEKG9yZywgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUpIHtcblx0XHRjb25zdCBpbmZvID0ge29yZywgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWV9XG5cdFx0cmV0dXJuIGJ0b2EoSlNPTi5zdHJpbmdpZnkoaW5mbykpOyAgICAgICAgXG5cdH1cblx0XG5cdHBhcnNlVHlwZU5hbWUobmFtZSkge1xuXHRcdGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGF0b2IobmFtZSkpO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdFxuXHRwYXJzZVR5cGUoaWQpIHtcblx0XHRsZXQgZGF0YSA9IEpTT04ucGFyc2UoYXRvYihpZCkpO1xuXHRcdFxuXHRcdGxldCBuZXdJZCA9IHtvcmc6IGRhdGEub3JnLCBjb2xsZWN0aW9uOiBkYXRhLmNvbGxlY3Rpb24sIGRvY3VtZW50X2lkOiBkYXRhLmRvY3VtZW50X2lkfVxuXHRcdHJldHVybiB7XG5cdFx0XHRpZDogYnRvYShKU09OLnN0cmluZ2lmeShuZXdJZCkpLFxuXHRcdFx0bmFtZTogZGF0YS5uYW1lLFxuXHRcdFx0ZG9jdW1lbnRfaWQ6IGRhdGEuZG9jdW1lbnRfaWRcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVZU29ja2V0O1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crdt/src/core.js\n")},"./node_modules/@cocreate/crdt/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/@cocreate/crdt/src/core.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\n\nclass CoCreateCRDTClass extends _core_js__WEBPACK_IMPORTED_MODULE_0__.default \n{\n\tconstructor(org, doc) {\n\t\tsuper(org, doc)\n\t}\n\n\t/*\n\tcrdt.init({\n\t\tcollection: \"module\",\n\t\tdocument_id: \"\",\n\t\tname: \"\",\n\t\telement: dom_object,\n\t\tmetadata: \"xxxx\"\n\t})\n\t*/\n\tinit(info) {\n\t\ttry {\n\t\t\tthis.__validateKeysJson(info, ['collection', 'document_id', 'name']);\n\t\t\t\n\t\t\tconst id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n\n\t\t\tif (!id) return;\n\t\t\tconst status = this.createDoc(id, info.element)\n\t\t\tconsole.log(\"InitCrdt\")\n\t\t} catch(e) {\n\t\t\tconsole.log('Invalid param', e);\n\t\t}\n\t}\n\n\t/*. init data function\n\tcrdt.replaceText({\n\t\tcollection: \"module\",\n\t\tdocument_id: \"\",\n\t\tname: \"\",\n\t\tvalue: \"\",\n\t\tupdateCrud: true | false,\n\t\telement: dom_object,\n\t\tmetadata: \"xxxx\"\n\t})\n\t*/\n\t\n\treplaceText(info){\n\t\tif (!info) return;\n\t\t\n\t\tconst id = this.__getYDocId(info.collection, info.document_id, info.name)\n\t\tif (!id) return;\n\n\t\tif (info.updateCrud != false) info.updateCrud = true;\n\t\t\n\t\tif (this.getType(id) ) {\n\t\t\tlet oldData = this.getType(id).toString();\n\t\t\tlet textValue = info.value.toString();\n\t\t\tif (oldData && oldData.length > 0) {\n\t\t\t\tthis.deleteData(id, 0, Math.max(oldData.length, textValue.length));\n\t\t\t}\n\t\t\tthis.insertData(id, 0, textValue);\n\t\t}\n\t\tif (info.updateCrud) {\n\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().updateDocument({\n\t\t\t\tcollection: info.collection,\n\t\t\t\tdocument_id: info.document_id,\n\t\t\t\tdata: {[info.name]: info.value},\n\t\t\t\telement: info.element,\n\t\t\t\tmetadata:info.metadata,\n\t\t\t\tnamespace: info.namespace,\n\t\t\t\troom: info.room,\n\t\t\t\tbroadcast: info.broadcast,\n\t\t\t\tupsert: info.upsert,\n\t\t\t\tbroadcast_sender: info.broadcast_sender\n\t\t\t})\n\t\t}\n\t}\n\t\n\t/*\n\tcrdt.insertText({\n\t\tcollection: 'module_activities',\n\t\tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n\t\tname: 'name',\n\t\tvalue: 'T',\n\t\tposition: '8',\n\t\tattributes: {bold: true}\n\t})\n\t*/\n\tinsertText(info) {\n\t\t\ttry {\n\t\t\t\tthis.__validateKeysJson(info,['collection','document_id','name','value','position']);\n\t\t\t\tlet id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n\t\t\t\tif (id) {\n\t\t\t\t\t\n\t\t\t\t\tthis.insertData(id, info['position'], info['value'].toString(), info['attributes']);\n\t\t\t\t\t\n\t\t\t\t\tlet wholestring = this.getType(id).toString();\n\t\t\t\t\t\n\t\t\t\t\tconsole.log(wholestring)\n\t\t\t\t\t\n\t\t\t\t\tif (info.crud != false) {\n\t\t\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().updateDocument({\n\t\t\t\t\t\t\tcollection: info.collection,\n\t\t\t\t\t\t\tdocument_id: info.document_id,\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t[info.name]: wholestring\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmetadata: 'yjs-change'\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tconsole.error(e); \n\t\t\t}\n\t}\n\t\n\t\n\t/*\n\tcrdt.deleteText({\n\t\tcollection: 'module_activities',\n\t\tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n\t\tname: 'name',\n\t\tposition: '8',\n\t\tlength: 2,\n\t})\n\t*/\n\tdeleteText(info) {\n\t\ttry{\n\t\t\tthis.__validateKeysJson(info,['collection','document_id','name', 'position','length']);\n\t\t\tlet id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n\t\t\tif (id) {\n\t\t\t\tthis.deleteData(id, info['position'], info['length']);\n\t\t\t\t\n\t\t\t\tlet wholestring = this.getType(id).toString();\n\t\t\t\t\n\t\t\t\tconsole.log(wholestring)\n\t\t\t\t\n\t\t\t\tif (info.crud != false) {\n\t\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().updateDocument({\n\t\t\t\t\t\tcollection: info.collection,\n\t\t\t\t\t\tdocument_id: info.document_id,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t[info.name]: wholestring\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmetadata: 'yjs-change'\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(e); \n\t\t}\n\t}\n\t\n\t\n\t/*\n\tcrdt.getText({\n\t\tcollection: 'module_activities',\n\t\tdocument_id: '5e4802ce3ed96d38e71fc7e5',\n\t\tname: 'name'\n\t})\n\t*/\n\tgetText(info) {\n\t\ttry{\n\t\t\tthis.__validateKeysJson(info,['collection','document_id','name']);\n\t\t\tlet id = this.__getYDocId(info['collection'], info['document_id'], info['name'])\n\t\t\tif (id) {\n\t\t\t\treturn this.getWholeString(id);\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(e); \n\t\t\treturn \"\";\n\t\t}\n\t}\n\n\t\n\t/* \n\tcrdt.getPosition(function(data))\n\tcrdt.getPosition(function(data){console.log(\" EScuchando ahora  \",data)})\n\t*/\n\tgetPosition(callback){\n\tif(typeof miFuncion === 'function')\n\t\tthis.changeListenAwereness(callback);\n\telse\n\t\tconsole.error('Callback should be a function')\n\t}\n \n\t__getYDocId(collection, document_id, name) {\n\t\tif (!_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().checkValue(collection) || \n\t\t\t\t!_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().checkValue(document_id) || \n\t\t\t\t!_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().checkValue(name)) \n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn this.generateID(config.organization_Id, collection, document_id, name);\n\t}\n\t\n\t__validateKeysJson(json,rules){\n\t\tlet keys_json = Object.keys(json);\n\t\tkeys_json.forEach(key=>{\n\t\t\tconst index = rules.indexOf(key);\n\t\t\tif(index != -1)\n\t\t\t\trules.splice(index, 1);\n\t\t});\n\t\tif( rules.length )\n\t\t\tthrow \"Requires the following \"+ rules.toString();\n\t}\n}\n\nlet CoCreateCrdt = null;\nif (!window.CoCreateCrdt) {\n\tconst crdtDoc = new yjs__WEBPACK_IMPORTED_MODULE_2__.Doc();\n\tCoCreateCrdt = new CoCreateCRDTClass(config.organization_Id, crdtDoc);\n\twindow.Y = yjs__WEBPACK_IMPORTED_MODULE_2__;\n\twindow.CoCreateCrdt = CoCreateCrdt;\n} else {\n\tCoCreateCrdt = window.CoCreateCrdt;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateCrdt);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcmR0L3NyYy9pbmRleC5qcz8zYjU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ2Y7QUFDaUI7OztBQUd6QyxnQ0FBZ0MsNkNBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkVBQW1CO0FBQ3RCO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLDJFQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLLDJFQUFtQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsaUNBQWlDLHdDQUF3QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sdUVBQWU7QUFDdEIsS0FBSyx1RUFBZTtBQUNwQixLQUFLLHVFQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQUs7QUFDMUI7QUFDQSxZQUFZLGdDQUFDO0FBQ2I7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxpRUFBZSxZQUFZLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2NyZHQvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvQ3JlYXRlWVNvY2tldCBmcm9tIFwiLi9jb3JlLmpzXCJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50JztcblxuXG5jbGFzcyBDb0NyZWF0ZUNSRFRDbGFzcyBleHRlbmRzIENvQ3JlYXRlWVNvY2tldCBcbntcblx0Y29uc3RydWN0b3Iob3JnLCBkb2MpIHtcblx0XHRzdXBlcihvcmcsIGRvYylcblx0fVxuXG5cdC8qXG5cdGNyZHQuaW5pdCh7XG5cdFx0Y29sbGVjdGlvbjogXCJtb2R1bGVcIixcblx0XHRkb2N1bWVudF9pZDogXCJcIixcblx0XHRuYW1lOiBcIlwiLFxuXHRcdGVsZW1lbnQ6IGRvbV9vYmplY3QsXG5cdFx0bWV0YWRhdGE6IFwieHh4eFwiXG5cdH0pXG5cdCovXG5cdGluaXQoaW5mbykge1xuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9fdmFsaWRhdGVLZXlzSnNvbihpbmZvLCBbJ2NvbGxlY3Rpb24nLCAnZG9jdW1lbnRfaWQnLCAnbmFtZSddKTtcblx0XHRcdFxuXHRcdFx0Y29uc3QgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm9bJ2NvbGxlY3Rpb24nXSwgaW5mb1snZG9jdW1lbnRfaWQnXSwgaW5mb1snbmFtZSddKVxuXG5cdFx0XHRpZiAoIWlkKSByZXR1cm47XG5cdFx0XHRjb25zdCBzdGF0dXMgPSB0aGlzLmNyZWF0ZURvYyhpZCwgaW5mby5lbGVtZW50KVxuXHRcdFx0Y29uc29sZS5sb2coXCJJbml0Q3JkdFwiKVxuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0Y29uc29sZS5sb2coJ0ludmFsaWQgcGFyYW0nLCBlKTtcblx0XHR9XG5cdH1cblxuXHQvKi4gaW5pdCBkYXRhIGZ1bmN0aW9uXG5cdGNyZHQucmVwbGFjZVRleHQoe1xuXHRcdGNvbGxlY3Rpb246IFwibW9kdWxlXCIsXG5cdFx0ZG9jdW1lbnRfaWQ6IFwiXCIsXG5cdFx0bmFtZTogXCJcIixcblx0XHR2YWx1ZTogXCJcIixcblx0XHR1cGRhdGVDcnVkOiB0cnVlIHwgZmFsc2UsXG5cdFx0ZWxlbWVudDogZG9tX29iamVjdCxcblx0XHRtZXRhZGF0YTogXCJ4eHh4XCJcblx0fSlcblx0Ki9cblx0XG5cdHJlcGxhY2VUZXh0KGluZm8pe1xuXHRcdGlmICghaW5mbykgcmV0dXJuO1xuXHRcdFxuXHRcdGNvbnN0IGlkID0gdGhpcy5fX2dldFlEb2NJZChpbmZvLmNvbGxlY3Rpb24sIGluZm8uZG9jdW1lbnRfaWQsIGluZm8ubmFtZSlcblx0XHRpZiAoIWlkKSByZXR1cm47XG5cblx0XHRpZiAoaW5mby51cGRhdGVDcnVkICE9IGZhbHNlKSBpbmZvLnVwZGF0ZUNydWQgPSB0cnVlO1xuXHRcdFxuXHRcdGlmICh0aGlzLmdldFR5cGUoaWQpICkge1xuXHRcdFx0bGV0IG9sZERhdGEgPSB0aGlzLmdldFR5cGUoaWQpLnRvU3RyaW5nKCk7XG5cdFx0XHRsZXQgdGV4dFZhbHVlID0gaW5mby52YWx1ZS50b1N0cmluZygpO1xuXHRcdFx0aWYgKG9sZERhdGEgJiYgb2xkRGF0YS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoaXMuZGVsZXRlRGF0YShpZCwgMCwgTWF0aC5tYXgob2xkRGF0YS5sZW5ndGgsIHRleHRWYWx1ZS5sZW5ndGgpKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaW5zZXJ0RGF0YShpZCwgMCwgdGV4dFZhbHVlKTtcblx0XHR9XG5cdFx0aWYgKGluZm8udXBkYXRlQ3J1ZCkge1xuXHRcdFx0Y3J1ZC51cGRhdGVEb2N1bWVudCh7XG5cdFx0XHRcdGNvbGxlY3Rpb246IGluZm8uY29sbGVjdGlvbixcblx0XHRcdFx0ZG9jdW1lbnRfaWQ6IGluZm8uZG9jdW1lbnRfaWQsXG5cdFx0XHRcdGRhdGE6IHtbaW5mby5uYW1lXTogaW5mby52YWx1ZX0sXG5cdFx0XHRcdGVsZW1lbnQ6IGluZm8uZWxlbWVudCxcblx0XHRcdFx0bWV0YWRhdGE6aW5mby5tZXRhZGF0YSxcblx0XHRcdFx0bmFtZXNwYWNlOiBpbmZvLm5hbWVzcGFjZSxcblx0XHRcdFx0cm9vbTogaW5mby5yb29tLFxuXHRcdFx0XHRicm9hZGNhc3Q6IGluZm8uYnJvYWRjYXN0LFxuXHRcdFx0XHR1cHNlcnQ6IGluZm8udXBzZXJ0LFxuXHRcdFx0XHRicm9hZGNhc3Rfc2VuZGVyOiBpbmZvLmJyb2FkY2FzdF9zZW5kZXJcblx0XHRcdH0pXG5cdFx0fVxuXHR9XG5cdFxuXHQvKlxuXHRjcmR0Lmluc2VydFRleHQoe1xuXHRcdGNvbGxlY3Rpb246ICdtb2R1bGVfYWN0aXZpdGllcycsXG5cdFx0ZG9jdW1lbnRfaWQ6ICc1ZTQ4MDJjZTNlZDk2ZDM4ZTcxZmM3ZTUnLFxuXHRcdG5hbWU6ICduYW1lJyxcblx0XHR2YWx1ZTogJ1QnLFxuXHRcdHBvc2l0aW9uOiAnOCcsXG5cdFx0YXR0cmlidXRlczoge2JvbGQ6IHRydWV9XG5cdH0pXG5cdCovXG5cdGluc2VydFRleHQoaW5mbykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhpcy5fX3ZhbGlkYXRlS2V5c0pzb24oaW5mbyxbJ2NvbGxlY3Rpb24nLCdkb2N1bWVudF9pZCcsJ25hbWUnLCd2YWx1ZScsJ3Bvc2l0aW9uJ10pO1xuXHRcdFx0XHRsZXQgaWQgPSB0aGlzLl9fZ2V0WURvY0lkKGluZm9bJ2NvbGxlY3Rpb24nXSwgaW5mb1snZG9jdW1lbnRfaWQnXSwgaW5mb1snbmFtZSddKVxuXHRcdFx0XHRpZiAoaWQpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR0aGlzLmluc2VydERhdGEoaWQsIGluZm9bJ3Bvc2l0aW9uJ10sIGluZm9bJ3ZhbHVlJ10udG9TdHJpbmcoKSwgaW5mb1snYXR0cmlidXRlcyddKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRsZXQgd2hvbGVzdHJpbmcgPSB0aGlzLmdldFR5cGUoaWQpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc29sZS5sb2cod2hvbGVzdHJpbmcpXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKGluZm8uY3J1ZCAhPSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Y3J1ZC51cGRhdGVEb2N1bWVudCh7XG5cdFx0XHRcdFx0XHRcdGNvbGxlY3Rpb246IGluZm8uY29sbGVjdGlvbixcblx0XHRcdFx0XHRcdFx0ZG9jdW1lbnRfaWQ6IGluZm8uZG9jdW1lbnRfaWQsXG5cdFx0XHRcdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRbaW5mby5uYW1lXTogd2hvbGVzdHJpbmdcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0bWV0YWRhdGE6ICd5anMtY2hhbmdlJ1xuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZSk7IFxuXHRcdFx0fVxuXHR9XG5cdFxuXHRcblx0Lypcblx0Y3JkdC5kZWxldGVUZXh0KHtcblx0XHRjb2xsZWN0aW9uOiAnbW9kdWxlX2FjdGl2aXRpZXMnLFxuXHRcdGRvY3VtZW50X2lkOiAnNWU0ODAyY2UzZWQ5NmQzOGU3MWZjN2U1Jyxcblx0XHRuYW1lOiAnbmFtZScsXG5cdFx0cG9zaXRpb246ICc4Jyxcblx0XHRsZW5ndGg6IDIsXG5cdH0pXG5cdCovXG5cdGRlbGV0ZVRleHQoaW5mbykge1xuXHRcdHRyeXtcblx0XHRcdHRoaXMuX192YWxpZGF0ZUtleXNKc29uKGluZm8sWydjb2xsZWN0aW9uJywnZG9jdW1lbnRfaWQnLCduYW1lJywgJ3Bvc2l0aW9uJywnbGVuZ3RoJ10pO1xuXHRcdFx0bGV0IGlkID0gdGhpcy5fX2dldFlEb2NJZChpbmZvWydjb2xsZWN0aW9uJ10sIGluZm9bJ2RvY3VtZW50X2lkJ10sIGluZm9bJ25hbWUnXSlcblx0XHRcdGlmIChpZCkge1xuXHRcdFx0XHR0aGlzLmRlbGV0ZURhdGEoaWQsIGluZm9bJ3Bvc2l0aW9uJ10sIGluZm9bJ2xlbmd0aCddKTtcblx0XHRcdFx0XG5cdFx0XHRcdGxldCB3aG9sZXN0cmluZyA9IHRoaXMuZ2V0VHlwZShpZCkudG9TdHJpbmcoKTtcblx0XHRcdFx0XG5cdFx0XHRcdGNvbnNvbGUubG9nKHdob2xlc3RyaW5nKVxuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGluZm8uY3J1ZCAhPSBmYWxzZSkge1xuXHRcdFx0XHRcdGNydWQudXBkYXRlRG9jdW1lbnQoe1xuXHRcdFx0XHRcdFx0Y29sbGVjdGlvbjogaW5mby5jb2xsZWN0aW9uLFxuXHRcdFx0XHRcdFx0ZG9jdW1lbnRfaWQ6IGluZm8uZG9jdW1lbnRfaWQsXG5cdFx0XHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0XHRcdFtpbmZvLm5hbWVdOiB3aG9sZXN0cmluZ1xuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdG1ldGFkYXRhOiAneWpzLWNoYW5nZSdcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGUpOyBcblx0XHR9XG5cdH1cblx0XG5cdFxuXHQvKlxuXHRjcmR0LmdldFRleHQoe1xuXHRcdGNvbGxlY3Rpb246ICdtb2R1bGVfYWN0aXZpdGllcycsXG5cdFx0ZG9jdW1lbnRfaWQ6ICc1ZTQ4MDJjZTNlZDk2ZDM4ZTcxZmM3ZTUnLFxuXHRcdG5hbWU6ICduYW1lJ1xuXHR9KVxuXHQqL1xuXHRnZXRUZXh0KGluZm8pIHtcblx0XHR0cnl7XG5cdFx0XHR0aGlzLl9fdmFsaWRhdGVLZXlzSnNvbihpbmZvLFsnY29sbGVjdGlvbicsJ2RvY3VtZW50X2lkJywnbmFtZSddKTtcblx0XHRcdGxldCBpZCA9IHRoaXMuX19nZXRZRG9jSWQoaW5mb1snY29sbGVjdGlvbiddLCBpbmZvWydkb2N1bWVudF9pZCddLCBpbmZvWyduYW1lJ10pXG5cdFx0XHRpZiAoaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0V2hvbGVTdHJpbmcoaWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGUpOyBcblx0XHRcdHJldHVybiBcIlwiO1xuXHRcdH1cblx0fVxuXG5cdFxuXHQvKiBcblx0Y3JkdC5nZXRQb3NpdGlvbihmdW5jdGlvbihkYXRhKSlcblx0Y3JkdC5nZXRQb3NpdGlvbihmdW5jdGlvbihkYXRhKXtjb25zb2xlLmxvZyhcIiBFU2N1Y2hhbmRvIGFob3JhICBcIixkYXRhKX0pXG5cdCovXG5cdGdldFBvc2l0aW9uKGNhbGxiYWNrKXtcblx0aWYodHlwZW9mIG1pRnVuY2lvbiA9PT0gJ2Z1bmN0aW9uJylcblx0XHR0aGlzLmNoYW5nZUxpc3RlbkF3ZXJlbmVzcyhjYWxsYmFjayk7XG5cdGVsc2Vcblx0XHRjb25zb2xlLmVycm9yKCdDYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbicpXG5cdH1cbiBcblx0X19nZXRZRG9jSWQoY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUpIHtcblx0XHRpZiAoIWNydWQuY2hlY2tWYWx1ZShjb2xsZWN0aW9uKSB8fCBcblx0XHRcdFx0IWNydWQuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkgfHwgXG5cdFx0XHRcdCFjcnVkLmNoZWNrVmFsdWUobmFtZSkpIFxuXHRcdHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUlEKGNvbmZpZy5vcmdhbml6YXRpb25fSWQsIGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKTtcblx0fVxuXHRcblx0X192YWxpZGF0ZUtleXNKc29uKGpzb24scnVsZXMpe1xuXHRcdGxldCBrZXlzX2pzb24gPSBPYmplY3Qua2V5cyhqc29uKTtcblx0XHRrZXlzX2pzb24uZm9yRWFjaChrZXk9Pntcblx0XHRcdGNvbnN0IGluZGV4ID0gcnVsZXMuaW5kZXhPZihrZXkpO1xuXHRcdFx0aWYoaW5kZXggIT0gLTEpXG5cdFx0XHRcdHJ1bGVzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0fSk7XG5cdFx0aWYoIHJ1bGVzLmxlbmd0aCApXG5cdFx0XHR0aHJvdyBcIlJlcXVpcmVzIHRoZSBmb2xsb3dpbmcgXCIrIHJ1bGVzLnRvU3RyaW5nKCk7XG5cdH1cbn1cblxubGV0IENvQ3JlYXRlQ3JkdCA9IG51bGw7XG5pZiAoIXdpbmRvdy5Db0NyZWF0ZUNyZHQpIHtcblx0Y29uc3QgY3JkdERvYyA9IG5ldyBZLkRvYygpO1xuXHRDb0NyZWF0ZUNyZHQgPSBuZXcgQ29DcmVhdGVDUkRUQ2xhc3MoY29uZmlnLm9yZ2FuaXphdGlvbl9JZCwgY3JkdERvYyk7XG5cdHdpbmRvdy5ZID0gWTtcblx0d2luZG93LkNvQ3JlYXRlQ3JkdCA9IENvQ3JlYXRlQ3JkdDtcbn0gZWxzZSB7XG5cdENvQ3JlYXRlQ3JkdCA9IHdpbmRvdy5Db0NyZWF0ZUNyZHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQ3JkdDtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crdt/src/index.js\n")},"./node_modules/@cocreate/crdt/src/utils/cursor/userCursor_class.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UserCursor\": () => (/* binding */ UserCursor)\n/* harmony export */ });\n/* harmony import */ var _usercolor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usercolor.js */ \"./node_modules/@cocreate/crdt/src/utils/cursor/usercolor.js\");\n\n/* eslint-env browser */\n// @ts-ignore\n\n\n\nclass UserCursor {\n    \n    constructor(provider) {\n      this.awareness = provider.awareness;\n      this.debug = false;\n      //console.log(\" awareness\",provider)\n     this.__init();\n    }\n    \n    __init(){\n          \n          var cursor_user = localStorage.getItem('cursor_user')\n          if(this.debug)\n            console.log(\" INIT cursor_user = \",cursor_user)\n          var user_id = localStorage.getItem('user_id')\n          if (cursor_user == null){\n            var uuid = this.generateUUID(4)\n            let cursor_user = 'User : ' + uuid;\n            localStorage.setItem('cursor_user',cursor_user)\n            if(this.debug)\n              console.log(\"update name From __init__USERCURSORQUILL \"+cursor_user)\n            this.updateAwarenessFromLocalstorage()\n          }\n          \n          addEventListener('storage', this.updateAwarenessFromLocalstorage)\n          \n          this.awareness.setLocalStateField('user', {\n            name: localStorage.getItem('cursor_user') || 'Anonymous',\n            color: _usercolor_js__WEBPACK_IMPORTED_MODULE_0__.userColor.color,\n            colorLight: _usercolor_js__WEBPACK_IMPORTED_MODULE_0__.userColor.light\n          })\n    }\n    \n    updateAwarenessFromLocalstorage(){\n      const localstorageUsername = localStorage.getItem('cursor_user')\n      if(this.debug)\n        console.log(\" from localStorage \",localstorageUsername)\n      const awarenessState = this.awareness.getLocalState()\n      if(this.debug)\n        console.log(awarenessState)\n      if(awarenessState != null && typeof(awarenessState.user.name)=='undefined' ){\n        this.awareness.setLocalStateField('user', {\n          name:  'Anonymous',\n          color: _usercolor_js__WEBPACK_IMPORTED_MODULE_0__.userColor.color,\n          colorLight: _usercolor_js__WEBPACK_IMPORTED_MODULE_0__.userColor.light\n        })\n      }\n      if (localstorageUsername != null && awarenessState !== null && localstorageUsername !== awarenessState.user.name) {\n        this.awareness.setLocalStateField('user', {\n          name: localstorageUsername || 'Anonymous',\n          color: _usercolor_js__WEBPACK_IMPORTED_MODULE_0__.userColor.color,\n          colorLight: _usercolor_js__WEBPACK_IMPORTED_MODULE_0__.userColor.light\n        })\n      }\n    }\n    \n    generateUUID(length=null) {\n      var d = new Date().getTime();\n      var d2 = (performance && performance.now && (performance.now()*1000)) || 0;//Time in microseconds since page-load or 0 if unsupported\n      var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n          var r = Math.random() * 16;\n          if(d > 0){\n              var r = (d + r)%16 | 0;\n              d = Math.floor(d/16);\n          } else {\n              var r = (d2 + r)%16 | 0;\n              d2 = Math.floor(d2/16);\n          }\n          return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n      });\n      if(length!=null){\n        uuid = uuid.substr(0,length)\n      }\n      return uuid;\n  }\n}//en class\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcmR0L3NyYy91dGlscy9jdXJzb3IvdXNlckN1cnNvcl9jbGFzcy5qcz80ZmYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQWE7QUFDYjtBQUNBOztBQUUwQzs7QUFFbkM7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFlO0FBQ2xDLHdCQUF3QiwwREFBZTtBQUN2QyxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWU7QUFDaEMsc0JBQXNCLDBEQUFlO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwREFBZTtBQUNoQyxzQkFBc0IsMERBQWU7QUFDckMsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcmR0L3NyYy91dGlscy9jdXJzb3IvdXNlckN1cnNvcl9jbGFzcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWVudiBicm93c2VyICovXG4vLyBAdHMtaWdub3JlXG5cbmltcG9ydCB7IHVzZXJDb2xvciB9IGZyb20gJy4vdXNlcmNvbG9yLmpzJ1xuXG5leHBvcnQgY2xhc3MgVXNlckN1cnNvciB7XG4gICAgXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuYXdhcmVuZXNzID0gcHJvdmlkZXIuYXdhcmVuZXNzO1xuICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgLy9jb25zb2xlLmxvZyhcIiBhd2FyZW5lc3NcIixwcm92aWRlcilcbiAgICAgdGhpcy5fX2luaXQoKTtcbiAgICB9XG4gICAgXG4gICAgX19pbml0KCl7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGN1cnNvcl91c2VyID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2N1cnNvcl91c2VyJylcbiAgICAgICAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgSU5JVCBjdXJzb3JfdXNlciA9IFwiLGN1cnNvcl91c2VyKVxuICAgICAgICAgIHZhciB1c2VyX2lkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfaWQnKVxuICAgICAgICAgIGlmIChjdXJzb3JfdXNlciA9PSBudWxsKXtcbiAgICAgICAgICAgIHZhciB1dWlkID0gdGhpcy5nZW5lcmF0ZVVVSUQoNClcbiAgICAgICAgICAgIGxldCBjdXJzb3JfdXNlciA9ICdVc2VyIDogJyArIHV1aWQ7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3Vyc29yX3VzZXInLGN1cnNvcl91c2VyKVxuICAgICAgICAgICAgaWYodGhpcy5kZWJ1ZylcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1cGRhdGUgbmFtZSBGcm9tIF9faW5pdF9fVVNFUkNVUlNPUlFVSUxMIFwiK2N1cnNvcl91c2VyKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVBd2FyZW5lc3NGcm9tTG9jYWxzdG9yYWdlKClcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHRoaXMudXBkYXRlQXdhcmVuZXNzRnJvbUxvY2Fsc3RvcmFnZSlcbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ3VzZXInLCB7XG4gICAgICAgICAgICBuYW1lOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY3Vyc29yX3VzZXInKSB8fCAnQW5vbnltb3VzJyxcbiAgICAgICAgICAgIGNvbG9yOiB1c2VyQ29sb3IuY29sb3IsXG4gICAgICAgICAgICBjb2xvckxpZ2h0OiB1c2VyQ29sb3IubGlnaHRcbiAgICAgICAgICB9KVxuICAgIH1cbiAgICBcbiAgICB1cGRhdGVBd2FyZW5lc3NGcm9tTG9jYWxzdG9yYWdlKCl7XG4gICAgICBjb25zdCBsb2NhbHN0b3JhZ2VVc2VybmFtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJzb3JfdXNlcicpXG4gICAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICBjb25zb2xlLmxvZyhcIiBmcm9tIGxvY2FsU3RvcmFnZSBcIixsb2NhbHN0b3JhZ2VVc2VybmFtZSlcbiAgICAgIGNvbnN0IGF3YXJlbmVzc1N0YXRlID0gdGhpcy5hd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpXG4gICAgICBpZih0aGlzLmRlYnVnKVxuICAgICAgICBjb25zb2xlLmxvZyhhd2FyZW5lc3NTdGF0ZSlcbiAgICAgIGlmKGF3YXJlbmVzc1N0YXRlICE9IG51bGwgJiYgdHlwZW9mKGF3YXJlbmVzc1N0YXRlLnVzZXIubmFtZSk9PSd1bmRlZmluZWQnICl7XG4gICAgICAgIHRoaXMuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgndXNlcicsIHtcbiAgICAgICAgICBuYW1lOiAgJ0Fub255bW91cycsXG4gICAgICAgICAgY29sb3I6IHVzZXJDb2xvci5jb2xvcixcbiAgICAgICAgICBjb2xvckxpZ2h0OiB1c2VyQ29sb3IubGlnaHRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmIChsb2NhbHN0b3JhZ2VVc2VybmFtZSAhPSBudWxsICYmIGF3YXJlbmVzc1N0YXRlICE9PSBudWxsICYmIGxvY2Fsc3RvcmFnZVVzZXJuYW1lICE9PSBhd2FyZW5lc3NTdGF0ZS51c2VyLm5hbWUpIHtcbiAgICAgICAgdGhpcy5hd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCd1c2VyJywge1xuICAgICAgICAgIG5hbWU6IGxvY2Fsc3RvcmFnZVVzZXJuYW1lIHx8ICdBbm9ueW1vdXMnLFxuICAgICAgICAgIGNvbG9yOiB1c2VyQ29sb3IuY29sb3IsXG4gICAgICAgICAgY29sb3JMaWdodDogdXNlckNvbG9yLmxpZ2h0XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGdlbmVyYXRlVVVJRChsZW5ndGg9bnVsbCkge1xuICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIHZhciBkMiA9IChwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgJiYgKHBlcmZvcm1hbmNlLm5vdygpKjEwMDApKSB8fCAwOy8vVGltZSBpbiBtaWNyb3NlY29uZHMgc2luY2UgcGFnZS1sb2FkIG9yIDAgaWYgdW5zdXBwb3J0ZWRcbiAgICAgIHZhciB1dWlkID0gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTY7XG4gICAgICAgICAgaWYoZCA+IDApe1xuICAgICAgICAgICAgICB2YXIgciA9IChkICsgciklMTYgfCAwO1xuICAgICAgICAgICAgICBkID0gTWF0aC5mbG9vcihkLzE2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgciA9IChkMiArIHIpJTE2IHwgMDtcbiAgICAgICAgICAgICAgZDIgPSBNYXRoLmZsb29yKGQyLzE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIChjPT0neCcgPyByIDogKHImMHg3fDB4OCkpLnRvU3RyaW5nKDE2KTtcbiAgICAgIH0pO1xuICAgICAgaWYobGVuZ3RoIT1udWxsKXtcbiAgICAgICAgdXVpZCA9IHV1aWQuc3Vic3RyKDAsbGVuZ3RoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHV1aWQ7XG4gIH1cbn0vL2VuIGNsYXNzXG5cblxuXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crdt/src/utils/cursor/userCursor_class.js\n")},"./node_modules/@cocreate/crdt/src/utils/cursor/usercolor.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"usercolors\": () => (/* binding */ usercolors),\n/* harmony export */   \"userColor\": () => (/* binding */ userColor)\n/* harmony export */ });\n/* harmony import */ var lib0_random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/random.js */ \"./node_modules/lib0/random.js\");\n\n\nconst usercolors = [\n  { color: '#30bced', light: '#30bced33' },\n  { color: '#6eeb83', light: '#6eeb8333' },\n  { color: '#ffbc42', light: '#ffbc4233' },\n  { color: '#ecd444', light: '#ecd44433' },\n  { color: '#ee6352', light: '#ee635233' },\n  { color: '#9ac2c9', light: '#9ac2c933' },\n  { color: '#8acb88', light: '#8acb8833' },\n  { color: '#1be7ff', light: '#1be7ff33' }\n]\n\nconst userColor = usercolors[lib0_random_js__WEBPACK_IMPORTED_MODULE_0__.uint32() % usercolors.length]\n//export const userColor = usercolors[2]//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcmR0L3NyYy91dGlscy9jdXJzb3IvdXNlcmNvbG9yLmpzP2YyZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdDOztBQUVqQztBQUNQLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUcsdUNBQXVDO0FBQzFDLEdBQUc7QUFDSDs7QUFFTyw2QkFBNkIsa0RBQWE7QUFDakQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2NyZHQvc3JjL3V0aWxzL2N1cnNvci91c2VyY29sb3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyByYW5kb20gZnJvbSAnbGliMC9yYW5kb20uanMnXG5cbmV4cG9ydCBjb25zdCB1c2VyY29sb3JzID0gW1xuICB7IGNvbG9yOiAnIzMwYmNlZCcsIGxpZ2h0OiAnIzMwYmNlZDMzJyB9LFxuICB7IGNvbG9yOiAnIzZlZWI4MycsIGxpZ2h0OiAnIzZlZWI4MzMzJyB9LFxuICB7IGNvbG9yOiAnI2ZmYmM0MicsIGxpZ2h0OiAnI2ZmYmM0MjMzJyB9LFxuICB7IGNvbG9yOiAnI2VjZDQ0NCcsIGxpZ2h0OiAnI2VjZDQ0NDMzJyB9LFxuICB7IGNvbG9yOiAnI2VlNjM1MicsIGxpZ2h0OiAnI2VlNjM1MjMzJyB9LFxuICB7IGNvbG9yOiAnIzlhYzJjOScsIGxpZ2h0OiAnIzlhYzJjOTMzJyB9LFxuICB7IGNvbG9yOiAnIzhhY2I4OCcsIGxpZ2h0OiAnIzhhY2I4ODMzJyB9LFxuICB7IGNvbG9yOiAnIzFiZTdmZicsIGxpZ2h0OiAnIzFiZTdmZjMzJyB9XG5dXG5cbmV4cG9ydCBjb25zdCB1c2VyQ29sb3IgPSB1c2VyY29sb3JzW3JhbmRvbS51aW50MzIoKSAlIHVzZXJjb2xvcnMubGVuZ3RoXVxuLy9leHBvcnQgY29uc3QgdXNlckNvbG9yID0gdXNlcmNvbG9yc1syXSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crdt/src/utils/cursor/usercolor.js\n")},"./node_modules/@cocreate/crud-client/src/crud.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// import {getCommonParams, getCommonParamsExtend, generateSocketClient} from \"@cocreate/socket-client/src/common-fun.js\"\n\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! @cocreate/socket-client/src/common-fun.js */ \"./node_modules/@cocreate/socket-client/src/common-fun.js\"), __webpack_require__(/*! ./utils.crud.js */ \"./node_modules/@cocreate/crud-client/src/utils.crud.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(commonFunc, utilsCrud) {\n        \treturn factory(window, commonFunc, utilsCrud)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function (wnd, commonFunc, utilsCrud) {\n  \n  const CoCreateCRUD = {\n    socket: null,\n    setSocket: function(socket) {\n      this.socket = socket;\n    },\n\n    readDocumentList(info){\n      if( !info ) return false;\n      let request_data = commonFunc.getCommonParams();\n      if (!info.collection) {\n        return false;\n      }\n      \n      request_data = {...request_data, ...info};\n      \n      this.socket.send('readDocumentList', request_data);\n      return true;\n    },\n    \n    createDocument: function(info) {\n      if (info === null) {\n        return false;\n      }\n      let commonData = commonFunc.getCommonParamsExtend(info);\n      let request_data = {...info, ...commonData};\n  \n      let data = info.data || {};\n      \n      if (!data['organization_id']) {\n        data['organization_id'] = wnd.config.organization_Id\n      }\n      if (info['data']) {\n        data = {...data, ...info['data']}\n      }\n      \n      //. rebuild data\n      request_data['data'] = data;\n  \n      const room = commonFunc.generateSocketClient(info.namespace, info.room);\n      this.socket.send('createDocument', request_data, room);\n      return true;\n    },\n    \n    updateDocument: function(info) {\n      if (!info || !utilsCrud.checkDocumentId(info['document_id'])) return false;\n      \n      let commonData = commonFunc.getCommonParamsExtend(info);\n      \n      let request_data = {...info, ...commonData};\n      \n      if( typeof info['data'] === 'object' ) {\n        request_data['set'] = info['data']\n      }\n      if( Array.isArray(info['delete_fields']) ) request_data['unset'] = info['delete_fields'];\n      \n      if(!request_data['set'] && !request_data['unset']) return false;\n      \n      if (info.broadcast === false) {\n        request_data['broadcast'] = false;\n      }\n      \n      /** socket parameters **/\n      if (info['broadcast_sender'] === undefined) {\n        request_data['broadcast_sender'] = true;\n      }\n      \n      const room = commonFunc.generateSocketClient(info.namespace, info.room);\n      this.socket.send('updateDocument', request_data, room);\n      \n      return true;\n    },\n    \n    readDocument: function(info) {\n      if (info === null) {\n        return false;\n      }\n      \n      if (!info || !utilsCrud.checkDocumentId(info['document_id'])) {\n        return false;\n      }\n      \n      let commonData = commonFunc.getCommonParamsExtend(info);\n      let request_data = {...info, ...commonData};\n      console.log(\"crud.readDocument => \",request_data)\n      this.socket.send('readDocument', request_data);\n      return true;\n    },\n    \n    \n    deleteDocument: function(info) {\n      if (!info || !utilsCrud.checkDocumentId(info['document_id'])) {\n        return false;\n      }\n      \n      let commonData = commonFunc.getCommonParamsExtend(info);\n      let request_data = {...info, ...commonData};\n      \n      const room = commonFunc.generateSocketClient(info.namespace, info.room);\n      this.socket.send('deleteDocument', request_data, room);\n      return true;\n    },\n  \n  \n   /** export / import db functions **/\n    exportCollection: function(info) {\n      if (info === null) return;\n  \n      let request_data = commonFunc.getCommonParamsExtend(info);\n      request_data['collection'] = info['collection'];\n      request_data['export_type'] = info['export_type'];\n  \n      request_data['metadata'] = info['metadata']\n      this.socket.send('exportDB', request_data);\n    },\n    \n    importCollection: function(info) {\n      const {file} = info;\n      if (info === null || !(file instanceof wnd.File)) return;\n  \n      const extension = file.name.split(\".\").pop();\n      \n      if (!['json','csv'].some((item) => item === extension)) return;\n  \n      let request_data = commonFunc.getCommonParamsExtend(info)\n      request_data['collection'] = info['collection']\n      request_data['import_type'] = extension;\n      this.socket.send('importDB', request_data)\n      this.socket.sendFile(file);\n    },\n    \n    listen: function(message, fun) {\n      this.socket.listen(message, fun);\n    },\n    \n    listenAsync: function(eventname) {\n      return this.socket.listenAsync(eventname);\n    },\n  \n  \tcreateSocket: function(host, namespace) {\n  \t\tif (namespace) {\n  \t\t\tthis.socket.create({\n  \t\t\t\tnamespace: namespace, \n  \t\t\t\troom: null,\n  \t\t\t\thost: host\n  \t\t\t});\n  \t\t\tthis.socket.setGlobalScope(namespace);\n  \t\t} else {\n  \t\t\tthis.socket.create({\n  \t\t\t\tnamespace: null, \n  \t\t\t\troom: null,\n  \t\t\t\thost: host\n  \t\t\t});\n  \t\t}\n  \t},\n  \t\n  \t...utilsCrud\n  }\n  \n  return CoCreateCRUD;\n}));\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcnVkLWNsaWVudC9zcmMvY3J1ZC5qcz9jNDMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJFQUFXLDZEQUE2RDs7QUFFeEU7QUFDQSxRQUFRLElBQTBDO0FBQ2xELFFBQVEsaUNBQU8sQ0FBQyxnSUFBMkMsRUFBRSxvR0FBaUIsQ0FBQyxtQ0FBRTtBQUNqRjtBQUNBLFNBQVM7QUFBQSxrR0FBQztBQUNWLEtBQUssTUFBTSxFQVVSO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2NydWQtY2xpZW50L3NyYy9jcnVkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0IHtnZXRDb21tb25QYXJhbXMsIGdldENvbW1vblBhcmFtc0V4dGVuZCwgZ2VuZXJhdGVTb2NrZXRDbGllbnR9IGZyb20gXCJAY29jcmVhdGUvc29ja2V0LWNsaWVudC9zcmMvY29tbW9uLWZ1bi5qc1wiXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcIkBjb2NyZWF0ZS9zb2NrZXQtY2xpZW50L3NyYy9jb21tb24tZnVuLmpzXCIsIFwiLi91dGlscy5jcnVkLmpzXCJdLCBmdW5jdGlvbihjb21tb25GdW5jLCB1dGlsc0NydWQpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFjdG9yeSh3aW5kb3csIGNvbW1vbkZ1bmMsIHV0aWxzQ3J1ZClcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgbGV0IHduZCA9IHtcbiAgICAgICAgY29uZmlnOiB7fSxcbiAgICAgICAgRmlsZToge31cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbW1vbkZ1bmMgPSByZXF1aXJlKFwiQGNvY3JlYXRlL3NvY2tldC1jbGllbnQvc3JjL2NvbW1vbi1mdW4uanNcIilcbiAgICAgIGNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuY3J1ZC5qc1wiKVxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHduZCwgY29tbW9uRnVuYywgdXRpbHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3Rvcnkod2luZG93LCByb290W1wiQGNvY3JlYXRlL3NvY2tldC1jbGllbnQvc3JjL2NvbW1vbi1mdW4uanNcIl0sIHJvb3RbXCIuL3V0aWxzLmNydWQuanNcIl0pO1xuICB9XG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAod25kLCBjb21tb25GdW5jLCB1dGlsc0NydWQpIHtcbiAgXG4gIGNvbnN0IENvQ3JlYXRlQ1JVRCA9IHtcbiAgICBzb2NrZXQ6IG51bGwsXG4gICAgc2V0U29ja2V0OiBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICAgIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgIH0sXG5cbiAgICByZWFkRG9jdW1lbnRMaXN0KGluZm8pe1xuICAgICAgaWYoICFpbmZvICkgcmV0dXJuIGZhbHNlO1xuICAgICAgbGV0IHJlcXVlc3RfZGF0YSA9IGNvbW1vbkZ1bmMuZ2V0Q29tbW9uUGFyYW1zKCk7XG4gICAgICBpZiAoIWluZm8uY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlcXVlc3RfZGF0YSA9IHsuLi5yZXF1ZXN0X2RhdGEsIC4uLmluZm99O1xuICAgICAgXG4gICAgICB0aGlzLnNvY2tldC5zZW5kKCdyZWFkRG9jdW1lbnRMaXN0JywgcmVxdWVzdF9kYXRhKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgY3JlYXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBjb21tb25EYXRhID0gY29tbW9uRnVuYy5nZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbyk7XG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gey4uLmluZm8sIC4uLmNvbW1vbkRhdGF9O1xuICBcbiAgICAgIGxldCBkYXRhID0gaW5mby5kYXRhIHx8IHt9O1xuICAgICAgXG4gICAgICBpZiAoIWRhdGFbJ29yZ2FuaXphdGlvbl9pZCddKSB7XG4gICAgICAgIGRhdGFbJ29yZ2FuaXphdGlvbl9pZCddID0gd25kLmNvbmZpZy5vcmdhbml6YXRpb25fSWRcbiAgICAgIH1cbiAgICAgIGlmIChpbmZvWydkYXRhJ10pIHtcbiAgICAgICAgZGF0YSA9IHsuLi5kYXRhLCAuLi5pbmZvWydkYXRhJ119XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vLiByZWJ1aWxkIGRhdGFcbiAgICAgIHJlcXVlc3RfZGF0YVsnZGF0YSddID0gZGF0YTtcbiAgXG4gICAgICBjb25zdCByb29tID0gY29tbW9uRnVuYy5nZW5lcmF0ZVNvY2tldENsaWVudChpbmZvLm5hbWVzcGFjZSwgaW5mby5yb29tKTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ2NyZWF0ZURvY3VtZW50JywgcmVxdWVzdF9kYXRhLCByb29tKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgdXBkYXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmICghaW5mbyB8fCAhdXRpbHNDcnVkLmNoZWNrRG9jdW1lbnRJZChpbmZvWydkb2N1bWVudF9pZCddKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBsZXQgY29tbW9uRGF0YSA9IGNvbW1vbkZ1bmMuZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kKGluZm8pO1xuICAgICAgXG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gey4uLmluZm8sIC4uLmNvbW1vbkRhdGF9O1xuICAgICAgXG4gICAgICBpZiggdHlwZW9mIGluZm9bJ2RhdGEnXSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgIHJlcXVlc3RfZGF0YVsnc2V0J10gPSBpbmZvWydkYXRhJ11cbiAgICAgIH1cbiAgICAgIGlmKCBBcnJheS5pc0FycmF5KGluZm9bJ2RlbGV0ZV9maWVsZHMnXSkgKSByZXF1ZXN0X2RhdGFbJ3Vuc2V0J10gPSBpbmZvWydkZWxldGVfZmllbGRzJ107XG4gICAgICBcbiAgICAgIGlmKCFyZXF1ZXN0X2RhdGFbJ3NldCddICYmICFyZXF1ZXN0X2RhdGFbJ3Vuc2V0J10pIHJldHVybiBmYWxzZTtcbiAgICAgIFxuICAgICAgaWYgKGluZm8uYnJvYWRjYXN0ID09PSBmYWxzZSkge1xuICAgICAgICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdCddID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qKiBzb2NrZXQgcGFyYW1ldGVycyAqKi9cbiAgICAgIGlmIChpbmZvWydicm9hZGNhc3Rfc2VuZGVyJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdF9zZW5kZXInXSA9IHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJvb20gPSBjb21tb25GdW5jLmdlbmVyYXRlU29ja2V0Q2xpZW50KGluZm8ubmFtZXNwYWNlLCBpbmZvLnJvb20pO1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZCgndXBkYXRlRG9jdW1lbnQnLCByZXF1ZXN0X2RhdGEsIHJvb20pO1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIHJlYWREb2N1bWVudDogZnVuY3Rpb24oaW5mbykge1xuICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWluZm8gfHwgIXV0aWxzQ3J1ZC5jaGVja0RvY3VtZW50SWQoaW5mb1snZG9jdW1lbnRfaWQnXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBsZXQgY29tbW9uRGF0YSA9IGNvbW1vbkZ1bmMuZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kKGluZm8pO1xuICAgICAgbGV0IHJlcXVlc3RfZGF0YSA9IHsuLi5pbmZvLCAuLi5jb21tb25EYXRhfTtcbiAgICAgIGNvbnNvbGUubG9nKFwiY3J1ZC5yZWFkRG9jdW1lbnQgPT4gXCIscmVxdWVzdF9kYXRhKVxuICAgICAgdGhpcy5zb2NrZXQuc2VuZCgncmVhZERvY3VtZW50JywgcmVxdWVzdF9kYXRhKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgXG4gICAgZGVsZXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmICghaW5mbyB8fCAhdXRpbHNDcnVkLmNoZWNrRG9jdW1lbnRJZChpbmZvWydkb2N1bWVudF9pZCddKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxldCBjb21tb25EYXRhID0gY29tbW9uRnVuYy5nZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbyk7XG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gey4uLmluZm8sIC4uLmNvbW1vbkRhdGF9O1xuICAgICAgXG4gICAgICBjb25zdCByb29tID0gY29tbW9uRnVuYy5nZW5lcmF0ZVNvY2tldENsaWVudChpbmZvLm5hbWVzcGFjZSwgaW5mby5yb29tKTtcbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ2RlbGV0ZURvY3VtZW50JywgcmVxdWVzdF9kYXRhLCByb29tKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gIFxuICBcbiAgIC8qKiBleHBvcnQgLyBpbXBvcnQgZGIgZnVuY3Rpb25zICoqL1xuICAgIGV4cG9ydENvbGxlY3Rpb246IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGlmIChpbmZvID09PSBudWxsKSByZXR1cm47XG4gIFxuICAgICAgbGV0IHJlcXVlc3RfZGF0YSA9IGNvbW1vbkZ1bmMuZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kKGluZm8pO1xuICAgICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ107XG4gICAgICByZXF1ZXN0X2RhdGFbJ2V4cG9ydF90eXBlJ10gPSBpbmZvWydleHBvcnRfdHlwZSddO1xuICBcbiAgICAgIHJlcXVlc3RfZGF0YVsnbWV0YWRhdGEnXSA9IGluZm9bJ21ldGFkYXRhJ11cbiAgICAgIHRoaXMuc29ja2V0LnNlbmQoJ2V4cG9ydERCJywgcmVxdWVzdF9kYXRhKTtcbiAgICB9LFxuICAgIFxuICAgIGltcG9ydENvbGxlY3Rpb246IGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIGNvbnN0IHtmaWxlfSA9IGluZm87XG4gICAgICBpZiAoaW5mbyA9PT0gbnVsbCB8fCAhKGZpbGUgaW5zdGFuY2VvZiB3bmQuRmlsZSkpIHJldHVybjtcbiAgXG4gICAgICBjb25zdCBleHRlbnNpb24gPSBmaWxlLm5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpO1xuICAgICAgXG4gICAgICBpZiAoIVsnanNvbicsJ2NzdiddLnNvbWUoKGl0ZW0pID0+IGl0ZW0gPT09IGV4dGVuc2lvbikpIHJldHVybjtcbiAgXG4gICAgICBsZXQgcmVxdWVzdF9kYXRhID0gY29tbW9uRnVuYy5nZXRDb21tb25QYXJhbXNFeHRlbmQoaW5mbylcbiAgICAgIHJlcXVlc3RfZGF0YVsnY29sbGVjdGlvbiddID0gaW5mb1snY29sbGVjdGlvbiddXG4gICAgICByZXF1ZXN0X2RhdGFbJ2ltcG9ydF90eXBlJ10gPSBleHRlbnNpb247XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKCdpbXBvcnREQicsIHJlcXVlc3RfZGF0YSlcbiAgICAgIHRoaXMuc29ja2V0LnNlbmRGaWxlKGZpbGUpO1xuICAgIH0sXG4gICAgXG4gICAgbGlzdGVuOiBmdW5jdGlvbihtZXNzYWdlLCBmdW4pIHtcbiAgICAgIHRoaXMuc29ja2V0Lmxpc3RlbihtZXNzYWdlLCBmdW4pO1xuICAgIH0sXG4gICAgXG4gICAgbGlzdGVuQXN5bmM6IGZ1bmN0aW9uKGV2ZW50bmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0Lmxpc3RlbkFzeW5jKGV2ZW50bmFtZSk7XG4gICAgfSxcbiAgXG4gIFx0Y3JlYXRlU29ja2V0OiBmdW5jdGlvbihob3N0LCBuYW1lc3BhY2UpIHtcbiAgXHRcdGlmIChuYW1lc3BhY2UpIHtcbiAgXHRcdFx0dGhpcy5zb2NrZXQuY3JlYXRlKHtcbiAgXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZSwgXG4gIFx0XHRcdFx0cm9vbTogbnVsbCxcbiAgXHRcdFx0XHRob3N0OiBob3N0XG4gIFx0XHRcdH0pO1xuICBcdFx0XHR0aGlzLnNvY2tldC5zZXRHbG9iYWxTY29wZShuYW1lc3BhY2UpO1xuICBcdFx0fSBlbHNlIHtcbiAgXHRcdFx0dGhpcy5zb2NrZXQuY3JlYXRlKHtcbiAgXHRcdFx0XHRuYW1lc3BhY2U6IG51bGwsIFxuICBcdFx0XHRcdHJvb206IG51bGwsXG4gIFx0XHRcdFx0aG9zdDogaG9zdFxuICBcdFx0XHR9KTtcbiAgXHRcdH1cbiAgXHR9LFxuICBcdFxuICBcdC4uLnV0aWxzQ3J1ZFxuICB9XG4gIFxuICByZXR1cm4gQ29DcmVhdGVDUlVEO1xufSkpO1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crud-client/src/crud.js\n")},"./node_modules/@cocreate/crud-client/src/index.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! @cocreate/socket-client */ \"./node_modules/@cocreate/socket-client/src/index.js\"), __webpack_require__(/*! ./crud.js */ \"./node_modules/@cocreate/crud-client/src/crud.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(CoCreateSocket, CoCreateCRUD) {\n        \treturn factory(true, CoCreateSocket, CoCreateCRUD)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function (isBrowser, CoCreateSocket, CoCreateCRUD) {\n  if (isBrowser) {\n    \n    let crud_socket = window.CoCreateCrudSocket\n\n    if (!crud_socket) {\n      crud_socket = new CoCreateSocket('ws');\n      window.CoCreateCrudSocket = crud_socket;\n    }\n    \n    CoCreateCRUD.setSocket(crud_socket);\n    CoCreateCRUD.createSocket(window.config.host ? window.config.host : window.location.hostname, window.config.organization_Id)\n  } \n  return CoCreateCRUD;\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcnVkLWNsaWVudC9zcmMvaW5kZXguanM/NWViZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxpQ0FBTyxDQUFDLHlHQUF5QixFQUFFLHdGQUFXLENBQUMsbUNBQUU7QUFDekQ7QUFDQSxTQUFTO0FBQUEsa0dBQUM7QUFDVixLQUFLLE1BQU0sRUFVUjtBQUNILENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRztBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvY3J1ZC1jbGllbnQvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wiQGNvY3JlYXRlL3NvY2tldC1jbGllbnRcIiwgXCIuL2NydWQuanNcIl0sIGZ1bmN0aW9uKENvQ3JlYXRlU29ja2V0LCBDb0NyZWF0ZUNSVUQpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFjdG9yeSh0cnVlLCBDb0NyZWF0ZVNvY2tldCwgQ29DcmVhdGVDUlVEKVxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBsZXQgd25kID0ge1xuICAgICAgICBjb25maWc6IHt9LFxuICAgICAgICBGaWxlOiB7fVxuICAgICAgfVxuICAgICAgY29uc3QgQ29DcmVhdGVDUlVEID0gcmVxdWlyZShcIi4vY3J1ZC5qc1wiKVxuICAgICAgY29uc3QgQ29DcmVhdGVTb2NrZXQgPSByZXF1aXJlKFwiQGNvY3JlYXRlL3NvY2tldC1jbGllbnRcIilcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWxzZSwgQ29DcmVhdGVTb2NrZXQsIENvQ3JlYXRlQ1JVRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSh0cnVlLCByb290W1wiQGNvY3JlYXRlL3NvY2tldC1jbGllbnRcIl0sIHJvb3RbXCIuL2NydWQuanNcIl0pO1xuICB9XG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoaXNCcm93c2VyLCBDb0NyZWF0ZVNvY2tldCwgQ29DcmVhdGVDUlVEKSB7XG4gIGlmIChpc0Jyb3dzZXIpIHtcbiAgICBcbiAgICBsZXQgY3J1ZF9zb2NrZXQgPSB3aW5kb3cuQ29DcmVhdGVDcnVkU29ja2V0XG5cbiAgICBpZiAoIWNydWRfc29ja2V0KSB7XG4gICAgICBjcnVkX3NvY2tldCA9IG5ldyBDb0NyZWF0ZVNvY2tldCgnd3MnKTtcbiAgICAgIHdpbmRvdy5Db0NyZWF0ZUNydWRTb2NrZXQgPSBjcnVkX3NvY2tldDtcbiAgICB9XG4gICAgXG4gICAgQ29DcmVhdGVDUlVELnNldFNvY2tldChjcnVkX3NvY2tldCk7XG4gICAgQ29DcmVhdGVDUlVELmNyZWF0ZVNvY2tldCh3aW5kb3cuY29uZmlnLmhvc3QgPyB3aW5kb3cuY29uZmlnLmhvc3QgOiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUsIHdpbmRvdy5jb25maWcub3JnYW5pemF0aW9uX0lkKVxuICB9IFxuICByZXR1cm4gQ29DcmVhdGVDUlVEO1xufSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crud-client/src/index.js\n")},"./node_modules/@cocreate/crud-client/src/utils.crud.js":function(module,exports){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        \treturn factory()\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== 'undefined' ? self : this, function () {\n  \n  function \t__mergeObject(target, source) \n  {\n  \ttarget = target || {};\n  \tfor (let key of Object.keys(source)) {\n  \t\tif (source[key] instanceof Object) {\n  \t\t\tObject.assign(source[key], __mergeObject(target[key], source[key]))\n  \t\t}\n  \t}\n  \t\n  \tObject.assign(target || {}, source)\n  \treturn target\n  }\n  \n  function __createObject(data, path) \n  {\n  \tif (!path) return data;\n  \t\n  \tlet keys = path.split('.')\n  \tlet newObject = data;\n  \n  \tfor (var  i = keys.length - 1; i >= 0; i--) {\n  \t\tnewObject = {[keys[i]]: newObject}\t\t\t\t\n  \t}\n  \treturn newObject;\n  }\n  \n  function __createArray(key, data)\n  {\n    try {\n      let item = /([\\w\\W]+)\\[(\\d+)\\]/gm.exec(key)\n      if (item && item.length == 3) {\n        let arrayKey = item[1];\n        let index = parseInt(item[2]);\n        \n        if (!data[arrayKey] || !Array.isArray(data[arrayKey])) {\n          data[arrayKey] = [];\n        } \n        data[arrayKey][index] = data[key];\n        delete data[key];\n        key = arrayKey;\n      }\n    } catch {\n      console.log('create array error');\n    }\n    return key;\n  }\n  \n  function isObject(item) {\n    return (!!item) && (item.constructor === Object);\n  }\n  function isArray(item) {\n    return (!!item) && (item.constructor === Array);\n  }\n  \n  function decodeObject(data) {\n    let keys = Object.keys(data)\n    let objectData = {};\n    \n    keys.forEach((k) => {\n      k = __createArray(k, data);\n      if (k.split('.').length > 1) {\n        let newData = __createObject(data[k], k);\n        delete data[k];\n        \n        objectData = __mergeObject(objectData, newData);\n      } else {\n        objectData[k] = data[k];\n      }\n    })\n    return objectData;\n  }\n  \n  function encodeObject(data) {\n    let keys = Object.keys(data);\n    let newData = {};\n    keys.forEach((k) => {\n      let data_value = data[k];\n      if (isObject(data[k])) {\n        let new_obj = encodeObject(data[k]);\n        \n        let newKeys = Object.keys(new_obj);\n        newKeys.forEach((newKey) => {\n          let value = new_obj[newKey];\n          newKey = k + \".\" + newKey;\n          newData[newKey] = value;\n        })\n        \n      } else if (isArray(data_value)){\n        data_value.forEach((v, index) => {\n          newData[`${k}[${index}]`] = v;\n        })\n      } else {\n        newData[k] = data[k];\n      }\n    })\n    return newData;\n  }\n  \n  function getAttr(el) {\n    if (!el) return\n  \n    let collection = el.getAttribute('data-collection')\n    let document_id = el.getAttribute('data-document_id')\n    let name = el.getAttribute('name')\n    return { collection, document_id, name }\n  }\n  \n  function getFlagAttr(el) {\n    if (!el) return {}\n    let is_realtime = isRealtimeAttr(el);\n    let is_save = isSaveAttr(el);\n    let is_read = isReadAttr(el);\n    let is_update = isUpdateAttr(el);\n    return { is_realtime, is_save, is_read, is_update }\n  }\n  \n  const isReadAttr = (el) => ( __isValueOfAttr(el, 'data-read_value'));\n  const isSaveAttr = (el) => ( __isValueOfAttr(el, 'data-save_value'));\n  const isUpdateAttr = (el) => ( __isValueOfAttr(el, 'data-update_value'));\n  // const isRealtimeAttr = (el) => ( __isValueOfAttr(el, 'data-realtime'));\n  const isRealtimeAttr = (el) => {\n    if (!el) return false\n    let flag = el.getAttribute('data-realtime') == \"false\" ? false : true;\n    return flag\n  };\n  \n  function __isValueOfAttr(el, attr) {\n    if (!el) return false;\n    let flag = el.getAttribute(attr) === \"false\" ? false : true;\n    return flag\n  }\n  \n  function checkValue(value) {\n    if (!value) return false;\n    if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n      return false;\n    }\n  \n    return true;\n  }\n  \n  function isJsonString(str_data) {\n    try {\n      let json_data = JSON.parse(str_data);\n      if (typeof json_data === \"object\" && json_data != null) {\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n    catch (e) {\n      return false;\n    }\n  }\n  \n  function isCRDT(input) {\n    const { collection, document_id, name } = getAttr(input)\n    \n    if (isJsonString(collection)) return false;\n    if (isJsonString(name)) return false;\n  \n    if ((input.tagName === \"INPUT\" && [\"text\", \"email\", \"tel\", \"url\"].includes(input.type)) || input.tagName === \"TEXTAREA\") {\n      \n      if (!name) return false;\n      if (!isRealtimeAttr(input)) return false;\n      if (input.getAttribute(\"data-unique\") === \"true\") return false;\n      if (input.type === 'password') return false;\n      if (!isReadAttr(input)) return false;\n      return true;\n      \n    }\n    return false;\n  }\n  \n  function checkDocumentId(document_id) {\n    try {\n      if (!document_id) return false;\n      if (document_id.toLowerCase() === \"null\") return false;\n      return true;\n    } catch(error) {\n      return false;\n    }\n  }\n  \n  \n  return {\n    decodeObject,\n    encodeObject,\n    getAttr,\n    getFlagAttr,\n    isRealtimeAttr,\n    isReadAttr,\n    isSaveAttr,\n    isUpdateAttr,\n    checkValue,\n    isCRDT,\n    checkDocumentId\n  }\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jcnVkLWNsaWVudC9zcmMvdXRpbHMuY3J1ZC5qcz8xNTdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLGlDQUFPLEVBQUUsbUNBQUU7QUFDbkI7QUFDQSxTQUFTO0FBQUEsa0dBQUM7QUFDVixLQUFLLE1BQU0sRUFLUjtBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QyxpQkFBaUIscUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxPQUFPO0FBQ1A7QUFDQSxxQkFBcUIsRUFBRSxHQUFHLE1BQU07QUFDaEMsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0NBQWdDOztBQUUzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2NydWQtY2xpZW50L3NyYy91dGlscy5jcnVkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICBcdHJldHVybiBmYWN0b3J5KClcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgXG4gIGZ1bmN0aW9uIFx0X19tZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSkgXG4gIHtcbiAgXHR0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gIFx0Zm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcbiAgXHRcdGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICBcdFx0XHRPYmplY3QuYXNzaWduKHNvdXJjZVtrZXldLCBfX21lcmdlT2JqZWN0KHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpXG4gIFx0XHR9XG4gIFx0fVxuICBcdFxuICBcdE9iamVjdC5hc3NpZ24odGFyZ2V0IHx8IHt9LCBzb3VyY2UpXG4gIFx0cmV0dXJuIHRhcmdldFxuICB9XG4gIFxuICBmdW5jdGlvbiBfX2NyZWF0ZU9iamVjdChkYXRhLCBwYXRoKSBcbiAge1xuICBcdGlmICghcGF0aCkgcmV0dXJuIGRhdGE7XG4gIFx0XG4gIFx0bGV0IGtleXMgPSBwYXRoLnNwbGl0KCcuJylcbiAgXHRsZXQgbmV3T2JqZWN0ID0gZGF0YTtcbiAgXG4gIFx0Zm9yICh2YXIgIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gIFx0XHRuZXdPYmplY3QgPSB7W2tleXNbaV1dOiBuZXdPYmplY3R9XHRcdFx0XHRcbiAgXHR9XG4gIFx0cmV0dXJuIG5ld09iamVjdDtcbiAgfVxuICBcbiAgZnVuY3Rpb24gX19jcmVhdGVBcnJheShrZXksIGRhdGEpXG4gIHtcbiAgICB0cnkge1xuICAgICAgbGV0IGl0ZW0gPSAvKFtcXHdcXFddKylcXFsoXFxkKylcXF0vZ20uZXhlYyhrZXkpXG4gICAgICBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgIGxldCBhcnJheUtleSA9IGl0ZW1bMV07XG4gICAgICAgIGxldCBpbmRleCA9IHBhcnNlSW50KGl0ZW1bMl0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkYXRhW2FycmF5S2V5XSB8fCAhQXJyYXkuaXNBcnJheShkYXRhW2FycmF5S2V5XSkpIHtcbiAgICAgICAgICBkYXRhW2FycmF5S2V5XSA9IFtdO1xuICAgICAgICB9IFxuICAgICAgICBkYXRhW2FycmF5S2V5XVtpbmRleF0gPSBkYXRhW2tleV07XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgIGtleSA9IGFycmF5S2V5O1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgY29uc29sZS5sb2coJ2NyZWF0ZSBhcnJheSBlcnJvcicpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIFxuICBmdW5jdGlvbiBpc09iamVjdChpdGVtKSB7XG4gICAgcmV0dXJuICghIWl0ZW0pICYmIChpdGVtLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuICB9XG4gIGZ1bmN0aW9uIGlzQXJyYXkoaXRlbSkge1xuICAgIHJldHVybiAoISFpdGVtKSAmJiAoaXRlbS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpO1xuICB9XG4gIFxuICBmdW5jdGlvbiBkZWNvZGVPYmplY3QoZGF0YSkge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICBsZXQgb2JqZWN0RGF0YSA9IHt9O1xuICAgIFxuICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgayA9IF9fY3JlYXRlQXJyYXkoaywgZGF0YSk7XG4gICAgICBpZiAoay5zcGxpdCgnLicpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGV0IG5ld0RhdGEgPSBfX2NyZWF0ZU9iamVjdChkYXRhW2tdLCBrKTtcbiAgICAgICAgZGVsZXRlIGRhdGFba107XG4gICAgICAgIFxuICAgICAgICBvYmplY3REYXRhID0gX19tZXJnZU9iamVjdChvYmplY3REYXRhLCBuZXdEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdERhdGFba10gPSBkYXRhW2tdO1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIG9iamVjdERhdGE7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGVuY29kZU9iamVjdChkYXRhKSB7XG4gICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICBsZXQgbmV3RGF0YSA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgbGV0IGRhdGFfdmFsdWUgPSBkYXRhW2tdO1xuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFba10pKSB7XG4gICAgICAgIGxldCBuZXdfb2JqID0gZW5jb2RlT2JqZWN0KGRhdGFba10pO1xuICAgICAgICBcbiAgICAgICAgbGV0IG5ld0tleXMgPSBPYmplY3Qua2V5cyhuZXdfb2JqKTtcbiAgICAgICAgbmV3S2V5cy5mb3JFYWNoKChuZXdLZXkpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBuZXdfb2JqW25ld0tleV07XG4gICAgICAgICAgbmV3S2V5ID0gayArIFwiLlwiICsgbmV3S2V5O1xuICAgICAgICAgIG5ld0RhdGFbbmV3S2V5XSA9IHZhbHVlO1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhX3ZhbHVlKSl7XG4gICAgICAgIGRhdGFfdmFsdWUuZm9yRWFjaCgodiwgaW5kZXgpID0+IHtcbiAgICAgICAgICBuZXdEYXRhW2Ake2t9WyR7aW5kZXh9XWBdID0gdjtcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0RhdGFba10gPSBkYXRhW2tdO1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIG5ld0RhdGE7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldEF0dHIoZWwpIHtcbiAgICBpZiAoIWVsKSByZXR1cm5cbiAgXG4gICAgbGV0IGNvbGxlY3Rpb24gPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpXG4gICAgbGV0IGRvY3VtZW50X2lkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJylcbiAgICBsZXQgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgcmV0dXJuIHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBnZXRGbGFnQXR0cihlbCkge1xuICAgIGlmICghZWwpIHJldHVybiB7fVxuICAgIGxldCBpc19yZWFsdGltZSA9IGlzUmVhbHRpbWVBdHRyKGVsKTtcbiAgICBsZXQgaXNfc2F2ZSA9IGlzU2F2ZUF0dHIoZWwpO1xuICAgIGxldCBpc19yZWFkID0gaXNSZWFkQXR0cihlbCk7XG4gICAgbGV0IGlzX3VwZGF0ZSA9IGlzVXBkYXRlQXR0cihlbCk7XG4gICAgcmV0dXJuIHsgaXNfcmVhbHRpbWUsIGlzX3NhdmUsIGlzX3JlYWQsIGlzX3VwZGF0ZSB9XG4gIH1cbiAgXG4gIGNvbnN0IGlzUmVhZEF0dHIgPSAoZWwpID0+ICggX19pc1ZhbHVlT2ZBdHRyKGVsLCAnZGF0YS1yZWFkX3ZhbHVlJykpO1xuICBjb25zdCBpc1NhdmVBdHRyID0gKGVsKSA9PiAoIF9faXNWYWx1ZU9mQXR0cihlbCwgJ2RhdGEtc2F2ZV92YWx1ZScpKTtcbiAgY29uc3QgaXNVcGRhdGVBdHRyID0gKGVsKSA9PiAoIF9faXNWYWx1ZU9mQXR0cihlbCwgJ2RhdGEtdXBkYXRlX3ZhbHVlJykpO1xuICAvLyBjb25zdCBpc1JlYWx0aW1lQXR0ciA9IChlbCkgPT4gKCBfX2lzVmFsdWVPZkF0dHIoZWwsICdkYXRhLXJlYWx0aW1lJykpO1xuICBjb25zdCBpc1JlYWx0aW1lQXR0ciA9IChlbCkgPT4ge1xuICAgIGlmICghZWwpIHJldHVybiBmYWxzZVxuICAgIGxldCBmbGFnID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJykgPT0gXCJmYWxzZVwiID8gZmFsc2UgOiB0cnVlO1xuICAgIHJldHVybiBmbGFnXG4gIH07XG4gIFxuICBmdW5jdGlvbiBfX2lzVmFsdWVPZkF0dHIoZWwsIGF0dHIpIHtcbiAgICBpZiAoIWVsKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGZsYWcgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cikgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdHJ1ZTtcbiAgICByZXR1cm4gZmxhZ1xuICB9XG4gIFxuICBmdW5jdGlvbiBjaGVja1ZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgve3tcXHMqKFtcXHdcXFddKylcXHMqfX0vZy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGlzSnNvblN0cmluZyhzdHJfZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBsZXQganNvbl9kYXRhID0gSlNPTi5wYXJzZShzdHJfZGF0YSk7XG4gICAgICBpZiAodHlwZW9mIGpzb25fZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBqc29uX2RhdGEgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICBmdW5jdGlvbiBpc0NSRFQoaW5wdXQpIHtcbiAgICBjb25zdCB7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lIH0gPSBnZXRBdHRyKGlucHV0KVxuICAgIFxuICAgIGlmIChpc0pzb25TdHJpbmcoY29sbGVjdGlvbikpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaXNKc29uU3RyaW5nKG5hbWUpKSByZXR1cm4gZmFsc2U7XG4gIFxuICAgIGlmICgoaW5wdXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIFtcInRleHRcIiwgXCJlbWFpbFwiLCBcInRlbFwiLCBcInVybFwiXS5pbmNsdWRlcyhpbnB1dC50eXBlKSkgfHwgaW5wdXQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSB7XG4gICAgICBcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFpc1JlYWx0aW1lQXR0cihpbnB1dCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVuaXF1ZVwiKSA9PT0gXCJ0cnVlXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChpbnB1dC50eXBlID09PSAncGFzc3dvcmQnKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIWlzUmVhZEF0dHIoaW5wdXQpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIFxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGNoZWNrRG9jdW1lbnRJZChkb2N1bWVudF9pZCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWRvY3VtZW50X2lkKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZG9jdW1lbnRfaWQudG9Mb3dlckNhc2UoKSA9PT0gXCJudWxsXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgXG4gIFxuICByZXR1cm4ge1xuICAgIGRlY29kZU9iamVjdCxcbiAgICBlbmNvZGVPYmplY3QsXG4gICAgZ2V0QXR0cixcbiAgICBnZXRGbGFnQXR0cixcbiAgICBpc1JlYWx0aW1lQXR0cixcbiAgICBpc1JlYWRBdHRyLFxuICAgIGlzU2F2ZUF0dHIsXG4gICAgaXNVcGRhdGVBdHRyLFxuICAgIGNoZWNrVmFsdWUsXG4gICAgaXNDUkRULFxuICAgIGNoZWNrRG9jdW1lbnRJZFxuICB9XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/crud-client/src/utils.crud.js\n")},"./node_modules/@cocreate/cursors/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _CoCreate_cursors_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CoCreate-cursors.css */ \"./node_modules/@cocreate/cursors/src/CoCreate-cursors.css\");\n/*global Element*/\n\n// import utils from '@cocreate/utils';\n\n// import input from '@cocreate/input'\n\n\n\n/**Uso esta variable para mostrar errores en caso que no este en prod*/\n\nvar element_multicursors = document.querySelectorAll('input,textarea,[contenteditable]')\n\n//console.log(element_multicursors)\nvar debug = false\nvar enviroment_prod = true\nvar properties = ['boxSizing','borderTopWidth','borderRightWidth','borderBottomWidth','borderLeftWidth','paddingTop','paddingRight','paddingBottom','paddingLeft','marginTop','marginRight','marginBottom','marginLeft','fontStyle','fontVariant','fontWeight','fontStretch','fontSize','lineHeight','fontFamily','textAlign','textTransform','textIndent','textDecoration','letterSpacing','wordSpacing','textRendering','webkitWritingMode','textTransform','textIndent','overflowWrap'];\nvar length_uuid = 30;\n\n\nclass CocreateUtilsCursor{\n  \n  static print(message,debug) {\n    debug = debug || false;\n    if(debug)\n      console.log(message)\n  }\n  \n  static generateUUID(length=null) {\n    var d = new Date().getTime();\n    var d2 = (performance && performance.now && (performance.now()*1000)) || 0;//Time in microseconds since page-load or 0 if unsupported\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16;\n        if(d > 0){\n            var r = (d + r)%16 | 0;\n            d = Math.floor(d/16);\n        } else {\n            var r = (d2 + r)%16 | 0;\n            d2 = Math.floor(d2/16);\n        }\n        return (c=='x' ? r : (r&0x7|0x8)).toString(16);\n    });\n    if(length!=null){\n      uuid = uuid.substr(0,length)\n    }\n    return uuid;\n  }\n  \n}\n\nvar getParents = function (elem, selector) {\n\n// \tif (!Element.prototype.matches) {\n// \t\tElement.prototype.matches =\n// \t\t\tElement.prototype.matchesSelector ||\n// \t\t\tElement.prototype.mozMatchesSelector ||\n// \t\t\tElement.prototype.msMatchesSelector ||\n// \t\t\tElement.prototype.oMatchesSelector ||\n// \t\t\tElement.prototype.webkitMatchesSelector ||\n// \t\t\tfunction(s) {\n// \t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s),\n// \t\t\t\t\ti = matches.length;\n// \t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n// \t\t\t\treturn i > -1;\n// \t\t\t};\n// \t}\n}\n\nvar mirrorDiv, computed, style, computedParentElement;\n\nvar getCaretCoordinates = function (element, position_start, position_end) {\n  // mirrored div\n  let name = element.getAttribute('name')\n  let document_id = element.getAttribute('data-document_id') || '';\n  if(document_id == ''){\n    return false;\n  }\n  var ID_MIRROR = element.dataset['mirror_id']; //document_id + name +  '--mirror-div';\n  mirrorDiv = document.getElementById(ID_MIRROR);\n  var add_class_scroll = (element.className.indexOf('floating-label') == -1) ? false : true;\n\n  if (!mirrorDiv) {\n    mirrorDiv = document.createElement('div');\n    mirrorDiv.id = ID_MIRROR;//document_id +name+ '--mirror-div';\n      mirrorDiv.className = (enviroment_prod) ? 'mirror_color mirror_scroll mirror-width-scroll' : 'mirror-width-scroll';\n    //document.body.appendChild(mirrorDiv);\n    element.insertAdjacentElement('afterend',mirrorDiv);\n  }\n\n  var scrollwidth = element.offsetWidth - element.scrollWidth;\n\n  style = mirrorDiv.style;\n  computed = getComputedStyle(element);\n  computedParentElement = getComputedStyle(element.parentElement);\n  let margin_top = parseInt(computed['marginTop'])\n  let margin_left = parseInt(computed['marginLeft'])\n\n  if (element.nodeName !== 'INPUT'){\n    style.wordWrap = 'break-word';  // only for textarea-s\n    style.whiteSpace = 'pre-wrap';\n  }else{\n    style.whiteSpace = 'pre';\n  }\n  // position off-screen\n  style.position = 'absolute';  // required to return coordinates properly\n  \n  var rect = element.getBoundingClientRect(); // get Position from element\n  \n  \n  let scrrollTop_browser = document.documentElement.scrollTop\n  \n  //style.top = ((rect.top+scrrollTop_browser)-1) - (parseInt(computed['marginTop']) - parseInt(computed['borderTopWidth']) ) + 'px'//parseInt(computed.borderTopWidth) + 'px'; //  element.offsetTop + parseInt(computed.borderTopWidth) + 'px';\n  //style.top = computedParentElement['top'];\n  style.top = element.offsetTop+'px';\n  //style.left = rect.left - (parseInt(computed['marginLeft']) -  parseInt(computed['borderLeftWidth']) ) + 'px'//parseInt(computed.borderLeftWidth) + 'px'   // margin_left+\"px\";//\"400px\";\n  //style.left =  computedParentElement['left'];\n  style.left = element.offsetLeft+'px';\n  style.width = rect.width+'px';// - (parseInt(computed.borderLeftWidth) + parseInt(computed.borderRightWidth)) + 'px'   // margin_left+\"px\";//\"400px\";\n  style.height = rect.height+'px';// - (parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth)) + 'px'   // margin_left+\"px\";//\"400px\";\n  style.visibility ='visible'\n  properties.forEach(function (prop) {\n    if(['left','top'].indexOf(prop.toLowerCase()) === -1)\n    style[prop] = computed[prop];\n  });\n  \n  style.overflowX ='auto';\n  style.overflowY ='hidden';\n  style.margin = '0px'\n  //style.padding = '0px'\n  style.border = computed['border'];\n  style.borderColor = 'transparent';\n  /* \n  if(element.nodeName.toLowerCase()=='input'){\n    style.overflowX ='auto';\n    style.overflowY ='hidden';\n  }else{\n    style.overflow=\"visible\"\n  }*/\n  \n  // style.paddingRight = (parseInt(style.paddingRight) + scrollwidth - parseInt(computed.borderRightWidth)) +'px';\n  let cursor_container = mirrorDiv.querySelectorAll('.cursor-container');\n  let selectors_by_users = mirrorDiv.querySelectorAll('.selectors_by_users');\n  let value_element = (['TEXTAREA','INPUT'].indexOf(element.nodeName)==-1) ?element.innerHTML :element.value;\n\n  mirrorDiv.textContent = value_element.substring(0, position_start);\n  if (element.nodeName === 'INPUT')\n    mirrorDiv.textContent = mirrorDiv.textContent.replace(/\\s/g, \"\\u00a0\");\n  var span = document.createElement('span');\n  span.id = element.nodeName + 'span_selections';\n  let value_span = value_element.substring(position_start,position_end) || ''\n  span.textContent = value_span;  // || because a completely empty faux span doesn't render at all\n  //span.style.backgroundColor = \"lightgrey\";\n  mirrorDiv.appendChild(span);\n  \n  if(cursor_container){\n      cursor_container.forEach(function (child_cursor, index, array) {\n        mirrorDiv.appendChild(child_cursor);\n    })\n  }\n  \n  if(selectors_by_users){\n    selectors_by_users.forEach(function (child_selection, index, array) {\n        mirrorDiv.appendChild(child_selection);\n    })\n  }\n  \n  let value_end = value_element.substring(position_end)  || '';\n  var span_end = document.createElement('span');\n  mirrorDiv.appendChild(span_end);\n  span_end.textContent = value_end;\n  var rect = element.getBoundingClientRect(); // get Position from element\n  var coordinates = {\n    start : {\n        top: span.offsetTop,\n        left:  span.offsetLeft\n    },\n    end : {\n        top: span_end.offsetTop, //+ parseInt(computed['borderTopWidth']),\n        left:  span_end.offsetLeft // + parseInt(computed['borderLeftWidth'])\n    }\n  };\n\n  return coordinates;\n}\n\nfunction getStyle(el,styleProp)\n{\n    if (window.getComputedStyle)\n        var y = document.defaultView.getComputedStyle(el,null).getPropertyValue(styleProp);\n    return y;\n}\n\n\nfunction getDocument(collection,module_id){\n  _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().readDocument({\n    'collection': collection,\n    'document_id': module_id\n  })\n}\n\n_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().listen('readDocument', function(data) {\n    let cursor = document.querySelector('.cursor-flag[data-document_id=\"'+data['document_id']+'\"]')\n    if (cursor)\n      cursor.innerHTML = data.result[cursor.getAttribute('name')]\n})\n\n\nfunction draw_cursor(json){\n        CocreateUtilsCursor.print([\"draw Cursor \",json],debug)\n        let element = json['element'];\n        let activate_cursor = (element.dataset['cursors'])?element.dataset['mirror_id']:true;\n        if(activate_cursor){\n          let start = json['startPosition']\n          let end = json['endPositon']\n          let socket_id = json['clientId']\n          let document_id = element.getAttribute('data-document_id') || '';\n          if(document_id!=''){\n            CocreateUtilsCursor.print(\"action document_id \" + document_id,debug)\n            if( typeof element.dataset['mirror_id'] == 'undefined' || element.dataset['mirror_id'] == '')\n                element.dataset['mirror_id'] = CocreateUtilsCursor.generateUUID(length_uuid)\n            let coordinates = getCaretCoordinates(element,start,end);\n            if(!coordinates)\n              return false;\n            let name = element.getAttribute('name')\n            let id_mirror = element.dataset['mirror_id']; //document_id+name+'--mirror-div'\n            let mi_mirror = document.getElementById(id_mirror)\n            let cursor = false;\n            let selection_user = false;\n            let identify = '_'+id_mirror;\n            let user = (typeof(json) != 'undefined' && json.hasOwnProperty('user')) ? json.user : false\n            let user_id = (typeof(json) != 'undefined' && json.hasOwnProperty('user_id') ) ?  user.user_id : false\n            if (socket_id){\n               //if(data && data.hasOwnProperty('id_mirror')){\n                 var cursores_other_elements = document.querySelectorAll('#socket_'+socket_id+identify)\n                 cursores_other_elements.forEach(function(child_cursor, index, array){\n                   if(child_cursor.parentElement.getAttribute('id') != id_mirror){\n                     CocreateUtilsCursor.print(\"remove old cursor others elements\",debug)\n                      child_cursor.remove()\n                   }\n                 })\n               //}\n                 cursor = mi_mirror.querySelector('.cursor-container#socket_'+socket_id+identify);\n                 if(!cursor  && json.hasOwnProperty('user')){\n                    if(user){\n                      CocreateUtilsCursor.print(\"Create Cursor\",debug)\n                      let cursor_template = '<div style=\"color:blue;\" class=\"cursor-container\" \\\n                                                  id=\"socket_'+socket_id+identify+'\" \\\n                                                  ><div class=\"cursor\" \\\n                                                  style=\"background-color:'+user.color+'\"></div>\\\n                                                  <div class=\"cursor-flag\" data-collection=\"users\" \\\n                                                  name=\"name\" \\\n                                                  data-user_name=\"'+user.name+'\" \\\n                                                  data-user_color=\"'+user.color+'\" \\\n                                                  data-socket_id=\"'+socket_id+'\" \\\n                                                  data-id_mirror=\"'+id_mirror+'\" \\\n                                                  data-document_id=\"'+user_id+'\" \\\n                                                  style=\"background-color:'+user.color+'\" \\\n                                                  flag>'+user.name+'</div></div>';\n                      mi_mirror.innerHTML = cursor_template + mi_mirror.innerHTML;\n                      \n                    }\n                    if(user_id){\n                     // si tiene user_id actualiza el nombre del cursor usando crud\n                      _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_1___default().readDocument({\n                        'collection' : 'users', \n                        'document_id': user_id\n                      })\n                   }\n                 }\n              cursor = mi_mirror.querySelector('.cursor-container#socket_'+socket_id+identify);\n            }\n            if(cursor){\n              CocreateUtilsCursor.print([\"Update Cursor\",cursor,coordinates],debug)\n              let font_size = getStyle(element,'font-size')\n              font_size = parseFloat(font_size.substring(0,font_size.length-2));\n              let cursor_height = ( (font_size * 112.5) / 100)\n              let my_cursor = cursor.querySelector('.cursor')\n              cursor.dataset.start = start\n              cursor.dataset.end = end\n              cursor.dataset.socket_id = socket_id\n              /*cursor.dataset.user_name = user.name\n              cursor.dataset.user_color = user.color*/\n  \n              cursor.style[\"top\"] = coordinates.end.top+\"px\"; \n              \n              cursor.style[\"width\"] = \"2px\";  //2px\n              my_cursor.style[\"height\"] = cursor_height+\"px\"; \n              cursor.style[\"left\"] = coordinates.end.left+\"px\"; \n              \n              //add selections\n                selection_user = document.getElementById('sel-'+socket_id+identify);\n                if((start != end) && user ){\n                      selection_user = document.getElementById('sel-'+socket_id+identify)\n                      if(selection_user){\n                        selection_user.remove()\n                      }\n                        var scrollwidth = element.offsetWidth - element.scrollWidth;\n                        var padding_right = parseInt(getComputedStyle(element)[\"paddingRight\"])\n                        selection_user = document.createElement('span');\n                        selection_user.id = 'sel-'+socket_id+identify;\n                        selection_user.className='selectors_by_users'\n                        let style_mirror = getComputedStyle(mi_mirror)\n                        selection_user.style[\"position\"] = \"absolute\"; \n                        selection_user.style[\"top\"] = style_mirror.paddingTop; \n                        selection_user.style[\"left\"] = style_mirror.paddingLeft; \n                        selection_user.style[\"padding-right\"] = scrollwidth+padding_right+\"px\"; \n                        mi_mirror.insertBefore(selection_user, mi_mirror.firstChild);\n                      let selection_span_by_user = document.createElement('span');\n                      selection_span_by_user.id = 'selection-'+socket_id+identify;\n                      selection_span_by_user.style.backgroundColor = user.color;\n                      let value_element = (['TEXTAREA','INPUT'].indexOf(element.nodeName)==-1) ?element.innerHTML :element.value;\n                      selection_user.textContent = value_element.substring(0, start);\n                      let value_span_selection = value_element.substring(start,end) || ''\n                      console.log(\"Selection \",value_span_selection,start,end)\n                      //selection_span_by_user.style.opacity = 0.5;\n                      selection_span_by_user.textContent = value_span_selection;\n                      selection_user.appendChild(selection_span_by_user)\n                }//end Selections\n                else{\n                  if(selection_user){\n                    selection_user.remove()\n                  }\n                }\n            }\n          }//end if document_id\n        }//end activate_cursors\n}//draw_cursor\n\nfunction refresh_mirror(element){\n  var id_mirror = ''\n  let document_id = element.getAttribute('data-document_id') || '';\n  if(document_id!=''){\n    name = element.getAttribute('name')\n    if(element.dataset['mirror_id'])\n      id_mirror = element.dataset['mirror_id']\n      else \n      return;\n    //console.log(\"Refresh \",id_mirror)\n    var mi_mirror = document.getElementById(id_mirror)\n    CocreateUtilsCursor.print([\"refresh_mirror \",mi_mirror],debug)\n    var selector_element = element.nodeName+\"[name='\"+name+\"'][data-document_id='\"+document_id+\"']\"\n    CocreateUtilsCursor.print([\"selector -> \"+selector_element],debug)\n    \n      if(mi_mirror){\n        computed = getComputedStyle(element);\n        style = mi_mirror.style\n        style.width = element.offsetWidth - (parseInt(computed.borderLeftWidth) + parseInt(computed.borderRightWidth)) + 'px'\n        style.height = element.offsetHeight - (parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth)) + 'px'\n        var cursor_container = mi_mirror.querySelectorAll('.cursor-container');\n        cursor_container.forEach(function (child_cursor, index, array) {\n          //console.log(\"REdraw cursor\")\n        let child = child_cursor.querySelector('.cursor-flag');\n        let dataset_child = child.dataset;\n        let dataset = child_cursor.dataset;\n          draw_cursor({\n                            element:element,\n                            startPosition:dataset.start,\n                            endPositon:dataset.end,\n                            clientId : dataset.socket_id,\n                            user:{\n                                'color':dataset_child.user_color,\n                                'name':dataset.user_name\n                                },\n                        });\n        })\n      }\n  }//end document\n}//end verify \n\nElement.prototype.remove = function() {\n  if (this.parentElement) {\n    this.parentElement.removeChild(this);\n  }\n}\n\nfunction recalculate_local_cursors(element,count){\n          CocreateUtilsCursor.print(\"count \"+count,debug)\n          let my_start = ( ! element.hasAttribute('contenteditable'))  ? element.selectionStart : parseInt(element.getAttribute(\"selection_start\"));\n          //let my_start   = element.selectionStart\n          let name = element.getAttribute('name') || '';\n          let document_id = element.getAttribute('data-document_id') || '';\n          let collection = element.getAttribute('data-collection') || '';\n          let selector = '[data-collection=\"'+collection+'\"][data-document_id=\"'+document_id+'\"][name=\"'+name+'\"]'\n          let id_mirror = element.dataset['mirror_id']; //let id_mirror = document_id+name+'--mirror-div';\n          let mirrorDiv = document.getElementById(id_mirror);\n          let cursor_container = (mirrorDiv) ? mirrorDiv.querySelectorAll('.cursor-container') : null;\n          if(cursor_container){\n              let containers_cursors = [];\n              cursor_container.forEach(function (child_cursor, index, array) {\n                  let start = parseInt(child_cursor.getAttribute('data-start'));\n                  let user_name = child_cursor.getAttribute('data-user_name');\n                    CocreateUtilsCursor.print([\"my_start local\",my_start,'start cursor '+user_name+\" = \",start],debug)\n                  if(start > my_start && containers_cursors.indexOf(user_name) == -1 ){\n                    CocreateUtilsCursor.print(\"Es mayor\",debug)\n                    let end = parseInt(child_cursor.getAttribute('data-end'));\n                    let pos_start = start+count;\n                    let pos_end = end+count;\n                    CocreateUtilsCursor.print(['pos_start',pos_start,'pos_end',pos_end],debug)\n                    let dataset = child_cursor.querySelector('.cursor-flag').dataset\n                    let clientId = dataset.socket_id;\n                    let json = {\n                                element:element,\n                                startPosition:pos_start,\n                                endPositon:pos_end,\n                                clientId:clientId,\n                                'user':{\n                                    'color':dataset.user_color,\n                                    'name':dataset.user_name\n                                    },\n                            }\n                    CocreateUtilsCursor.print([\"sent Draw Cursor \",json],debug)\n                    draw_cursor(json);\n                    containers_cursors.push(user_name);\n                  }\n                  \n                //mirrorDiv.appendChild(child_cursor);\n            })\n          }\n}\n\nfunction initCursorEl(element){\n  let formulario = getParents(element,'form')\n          let realtime = element.hasAttribute('data-realtime') ? element.getAttribute('data-realtime') : 'true';\n          if( realtime =='true' ||  (formulario && formulario.getAttribute('data-realtime') =='true' ) ){\n            if(realtime =='false')\n                      return false;\n                  CocreateUtilsCursor.print([\"Init Events \",element],debug)\n                  /*\n                  element.addEventListener('input',function(event){\n                      let start = element.selectionStart;\n                      let end = element.selectionEnd;\n                      let coordinates = getCaretCoordinates(element,start,end);\n                      let count = 0;\n                      switch(event.inputType){\n                        case 'insertText':\n                          count = 1;\n                        break;\n                        case 'insertFromPaste':\n                         // count = event.clipboardData.getData('Text').length\n                        break;\n                        case 'deleteContentBackward':\n                        //case 'insertFromPaste':\n                          count = -1;\n                        break;\n                      }\n                      if(count)\n                        recalculate_local_cursors(this,count)\n                  },false)\n                  */\n                    element.addEventListener('scroll',function(){\n                      CocreateUtilsCursor.print([\"Move Scroll \",element],true)\n                      let name = element.getAttribute('name')\n                      let document_id = element.getAttribute('data-document_id') || '';\n                      let id_mirror = element.dataset['mirror_id'];\n                      let mi_mirror = document.getElementById(id_mirror)\n                      if(mi_mirror){\n                        mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                      }\n                    },false)\n                    \n                    //resize\n                    function outputsize() {\n                      element_multicursors.forEach(function (element_for, index, array) {\n                              let name = element_for.getAttribute('name')\n                              let id_mirror = element.dataset['mirror_id']; \n                              CocreateUtilsCursor.print([\"Resize id_mirror -> \"+id_mirror],debug)\n                              let mi_mirror = document.getElementById(id_mirror)\n                              if(mi_mirror){\n                                mi_mirror.style[\"width\"] = element_for.offsetWidth+\"px\";\n                                mi_mirror.style[\"height\"] = element_for.offsetHeight+\"px\";\n                                //var isFocused = (document.activeElement === element_for);\n                                //verify_cursor(element_for,isFocused)\n                                var isFocused = (document.activeElement === element);\n                                if(isFocused)\n                                  getCaretCoordinates(element,element.selectionStart,element.selectionEnd)\n                                refresh_mirror(element)\n                              }\n                        })\n                    }\n                    new ResizeObserver(outputsize).observe(element)\n                  //if (element.nodeName == 'INPUT'){\n                    element.addEventListener('mousemove',function(event){\n                        let name = element.getAttribute('name')\n                        let document_id = element.getAttribute('data-document_id')\n                        let id_mirror = element.dataset['mirror_id'];\n                        let mi_mirror = document.getElementById(id_mirror)\n                        if(mi_mirror)\n                          mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                    });\n                    \n                    element.addEventListener('focusout',function(event){\n                        let name = element.getAttribute('name')\n                        let document_id = element.getAttribute('data-document_id') || '';\n                        let id_mirror = element.dataset['mirror_id'];\n                        let mi_mirror = document.getElementById(id_mirror)\n                        if(mi_mirror)\n                          mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                    })\n                    \n                    element.addEventListener('keydown',function(event){\n                      //console.log(\"keydown L,T => \",element.scrollLeft,element.scrollTop)\n                         let name = element.getAttribute('name')\n                         let id_mirror = element.dataset['mirror_id'];\n                          let mi_mirror = document.getElementById(id_mirror)\n                          if(mi_mirror){\n                            mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);  \n                            refresh_mirror(element)\n                          }\n                    });\n                    \n                    \n                    element.addEventListener('keyup',function(event){\n                      //console.log(\"keyup L,T => \",element.scrollLeft,element.scrollTop)\n                       let name = element.getAttribute('name')\n                       let id_mirror = element.dataset['mirror_id'];\n                        let mi_mirror = document.getElementById(id_mirror)\n                        if(mi_mirror)\n                          mi_mirror.scrollTo(element.scrollLeft,element.scrollTop);\n                    })\n                    \n                  //}\n          }//end if realtime TRUE\n}\n\nvar initialize_multicursor = function(element_multicursors){\n      element_multicursors.forEach(function (element, index, array) {\n          initCursorEl(element);\n      }); // element_multicursors.forEach\n}//end initialize_multicursor \n\n\nwindow.addEventListener('resize', function(e){ \n  //console.log(\"resize windows\")\n  document.querySelectorAll('[data-mirror_id]').forEach(function (element, index, array) {\n          refresh_mirror(element)\n  }); // element_multicursors.forEach\n}, true);\ndocument.addEventListener('scroll', function(e){ \n  //console.log(\"Scroll \")\n  //console.log(\"scroll windows\",document.body.scrollLeft,document.body.scrollTop)\n  //element_multicursors.forEach(function (element, index, array) {\n  document.querySelectorAll('[data-mirror_id]').forEach(function (element, index, array) {\n          refresh_mirror(element)\n  }); // element_multicursors.forEach\n  \n  \n}, true);\n\nfunction initCursorElements(container) {\n  let mainContainer = container || window;\n  \n  if (!mainContainer.querySelectorAll) {\n    return;\n  }\n  \n  let elements = mainContainer.querySelectorAll('[data-realtime=true]');\n  \n  elements.forEach(el => {\n    initCursorEl(el);\n  })\n}\n\nif(debug)\n  console.log(\"elements to INIT -> \",element_multicursors)\ninitialize_multicursor(element_multicursors);\n\n// CoCreateInit.register_old('[data-realtime=true]',initCursorEl);\n// CoCreateInit.register('CoCreateCursor', window, initCursorElements);\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({ \n\tname: 'CoCreateCursor', \n\tobserve: ['subtree', 'childList'],\n\tinclude: '[data-collection][data-document_id][name][data-realtime=true]', \n\tcallback: function(mutation) {\n\t\tinitCursorElements(mutation.target)\n\t}\n});\n\nconst CoCreateCursors = { draw_cursor, refresh_mirror, recalculate_local_cursors };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateCursors);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jdXJzb3JzL3NyYy9pbmRleC5qcz9lN2IzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDeUM7QUFDekM7QUFDeUM7QUFDekM7O0FBRWdDOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLDZDQUE2Qzs7O0FBRzdDOztBQUVBLCtLQUErSztBQUMvSztBQUNBO0FBQ0Esa0xBQWtMO0FBQ2xMO0FBQ0E7QUFDQSxnQ0FBZ0MsNkdBQTZHO0FBQzdJLGtDQUFrQyw2R0FBNkc7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7O0FBR3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVCxDQUFDOzs7QUFHRCw4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMLENBQUM7QUFDRCxnRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUU7OztBQUdMLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBYSxFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCx5QkFBeUI7QUFDekIsaUVBQWUsZUFBZSxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jdXJzb3JzL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIEVsZW1lbnQqL1xuaW1wb3J0IG9ic2VydmVyIGZyb20gJ0Bjb2NyZWF0ZS9vYnNlcnZlcidcbi8vIGltcG9ydCB1dGlscyBmcm9tICdAY29jcmVhdGUvdXRpbHMnO1xuaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50Jztcbi8vIGltcG9ydCBpbnB1dCBmcm9tICdAY29jcmVhdGUvaW5wdXQnXG5cbmltcG9ydCAnLi9Db0NyZWF0ZS1jdXJzb3JzLmNzcyc7XG5cbi8qKlVzbyBlc3RhIHZhcmlhYmxlIHBhcmEgbW9zdHJhciBlcnJvcmVzIGVuIGNhc28gcXVlIG5vIGVzdGUgZW4gcHJvZCovXG5cbnZhciBlbGVtZW50X211bHRpY3Vyc29ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LHRleHRhcmVhLFtjb250ZW50ZWRpdGFibGVdJylcblxuLy9jb25zb2xlLmxvZyhlbGVtZW50X211bHRpY3Vyc29ycylcbnZhciBkZWJ1ZyA9IGZhbHNlXG52YXIgZW52aXJvbWVudF9wcm9kID0gdHJ1ZVxudmFyIHByb3BlcnRpZXMgPSBbJ2JveFNpemluZycsJ2JvcmRlclRvcFdpZHRoJywnYm9yZGVyUmlnaHRXaWR0aCcsJ2JvcmRlckJvdHRvbVdpZHRoJywnYm9yZGVyTGVmdFdpZHRoJywncGFkZGluZ1RvcCcsJ3BhZGRpbmdSaWdodCcsJ3BhZGRpbmdCb3R0b20nLCdwYWRkaW5nTGVmdCcsJ21hcmdpblRvcCcsJ21hcmdpblJpZ2h0JywnbWFyZ2luQm90dG9tJywnbWFyZ2luTGVmdCcsJ2ZvbnRTdHlsZScsJ2ZvbnRWYXJpYW50JywnZm9udFdlaWdodCcsJ2ZvbnRTdHJldGNoJywnZm9udFNpemUnLCdsaW5lSGVpZ2h0JywnZm9udEZhbWlseScsJ3RleHRBbGlnbicsJ3RleHRUcmFuc2Zvcm0nLCd0ZXh0SW5kZW50JywndGV4dERlY29yYXRpb24nLCdsZXR0ZXJTcGFjaW5nJywnd29yZFNwYWNpbmcnLCd0ZXh0UmVuZGVyaW5nJywnd2Via2l0V3JpdGluZ01vZGUnLCd0ZXh0VHJhbnNmb3JtJywndGV4dEluZGVudCcsJ292ZXJmbG93V3JhcCddO1xudmFyIGxlbmd0aF91dWlkID0gMzA7XG5cblxuY2xhc3MgQ29jcmVhdGVVdGlsc0N1cnNvcntcbiAgXG4gIHN0YXRpYyBwcmludChtZXNzYWdlLGRlYnVnKSB7XG4gICAgZGVidWcgPSBkZWJ1ZyB8fCBmYWxzZTtcbiAgICBpZihkZWJ1ZylcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpXG4gIH1cbiAgXG4gIHN0YXRpYyBnZW5lcmF0ZVVVSUQobGVuZ3RoPW51bGwpIHtcbiAgICB2YXIgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBkMiA9IChwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgJiYgKHBlcmZvcm1hbmNlLm5vdygpKjEwMDApKSB8fCAwOy8vVGltZSBpbiBtaWNyb3NlY29uZHMgc2luY2UgcGFnZS1sb2FkIG9yIDAgaWYgdW5zdXBwb3J0ZWRcbiAgICB2YXIgdXVpZCA9ICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24oYykge1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgICAgICAgaWYoZCA+IDApe1xuICAgICAgICAgICAgdmFyIHIgPSAoZCArIHIpJTE2IHwgMDtcbiAgICAgICAgICAgIGQgPSBNYXRoLmZsb29yKGQvMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHIgPSAoZDIgKyByKSUxNiB8IDA7XG4gICAgICAgICAgICBkMiA9IE1hdGguZmxvb3IoZDIvMTYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoYz09J3gnID8gciA6IChyJjB4N3wweDgpKS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gICAgaWYobGVuZ3RoIT1udWxsKXtcbiAgICAgIHV1aWQgPSB1dWlkLnN1YnN0cigwLGxlbmd0aClcbiAgICB9XG4gICAgcmV0dXJuIHV1aWQ7XG4gIH1cbiAgXG59XG5cbnZhciBnZXRQYXJlbnRzID0gZnVuY3Rpb24gKGVsZW0sIHNlbGVjdG9yKSB7XG5cbi8vIFx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4vLyBcdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG4vLyBcdFx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzU2VsZWN0b3IgfHxcbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0RWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcbi8vIFx0XHRcdEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuLy8gXHRcdFx0ZnVuY3Rpb24ocykge1xuLy8gXHRcdFx0XHR2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSxcbi8vIFx0XHRcdFx0XHRpID0gbWF0Y2hlcy5sZW5ndGg7XG4vLyBcdFx0XHRcdHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4vLyBcdFx0XHRcdHJldHVybiBpID4gLTE7XG4vLyBcdFx0XHR9O1xuLy8gXHR9XG59XG5cbnZhciBtaXJyb3JEaXYsIGNvbXB1dGVkLCBzdHlsZSwgY29tcHV0ZWRQYXJlbnRFbGVtZW50O1xuXG52YXIgZ2V0Q2FyZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3NpdGlvbl9zdGFydCwgcG9zaXRpb25fZW5kKSB7XG4gIC8vIG1pcnJvcmVkIGRpdlxuICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgbGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKSB8fCAnJztcbiAgaWYoZG9jdW1lbnRfaWQgPT0gJycpe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgSURfTUlSUk9SID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTsgLy9kb2N1bWVudF9pZCArIG5hbWUgKyAgJy0tbWlycm9yLWRpdic7XG4gIG1pcnJvckRpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKElEX01JUlJPUik7XG4gIHZhciBhZGRfY2xhc3Nfc2Nyb2xsID0gKGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2Zsb2F0aW5nLWxhYmVsJykgPT0gLTEpID8gZmFsc2UgOiB0cnVlO1xuXG4gIGlmICghbWlycm9yRGl2KSB7XG4gICAgbWlycm9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbWlycm9yRGl2LmlkID0gSURfTUlSUk9SOy8vZG9jdW1lbnRfaWQgK25hbWUrICctLW1pcnJvci1kaXYnO1xuICAgICAgbWlycm9yRGl2LmNsYXNzTmFtZSA9IChlbnZpcm9tZW50X3Byb2QpID8gJ21pcnJvcl9jb2xvciBtaXJyb3Jfc2Nyb2xsIG1pcnJvci13aWR0aC1zY3JvbGwnIDogJ21pcnJvci13aWR0aC1zY3JvbGwnO1xuICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtaXJyb3JEaXYpO1xuICAgIGVsZW1lbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsbWlycm9yRGl2KTtcbiAgfVxuXG4gIHZhciBzY3JvbGx3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuXG4gIHN0eWxlID0gbWlycm9yRGl2LnN0eWxlO1xuICBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGNvbXB1dGVkUGFyZW50RWxlbWVudCA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgbGV0IG1hcmdpbl90b3AgPSBwYXJzZUludChjb21wdXRlZFsnbWFyZ2luVG9wJ10pXG4gIGxldCBtYXJnaW5fbGVmdCA9IHBhcnNlSW50KGNvbXB1dGVkWydtYXJnaW5MZWZ0J10pXG5cbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgIT09ICdJTlBVVCcpe1xuICAgIHN0eWxlLndvcmRXcmFwID0gJ2JyZWFrLXdvcmQnOyAgLy8gb25seSBmb3IgdGV4dGFyZWEtc1xuICAgIHN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICB9ZWxzZXtcbiAgICBzdHlsZS53aGl0ZVNwYWNlID0gJ3ByZSc7XG4gIH1cbiAgLy8gcG9zaXRpb24gb2ZmLXNjcmVlblxuICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7ICAvLyByZXF1aXJlZCB0byByZXR1cm4gY29vcmRpbmF0ZXMgcHJvcGVybHlcbiAgXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gZ2V0IFBvc2l0aW9uIGZyb20gZWxlbWVudFxuICBcbiAgXG4gIGxldCBzY3Jyb2xsVG9wX2Jyb3dzZXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gIFxuICAvL3N0eWxlLnRvcCA9ICgocmVjdC50b3Arc2Nycm9sbFRvcF9icm93c2VyKS0xKSAtIChwYXJzZUludChjb21wdXRlZFsnbWFyZ2luVG9wJ10pIC0gcGFyc2VJbnQoY29tcHV0ZWRbJ2JvcmRlclRvcFdpZHRoJ10pICkgKyAncHgnLy9wYXJzZUludChjb21wdXRlZC5ib3JkZXJUb3BXaWR0aCkgKyAncHgnOyAvLyAgZWxlbWVudC5vZmZzZXRUb3AgKyBwYXJzZUludChjb21wdXRlZC5ib3JkZXJUb3BXaWR0aCkgKyAncHgnO1xuICAvL3N0eWxlLnRvcCA9IGNvbXB1dGVkUGFyZW50RWxlbWVudFsndG9wJ107XG4gIHN0eWxlLnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wKydweCc7XG4gIC8vc3R5bGUubGVmdCA9IHJlY3QubGVmdCAtIChwYXJzZUludChjb21wdXRlZFsnbWFyZ2luTGVmdCddKSAtICBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyTGVmdFdpZHRoJ10pICkgKyAncHgnLy9wYXJzZUludChjb21wdXRlZC5ib3JkZXJMZWZ0V2lkdGgpICsgJ3B4JyAgIC8vIG1hcmdpbl9sZWZ0K1wicHhcIjsvL1wiNDAwcHhcIjtcbiAgLy9zdHlsZS5sZWZ0ID0gIGNvbXB1dGVkUGFyZW50RWxlbWVudFsnbGVmdCddO1xuICBzdHlsZS5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0KydweCc7XG4gIHN0eWxlLndpZHRoID0gcmVjdC53aWR0aCsncHgnOy8vIC0gKHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUludChjb21wdXRlZC5ib3JkZXJSaWdodFdpZHRoKSkgKyAncHgnICAgLy8gbWFyZ2luX2xlZnQrXCJweFwiOy8vXCI0MDBweFwiO1xuICBzdHlsZS5oZWlnaHQgPSByZWN0LmhlaWdodCsncHgnOy8vIC0gKHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlckJvdHRvbVdpZHRoKSkgKyAncHgnICAgLy8gbWFyZ2luX2xlZnQrXCJweFwiOy8vXCI0MDBweFwiO1xuICBzdHlsZS52aXNpYmlsaXR5ID0ndmlzaWJsZSdcbiAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYoWydsZWZ0JywndG9wJ10uaW5kZXhPZihwcm9wLnRvTG93ZXJDYXNlKCkpID09PSAtMSlcbiAgICBzdHlsZVtwcm9wXSA9IGNvbXB1dGVkW3Byb3BdO1xuICB9KTtcbiAgXG4gIHN0eWxlLm92ZXJmbG93WCA9J2F1dG8nO1xuICBzdHlsZS5vdmVyZmxvd1kgPSdoaWRkZW4nO1xuICBzdHlsZS5tYXJnaW4gPSAnMHB4J1xuICAvL3N0eWxlLnBhZGRpbmcgPSAnMHB4J1xuICBzdHlsZS5ib3JkZXIgPSBjb21wdXRlZFsnYm9yZGVyJ107XG4gIHN0eWxlLmJvcmRlckNvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgLyogXG4gIGlmKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09J2lucHV0Jyl7XG4gICAgc3R5bGUub3ZlcmZsb3dYID0nYXV0byc7XG4gICAgc3R5bGUub3ZlcmZsb3dZID0naGlkZGVuJztcbiAgfWVsc2V7XG4gICAgc3R5bGUub3ZlcmZsb3c9XCJ2aXNpYmxlXCJcbiAgfSovXG4gIFxuICAvLyBzdHlsZS5wYWRkaW5nUmlnaHQgPSAocGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0KSArIHNjcm9sbHdpZHRoIC0gcGFyc2VJbnQoY29tcHV0ZWQuYm9yZGVyUmlnaHRXaWR0aCkpICsncHgnO1xuICBsZXQgY3Vyc29yX2NvbnRhaW5lciA9IG1pcnJvckRpdi5xdWVyeVNlbGVjdG9yQWxsKCcuY3Vyc29yLWNvbnRhaW5lcicpO1xuICBsZXQgc2VsZWN0b3JzX2J5X3VzZXJzID0gbWlycm9yRGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZWxlY3RvcnNfYnlfdXNlcnMnKTtcbiAgbGV0IHZhbHVlX2VsZW1lbnQgPSAoWydURVhUQVJFQScsJ0lOUFVUJ10uaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lKT09LTEpID9lbGVtZW50LmlubmVySFRNTCA6ZWxlbWVudC52YWx1ZTtcblxuICBtaXJyb3JEaXYudGV4dENvbnRlbnQgPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZygwLCBwb3NpdGlvbl9zdGFydCk7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnKVxuICAgIG1pcnJvckRpdi50ZXh0Q29udGVudCA9IG1pcnJvckRpdi50ZXh0Q29udGVudC5yZXBsYWNlKC9cXHMvZywgXCJcXHUwMGEwXCIpO1xuICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgc3Bhbi5pZCA9IGVsZW1lbnQubm9kZU5hbWUgKyAnc3Bhbl9zZWxlY3Rpb25zJztcbiAgbGV0IHZhbHVlX3NwYW4gPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZyhwb3NpdGlvbl9zdGFydCxwb3NpdGlvbl9lbmQpIHx8ICcnXG4gIHNwYW4udGV4dENvbnRlbnQgPSB2YWx1ZV9zcGFuOyAgLy8gfHwgYmVjYXVzZSBhIGNvbXBsZXRlbHkgZW1wdHkgZmF1eCBzcGFuIGRvZXNuJ3QgcmVuZGVyIGF0IGFsbFxuICAvL3NwYW4uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJsaWdodGdyZXlcIjtcbiAgbWlycm9yRGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuICBcbiAgaWYoY3Vyc29yX2NvbnRhaW5lcil7XG4gICAgICBjdXJzb3JfY29udGFpbmVyLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkX2N1cnNvciwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIG1pcnJvckRpdi5hcHBlbmRDaGlsZChjaGlsZF9jdXJzb3IpO1xuICAgIH0pXG4gIH1cbiAgXG4gIGlmKHNlbGVjdG9yc19ieV91c2Vycyl7XG4gICAgc2VsZWN0b3JzX2J5X3VzZXJzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkX3NlbGVjdGlvbiwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgIG1pcnJvckRpdi5hcHBlbmRDaGlsZChjaGlsZF9zZWxlY3Rpb24pO1xuICAgIH0pXG4gIH1cbiAgXG4gIGxldCB2YWx1ZV9lbmQgPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZyhwb3NpdGlvbl9lbmQpICB8fCAnJztcbiAgdmFyIHNwYW5fZW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBtaXJyb3JEaXYuYXBwZW5kQ2hpbGQoc3Bhbl9lbmQpO1xuICBzcGFuX2VuZC50ZXh0Q29udGVudCA9IHZhbHVlX2VuZDtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBnZXQgUG9zaXRpb24gZnJvbSBlbGVtZW50XG4gIHZhciBjb29yZGluYXRlcyA9IHtcbiAgICBzdGFydCA6IHtcbiAgICAgICAgdG9wOiBzcGFuLm9mZnNldFRvcCxcbiAgICAgICAgbGVmdDogIHNwYW4ub2Zmc2V0TGVmdFxuICAgIH0sXG4gICAgZW5kIDoge1xuICAgICAgICB0b3A6IHNwYW5fZW5kLm9mZnNldFRvcCwgLy8rIHBhcnNlSW50KGNvbXB1dGVkWydib3JkZXJUb3BXaWR0aCddKSxcbiAgICAgICAgbGVmdDogIHNwYW5fZW5kLm9mZnNldExlZnQgLy8gKyBwYXJzZUludChjb21wdXRlZFsnYm9yZGVyTGVmdFdpZHRoJ10pXG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBjb29yZGluYXRlcztcbn1cblxuZnVuY3Rpb24gZ2V0U3R5bGUoZWwsc3R5bGVQcm9wKVxue1xuICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSlcbiAgICAgICAgdmFyIHkgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLG51bGwpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wKTtcbiAgICByZXR1cm4geTtcbn1cblxuXG5mdW5jdGlvbiBnZXREb2N1bWVudChjb2xsZWN0aW9uLG1vZHVsZV9pZCl7XG4gIGNydWQucmVhZERvY3VtZW50KHtcbiAgICAnY29sbGVjdGlvbic6IGNvbGxlY3Rpb24sXG4gICAgJ2RvY3VtZW50X2lkJzogbW9kdWxlX2lkXG4gIH0pXG59XG5cbmNydWQubGlzdGVuKCdyZWFkRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgbGV0IGN1cnNvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jdXJzb3ItZmxhZ1tkYXRhLWRvY3VtZW50X2lkPVwiJytkYXRhWydkb2N1bWVudF9pZCddKydcIl0nKVxuICAgIGlmIChjdXJzb3IpXG4gICAgICBjdXJzb3IuaW5uZXJIVE1MID0gZGF0YS5yZXN1bHRbY3Vyc29yLmdldEF0dHJpYnV0ZSgnbmFtZScpXVxufSlcblxuXG5mdW5jdGlvbiBkcmF3X2N1cnNvcihqc29uKXtcbiAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJkcmF3IEN1cnNvciBcIixqc29uXSxkZWJ1ZylcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBqc29uWydlbGVtZW50J107XG4gICAgICAgIGxldCBhY3RpdmF0ZV9jdXJzb3IgPSAoZWxlbWVudC5kYXRhc2V0WydjdXJzb3JzJ10pP2VsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ106dHJ1ZTtcbiAgICAgICAgaWYoYWN0aXZhdGVfY3Vyc29yKXtcbiAgICAgICAgICBsZXQgc3RhcnQgPSBqc29uWydzdGFydFBvc2l0aW9uJ11cbiAgICAgICAgICBsZXQgZW5kID0ganNvblsnZW5kUG9zaXRvbiddXG4gICAgICAgICAgbGV0IHNvY2tldF9pZCA9IGpzb25bJ2NsaWVudElkJ11cbiAgICAgICAgICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICAgICAgICAgIGlmKGRvY3VtZW50X2lkIT0nJyl7XG4gICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwiYWN0aW9uIGRvY3VtZW50X2lkIFwiICsgZG9jdW1lbnRfaWQsZGVidWcpXG4gICAgICAgICAgICBpZiggdHlwZW9mIGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ10gPT0gJ3VuZGVmaW5lZCcgfHwgZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXSA9PSAnJylcbiAgICAgICAgICAgICAgICBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddID0gQ29jcmVhdGVVdGlsc0N1cnNvci5nZW5lcmF0ZVVVSUQobGVuZ3RoX3V1aWQpXG4gICAgICAgICAgICBsZXQgY29vcmRpbmF0ZXMgPSBnZXRDYXJldENvb3JkaW5hdGVzKGVsZW1lbnQsc3RhcnQsZW5kKTtcbiAgICAgICAgICAgIGlmKCFjb29yZGluYXRlcylcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICBsZXQgaWRfbWlycm9yID0gZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXTsgLy9kb2N1bWVudF9pZCtuYW1lKyctLW1pcnJvci1kaXYnXG4gICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgbGV0IGN1cnNvciA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbl91c2VyID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaWRlbnRpZnkgPSAnXycraWRfbWlycm9yO1xuICAgICAgICAgICAgbGV0IHVzZXIgPSAodHlwZW9mKGpzb24pICE9ICd1bmRlZmluZWQnICYmIGpzb24uaGFzT3duUHJvcGVydHkoJ3VzZXInKSkgPyBqc29uLnVzZXIgOiBmYWxzZVxuICAgICAgICAgICAgbGV0IHVzZXJfaWQgPSAodHlwZW9mKGpzb24pICE9ICd1bmRlZmluZWQnICYmIGpzb24uaGFzT3duUHJvcGVydHkoJ3VzZXJfaWQnKSApID8gIHVzZXIudXNlcl9pZCA6IGZhbHNlXG4gICAgICAgICAgICBpZiAoc29ja2V0X2lkKXtcbiAgICAgICAgICAgICAgIC8vaWYoZGF0YSAmJiBkYXRhLmhhc093blByb3BlcnR5KCdpZF9taXJyb3InKSl7XG4gICAgICAgICAgICAgICAgIHZhciBjdXJzb3Jlc19vdGhlcl9lbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNzb2NrZXRfJytzb2NrZXRfaWQraWRlbnRpZnkpXG4gICAgICAgICAgICAgICAgIGN1cnNvcmVzX290aGVyX2VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY2hpbGRfY3Vyc29yLCBpbmRleCwgYXJyYXkpe1xuICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkX2N1cnNvci5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSAhPSBpZF9taXJyb3Ipe1xuICAgICAgICAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChcInJlbW92ZSBvbGQgY3Vyc29yIG90aGVycyBlbGVtZW50c1wiLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkX2N1cnNvci5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgICAgICBjdXJzb3IgPSBtaV9taXJyb3IucXVlcnlTZWxlY3RvcignLmN1cnNvci1jb250YWluZXIjc29ja2V0Xycrc29ja2V0X2lkK2lkZW50aWZ5KTtcbiAgICAgICAgICAgICAgICAgaWYoIWN1cnNvciAgJiYganNvbi5oYXNPd25Qcm9wZXJ0eSgndXNlcicpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodXNlcil7XG4gICAgICAgICAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChcIkNyZWF0ZSBDdXJzb3JcIixkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgY3Vyc29yX3RlbXBsYXRlID0gJzxkaXYgc3R5bGU9XCJjb2xvcjpibHVlO1wiIGNsYXNzPVwiY3Vyc29yLWNvbnRhaW5lclwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwic29ja2V0Xycrc29ja2V0X2lkK2lkZW50aWZ5KydcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PGRpdiBjbGFzcz1cImN1cnNvclwiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonK3VzZXIuY29sb3IrJ1wiPjwvZGl2PlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJzb3ItZmxhZ1wiIGRhdGEtY29sbGVjdGlvbj1cInVzZXJzXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cIm5hbWVcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXVzZXJfbmFtZT1cIicrdXNlci5uYW1lKydcIiBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXVzZXJfY29sb3I9XCInK3VzZXIuY29sb3IrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtc29ja2V0X2lkPVwiJytzb2NrZXRfaWQrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtaWRfbWlycm9yPVwiJytpZF9taXJyb3IrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtZG9jdW1lbnRfaWQ9XCInK3VzZXJfaWQrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonK3VzZXIuY29sb3IrJ1wiIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsYWc+Jyt1c2VyLm5hbWUrJzwvZGl2PjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLmlubmVySFRNTCA9IGN1cnNvcl90ZW1wbGF0ZSArIG1pX21pcnJvci5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYodXNlcl9pZCl7XG4gICAgICAgICAgICAgICAgICAgICAvLyBzaSB0aWVuZSB1c2VyX2lkIGFjdHVhbGl6YSBlbCBub21icmUgZGVsIGN1cnNvciB1c2FuZG8gY3J1ZFxuICAgICAgICAgICAgICAgICAgICAgIGNydWQucmVhZERvY3VtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb2xsZWN0aW9uJyA6ICd1c2VycycsIFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RvY3VtZW50X2lkJzogdXNlcl9pZFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN1cnNvciA9IG1pX21pcnJvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yLWNvbnRhaW5lciNzb2NrZXRfJytzb2NrZXRfaWQraWRlbnRpZnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoY3Vyc29yKXtcbiAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJVcGRhdGUgQ3Vyc29yXCIsY3Vyc29yLGNvb3JkaW5hdGVzXSxkZWJ1ZylcbiAgICAgICAgICAgICAgbGV0IGZvbnRfc2l6ZSA9IGdldFN0eWxlKGVsZW1lbnQsJ2ZvbnQtc2l6ZScpXG4gICAgICAgICAgICAgIGZvbnRfc2l6ZSA9IHBhcnNlRmxvYXQoZm9udF9zaXplLnN1YnN0cmluZygwLGZvbnRfc2l6ZS5sZW5ndGgtMikpO1xuICAgICAgICAgICAgICBsZXQgY3Vyc29yX2hlaWdodCA9ICggKGZvbnRfc2l6ZSAqIDExMi41KSAvIDEwMClcbiAgICAgICAgICAgICAgbGV0IG15X2N1cnNvciA9IGN1cnNvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yJylcbiAgICAgICAgICAgICAgY3Vyc29yLmRhdGFzZXQuc3RhcnQgPSBzdGFydFxuICAgICAgICAgICAgICBjdXJzb3IuZGF0YXNldC5lbmQgPSBlbmRcbiAgICAgICAgICAgICAgY3Vyc29yLmRhdGFzZXQuc29ja2V0X2lkID0gc29ja2V0X2lkXG4gICAgICAgICAgICAgIC8qY3Vyc29yLmRhdGFzZXQudXNlcl9uYW1lID0gdXNlci5uYW1lXG4gICAgICAgICAgICAgIGN1cnNvci5kYXRhc2V0LnVzZXJfY29sb3IgPSB1c2VyLmNvbG9yKi9cbiAgXG4gICAgICAgICAgICAgIGN1cnNvci5zdHlsZVtcInRvcFwiXSA9IGNvb3JkaW5hdGVzLmVuZC50b3ArXCJweFwiOyBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGN1cnNvci5zdHlsZVtcIndpZHRoXCJdID0gXCIycHhcIjsgIC8vMnB4XG4gICAgICAgICAgICAgIG15X2N1cnNvci5zdHlsZVtcImhlaWdodFwiXSA9IGN1cnNvcl9oZWlnaHQrXCJweFwiOyBcbiAgICAgICAgICAgICAgY3Vyc29yLnN0eWxlW1wibGVmdFwiXSA9IGNvb3JkaW5hdGVzLmVuZC5sZWZ0K1wicHhcIjsgXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvL2FkZCBzZWxlY3Rpb25zXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VsLScrc29ja2V0X2lkK2lkZW50aWZ5KTtcbiAgICAgICAgICAgICAgICBpZigoc3RhcnQgIT0gZW5kKSAmJiB1c2VyICl7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2VsLScrc29ja2V0X2lkK2lkZW50aWZ5KVxuICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGVjdGlvbl91c2VyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ19yaWdodCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudClbXCJwYWRkaW5nUmlnaHRcIl0pXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLmlkID0gJ3NlbC0nK3NvY2tldF9pZCtpZGVudGlmeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLmNsYXNzTmFtZT0nc2VsZWN0b3JzX2J5X3VzZXJzJ1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlX21pcnJvciA9IGdldENvbXB1dGVkU3R5bGUobWlfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuc3R5bGVbXCJwb3NpdGlvblwiXSA9IFwiYWJzb2x1dGVcIjsgXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci5zdHlsZVtcInRvcFwiXSA9IHN0eWxlX21pcnJvci5wYWRkaW5nVG9wOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnN0eWxlW1wibGVmdFwiXSA9IHN0eWxlX21pcnJvci5wYWRkaW5nTGVmdDsgXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fdXNlci5zdHlsZVtcInBhZGRpbmctcmlnaHRcIl0gPSBzY3JvbGx3aWR0aCtwYWRkaW5nX3JpZ2h0K1wicHhcIjsgXG4gICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3IuaW5zZXJ0QmVmb3JlKHNlbGVjdGlvbl91c2VyLCBtaV9taXJyb3IuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbl9zcGFuX2J5X3VzZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3NwYW5fYnlfdXNlci5pZCA9ICdzZWxlY3Rpb24tJytzb2NrZXRfaWQraWRlbnRpZnk7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3NwYW5fYnlfdXNlci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB1c2VyLmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZV9lbGVtZW50ID0gKFsnVEVYVEFSRUEnLCdJTlBVVCddLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZSk9PS0xKSA/ZWxlbWVudC5pbm5lckhUTUwgOmVsZW1lbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIudGV4dENvbnRlbnQgPSB2YWx1ZV9lbGVtZW50LnN1YnN0cmluZygwLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlX3NwYW5fc2VsZWN0aW9uID0gdmFsdWVfZWxlbWVudC5zdWJzdHJpbmcoc3RhcnQsZW5kKSB8fCAnJ1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VsZWN0aW9uIFwiLHZhbHVlX3NwYW5fc2VsZWN0aW9uLHN0YXJ0LGVuZClcbiAgICAgICAgICAgICAgICAgICAgICAvL3NlbGVjdGlvbl9zcGFuX2J5X3VzZXIuc3R5bGUub3BhY2l0eSA9IDAuNTtcbiAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25fc3Bhbl9ieV91c2VyLnRleHRDb250ZW50ID0gdmFsdWVfc3Bhbl9zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uX3VzZXIuYXBwZW5kQ2hpbGQoc2VsZWN0aW9uX3NwYW5fYnlfdXNlcilcbiAgICAgICAgICAgICAgICB9Ly9lbmQgU2VsZWN0aW9uc1xuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICBpZihzZWxlY3Rpb25fdXNlcil7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbl91c2VyLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0vL2VuZCBpZiBkb2N1bWVudF9pZFxuICAgICAgICB9Ly9lbmQgYWN0aXZhdGVfY3Vyc29yc1xufS8vZHJhd19jdXJzb3JcblxuZnVuY3Rpb24gcmVmcmVzaF9taXJyb3IoZWxlbWVudCl7XG4gIHZhciBpZF9taXJyb3IgPSAnJ1xuICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICBpZihkb2N1bWVudF9pZCE9Jycpe1xuICAgIG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgaWYoZWxlbWVudC5kYXRhc2V0WydtaXJyb3JfaWQnXSlcbiAgICAgIGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ11cbiAgICAgIGVsc2UgXG4gICAgICByZXR1cm47XG4gICAgLy9jb25zb2xlLmxvZyhcIlJlZnJlc2ggXCIsaWRfbWlycm9yKVxuICAgIHZhciBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJyZWZyZXNoX21pcnJvciBcIixtaV9taXJyb3JdLGRlYnVnKVxuICAgIHZhciBzZWxlY3Rvcl9lbGVtZW50ID0gZWxlbWVudC5ub2RlTmFtZStcIltuYW1lPSdcIituYW1lK1wiJ11bZGF0YS1kb2N1bWVudF9pZD0nXCIrZG9jdW1lbnRfaWQrXCInXVwiXG4gICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJzZWxlY3RvciAtPiBcIitzZWxlY3Rvcl9lbGVtZW50XSxkZWJ1ZylcbiAgICBcbiAgICAgIGlmKG1pX21pcnJvcil7XG4gICAgICAgIGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgc3R5bGUgPSBtaV9taXJyb3Iuc3R5bGVcbiAgICAgICAgc3R5bGUud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gKHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUludChjb21wdXRlZC5ib3JkZXJSaWdodFdpZHRoKSkgKyAncHgnXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gKHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlSW50KGNvbXB1dGVkLmJvcmRlckJvdHRvbVdpZHRoKSkgKyAncHgnXG4gICAgICAgIHZhciBjdXJzb3JfY29udGFpbmVyID0gbWlfbWlycm9yLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jdXJzb3ItY29udGFpbmVyJyk7XG4gICAgICAgIGN1cnNvcl9jb250YWluZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRfY3Vyc29yLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUkVkcmF3IGN1cnNvclwiKVxuICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZF9jdXJzb3IucXVlcnlTZWxlY3RvcignLmN1cnNvci1mbGFnJyk7XG4gICAgICAgIGxldCBkYXRhc2V0X2NoaWxkID0gY2hpbGQuZGF0YXNldDtcbiAgICAgICAgbGV0IGRhdGFzZXQgPSBjaGlsZF9jdXJzb3IuZGF0YXNldDtcbiAgICAgICAgICBkcmF3X2N1cnNvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDplbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zaXRpb246ZGF0YXNldC5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRQb3NpdG9uOmRhdGFzZXQuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudElkIDogZGF0YXNldC5zb2NrZXRfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjp7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvcic6ZGF0YXNldF9jaGlsZC51c2VyX2NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbmFtZSc6ZGF0YXNldC51c2VyX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgfVxuICB9Ly9lbmQgZG9jdW1lbnRcbn0vL2VuZCB2ZXJpZnkgXG5cbkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgdGhpcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY2FsY3VsYXRlX2xvY2FsX2N1cnNvcnMoZWxlbWVudCxjb3VudCl7XG4gICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChcImNvdW50IFwiK2NvdW50LGRlYnVnKVxuICAgICAgICAgIGxldCBteV9zdGFydCA9ICggISBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpICA/IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgOiBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShcInNlbGVjdGlvbl9zdGFydFwiKSk7XG4gICAgICAgICAgLy9sZXQgbXlfc3RhcnQgICA9IGVsZW1lbnQuc2VsZWN0aW9uU3RhcnRcbiAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJykgfHwgJyc7XG4gICAgICAgICAgbGV0IGRvY3VtZW50X2lkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnKSB8fCAnJztcbiAgICAgICAgICBsZXQgY29sbGVjdGlvbiA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSB8fCAnJztcbiAgICAgICAgICBsZXQgc2VsZWN0b3IgPSAnW2RhdGEtY29sbGVjdGlvbj1cIicrY29sbGVjdGlvbisnXCJdW2RhdGEtZG9jdW1lbnRfaWQ9XCInK2RvY3VtZW50X2lkKydcIl1bbmFtZT1cIicrbmFtZSsnXCJdJ1xuICAgICAgICAgIGxldCBpZF9taXJyb3IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddOyAvL2xldCBpZF9taXJyb3IgPSBkb2N1bWVudF9pZCtuYW1lKyctLW1pcnJvci1kaXYnO1xuICAgICAgICAgIGxldCBtaXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpO1xuICAgICAgICAgIGxldCBjdXJzb3JfY29udGFpbmVyID0gKG1pcnJvckRpdikgPyBtaXJyb3JEaXYucXVlcnlTZWxlY3RvckFsbCgnLmN1cnNvci1jb250YWluZXInKSA6IG51bGw7XG4gICAgICAgICAgaWYoY3Vyc29yX2NvbnRhaW5lcil7XG4gICAgICAgICAgICAgIGxldCBjb250YWluZXJzX2N1cnNvcnMgPSBbXTtcbiAgICAgICAgICAgICAgY3Vyc29yX2NvbnRhaW5lci5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZF9jdXJzb3IsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcGFyc2VJbnQoY2hpbGRfY3Vyc29yLmdldEF0dHJpYnV0ZSgnZGF0YS1zdGFydCcpKTtcbiAgICAgICAgICAgICAgICAgIGxldCB1c2VyX25hbWUgPSBjaGlsZF9jdXJzb3IuZ2V0QXR0cmlidXRlKCdkYXRhLXVzZXJfbmFtZScpO1xuICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcIm15X3N0YXJ0IGxvY2FsXCIsbXlfc3RhcnQsJ3N0YXJ0IGN1cnNvciAnK3VzZXJfbmFtZStcIiA9IFwiLHN0YXJ0XSxkZWJ1ZylcbiAgICAgICAgICAgICAgICAgIGlmKHN0YXJ0ID4gbXlfc3RhcnQgJiYgY29udGFpbmVyc19jdXJzb3JzLmluZGV4T2YodXNlcl9uYW1lKSA9PSAtMSApe1xuICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFwiRXMgbWF5b3JcIixkZWJ1ZylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHBhcnNlSW50KGNoaWxkX2N1cnNvci5nZXRBdHRyaWJ1dGUoJ2RhdGEtZW5kJykpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zX3N0YXJ0ID0gc3RhcnQrY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3NfZW5kID0gZW5kK2NvdW50O1xuICAgICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFsncG9zX3N0YXJ0Jyxwb3Nfc3RhcnQsJ3Bvc19lbmQnLHBvc19lbmRdLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YXNldCA9IGNoaWxkX2N1cnNvci5xdWVyeVNlbGVjdG9yKCcuY3Vyc29yLWZsYWcnKS5kYXRhc2V0XG4gICAgICAgICAgICAgICAgICAgIGxldCBjbGllbnRJZCA9IGRhdGFzZXQuc29ja2V0X2lkO1xuICAgICAgICAgICAgICAgICAgICBsZXQganNvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDplbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvc2l0aW9uOnBvc19zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kUG9zaXRvbjpwb3NfZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRJZDpjbGllbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZXInOntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2xvcic6ZGF0YXNldC51c2VyX2NvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25hbWUnOmRhdGFzZXQudXNlcl9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJzZW50IERyYXcgQ3Vyc29yIFwiLGpzb25dLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBkcmF3X2N1cnNvcihqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyc19jdXJzb3JzLnB1c2godXNlcl9uYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vbWlycm9yRGl2LmFwcGVuZENoaWxkKGNoaWxkX2N1cnNvcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEN1cnNvckVsKGVsZW1lbnQpe1xuICBsZXQgZm9ybXVsYXJpbyA9IGdldFBhcmVudHMoZWxlbWVudCwnZm9ybScpXG4gICAgICAgICAgbGV0IHJlYWx0aW1lID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcmVhbHRpbWUnKSA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJykgOiAndHJ1ZSc7XG4gICAgICAgICAgaWYoIHJlYWx0aW1lID09J3RydWUnIHx8ICAoZm9ybXVsYXJpbyAmJiBmb3JtdWxhcmlvLmdldEF0dHJpYnV0ZSgnZGF0YS1yZWFsdGltZScpID09J3RydWUnICkgKXtcbiAgICAgICAgICAgIGlmKHJlYWx0aW1lID09J2ZhbHNlJylcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBDb2NyZWF0ZVV0aWxzQ3Vyc29yLnByaW50KFtcIkluaXQgRXZlbnRzIFwiLGVsZW1lbnRdLGRlYnVnKVxuICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBlbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmQgPSBlbGVtZW50LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgY29vcmRpbmF0ZXMgPSBnZXRDYXJldENvb3JkaW5hdGVzKGVsZW1lbnQsc3RhcnQsZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaChldmVudC5pbnB1dFR5cGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0VGV4dCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGVDb250ZW50QmFja3dhcmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlICdpbnNlcnRGcm9tUGFzdGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmKGNvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjYWxjdWxhdGVfbG9jYWxfY3Vyc29ycyh0aGlzLGNvdW50KVxuICAgICAgICAgICAgICAgICAgfSxmYWxzZSlcbiAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgIENvY3JlYXRlVXRpbHNDdXJzb3IucHJpbnQoW1wiTW92ZSBTY3JvbGwgXCIsZWxlbWVudF0sdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBpZF9taXJyb3IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddO1xuICAgICAgICAgICAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pX21pcnJvci5zY3JvbGxUbyhlbGVtZW50LnNjcm9sbExlZnQsZWxlbWVudC5zY3JvbGxUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzaXplXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG91dHB1dHNpemUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZWxlbWVudF9tdWx0aWN1cnNvcnMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudF9mb3IsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBlbGVtZW50X2Zvci5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29jcmVhdGVVdGlsc0N1cnNvci5wcmludChbXCJSZXNpemUgaWRfbWlycm9yIC0+IFwiK2lkX21pcnJvcl0sZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnN0eWxlW1wid2lkdGhcIl0gPSBlbGVtZW50X2Zvci5vZmZzZXRXaWR0aCtcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pX21pcnJvci5zdHlsZVtcImhlaWdodFwiXSA9IGVsZW1lbnRfZm9yLm9mZnNldEhlaWdodCtcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGlzRm9jdXNlZCA9IChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50X2Zvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmVyaWZ5X2N1cnNvcihlbGVtZW50X2Zvcixpc0ZvY3VzZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0ZvY3VzZWQgPSAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzRm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRDYXJldENvb3JkaW5hdGVzKGVsZW1lbnQsZWxlbWVudC5zZWxlY3Rpb25TdGFydCxlbGVtZW50LnNlbGVjdGlvbkVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaF9taXJyb3IoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3IFJlc2l6ZU9ic2VydmVyKG91dHB1dHNpemUpLm9ic2VydmUoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgIC8vaWYgKGVsZW1lbnQubm9kZU5hbWUgPT0gJ0lOUFVUJyl7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxmdW5jdGlvbihldmVudCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCduYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZF9taXJyb3IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1pX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnNjcm9sbFRvKGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlfbWlycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobWlfbWlycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaV9taXJyb3Iuc2Nyb2xsVG8oZWxlbWVudC5zY3JvbGxMZWZ0LGVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJrZXlkb3duIEwsVCA9PiBcIixlbGVtZW50LnNjcm9sbExlZnQsZWxlbWVudC5zY3JvbGxUb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlkX21pcnJvciA9IGVsZW1lbnQuZGF0YXNldFsnbWlycm9yX2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtaV9taXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZF9taXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1pX21pcnJvcil7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnNjcm9sbFRvKGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcCk7ICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoX21pcnJvcihlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwia2V5dXAgTCxUID0+IFwiLGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcClcbiAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgICAgICAgICAgICAgICAgICAgIGxldCBpZF9taXJyb3IgPSBlbGVtZW50LmRhdGFzZXRbJ21pcnJvcl9pZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1pX21pcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1pX21pcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWlfbWlycm9yLnNjcm9sbFRvKGVsZW1lbnQuc2Nyb2xsTGVmdCxlbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy99XG4gICAgICAgICAgfS8vZW5kIGlmIHJlYWx0aW1lIFRSVUVcbn1cblxudmFyIGluaXRpYWxpemVfbXVsdGljdXJzb3IgPSBmdW5jdGlvbihlbGVtZW50X211bHRpY3Vyc29ycyl7XG4gICAgICBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICBpbml0Q3Vyc29yRWwoZWxlbWVudCk7XG4gICAgICB9KTsgLy8gZWxlbWVudF9tdWx0aWN1cnNvcnMuZm9yRWFjaFxufS8vZW5kIGluaXRpYWxpemVfbXVsdGljdXJzb3IgXG5cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKGUpeyBcbiAgLy9jb25zb2xlLmxvZyhcInJlc2l6ZSB3aW5kb3dzXCIpXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW1pcnJvcl9pZF0nKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICByZWZyZXNoX21pcnJvcihlbGVtZW50KVxuICB9KTsgLy8gZWxlbWVudF9tdWx0aWN1cnNvcnMuZm9yRWFjaFxufSwgdHJ1ZSk7XG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbihlKXsgXG4gIC8vY29uc29sZS5sb2coXCJTY3JvbGwgXCIpXG4gIC8vY29uc29sZS5sb2coXCJzY3JvbGwgd2luZG93c1wiLGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxkb2N1bWVudC5ib2R5LnNjcm9sbFRvcClcbiAgLy9lbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbWlycm9yX2lkXScpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgIHJlZnJlc2hfbWlycm9yKGVsZW1lbnQpXG4gIH0pOyAvLyBlbGVtZW50X211bHRpY3Vyc29ycy5mb3JFYWNoXG4gIFxuICBcbn0sIHRydWUpO1xuXG5mdW5jdGlvbiBpbml0Q3Vyc29yRWxlbWVudHMoY29udGFpbmVyKSB7XG4gIGxldCBtYWluQ29udGFpbmVyID0gY29udGFpbmVyIHx8IHdpbmRvdztcbiAgXG4gIGlmICghbWFpbkNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBsZXQgZWxlbWVudHMgPSBtYWluQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXJlYWx0aW1lPXRydWVdJyk7XG4gIFxuICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICBpbml0Q3Vyc29yRWwoZWwpO1xuICB9KVxufVxuXG5pZihkZWJ1ZylcbiAgY29uc29sZS5sb2coXCJlbGVtZW50cyB0byBJTklUIC0+IFwiLGVsZW1lbnRfbXVsdGljdXJzb3JzKVxuaW5pdGlhbGl6ZV9tdWx0aWN1cnNvcihlbGVtZW50X211bHRpY3Vyc29ycyk7XG5cbi8vIENvQ3JlYXRlSW5pdC5yZWdpc3Rlcl9vbGQoJ1tkYXRhLXJlYWx0aW1lPXRydWVdJyxpbml0Q3Vyc29yRWwpO1xuLy8gQ29DcmVhdGVJbml0LnJlZ2lzdGVyKCdDb0NyZWF0ZUN1cnNvcicsIHdpbmRvdywgaW5pdEN1cnNvckVsZW1lbnRzKTtcblxub2JzZXJ2ZXIuaW5pdCh7IFxuXHRuYW1lOiAnQ29DcmVhdGVDdXJzb3InLCBcblx0b2JzZXJ2ZTogWydzdWJ0cmVlJywgJ2NoaWxkTGlzdCddLFxuXHRpbmNsdWRlOiAnW2RhdGEtY29sbGVjdGlvbl1bZGF0YS1kb2N1bWVudF9pZF1bbmFtZV1bZGF0YS1yZWFsdGltZT10cnVlXScsIFxuXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcblx0XHRpbml0Q3Vyc29yRWxlbWVudHMobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KTtcblxuY29uc3QgQ29DcmVhdGVDdXJzb3JzID0geyBkcmF3X2N1cnNvciwgcmVmcmVzaF9taXJyb3IsIHJlY2FsY3VsYXRlX2xvY2FsX2N1cnNvcnMgfTtcbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQ3Vyc29ycztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/cursors/src/index.js\n")},"./node_modules/@cocreate/form/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_observer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\");\n/* harmony import */ var _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @cocreate/utils */ \"./node_modules/@cocreate/utils/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _cocreate_action__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @cocreate/action */ \"./node_modules/@cocreate/action/src/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ \"./node_modules/@cocreate/form/src/utils.js\");\n\n\n\n\n \n\nconst CoCreateForm = {\n\t\n\trequestAttr: \"data-document_request\",\n\tselectors: [],\n\tmodules: [],\n\n\tinit: function({name, selector, callback}) {\n\t\t\n\t\tthis.modules.push({\n\t\t\tname,\n\t\t\tselector,\n\t\t\tcallback\n\t\t});\n\t\t\n\t\tif (selector) {\n\t\t\tthis.selectors.push(selector);\n\t\t}\n\t},\n\t\n\tget: function() {\n\t\treturn {\n\t\t\tselectors: this.selectors\n\t\t}\n\t},\n\t\n\tcheckID: function(element, attr = \"data-document_id\") {\n\t\tlet document_id = element.getAttribute(attr) || \"\";\n\t\tif (document_id === \"\" || document_id === \"pending\" || !_cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(document_id)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\t\n\trequest: function({form, element, nameAttr, value}) {\n\t\t\n\t\tif (!form && element) {\n\t\t\tform = element.closest('form');\n\t\t}\n\t\t\n\t\tif (form) {\n\t\t\tthis.__requestDocumentIdOfForm(form)\n\t\t} else if (element) {\n\t\t\tnameAttr = nameAttr || \"name\"\n\t\t\tthis.__requestDocumentId(element, nameAttr, value);\n\t\t}\n\t\t\n\t},\n\t\n\tinitElement: function(container) {\n\t\tconst __container = container || document\n\t\t\n\t\tif (!__container.querySelectorAll) {\n\t\t\treturn;\n\t\t}\n\t\tlet  forms = __container.querySelectorAll('form');\n\n\t\tif (forms.length === 0 && __container != document && __container.tagName === \"FORM\") {\n\t\t\tforms = [__container];\n\t\t}\n\t\t\n\t\tforms.forEach((form) => {\n\t\t\t_utils__WEBPACK_IMPORTED_MODULE_4__.default.setAttribute(form)\n\t\t\t_utils__WEBPACK_IMPORTED_MODULE_4__.default.disableAutoFill(form);\n\t\t})\n\t},\n\t\n\t__init: function() {\n\t\tconst forms = document.querySelectorAll('form');\n\t\tthis.__initEvent();\n\n\t\tforms.forEach((form) => {\n\t\t\t_utils__WEBPACK_IMPORTED_MODULE_4__.default.setAttribute(form)\n\t\t})\n\t\t\n\t},\n\t\n\t__initEvent: function() {\n\t\tconst self = this;\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('createDocument', function(data) {\n\t\t\tconst {metadata} = data;\n\t\t\tself.__receivedDocumentId(data);\n\t\t\tif (metadata == \"createDocument-action\") {\n\t\t\t\t//. dispatch EndAction\n\t\t\t}\n\t\t})\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().listen('deleteDocument', function(data) {\n\t\t\tconst {metadata} = data\n\t\t\tif (metadata === \"deleteDocument-action\") {\n\t\t\t\t//.dispatch End Action\n\t\t\t}\n\t\t})\t\n\t\tdocument.addEventListener('clicked-submitBtn', function(event) {\n\t\t\tconst {element} = event.detail;\n\n\t\t\tself.modules.forEach(({selector, callback}) => {\n\t\t\t\tif (callback && element.matches(selector)) {\n\t\t\t\t\tcallback.call(null, element);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t},\n\n\t__deleteDocumentAction: function(btn) {\n\t\tconst { collection, document_id } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(btn)\n\t\tif (_cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(collection) && _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(document_id)) {\n\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().deleteDocument({ \n\t\t\t\tcollection, \n\t\t\t\tdocument_id, \n\t\t\t\t'metadata': 'deleteDocument-action' \n\t\t\t});\n\t\t\t\n\t\t\tdocument.dispatchEvent(new CustomEvent('deletedDocument', {\n\t\t\t\tdetail: {}\n\t\t\t}))\n\t\t}\n\t},\n\t\n\t__deleteDocumentsAction: function(btn) {\n\t\tconst { collection, document_id } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(btn)\n\t\tconst selector = btn.getAttribute('data-document_target');\n\t\tif (!selector) return;\n\t\t\n\t\tconst selectedEls = document.querySelectorAll(selector)\n\t\t\n\t\tif (_utils__WEBPACK_IMPORTED_MODULE_4__.default.checkValue(collection)) {\n\t\t\tselectedEls.forEach((el) => {\n\t\t\t\tconst document_id =  el.getAttribute('data-document_id');\n\t\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().checkValue(document_id)) {\n\t\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().deleteDocument({\n\t\t\t\t\t\t'collection': collection,\n\t\t\t\t\t\t'document_id': document_id,\n\t\t\t\t\t\t'metadata': ''\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t\t\n\t\t\tdocument.dispatchEvent(new CustomEvent('deletedDocuments', {\n\t\t\t\tdetail: {}\n\t\t\t}))\n\t\t}\n\t},\n\t\n\t__createDocumentAction: function(btn) {\n\t\tconst form = btn.closest(\"form\")\n\t\tconst self = this;\n\t\tlet collections = _utils__WEBPACK_IMPORTED_MODULE_4__.default.getCOllections(form)\n\t\t\n\t\tcollections.forEach((collection) => {\n\t\t\tlet data = _utils__WEBPACK_IMPORTED_MODULE_4__.default.getFormData(form, \"\", collection);\n\t\t\t\n\t\t\tif (Object.keys(data).length == 0 && data.constructor === Object) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (_cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.checkValue(collection)) {\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().createDocument({\n\t\t\t\t\t'collection': collection,\n\t\t\t\t\t'data': data,\n\t\t\t\t\t'metadata': 'createDocument-action' ,\n\t\t\t\t\t'element':'empty'\n\t\t\t\t});\n\t\t\t\tdocument.dispatchEvent(new CustomEvent('createdDocument', {\n\t\t\t\t\tdetail: {}\n\t\t\t\t}))\n\t\t\t}\n\t\t})\n\t},\n\t\n\t__saveDocumentAction: function(btn) {\n\t\tconst form = btn.closest(\"form\")\n\n\t\tif (!_utils__WEBPACK_IMPORTED_MODULE_4__.default.checkFormValidate(form)) {\n\t\t\talert('Values are not unique');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tconst selectors = this.selectors || [];\n\t\tconst elements = form.querySelectorAll(selectors.join(','));\n\t\t\n\t\tlet request_document_id = false;\n\t\tfor (var i = 0; i < elements.length; i++) {\n\t\t\tlet el = elements[i];\n\t\t\tconst { document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(el)\n\t\t\tconst is_save = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().isSaveAttr(el)\n\t\t\tif (!is_save) continue;\n\n\t\t\tif (!_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().checkValue(document_id)) {\n\t\t\t\tif (name) request_document_id = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().isCRDT(el)) continue;\n\n\t\t\tif (_utils__WEBPACK_IMPORTED_MODULE_4__.default.isTemplateInput(el)) return;\n\n\t\t\tvar new_event = new CustomEvent(\"clicked-submitBtn\", {\n\t\t\t\tbubbles: true,\n\t\t\t\tdetail: { \n\t\t\t\t\ttype: \"submitBtn\", \n\t\t\t\t\telement: el \n\t\t\t\t}});\n\t\t\tel.dispatchEvent(new_event);  \n\t\t}\n\t\tif (request_document_id) {\n\t\t\tthis.requestDocumentIdOfForm(form)\n\t\t}\n\t\t\n\t\tdocument.dispatchEvent(new CustomEvent('savedDocument', {\n\t\t\tdetail: {}\n\t\t}))\n\t},\n\t\n\t__requestDocumentId: function(element, nameAttr = \"name\", value = null) {\n\t\tconst { collection, name }  = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().getAttr(element)\n\t\tif (!collection || !name) return \n\n\t\tconst request_id = _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.generateUUID();\n\t\telement.setAttribute(this.requestAttr, request_id);\n\t\t\n\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().createDocument({\n\t\t\t\"collection\": collection,\n\t\t\t\"element\": request_id,\n\t\t\t\"metadata\": \"\",\n\t\t})\n\t},\n\t\t\n\t__requestDocumentIdOfForm: function (form) {\n\t\t\n\t\tlet self = this;\n\t\tlet elemens = form.querySelectorAll('[name], [data-pass_to]')\n\t\t\n\t\tlet collections = [];\n\n\t\tfor (var  i = 0; i < elemens.length; i++) {\n\t\t\tlet el = elemens[i];\n\t\t\tif (el.parentNode.classList.contains('template')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst collection = el.getAttribute(\"data-collection\") || el.getAttribute(\"data-pass_collection\") || \"\";\t\n\t\t\t\n\t\t\tif (\n\t\t\t\tcollection !== \"\" && \n\t\t\t\t!collections.includes(collection) && \n\t\t\t\t(!self.checkID(el, 'data-document_id') && !self.checkID(el, 'data-pass_document_id'))\n\t\t\t) {\n\t\t\t\tconst request_id = _cocreate_utils__WEBPACK_IMPORTED_MODULE_1__.default.generateUUID();\n\t\t\t\tcollections.push(collection);\n\n\t\t\t\tel.setAttribute(this.requestAttr, request_id);\n\t\t\t\t//. get Data\n\t\t\t\t\n\t\t\t\tlet data = _utils__WEBPACK_IMPORTED_MODULE_4__.default.getFormData(form, \"\", collection);\n\t\t\t\t\n\t\t\t\t/* FixME Create Document request */\t\n\t\t\t\t_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_2___default().createDocument({\n\t\t\t\t\t\"collection\": collection,\n\t\t\t\t\t\"element\": request_id,\n\t\t\t\t\t'data': data,\n\t\t\t\t\t\"metadata\": \"\",\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t},\n\n\t__setNewIdProcess: function(element, document_id, pass) {\n\t\tif (!element) return;\n\t\t\n  \t\telement.removeAttribute(this.requestAttr);\n\t\tconst event_data = {\n\t\t\tdocument_id: document_id,\n\t\t}\n\n\t\tif (!pass && !this.checkID(element) && element.hasAttribute('name')) {\n\t\t\telement.setAttribute('data-document_id', document_id);\n\t  \t}\n\n\t  \tif (pass && !this.checkID(element, 'data-pass_document_id') && element.hasAttribute('data-pass_to')) {\n\t\t\telement.setAttribute('data-pass_document_id', document_id);\n\t\t\t// CoCreateLogic.storePassData(element)\n\t\t\t\n\t\t\tif (element.parentNode.classList.contains('submitBtn')) {\n\t\t\t\telement.click();\n\t\t\t}\n\t  \t}\n  \t\n\t\tvar event = new CustomEvent('set-document_id', {detail: event_data})\n\t\telement.dispatchEvent(event);\n\n\t},\n\t\n\t__receivedDocumentId: function(data) {\n\t\tif (!data['document_id']) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet element = document.querySelector(`[${this.requestAttr}=\"${data['element']}\"]`);\n\t\tif (!element) return;\n\t\tlet self = this;\n\t\tconst form = (element.tagName === \"FORM\") ? element : _utils__WEBPACK_IMPORTED_MODULE_4__.default.getParents(element, 'form');\n\t\tconst collection = data['collection'];\n\t\tconst id = data['document_id']\n\t\tif (form && id) {\n\t\t\tform.setAttribute('data-form_id', data['element']);\n\t\t\tconst elements = form.querySelectorAll(`[data-collection=${collection}], [data-pass_collection=${collection}]`)\n\t\t\telements.forEach(function(el) {\n\t\t\t\tel.removeAttribute(self.requestAttr);\n\t\t\t\tif (el.hasAttribute('name')) self.__setNewIdProcess(el, id);\n\t\t\t\tif (el.hasAttribute('data-pass_to')) self.__setNewIdProcess(el, id, true);\n\t\t\t})\n\t  \t\n\t\t} else if (element) {\n\t\t\tthis.__setNewIdProcess(element, id);\n\t\t}\n\t},\n}\n\nCoCreateForm.__init();\n// core.registerInit(CoCreateForm.initElement, CoCreateForm);\n\n_cocreate_observer__WEBPACK_IMPORTED_MODULE_0__.default.init({ \n\tname: 'CoCreateForm', \n\tobserve: ['subtree', 'childList'],\n\tinclude: 'form', \n\tcallback: function(mutation) {\n\t\tCoCreateForm.initElement(mutation.target)\n\t}\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"createDocument\",\n\tendEvent: \"createdDocument\",\n\tcallback: (btn, data) => {\n\t\tCoCreateForm.__createDocumentAction(btn)\n\t},\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"deleteDocument\",\n\tendEvent: \"deletedDocument\",\n\tcallback: (btn, data) => {\n\t\tCoCreateForm.__deleteDocumentAction(btn)\n\t},\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"deleteDocuments\",\n\tendEvent: \"deletedDocuments\",\n\tcallback: (btn, data) => {\n\t\tCoCreateDocument.__deleteDocumentsAction(btn)\n\t},\n})\n\n_cocreate_action__WEBPACK_IMPORTED_MODULE_3__.default.init({\n\taction: \"saveDocument\",\n\tendEvent: \"savedDocument\",\n\tcallback: (btn, data) => {\n\t\tCoCreateForm.__saveDocumentAction(btn)\n\t},\n})\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateForm);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9mb3JtL3NyYy9pbmRleC5qcz9lYmViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUM7QUFDSjtBQUNHO0FBQ0g7QUFDVjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix5QkFBeUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsMERBQTBELCtEQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQiwrQkFBK0I7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyx3REFBa0I7QUFDckIsR0FBRywyREFBcUI7QUFDeEIsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyx3REFBa0I7QUFDckIsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFLG1FQUFXO0FBQ2IsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFLG1FQUFXO0FBQ2IsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFVBQVUsUUFBUTs7QUFFbEIsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQSxTQUFTLDBCQUEwQixHQUFHLG9FQUFZO0FBQ2xELE1BQU0sK0RBQWtCLGdCQUFnQiwrREFBa0I7QUFDMUQsR0FBRywyRUFBbUIsRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0EsU0FBUywwQkFBMEIsR0FBRyxvRUFBWTtBQUNsRDtBQUNBOztBQUVBOztBQUVBLE1BQU0sc0RBQWdCO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHVFQUFlO0FBQ3ZCLEtBQUssMkVBQW1CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFvQjs7QUFFeEM7QUFDQSxjQUFjLHVEQUFpQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0EsT0FBTywrREFBa0I7QUFDekIsSUFBSSwyRUFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsT0FBTyw2REFBdUI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0EsVUFBVSxvQkFBb0IsR0FBRyxvRUFBWTtBQUM3QyxtQkFBbUIsdUVBQWU7QUFDbEM7O0FBRUEsUUFBUSx1RUFBZTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxtRUFBVzs7QUFFbEIsT0FBTywyREFBcUI7O0FBRTVCO0FBQ0E7QUFDQSxhO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBLFNBQVMsbUJBQW1CLElBQUksb0VBQVk7QUFDNUM7O0FBRUEscUJBQXFCLGlFQUFvQjtBQUN6Qzs7QUFFQSxFQUFFLDJFQUFtQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlFQUFvQjtBQUMzQzs7QUFFQTtBQUNBOztBQUVBLGVBQWUsdURBQWlCOztBQUVoQztBQUNBLElBQUksMkVBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0QsbUJBQW1CO0FBQ3JFOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLGlCQUFpQixJQUFJLGdCQUFnQjtBQUNoRjtBQUNBO0FBQ0Esd0RBQXdELHNEQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxXQUFXLDJCQUEyQixXQUFXO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBLDREQUFhLEU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBEQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCwwREFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQsMERBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVELDBEQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCxpRUFBZSxZQUFZIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9mb3JtL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvYnNlcnZlciBmcm9tICdAY29jcmVhdGUvb2JzZXJ2ZXInXG5pbXBvcnQgY2N1dGlscyBmcm9tICdAY29jcmVhdGUvdXRpbHMnXG5pbXBvcnQgY3J1ZCBmcm9tICdAY29jcmVhdGUvY3J1ZC1jbGllbnQnXG5pbXBvcnQgYWN0aW9uIGZyb20gJ0Bjb2NyZWF0ZS9hY3Rpb24nXG5pbXBvcnQgdXRpbHMgZnJvbSBcIi4vdXRpbHNcIiBcblxuY29uc3QgQ29DcmVhdGVGb3JtID0ge1xuXHRcblx0cmVxdWVzdEF0dHI6IFwiZGF0YS1kb2N1bWVudF9yZXF1ZXN0XCIsXG5cdHNlbGVjdG9yczogW10sXG5cdG1vZHVsZXM6IFtdLFxuXG5cdGluaXQ6IGZ1bmN0aW9uKHtuYW1lLCBzZWxlY3RvciwgY2FsbGJhY2t9KSB7XG5cdFx0XG5cdFx0dGhpcy5tb2R1bGVzLnB1c2goe1xuXHRcdFx0bmFtZSxcblx0XHRcdHNlbGVjdG9yLFxuXHRcdFx0Y2FsbGJhY2tcblx0XHR9KTtcblx0XHRcblx0XHRpZiAoc2VsZWN0b3IpIHtcblx0XHRcdHRoaXMuc2VsZWN0b3JzLnB1c2goc2VsZWN0b3IpO1xuXHRcdH1cblx0fSxcblx0XG5cdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbGVjdG9yczogdGhpcy5zZWxlY3RvcnNcblx0XHR9XG5cdH0sXG5cdFxuXHRjaGVja0lEOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyID0gXCJkYXRhLWRvY3VtZW50X2lkXCIpIHtcblx0XHRsZXQgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKSB8fCBcIlwiO1xuXHRcdGlmIChkb2N1bWVudF9pZCA9PT0gXCJcIiB8fCBkb2N1bWVudF9pZCA9PT0gXCJwZW5kaW5nXCIgfHwgIWNjdXRpbHMuY2hlY2tWYWx1ZShkb2N1bWVudF9pZCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdFxuXHRyZXF1ZXN0OiBmdW5jdGlvbih7Zm9ybSwgZWxlbWVudCwgbmFtZUF0dHIsIHZhbHVlfSkge1xuXHRcdFxuXHRcdGlmICghZm9ybSAmJiBlbGVtZW50KSB7XG5cdFx0XHRmb3JtID0gZWxlbWVudC5jbG9zZXN0KCdmb3JtJyk7XG5cdFx0fVxuXHRcdFxuXHRcdGlmIChmb3JtKSB7XG5cdFx0XHR0aGlzLl9fcmVxdWVzdERvY3VtZW50SWRPZkZvcm0oZm9ybSlcblx0XHR9IGVsc2UgaWYgKGVsZW1lbnQpIHtcblx0XHRcdG5hbWVBdHRyID0gbmFtZUF0dHIgfHwgXCJuYW1lXCJcblx0XHRcdHRoaXMuX19yZXF1ZXN0RG9jdW1lbnRJZChlbGVtZW50LCBuYW1lQXR0ciwgdmFsdWUpO1xuXHRcdH1cblx0XHRcblx0fSxcblx0XG5cdGluaXRFbGVtZW50OiBmdW5jdGlvbihjb250YWluZXIpIHtcblx0XHRjb25zdCBfX2NvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudFxuXHRcdFxuXHRcdGlmICghX19jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRsZXQgIGZvcm1zID0gX19jb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnZm9ybScpO1xuXG5cdFx0aWYgKGZvcm1zLmxlbmd0aCA9PT0gMCAmJiBfX2NvbnRhaW5lciAhPSBkb2N1bWVudCAmJiBfX2NvbnRhaW5lci50YWdOYW1lID09PSBcIkZPUk1cIikge1xuXHRcdFx0Zm9ybXMgPSBbX19jb250YWluZXJdO1xuXHRcdH1cblx0XHRcblx0XHRmb3Jtcy5mb3JFYWNoKChmb3JtKSA9PiB7XG5cdFx0XHR1dGlscy5zZXRBdHRyaWJ1dGUoZm9ybSlcblx0XHRcdHV0aWxzLmRpc2FibGVBdXRvRmlsbChmb3JtKTtcblx0XHR9KVxuXHR9LFxuXHRcblx0X19pbml0OiBmdW5jdGlvbigpIHtcblx0XHRjb25zdCBmb3JtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Zvcm0nKTtcblx0XHR0aGlzLl9faW5pdEV2ZW50KCk7XG5cblx0XHRmb3Jtcy5mb3JFYWNoKChmb3JtKSA9PiB7XG5cdFx0XHR1dGlscy5zZXRBdHRyaWJ1dGUoZm9ybSlcblx0XHR9KVxuXHRcdFxuXHR9LFxuXHRcblx0X19pbml0RXZlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdGNydWQubGlzdGVuKCdjcmVhdGVEb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdGNvbnN0IHttZXRhZGF0YX0gPSBkYXRhO1xuXHRcdFx0c2VsZi5fX3JlY2VpdmVkRG9jdW1lbnRJZChkYXRhKTtcblx0XHRcdGlmIChtZXRhZGF0YSA9PSBcImNyZWF0ZURvY3VtZW50LWFjdGlvblwiKSB7XG5cdFx0XHRcdC8vLiBkaXNwYXRjaCBFbmRBY3Rpb25cblx0XHRcdH1cblx0XHR9KVxuXHRcdFxuXHRcdGNydWQubGlzdGVuKCdkZWxldGVEb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdGNvbnN0IHttZXRhZGF0YX0gPSBkYXRhXG5cdFx0XHRpZiAobWV0YWRhdGEgPT09IFwiZGVsZXRlRG9jdW1lbnQtYWN0aW9uXCIpIHtcblx0XHRcdFx0Ly8uZGlzcGF0Y2ggRW5kIEFjdGlvblxuXHRcdFx0fVxuXHRcdH0pXHRcblx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGlja2VkLXN1Ym1pdEJ0bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRjb25zdCB7ZWxlbWVudH0gPSBldmVudC5kZXRhaWw7XG5cblx0XHRcdHNlbGYubW9kdWxlcy5mb3JFYWNoKCh7c2VsZWN0b3IsIGNhbGxiYWNrfSkgPT4ge1xuXHRcdFx0XHRpZiAoY2FsbGJhY2sgJiYgZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fSlcblx0fSxcblxuXHRfX2RlbGV0ZURvY3VtZW50QWN0aW9uOiBmdW5jdGlvbihidG4pIHtcblx0XHRjb25zdCB7IGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkIH0gPSBjcnVkLmdldEF0dHIoYnRuKVxuXHRcdGlmIChjY3V0aWxzLmNoZWNrVmFsdWUoY29sbGVjdGlvbikgJiYgY2N1dGlscy5jaGVja1ZhbHVlKGRvY3VtZW50X2lkKSkge1xuXHRcdFx0Y3J1ZC5kZWxldGVEb2N1bWVudCh7IFxuXHRcdFx0XHRjb2xsZWN0aW9uLCBcblx0XHRcdFx0ZG9jdW1lbnRfaWQsIFxuXHRcdFx0XHQnbWV0YWRhdGEnOiAnZGVsZXRlRG9jdW1lbnQtYWN0aW9uJyBcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZGVsZXRlZERvY3VtZW50Jywge1xuXHRcdFx0XHRkZXRhaWw6IHt9XG5cdFx0XHR9KSlcblx0XHR9XG5cdH0sXG5cdFxuXHRfX2RlbGV0ZURvY3VtZW50c0FjdGlvbjogZnVuY3Rpb24oYnRuKSB7XG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCB9ID0gY3J1ZC5nZXRBdHRyKGJ0bilcblx0XHRjb25zdCBzZWxlY3RvciA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfdGFyZ2V0Jyk7XG5cdFx0aWYgKCFzZWxlY3RvcikgcmV0dXJuO1xuXHRcdFxuXHRcdGNvbnN0IHNlbGVjdGVkRWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcilcblx0XHRcblx0XHRpZiAodXRpbHMuY2hlY2tWYWx1ZShjb2xsZWN0aW9uKSkge1xuXHRcdFx0c2VsZWN0ZWRFbHMuZm9yRWFjaCgoZWwpID0+IHtcblx0XHRcdFx0Y29uc3QgZG9jdW1lbnRfaWQgPSAgZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJyk7XG5cdFx0XHRcdGlmIChjcnVkLmNoZWNrVmFsdWUoZG9jdW1lbnRfaWQpKSB7XG5cdFx0XHRcdFx0Y3J1ZC5kZWxldGVEb2N1bWVudCh7XG5cdFx0XHRcdFx0XHQnY29sbGVjdGlvbic6IGNvbGxlY3Rpb24sXG5cdFx0XHRcdFx0XHQnZG9jdW1lbnRfaWQnOiBkb2N1bWVudF9pZCxcblx0XHRcdFx0XHRcdCdtZXRhZGF0YSc6ICcnXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdFxuXHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RlbGV0ZWREb2N1bWVudHMnLCB7XG5cdFx0XHRcdGRldGFpbDoge31cblx0XHRcdH0pKVxuXHRcdH1cblx0fSxcblx0XG5cdF9fY3JlYXRlRG9jdW1lbnRBY3Rpb246IGZ1bmN0aW9uKGJ0bikge1xuXHRcdGNvbnN0IGZvcm0gPSBidG4uY2xvc2VzdChcImZvcm1cIilcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRsZXQgY29sbGVjdGlvbnMgPSB1dGlscy5nZXRDT2xsZWN0aW9ucyhmb3JtKVxuXHRcdFxuXHRcdGNvbGxlY3Rpb25zLmZvckVhY2goKGNvbGxlY3Rpb24pID0+IHtcblx0XHRcdGxldCBkYXRhID0gdXRpbHMuZ2V0Rm9ybURhdGEoZm9ybSwgXCJcIiwgY29sbGVjdGlvbik7XG5cdFx0XHRcblx0XHRcdGlmIChPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPT0gMCAmJiBkYXRhLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNjdXRpbHMuY2hlY2tWYWx1ZShjb2xsZWN0aW9uKSkge1xuXHRcdFx0XHRjcnVkLmNyZWF0ZURvY3VtZW50KHtcblx0XHRcdFx0XHQnY29sbGVjdGlvbic6IGNvbGxlY3Rpb24sXG5cdFx0XHRcdFx0J2RhdGEnOiBkYXRhLFxuXHRcdFx0XHRcdCdtZXRhZGF0YSc6ICdjcmVhdGVEb2N1bWVudC1hY3Rpb24nICxcblx0XHRcdFx0XHQnZWxlbWVudCc6J2VtcHR5J1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NyZWF0ZWREb2N1bWVudCcsIHtcblx0XHRcdFx0XHRkZXRhaWw6IHt9XG5cdFx0XHRcdH0pKVxuXHRcdFx0fVxuXHRcdH0pXG5cdH0sXG5cdFxuXHRfX3NhdmVEb2N1bWVudEFjdGlvbjogZnVuY3Rpb24oYnRuKSB7XG5cdFx0Y29uc3QgZm9ybSA9IGJ0bi5jbG9zZXN0KFwiZm9ybVwiKVxuXG5cdFx0aWYgKCF1dGlscy5jaGVja0Zvcm1WYWxpZGF0ZShmb3JtKSkge1xuXHRcdFx0YWxlcnQoJ1ZhbHVlcyBhcmUgbm90IHVuaXF1ZScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRcblx0XHRjb25zdCBzZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9ycyB8fCBbXTtcblx0XHRjb25zdCBlbGVtZW50cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMuam9pbignLCcpKTtcblx0XHRcblx0XHRsZXQgcmVxdWVzdF9kb2N1bWVudF9pZCA9IGZhbHNlO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBlbCA9IGVsZW1lbnRzW2ldO1xuXHRcdFx0Y29uc3QgeyBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGVsKVxuXHRcdFx0Y29uc3QgaXNfc2F2ZSA9IGNydWQuaXNTYXZlQXR0cihlbClcblx0XHRcdGlmICghaXNfc2F2ZSkgY29udGludWU7XG5cblx0XHRcdGlmICghY3J1ZC5jaGVja1ZhbHVlKGRvY3VtZW50X2lkKSkge1xuXHRcdFx0XHRpZiAobmFtZSkgcmVxdWVzdF9kb2N1bWVudF9pZCA9IHRydWU7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoY3J1ZC5pc0NSRFQoZWwpKSBjb250aW51ZTtcblxuXHRcdFx0aWYgKHV0aWxzLmlzVGVtcGxhdGVJbnB1dChlbCkpIHJldHVybjtcblxuXHRcdFx0dmFyIG5ld19ldmVudCA9IG5ldyBDdXN0b21FdmVudChcImNsaWNrZWQtc3VibWl0QnRuXCIsIHtcblx0XHRcdFx0YnViYmxlczogdHJ1ZSxcblx0XHRcdFx0ZGV0YWlsOiB7IFxuXHRcdFx0XHRcdHR5cGU6IFwic3VibWl0QnRuXCIsIFxuXHRcdFx0XHRcdGVsZW1lbnQ6IGVsIFxuXHRcdFx0XHR9fSk7XG5cdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ld19ldmVudCk7ICBcblx0XHR9XG5cdFx0aWYgKHJlcXVlc3RfZG9jdW1lbnRfaWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdERvY3VtZW50SWRPZkZvcm0oZm9ybSlcblx0XHR9XG5cdFx0XG5cdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3NhdmVkRG9jdW1lbnQnLCB7XG5cdFx0XHRkZXRhaWw6IHt9XG5cdFx0fSkpXG5cdH0sXG5cdFxuXHRfX3JlcXVlc3REb2N1bWVudElkOiBmdW5jdGlvbihlbGVtZW50LCBuYW1lQXR0ciA9IFwibmFtZVwiLCB2YWx1ZSA9IG51bGwpIHtcblx0XHRjb25zdCB7IGNvbGxlY3Rpb24sIG5hbWUgfSAgPSBjcnVkLmdldEF0dHIoZWxlbWVudClcblx0XHRpZiAoIWNvbGxlY3Rpb24gfHwgIW5hbWUpIHJldHVybiBcblxuXHRcdGNvbnN0IHJlcXVlc3RfaWQgPSBjY3V0aWxzLmdlbmVyYXRlVVVJRCgpO1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMucmVxdWVzdEF0dHIsIHJlcXVlc3RfaWQpO1xuXHRcdFxuXHRcdGNydWQuY3JlYXRlRG9jdW1lbnQoe1xuXHRcdFx0XCJjb2xsZWN0aW9uXCI6IGNvbGxlY3Rpb24sXG5cdFx0XHRcImVsZW1lbnRcIjogcmVxdWVzdF9pZCxcblx0XHRcdFwibWV0YWRhdGFcIjogXCJcIixcblx0XHR9KVxuXHR9LFxuXHRcdFxuXHRfX3JlcXVlc3REb2N1bWVudElkT2ZGb3JtOiBmdW5jdGlvbiAoZm9ybSkge1xuXHRcdFxuXHRcdGxldCBzZWxmID0gdGhpcztcblx0XHRsZXQgZWxlbWVucyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnW25hbWVdLCBbZGF0YS1wYXNzX3RvXScpXG5cdFx0XG5cdFx0bGV0IGNvbGxlY3Rpb25zID0gW107XG5cblx0XHRmb3IgKHZhciAgaSA9IDA7IGkgPCBlbGVtZW5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgZWwgPSBlbGVtZW5zW2ldO1xuXHRcdFx0aWYgKGVsLnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCd0ZW1wbGF0ZScpKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY29sbGVjdGlvbiA9IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtY29sbGVjdGlvblwiKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhc3NfY29sbGVjdGlvblwiKSB8fCBcIlwiO1x0XG5cdFx0XHRcblx0XHRcdGlmIChcblx0XHRcdFx0Y29sbGVjdGlvbiAhPT0gXCJcIiAmJiBcblx0XHRcdFx0IWNvbGxlY3Rpb25zLmluY2x1ZGVzKGNvbGxlY3Rpb24pICYmIFxuXHRcdFx0XHQoIXNlbGYuY2hlY2tJRChlbCwgJ2RhdGEtZG9jdW1lbnRfaWQnKSAmJiAhc2VsZi5jaGVja0lEKGVsLCAnZGF0YS1wYXNzX2RvY3VtZW50X2lkJykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3QgcmVxdWVzdF9pZCA9IGNjdXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG5cdFx0XHRcdGNvbGxlY3Rpb25zLnB1c2goY29sbGVjdGlvbik7XG5cblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKHRoaXMucmVxdWVzdEF0dHIsIHJlcXVlc3RfaWQpO1xuXHRcdFx0XHQvLy4gZ2V0IERhdGFcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBkYXRhID0gdXRpbHMuZ2V0Rm9ybURhdGEoZm9ybSwgXCJcIiwgY29sbGVjdGlvbik7XG5cdFx0XHRcdFxuXHRcdFx0XHQvKiBGaXhNRSBDcmVhdGUgRG9jdW1lbnQgcmVxdWVzdCAqL1x0XG5cdFx0XHRcdGNydWQuY3JlYXRlRG9jdW1lbnQoe1xuXHRcdFx0XHRcdFwiY29sbGVjdGlvblwiOiBjb2xsZWN0aW9uLFxuXHRcdFx0XHRcdFwiZWxlbWVudFwiOiByZXF1ZXN0X2lkLFxuXHRcdFx0XHRcdCdkYXRhJzogZGF0YSxcblx0XHRcdFx0XHRcIm1ldGFkYXRhXCI6IFwiXCIsXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9fc2V0TmV3SWRQcm9jZXNzOiBmdW5jdGlvbihlbGVtZW50LCBkb2N1bWVudF9pZCwgcGFzcykge1xuXHRcdGlmICghZWxlbWVudCkgcmV0dXJuO1xuXHRcdFxuICBcdFx0ZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUodGhpcy5yZXF1ZXN0QXR0cik7XG5cdFx0Y29uc3QgZXZlbnRfZGF0YSA9IHtcblx0XHRcdGRvY3VtZW50X2lkOiBkb2N1bWVudF9pZCxcblx0XHR9XG5cblx0XHRpZiAoIXBhc3MgJiYgIXRoaXMuY2hlY2tJRChlbGVtZW50KSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbmFtZScpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcsIGRvY3VtZW50X2lkKTtcblx0ICBcdH1cblxuXHQgIFx0aWYgKHBhc3MgJiYgIXRoaXMuY2hlY2tJRChlbGVtZW50LCAnZGF0YS1wYXNzX2RvY3VtZW50X2lkJykgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcGFzc190bycpKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1wYXNzX2RvY3VtZW50X2lkJywgZG9jdW1lbnRfaWQpO1xuXHRcdFx0Ly8gQ29DcmVhdGVMb2dpYy5zdG9yZVBhc3NEYXRhKGVsZW1lbnQpXG5cdFx0XHRcblx0XHRcdGlmIChlbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdzdWJtaXRCdG4nKSkge1xuXHRcdFx0XHRlbGVtZW50LmNsaWNrKCk7XG5cdFx0XHR9XG5cdCAgXHR9XG4gIFx0XG5cdFx0dmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZXQtZG9jdW1lbnRfaWQnLCB7ZGV0YWlsOiBldmVudF9kYXRhfSlcblx0XHRlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG5cdH0sXG5cdFxuXHRfX3JlY2VpdmVkRG9jdW1lbnRJZDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdGlmICghZGF0YVsnZG9jdW1lbnRfaWQnXSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGxldCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgWyR7dGhpcy5yZXF1ZXN0QXR0cn09XCIke2RhdGFbJ2VsZW1lbnQnXX1cIl1gKTtcblx0XHRpZiAoIWVsZW1lbnQpIHJldHVybjtcblx0XHRsZXQgc2VsZiA9IHRoaXM7XG5cdFx0Y29uc3QgZm9ybSA9IChlbGVtZW50LnRhZ05hbWUgPT09IFwiRk9STVwiKSA/IGVsZW1lbnQgOiB1dGlscy5nZXRQYXJlbnRzKGVsZW1lbnQsICdmb3JtJyk7XG5cdFx0Y29uc3QgY29sbGVjdGlvbiA9IGRhdGFbJ2NvbGxlY3Rpb24nXTtcblx0XHRjb25zdCBpZCA9IGRhdGFbJ2RvY3VtZW50X2lkJ11cblx0XHRpZiAoZm9ybSAmJiBpZCkge1xuXHRcdFx0Zm9ybS5zZXRBdHRyaWJ1dGUoJ2RhdGEtZm9ybV9pZCcsIGRhdGFbJ2VsZW1lbnQnXSk7XG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtY29sbGVjdGlvbj0ke2NvbGxlY3Rpb259XSwgW2RhdGEtcGFzc19jb2xsZWN0aW9uPSR7Y29sbGVjdGlvbn1dYClcblx0XHRcdGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKHNlbGYucmVxdWVzdEF0dHIpO1xuXHRcdFx0XHRpZiAoZWwuaGFzQXR0cmlidXRlKCduYW1lJykpIHNlbGYuX19zZXROZXdJZFByb2Nlc3MoZWwsIGlkKTtcblx0XHRcdFx0aWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1wYXNzX3RvJykpIHNlbGYuX19zZXROZXdJZFByb2Nlc3MoZWwsIGlkLCB0cnVlKTtcblx0XHRcdH0pXG5cdCAgXHRcblx0XHR9IGVsc2UgaWYgKGVsZW1lbnQpIHtcblx0XHRcdHRoaXMuX19zZXROZXdJZFByb2Nlc3MoZWxlbWVudCwgaWQpO1xuXHRcdH1cblx0fSxcbn1cblxuQ29DcmVhdGVGb3JtLl9faW5pdCgpO1xuLy8gY29yZS5yZWdpc3RlckluaXQoQ29DcmVhdGVGb3JtLmluaXRFbGVtZW50LCBDb0NyZWF0ZUZvcm0pO1xuXG5vYnNlcnZlci5pbml0KHsgXG5cdG5hbWU6ICdDb0NyZWF0ZUZvcm0nLCBcblx0b2JzZXJ2ZTogWydzdWJ0cmVlJywgJ2NoaWxkTGlzdCddLFxuXHRpbmNsdWRlOiAnZm9ybScsIFxuXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcblx0XHRDb0NyZWF0ZUZvcm0uaW5pdEVsZW1lbnQobXV0YXRpb24udGFyZ2V0KVxuXHR9XG59KVxuXG5hY3Rpb24uaW5pdCh7XG5cdGFjdGlvbjogXCJjcmVhdGVEb2N1bWVudFwiLFxuXHRlbmRFdmVudDogXCJjcmVhdGVkRG9jdW1lbnRcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZUZvcm0uX19jcmVhdGVEb2N1bWVudEFjdGlvbihidG4pXG5cdH0sXG59KVxuXG5hY3Rpb24uaW5pdCh7XG5cdGFjdGlvbjogXCJkZWxldGVEb2N1bWVudFwiLFxuXHRlbmRFdmVudDogXCJkZWxldGVkRG9jdW1lbnRcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZUZvcm0uX19kZWxldGVEb2N1bWVudEFjdGlvbihidG4pXG5cdH0sXG59KVxuXG5hY3Rpb24uaW5pdCh7XG5cdGFjdGlvbjogXCJkZWxldGVEb2N1bWVudHNcIixcblx0ZW5kRXZlbnQ6IFwiZGVsZXRlZERvY3VtZW50c1wiLFxuXHRjYWxsYmFjazogKGJ0biwgZGF0YSkgPT4ge1xuXHRcdENvQ3JlYXRlRG9jdW1lbnQuX19kZWxldGVEb2N1bWVudHNBY3Rpb24oYnRuKVxuXHR9LFxufSlcblxuYWN0aW9uLmluaXQoe1xuXHRhY3Rpb246IFwic2F2ZURvY3VtZW50XCIsXG5cdGVuZEV2ZW50OiBcInNhdmVkRG9jdW1lbnRcIixcblx0Y2FsbGJhY2s6IChidG4sIGRhdGEpID0+IHtcblx0XHRDb0NyZWF0ZUZvcm0uX19zYXZlRG9jdW1lbnRBY3Rpb24oYnRuKVxuXHR9LFxufSlcblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVGb3JtOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/form/src/index.js\n")},"./node_modules/@cocreate/form/src/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\");\n/* harmony import */ var _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst Utils = {\n\n\tdisableAutoFill: function(element) {\n\t\tif (element.tagName == \"TEXTAREA\") {\n\t\t\telement.value = \"\";\n\t\t\telement.setAttribute(\"autocomplete\",\"off\")\n\t\t}\n\t\tif (!element.hasAttribute(\"autocomplete\")) {\n\t\t\telement.setAttribute('autocomplete', \"off\");\n\t\t}\n\t},\n\n\tsetAttribute: function(form) {\n\t\tconst { collection, document_id, name } = _cocreate_crud_client__WEBPACK_IMPORTED_MODULE_0___default().getAttr(form)\n\t\t\n\t\tconst dataRealTime = form.getAttribute('data-realtime');\n\t\tlet elements = form.querySelectorAll('[name], [data-pass_to]')\n\t\t\n\t\t\t\t\t\n\t\telements.forEach(function(el) {\n\t\t\tif (el.parentNode.classList.contains('template')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (el.getAttribute('data-realtime') == null && dataRealTime) {\n\t\t\t\t\n\t\t\t\t// if (!['INPUT', 'TEXTAREA'].indexOf(el.tagName)) {\n\t\t\t\tel.setAttribute('data-realtime', dataRealTime);\n\t\t\t\t// }\n\t\t\t}\n\t\t\tif (el.getAttribute('name') && !el.hasAttribute('data-collection') && collection) {\n\t\t\t\tel.setAttribute('data-collection', collection);\n\t\t\t}\n\t\t\t\n\t\t\tif (el.getAttribute('data-pass_to') && !el.hasAttribute('data-pass_collection') &&  collection) {\n\t\t\t\tel.setAttribute('data-pass_collection', collection);\n\t\t\t}\n\t\t\t\n\t\t\tif (el.getAttribute('name') && !el.getAttribute('data-document_id') && document_id) {\n\t\t\t\tel.setAttribute('data-document_id', document_id)\n\t\t\t}\n\t\t\tif (!el.hasAttribute(\"data-document_id\") && document_id != null) {\n\t\t\t\tel.setAttribute('data-document_id', document_id)\n\t\t\t}\n\n\t\t})\n\t},\n\n\tcheckFormValidate: function(form) {\n\t\t\n\t\tif (typeof CoCreate.unique !== 'undefined') {\n\t\t\treturn CoCreate.unique.checkValidate(form)\n\t\t}\n\t\treturn true;\n\t},\n\t\n\tisTemplateInput: function (input) {\n\t\tif (input.classList.contains('template')) return true;\n\t\t\n\t\tlet node = input.parentNode;\n\t\twhile (node) {\n\t\t\tif (node.classList && node.classList.contains('template')) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\t\n\t\treturn false;\n\t},\n\t\n\tgetFormData: function(form, document_id, collection) {\n\t\tlet data = {};\n\t\tif (!collection) return {}\n\t\t\n\t\tconst elements = form.querySelectorAll(`[name][data-collection='${collection}']`)\n\t\telements.forEach((el) => {\n\t\t\tlet el_document_id = el.getAttribute('data-document_id') || \"\"\n\t\t\tlet name = el.getAttribute('name')\n\t\t\tlet value = el.value || el.getAttribute('value')\n\t\t\tif (name === \"_id\") return;\n\t\t\tif (!name || !value) return;\n\t\t\tif (document_id == el_document_id) {\n\t\t\t\tdata[name] = el.value\n\t\t\t}\n\t\t})\n\t\treturn data;\n\t},\n\t// getFormData: function(form, selectors) {\n\t// \tconst self = this; \n\t// \tconst elements = form.querySelectorAll(selectors.join(','));\n\t\t\n\t// \tlet request_document_id = false;\n\t// \tlet dataList = [];\n\t\t\n\t\t\n\t// \telements.forEach(el => {\n\t// \t\tlet collection = el.getAttribute('data-collection')\n\t// \t\tlet document_id = el.getAttribute('data-document_id')\n\t// \t\tlet name = el.getAttribute('name')\n\t\t\t\n\t// \t\tif (el.getAttribute('data-save_value') == 'false') {\n\t// \t\t\treturn;\n\t// \t\t}\n\t\t\t\n\t// \t\tif (!document_id && name) {\n\t// \t\t\trequest_document_id = true;\n\t// \t\t\treturn;\n\t// \t\t}\n\t\t\t\n\t// \t\tlet data = dataList.find(d => d.collection == collection && d.document_id == document_id);\n\t\t\t\t\n\t// \t})\n\t// },\n\t\n\tgetParents: function(element, selector = \"form\") {\n\t\tif (!Element.prototype.matches) {\n\t\t\tElement.prototype.matches =\tElement.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector ||\tElement.prototype.oMatchesSelector ||\tElement.prototype.webkitMatchesSelector ||\n\t\t\t\n\t\t\tfunction(s) {\n\t\t\t\tvar matches = (this.document || this.ownerDocument).querySelectorAll(s), i = matches.length;\n\t\t\t\twhile (--i >= 0 && matches.item(i) !== this) {}\n\t\t\t\treturn i > -1;\n\t\t\t};\n\t\t}\n\t\t\n\t\tfor ( ; element && element !== document; element = element.parentNode ) {\n\t\t\tif ( element.matches( selector ) ) return element;\n\t\t}\n\t\treturn null;\n\t},\n\t\n\tsetDocumentIDOfElement: function(element, document_id) {\n\t\tlet old_document_id = element.getAttribute('data-document_id');\n\t\tif (!old_document_id || old_document_id == \"\" || old_document_id == \"pending\") {\n\t\t\telement.setAttribute('data-document_id', document_id);\n\t\t}\n\t},\n\t\n\tgetCOllections: function(form) {\n\t\tlet collections = [];\n\t\tif (!form) return collections;\n\n\t\tlet els = form.querySelectorAll('[name][data-collection]');\n\t\tels.forEach((el) => {\n\t\t\tlet tmpCollection = el.getAttribute('data-collection')\n\t\t\tif (tmpCollection && !collections.includes(tmpCollection)) {\n\t\t\t\tcollections.push(tmpCollection)\n\t\t\t} \n\t\t})\n\t\treturn collections;\n\t},\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Utils);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9mb3JtL3NyYy91dGlscy5qcz8xNjcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxTQUFTLGdDQUFnQyxHQUFHLG9FQUFZOztBQUV4RDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNILEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx1QjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsaUNBQWlDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGOztBQUVBLGlFQUFlLEtBQUsiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2Zvcm0vc3JjL3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNydWQgZnJvbSAnQGNvY3JlYXRlL2NydWQtY2xpZW50J1xuXG5jb25zdCBVdGlscyA9IHtcblxuXHRkaXNhYmxlQXV0b0ZpbGw6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRpZiAoZWxlbWVudC50YWdOYW1lID09IFwiVEVYVEFSRUFcIikge1xuXHRcdFx0ZWxlbWVudC52YWx1ZSA9IFwiXCI7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZVwiLFwib2ZmXCIpXG5cdFx0fVxuXHRcdGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIikpIHtcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCBcIm9mZlwiKTtcblx0XHR9XG5cdH0sXG5cblx0c2V0QXR0cmlidXRlOiBmdW5jdGlvbihmb3JtKSB7XG5cdFx0Y29uc3QgeyBjb2xsZWN0aW9uLCBkb2N1bWVudF9pZCwgbmFtZSB9ID0gY3J1ZC5nZXRBdHRyKGZvcm0pXG5cdFx0XG5cdFx0Y29uc3QgZGF0YVJlYWxUaW1lID0gZm9ybS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVhbHRpbWUnKTtcblx0XHRsZXQgZWxlbWVudHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tuYW1lXSwgW2RhdGEtcGFzc190b10nKVxuXHRcdFxuXHRcdFx0XHRcdFxuXHRcdGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdGlmIChlbC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygndGVtcGxhdGUnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJykgPT0gbnVsbCAmJiBkYXRhUmVhbFRpbWUpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGlmICghWydJTlBVVCcsICdURVhUQVJFQSddLmluZGV4T2YoZWwudGFnTmFtZSkpIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLXJlYWx0aW1lJywgZGF0YVJlYWxUaW1lKTtcblx0XHRcdFx0Ly8gfVxuXHRcdFx0fVxuXHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpICYmICFlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpICYmIGNvbGxlY3Rpb24pIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nLCBjb2xsZWN0aW9uKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXNzX3RvJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1wYXNzX2NvbGxlY3Rpb24nKSAmJiAgY29sbGVjdGlvbikge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFzc19jb2xsZWN0aW9uJywgY29sbGVjdGlvbik7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ25hbWUnKSAmJiAhZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJykgJiYgZG9jdW1lbnRfaWQpIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJywgZG9jdW1lbnRfaWQpXG5cdFx0XHR9XG5cdFx0XHRpZiAoIWVsLmhhc0F0dHJpYnV0ZShcImRhdGEtZG9jdW1lbnRfaWRcIikgJiYgZG9jdW1lbnRfaWQgIT0gbnVsbCkge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZG9jdW1lbnRfaWQnLCBkb2N1bWVudF9pZClcblx0XHRcdH1cblxuXHRcdH0pXG5cdH0sXG5cblx0Y2hlY2tGb3JtVmFsaWRhdGU6IGZ1bmN0aW9uKGZvcm0pIHtcblx0XHRcblx0XHRpZiAodHlwZW9mIENvQ3JlYXRlLnVuaXF1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiBDb0NyZWF0ZS51bmlxdWUuY2hlY2tWYWxpZGF0ZShmb3JtKVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0XG5cdGlzVGVtcGxhdGVJbnB1dDogZnVuY3Rpb24gKGlucHV0KSB7XG5cdFx0aWYgKGlucHV0LmNsYXNzTGlzdC5jb250YWlucygndGVtcGxhdGUnKSkgcmV0dXJuIHRydWU7XG5cdFx0XG5cdFx0bGV0IG5vZGUgPSBpbnB1dC5wYXJlbnROb2RlO1xuXHRcdHdoaWxlIChub2RlKSB7XG5cdFx0XHRpZiAobm9kZS5jbGFzc0xpc3QgJiYgbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ3RlbXBsYXRlJykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdFxuXHRnZXRGb3JtRGF0YTogZnVuY3Rpb24oZm9ybSwgZG9jdW1lbnRfaWQsIGNvbGxlY3Rpb24pIHtcblx0XHRsZXQgZGF0YSA9IHt9O1xuXHRcdGlmICghY29sbGVjdGlvbikgcmV0dXJuIHt9XG5cdFx0XG5cdFx0Y29uc3QgZWxlbWVudHMgPSBmb3JtLnF1ZXJ5U2VsZWN0b3JBbGwoYFtuYW1lXVtkYXRhLWNvbGxlY3Rpb249JyR7Y29sbGVjdGlvbn0nXWApXG5cdFx0ZWxlbWVudHMuZm9yRWFjaCgoZWwpID0+IHtcblx0XHRcdGxldCBlbF9kb2N1bWVudF9pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpIHx8IFwiXCJcblx0XHRcdGxldCBuYW1lID0gZWwuZ2V0QXR0cmlidXRlKCduYW1lJylcblx0XHRcdGxldCB2YWx1ZSA9IGVsLnZhbHVlIHx8IGVsLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuXHRcdFx0aWYgKG5hbWUgPT09IFwiX2lkXCIpIHJldHVybjtcblx0XHRcdGlmICghbmFtZSB8fCAhdmFsdWUpIHJldHVybjtcblx0XHRcdGlmIChkb2N1bWVudF9pZCA9PSBlbF9kb2N1bWVudF9pZCkge1xuXHRcdFx0XHRkYXRhW25hbWVdID0gZWwudmFsdWVcblx0XHRcdH1cblx0XHR9KVxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXHQvLyBnZXRGb3JtRGF0YTogZnVuY3Rpb24oZm9ybSwgc2VsZWN0b3JzKSB7XG5cdC8vIFx0Y29uc3Qgc2VsZiA9IHRoaXM7IFxuXHQvLyBcdGNvbnN0IGVsZW1lbnRzID0gZm9ybS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycy5qb2luKCcsJykpO1xuXHRcdFxuXHQvLyBcdGxldCByZXF1ZXN0X2RvY3VtZW50X2lkID0gZmFsc2U7XG5cdC8vIFx0bGV0IGRhdGFMaXN0ID0gW107XG5cdFx0XG5cdFx0XG5cdC8vIFx0ZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdC8vIFx0XHRsZXQgY29sbGVjdGlvbiA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jb2xsZWN0aW9uJylcblx0Ly8gXHRcdGxldCBkb2N1bWVudF9pZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpXG5cdC8vIFx0XHRsZXQgbmFtZSA9IGVsLmdldEF0dHJpYnV0ZSgnbmFtZScpXG5cdFx0XHRcblx0Ly8gXHRcdGlmIChlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2F2ZV92YWx1ZScpID09ICdmYWxzZScpIHtcblx0Ly8gXHRcdFx0cmV0dXJuO1xuXHQvLyBcdFx0fVxuXHRcdFx0XG5cdC8vIFx0XHRpZiAoIWRvY3VtZW50X2lkICYmIG5hbWUpIHtcblx0Ly8gXHRcdFx0cmVxdWVzdF9kb2N1bWVudF9pZCA9IHRydWU7XG5cdC8vIFx0XHRcdHJldHVybjtcblx0Ly8gXHRcdH1cblx0XHRcdFxuXHQvLyBcdFx0bGV0IGRhdGEgPSBkYXRhTGlzdC5maW5kKGQgPT4gZC5jb2xsZWN0aW9uID09IGNvbGxlY3Rpb24gJiYgZC5kb2N1bWVudF9pZCA9PSBkb2N1bWVudF9pZCk7XG5cdFx0XHRcdFxuXHQvLyBcdH0pXG5cdC8vIH0sXG5cdFxuXHRnZXRQYXJlbnRzOiBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3RvciA9IFwiZm9ybVwiKSB7XG5cdFx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG5cdFx0XHRFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzID1cdEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcdEVsZW1lbnQucHJvdG90eXBlLm9NYXRjaGVzU2VsZWN0b3IgfHxcdEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdFx0XG5cdFx0XHRmdW5jdGlvbihzKSB7XG5cdFx0XHRcdHZhciBtYXRjaGVzID0gKHRoaXMuZG9jdW1lbnQgfHwgdGhpcy5vd25lckRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHMpLCBpID0gbWF0Y2hlcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG5cdFx0XHRcdHJldHVybiBpID4gLTE7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRcblx0XHRmb3IgKCA7IGVsZW1lbnQgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQ7IGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGVsZW1lbnQubWF0Y2hlcyggc2VsZWN0b3IgKSApIHJldHVybiBlbGVtZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblx0XG5cdHNldERvY3VtZW50SURPZkVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvY3VtZW50X2lkKSB7XG5cdFx0bGV0IG9sZF9kb2N1bWVudF9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJyk7XG5cdFx0aWYgKCFvbGRfZG9jdW1lbnRfaWQgfHwgb2xkX2RvY3VtZW50X2lkID09IFwiXCIgfHwgb2xkX2RvY3VtZW50X2lkID09IFwicGVuZGluZ1wiKSB7XG5cdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcsIGRvY3VtZW50X2lkKTtcblx0XHR9XG5cdH0sXG5cdFxuXHRnZXRDT2xsZWN0aW9uczogZnVuY3Rpb24oZm9ybSkge1xuXHRcdGxldCBjb2xsZWN0aW9ucyA9IFtdO1xuXHRcdGlmICghZm9ybSkgcmV0dXJuIGNvbGxlY3Rpb25zO1xuXG5cdFx0bGV0IGVscyA9IGZvcm0ucXVlcnlTZWxlY3RvckFsbCgnW25hbWVdW2RhdGEtY29sbGVjdGlvbl0nKTtcblx0XHRlbHMuZm9yRWFjaCgoZWwpID0+IHtcblx0XHRcdGxldCB0bXBDb2xsZWN0aW9uID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKVxuXHRcdFx0aWYgKHRtcENvbGxlY3Rpb24gJiYgIWNvbGxlY3Rpb25zLmluY2x1ZGVzKHRtcENvbGxlY3Rpb24pKSB7XG5cdFx0XHRcdGNvbGxlY3Rpb25zLnB1c2godG1wQ29sbGVjdGlvbilcblx0XHRcdH0gXG5cdFx0fSlcblx0XHRyZXR1cm4gY29sbGVjdGlvbnM7XG5cdH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/form/src/utils.js\n")},"./node_modules/@cocreate/observer/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// window.addEventListener("load", () => {\n\n/*\nCoCreate.observer.init({ \n\tname: \'CoCreateFetchInit\', // no usage, just to provide for console debugging \n\tobserve: [\'subtree\', \'childList\',\'attributes\'], // the same parameters of options in #https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe\n\tattributes: [\'data-fetch_collection\'], // it doesn\'t count added nodes or remove nodes\n\tinclude: ".classname", // a selector to select only elements that matches\n\texclude: ".classname", // a selector to exclude elements from processing\n\tcallback: function(mutation) { // a function which gets a mutation object according to #https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord\n\t\tCoCreateFetch.initElement(mutation.target)\n\t}\n})\n*/\n\n\n/**\n * description\n * \n * @param {String} [name] - an optional name to provide for debugging console\n * @param {Array} observe - a list of mutation type to be observerd, a mix of possible `attributes`, `childList` or `subtree`\n * ... and other params can be here \n * \n * @return null\n */\nwindow.profiler = {}\nwindow.counter = 0;\nwindow.counter2 = 0;\nwindow.targets = {};\nwindow.attributeName = {};\nif (!Element.prototype.matches) {\n  Element.prototype.matches =\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n        i = matches.length;\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n}\n\nconst CoCreateObserver = {\n  initTasks: new Map(),\n  attrTasks: new Map(),\n  rules: new Map(),\n  rulesArray: [],\n\n  __init: function() {\n    const self = this;\n    const observer = new MutationObserver((mutationsList, observer) => self.__callback(mutationsList, observer));\n\n    // setTimeout(()=>{\n    observer.observe(document.body, {\n      attributes: true,\n      childList: true,\n      subtree: true,\n      characterData: false,\n      attributeOldValue: true,\n      characterData: true,\n    });\n  },\n\n  // init: function(data) {\n  //   this.add(data);\n  // },\n\n  init: function({ observe, include, exclude, attributes, name, callback }) {\n    console.log(\' aaaaaaaaaaaaaa observer init \',name)\n\n    // if (name == \'ccAttribute\' || name == \'ccCss\') {\n      if (observe.some(x => x == "childList")) {\n        this.initTasks.set(callback, { observe, include, exclude, attributes, name });\n      }\n\n      if (observe.some(x => x == "attributes")) {\n        this.attrTasks.set(callback, { observe, include, exclude, attributes, name });\n      }\n    // }\n\n  },\n  remove: function(callback) {\n    this.initTasks.delete(callback)\n    this.attrTasks.delete(callback)\n  },\n\n  addRule: function({ include, exclude, name }) {\n    this.rules.set(name, { include, exclude });\n    this.rulesArray = Array.from(this.rules);\n  },\n\n  removeRule: function({ name }) {\n    this.rules.delete(name);\n    this.rulesArray = Array.from(this.rules);\n  },\n\n  __callback: function(mutationsList, observer) {\n    // console.log(this)\n    window.counter++;\n    for (let mutation of mutationsList) {\n      if (mutation.type == "childList" && mutation.addedNodes.length > 0) {\n        //. run init functions\n        this.__initCallback(mutation)\n      }\n\n      if (mutation.type == "attributes") {\n        //. run attributes functions\n        this.__attrCallback(mutation);\n      }\n    }\n  },\n\n  __initCallback: function(mutation) {\n    let addedNodes = Array.from(mutation.addedNodes);\n\n    this.initTasks.forEach(({ observe, include, exclude, attributes, name }, callback) => {\n\n      mutation.addedNodes.forEach((el) => {\n        if (!el.tagName) return;\n\n        if (include && !(el.matches(include) || el.querySelector(include))) {\n          return\n        }\n        if (exclude && (el.matches(exclude) || el.querySelector(exclude))) {\n          return;\n        }\n\n        // if (el.created) return;\n        // window.counter2++;\n        // window.profiler[name] = window.profiler[name] != undefined ? window.profiler[name] + 1 : 0;\n        // window.targets[mutation.target.id || mutation.target.tagName] =\n        //   window.targets[mutation.target.id || mutation.target.tagName] != undefined ?\n        //   window.targets[mutation.target.id || mutation.target.tagName] + 1 :\n        //   0;\n\n        // window.attributeName[mutation.attributeName] =\n        //   window.attributeName[mutation.attributeName] != undefined ?\n        //   window.attributeName[mutation.attributeName] + 1 :\n        //   0;\n        callback.apply(null, [{ type: mutation.type, target: el }]);\n      })\n    });\n\n    // addedNodes.map(el => el.created = true);\n  },\n\n  __attrCallback: function(mutation) {\n    for (let [name, { include, exclude }] of this.rulesArray) {\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n    }\n    this.attrTasks.forEach(({ observe, include, exclude, attributes, name }, callback) => {\n      if (attributes && mutation.attributeName && !attributes.includes(mutation.attributeName)) {\n        return;\n      }\n      if (include && !mutation.target.matches(include)) return;\n      if (exclude && mutation.target.matches(exclude)) return;\n\n      if (mutation.attributeName) {\n        let newValue = mutation.target.getAttribute(mutation.attributeName);\n        if (newValue != mutation.oldValue) {\n          // window.counter2++;\n          // window.profiler[name] = window.profiler[name] != undefined ? window.profiler[name] + 1 : 0;\n          // window.targets[mutation.target.id || mutation.target.tagName] =\n          //   window.targets[mutation.target.id || mutation.target.tagName] != undefined ?\n          //   window.targets[mutation.target.id || mutation.target.tagName] + 1 :\n          //   0;\n\n          // window.attributeName[mutation.attributeName] =\n          //   window.attributeName[mutation.attributeName] != undefined ?\n          //   window.attributeName[mutation.attributeName] + 1 :\n          //   0;\n          callback.apply(null, [mutation]);\n        }\n      }\n\n    })\n  },\n\n  setInitialized: function(element, type) {\n    // element.setAttribute(`initialized_${type}`, "true");\n    type = type || "";\n    let key = "co_initialized_" + type;\n    element[key] = true;\n  },\n\n  getInitialized: function(element, type) {\n    type = type || "";\n    let key = "co_initialized_" + type;\n    if (!element[key]) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n}\n\nCoCreateObserver.__init();\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoCreateObserver);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9vYnNlcnZlci9zcmMvaW5kZXguanM/ZWQyYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQSx3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsTUFBTTs7QUFFTixrQkFBa0Isd0RBQXdEO0FBQzFFOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQThDO0FBQ3BGOztBQUVBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHFCQUFxQix5QkFBeUI7QUFDOUMsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBLEdBQUc7O0FBRUgsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLDZCQUE2Qiw4Q0FBOEM7O0FBRTNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtDQUFrQztBQUNqRSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4Q0FBOEM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLGlFQUFlLGdCQUFnQixFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9vYnNlcnZlci9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuXG4vKlxuQ29DcmVhdGUub2JzZXJ2ZXIuaW5pdCh7IFxuXHRuYW1lOiAnQ29DcmVhdGVGZXRjaEluaXQnLCAvLyBubyB1c2FnZSwganVzdCB0byBwcm92aWRlIGZvciBjb25zb2xlIGRlYnVnZ2luZyBcblx0b2JzZXJ2ZTogWydzdWJ0cmVlJywgJ2NoaWxkTGlzdCcsJ2F0dHJpYnV0ZXMnXSwgLy8gdGhlIHNhbWUgcGFyYW1ldGVycyBvZiBvcHRpb25zIGluICNodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlci9vYnNlcnZlXG5cdGF0dHJpYnV0ZXM6IFsnZGF0YS1mZXRjaF9jb2xsZWN0aW9uJ10sIC8vIGl0IGRvZXNuJ3QgY291bnQgYWRkZWQgbm9kZXMgb3IgcmVtb3ZlIG5vZGVzXG5cdGluY2x1ZGU6IFwiLmNsYXNzbmFtZVwiLCAvLyBhIHNlbGVjdG9yIHRvIHNlbGVjdCBvbmx5IGVsZW1lbnRzIHRoYXQgbWF0Y2hlc1xuXHRleGNsdWRlOiBcIi5jbGFzc25hbWVcIiwgLy8gYSBzZWxlY3RvciB0byBleGNsdWRlIGVsZW1lbnRzIGZyb20gcHJvY2Vzc2luZ1xuXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHsgLy8gYSBmdW5jdGlvbiB3aGljaCBnZXRzIGEgbXV0YXRpb24gb2JqZWN0IGFjY29yZGluZyB0byAjaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uUmVjb3JkXG5cdFx0Q29DcmVhdGVGZXRjaC5pbml0RWxlbWVudChtdXRhdGlvbi50YXJnZXQpXG5cdH1cbn0pXG4qL1xuXG5cbi8qKlxuICogZGVzY3JpcHRpb25cbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIGFuIG9wdGlvbmFsIG5hbWUgdG8gcHJvdmlkZSBmb3IgZGVidWdnaW5nIGNvbnNvbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG9ic2VydmUgLSBhIGxpc3Qgb2YgbXV0YXRpb24gdHlwZSB0byBiZSBvYnNlcnZlcmQsIGEgbWl4IG9mIHBvc3NpYmxlIGBhdHRyaWJ1dGVzYCwgYGNoaWxkTGlzdGAgb3IgYHN1YnRyZWVgXG4gKiAuLi4gYW5kIG90aGVyIHBhcmFtcyBjYW4gYmUgaGVyZSBcbiAqIFxuICogQHJldHVybiBudWxsXG4gKi9cbndpbmRvdy5wcm9maWxlciA9IHt9XG53aW5kb3cuY291bnRlciA9IDA7XG53aW5kb3cuY291bnRlcjIgPSAwO1xud2luZG93LnRhcmdldHMgPSB7fTtcbndpbmRvdy5hdHRyaWJ1dGVOYW1lID0ge307XG5pZiAoIUVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMpIHtcbiAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG1hdGNoZXMgPSAodGhpcy5kb2N1bWVudCB8fCB0aGlzLm93bmVyRG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwocyksXG4gICAgICAgIGkgPSBtYXRjaGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4gICAgICByZXR1cm4gaSA+IC0xO1xuICAgIH07XG59XG5cbmNvbnN0IENvQ3JlYXRlT2JzZXJ2ZXIgPSB7XG4gIGluaXRUYXNrczogbmV3IE1hcCgpLFxuICBhdHRyVGFza3M6IG5ldyBNYXAoKSxcbiAgcnVsZXM6IG5ldyBNYXAoKSxcbiAgcnVsZXNBcnJheTogW10sXG5cbiAgX19pbml0OiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnNMaXN0LCBvYnNlcnZlcikgPT4gc2VsZi5fX2NhbGxiYWNrKG11dGF0aW9uc0xpc3QsIG9ic2VydmVyKSk7XG5cbiAgICAvLyBzZXRUaW1lb3V0KCgpPT57XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoYXJhY3RlckRhdGE6IGZhbHNlLFxuICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICAgIH0pO1xuICB9LFxuXG4gIC8vIGluaXQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gICB0aGlzLmFkZChkYXRhKTtcbiAgLy8gfSxcblxuICBpbml0OiBmdW5jdGlvbih7IG9ic2VydmUsIGluY2x1ZGUsIGV4Y2x1ZGUsIGF0dHJpYnV0ZXMsIG5hbWUsIGNhbGxiYWNrIH0pIHtcbiAgICBjb25zb2xlLmxvZygnIGFhYWFhYWFhYWFhYWFhIG9ic2VydmVyIGluaXQgJyxuYW1lKVxuXG4gICAgLy8gaWYgKG5hbWUgPT0gJ2NjQXR0cmlidXRlJyB8fCBuYW1lID09ICdjY0NzcycpIHtcbiAgICAgIGlmIChvYnNlcnZlLnNvbWUoeCA9PiB4ID09IFwiY2hpbGRMaXN0XCIpKSB7XG4gICAgICAgIHRoaXMuaW5pdFRhc2tzLnNldChjYWxsYmFjaywgeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JzZXJ2ZS5zb21lKHggPT4geCA9PSBcImF0dHJpYnV0ZXNcIikpIHtcbiAgICAgICAgdGhpcy5hdHRyVGFza3Muc2V0KGNhbGxiYWNrLCB7IG9ic2VydmUsIGluY2x1ZGUsIGV4Y2x1ZGUsIGF0dHJpYnV0ZXMsIG5hbWUgfSk7XG4gICAgICB9XG4gICAgLy8gfVxuXG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLmluaXRUYXNrcy5kZWxldGUoY2FsbGJhY2spXG4gICAgdGhpcy5hdHRyVGFza3MuZGVsZXRlKGNhbGxiYWNrKVxuICB9LFxuXG4gIGFkZFJ1bGU6IGZ1bmN0aW9uKHsgaW5jbHVkZSwgZXhjbHVkZSwgbmFtZSB9KSB7XG4gICAgdGhpcy5ydWxlcy5zZXQobmFtZSwgeyBpbmNsdWRlLCBleGNsdWRlIH0pO1xuICAgIHRoaXMucnVsZXNBcnJheSA9IEFycmF5LmZyb20odGhpcy5ydWxlcyk7XG4gIH0sXG5cbiAgcmVtb3ZlUnVsZTogZnVuY3Rpb24oeyBuYW1lIH0pIHtcbiAgICB0aGlzLnJ1bGVzLmRlbGV0ZShuYW1lKTtcbiAgICB0aGlzLnJ1bGVzQXJyYXkgPSBBcnJheS5mcm9tKHRoaXMucnVsZXMpO1xuICB9LFxuXG4gIF9fY2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uc0xpc3QsIG9ic2VydmVyKSB7XG4gICAgLy8gY29uc29sZS5sb2codGhpcylcbiAgICB3aW5kb3cuY291bnRlcisrO1xuICAgIGZvciAobGV0IG11dGF0aW9uIG9mIG11dGF0aW9uc0xpc3QpIHtcbiAgICAgIGlmIChtdXRhdGlvbi50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vLiBydW4gaW5pdCBmdW5jdGlvbnNcbiAgICAgICAgdGhpcy5fX2luaXRDYWxsYmFjayhtdXRhdGlvbilcbiAgICAgIH1cblxuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgLy8uIHJ1biBhdHRyaWJ1dGVzIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLl9fYXR0ckNhbGxiYWNrKG11dGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX19pbml0Q2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uKSB7XG4gICAgbGV0IGFkZGVkTm9kZXMgPSBBcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuXG4gICAgdGhpcy5pbml0VGFza3MuZm9yRWFjaCgoeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lIH0sIGNhbGxiYWNrKSA9PiB7XG5cbiAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgaWYgKCFlbC50YWdOYW1lKSByZXR1cm47XG5cbiAgICAgICAgaWYgKGluY2x1ZGUgJiYgIShlbC5tYXRjaGVzKGluY2x1ZGUpIHx8IGVsLnF1ZXJ5U2VsZWN0b3IoaW5jbHVkZSkpKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4Y2x1ZGUgJiYgKGVsLm1hdGNoZXMoZXhjbHVkZSkgfHwgZWwucXVlcnlTZWxlY3RvcihleGNsdWRlKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoZWwuY3JlYXRlZCkgcmV0dXJuO1xuICAgICAgICAvLyB3aW5kb3cuY291bnRlcjIrKztcbiAgICAgICAgLy8gd2luZG93LnByb2ZpbGVyW25hbWVdID0gd2luZG93LnByb2ZpbGVyW25hbWVdICE9IHVuZGVmaW5lZCA/IHdpbmRvdy5wcm9maWxlcltuYW1lXSArIDEgOiAwO1xuICAgICAgICAvLyB3aW5kb3cudGFyZ2V0c1ttdXRhdGlvbi50YXJnZXQuaWQgfHwgbXV0YXRpb24udGFyZ2V0LnRhZ05hbWVdID1cbiAgICAgICAgLy8gICB3aW5kb3cudGFyZ2V0c1ttdXRhdGlvbi50YXJnZXQuaWQgfHwgbXV0YXRpb24udGFyZ2V0LnRhZ05hbWVdICE9IHVuZGVmaW5lZCA/XG4gICAgICAgIC8vICAgd2luZG93LnRhcmdldHNbbXV0YXRpb24udGFyZ2V0LmlkIHx8IG11dGF0aW9uLnRhcmdldC50YWdOYW1lXSArIDEgOlxuICAgICAgICAvLyAgIDA7XG5cbiAgICAgICAgLy8gd2luZG93LmF0dHJpYnV0ZU5hbWVbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0gPVxuICAgICAgICAvLyAgIHdpbmRvdy5hdHRyaWJ1dGVOYW1lW211dGF0aW9uLmF0dHJpYnV0ZU5hbWVdICE9IHVuZGVmaW5lZCA/XG4gICAgICAgIC8vICAgd2luZG93LmF0dHJpYnV0ZU5hbWVbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0gKyAxIDpcbiAgICAgICAgLy8gICAwO1xuICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbeyB0eXBlOiBtdXRhdGlvbi50eXBlLCB0YXJnZXQ6IGVsIH1dKTtcbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICAvLyBhZGRlZE5vZGVzLm1hcChlbCA9PiBlbC5jcmVhdGVkID0gdHJ1ZSk7XG4gIH0sXG5cbiAgX19hdHRyQ2FsbGJhY2s6IGZ1bmN0aW9uKG11dGF0aW9uKSB7XG4gICAgZm9yIChsZXQgW25hbWUsIHsgaW5jbHVkZSwgZXhjbHVkZSB9XSBvZiB0aGlzLnJ1bGVzQXJyYXkpIHtcbiAgICAgIGlmIChpbmNsdWRlICYmICFtdXRhdGlvbi50YXJnZXQubWF0Y2hlcyhpbmNsdWRlKSkgcmV0dXJuO1xuICAgICAgaWYgKGV4Y2x1ZGUgJiYgbXV0YXRpb24udGFyZ2V0Lm1hdGNoZXMoZXhjbHVkZSkpIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdHRyVGFza3MuZm9yRWFjaCgoeyBvYnNlcnZlLCBpbmNsdWRlLCBleGNsdWRlLCBhdHRyaWJ1dGVzLCBuYW1lIH0sIGNhbGxiYWNrKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlcyAmJiBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lICYmICFhdHRyaWJ1dGVzLmluY2x1ZGVzKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlICYmICFtdXRhdGlvbi50YXJnZXQubWF0Y2hlcyhpbmNsdWRlKSkgcmV0dXJuO1xuICAgICAgaWYgKGV4Y2x1ZGUgJiYgbXV0YXRpb24udGFyZ2V0Lm1hdGNoZXMoZXhjbHVkZSkpIHJldHVybjtcblxuICAgICAgaWYgKG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gbXV0YXRpb24udGFyZ2V0LmdldEF0dHJpYnV0ZShtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9IG11dGF0aW9uLm9sZFZhbHVlKSB7XG4gICAgICAgICAgLy8gd2luZG93LmNvdW50ZXIyKys7XG4gICAgICAgICAgLy8gd2luZG93LnByb2ZpbGVyW25hbWVdID0gd2luZG93LnByb2ZpbGVyW25hbWVdICE9IHVuZGVmaW5lZCA/IHdpbmRvdy5wcm9maWxlcltuYW1lXSArIDEgOiAwO1xuICAgICAgICAgIC8vIHdpbmRvdy50YXJnZXRzW211dGF0aW9uLnRhcmdldC5pZCB8fCBtdXRhdGlvbi50YXJnZXQudGFnTmFtZV0gPVxuICAgICAgICAgIC8vICAgd2luZG93LnRhcmdldHNbbXV0YXRpb24udGFyZ2V0LmlkIHx8IG11dGF0aW9uLnRhcmdldC50YWdOYW1lXSAhPSB1bmRlZmluZWQgP1xuICAgICAgICAgIC8vICAgd2luZG93LnRhcmdldHNbbXV0YXRpb24udGFyZ2V0LmlkIHx8IG11dGF0aW9uLnRhcmdldC50YWdOYW1lXSArIDEgOlxuICAgICAgICAgIC8vICAgMDtcblxuICAgICAgICAgIC8vIHdpbmRvdy5hdHRyaWJ1dGVOYW1lW211dGF0aW9uLmF0dHJpYnV0ZU5hbWVdID1cbiAgICAgICAgICAvLyAgIHdpbmRvdy5hdHRyaWJ1dGVOYW1lW211dGF0aW9uLmF0dHJpYnV0ZU5hbWVdICE9IHVuZGVmaW5lZCA/XG4gICAgICAgICAgLy8gICB3aW5kb3cuYXR0cmlidXRlTmFtZVttdXRhdGlvbi5hdHRyaWJ1dGVOYW1lXSArIDEgOlxuICAgICAgICAgIC8vICAgMDtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBbbXV0YXRpb25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSlcbiAgfSxcblxuICBzZXRJbml0aWFsaXplZDogZnVuY3Rpb24oZWxlbWVudCwgdHlwZSkge1xuICAgIC8vIGVsZW1lbnQuc2V0QXR0cmlidXRlKGBpbml0aWFsaXplZF8ke3R5cGV9YCwgXCJ0cnVlXCIpO1xuICAgIHR5cGUgPSB0eXBlIHx8IFwiXCI7XG4gICAgbGV0IGtleSA9IFwiY29faW5pdGlhbGl6ZWRfXCIgKyB0eXBlO1xuICAgIGVsZW1lbnRba2V5XSA9IHRydWU7XG4gIH0sXG5cbiAgZ2V0SW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUpIHtcbiAgICB0eXBlID0gdHlwZSB8fCBcIlwiO1xuICAgIGxldCBrZXkgPSBcImNvX2luaXRpYWxpemVkX1wiICsgdHlwZTtcbiAgICBpZiAoIWVsZW1lbnRba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5Db0NyZWF0ZU9ic2VydmVyLl9faW5pdCgpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlT2JzZXJ2ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/observer/src/index.js\n')},"./node_modules/@cocreate/socket-client/src/common-fun.js":function(module,exports){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        \treturn factory(window)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== \'undefined\' ? self : this, function (wnd) {\n  function getCommonParams() \n  {\n    let config = {};\n    if (wnd && wnd.config) {\n      config = wnd.config\n    }\n    \n    return {\n      "apiKey":           config.apiKey,\n      "organization_id":  config.organization_Id,\n    }\n  }\n  \n  function getCommonParamsExtend(info) \n  {\n    let config = {};\n    if (wnd && wnd.config) config = wnd.config\n    \n    return {\n      "apiKey":           info.apiKey || config.apiKey,\n      "organization_id":  info.organization_id || config.organization_Id,\n    }\n  }\n  \n  function generateSocketClient (namespace, room) \n  {\n    let config = {};\n    if (wnd && wnd.config) config = wnd.config\n    \n    let ns = namespace || config.organization_Id\n    let rr = room || \'\';\n    if (rr) {\n      return `${ns}/${rr}`\n    } else {\n      return ns;\n    }\n  }\n  \n  function GenerateUUID(length = 36) {\n    let d = new Date().getTime();\n    let d2 = 0;\n    let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n  \n    if (length <= pattern.length) {\n      pattern = pattern.substr(0, length);\n    } else {\n      let add_len = length - pattern.length;\n      let sub_pattern = "-xxxyyxxx";\n  \n      let group_n = Math.floor(add_len / sub_pattern.length);\n  \n      for (let i = 0; i < group_n; i++) {\n        pattern += sub_pattern;\n      }\n  \n      group_n = add_len - group_n * sub_pattern.length;\n      pattern += sub_pattern.substr(0, group_n);\n    }\n  \n    let uuid = pattern.replace(/[xy]/g, function (c) {\n      var r = Math.random() * 16;\n      if (d > 0) {\n        var r = (d + r) % 16 | 0;\n        d = Math.floor(d / 16);\n      } else {\n        var r = (d2 + r) % 16 | 0;\n        d2 = Math.floor(d2 / 16);\n      }\n      return (c == "x" ? r : (r & 0x7) | 0x8).toString(16);\n    });\n    return uuid;\n  }\n  \n  return {getCommonParams, getCommonParamsExtend, generateSocketClient, GenerateUUID};\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9zb2NrZXQtY2xpZW50L3NyYy9jb21tb24tZnVuLmpzPzY5MTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xEO0FBQ0EsUUFBUSxpQ0FBTyxFQUFFLG1DQUFFO0FBQ25CO0FBQ0EsU0FBUztBQUFBLGtHQUFDO0FBQ1YsS0FBSyxNQUFNLEVBUVI7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7QUFDekIsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLFVBQVU7QUFDVixDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9zb2NrZXQtY2xpZW50L3NyYy9jb21tb24tZnVuLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIFx0cmV0dXJuIGZhY3Rvcnkod2luZG93KVxuICAgICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5yZXR1cm5FeHBvcnRzID0gZmFjdG9yeSh3aW5kb3cpO1xuICB9XG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAod25kKSB7XG4gIGZ1bmN0aW9uIGdldENvbW1vblBhcmFtcygpIFxuICB7XG4gICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgIGlmICh3bmQgJiYgd25kLmNvbmZpZykge1xuICAgICAgY29uZmlnID0gd25kLmNvbmZpZ1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgXCJhcGlLZXlcIjogICAgICAgICAgIGNvbmZpZy5hcGlLZXksXG4gICAgICBcIm9yZ2FuaXphdGlvbl9pZFwiOiAgY29uZmlnLm9yZ2FuaXphdGlvbl9JZCxcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldENvbW1vblBhcmFtc0V4dGVuZChpbmZvKSBcbiAge1xuICAgIGxldCBjb25maWcgPSB7fTtcbiAgICBpZiAod25kICYmIHduZC5jb25maWcpIGNvbmZpZyA9IHduZC5jb25maWdcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgXCJhcGlLZXlcIjogICAgICAgICAgIGluZm8uYXBpS2V5IHx8IGNvbmZpZy5hcGlLZXksXG4gICAgICBcIm9yZ2FuaXphdGlvbl9pZFwiOiAgaW5mby5vcmdhbml6YXRpb25faWQgfHwgY29uZmlnLm9yZ2FuaXphdGlvbl9JZCxcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdlbmVyYXRlU29ja2V0Q2xpZW50IChuYW1lc3BhY2UsIHJvb20pIFxuICB7XG4gICAgbGV0IGNvbmZpZyA9IHt9O1xuICAgIGlmICh3bmQgJiYgd25kLmNvbmZpZykgY29uZmlnID0gd25kLmNvbmZpZ1xuICAgIFxuICAgIGxldCBucyA9IG5hbWVzcGFjZSB8fCBjb25maWcub3JnYW5pemF0aW9uX0lkXG4gICAgbGV0IHJyID0gcm9vbSB8fCAnJztcbiAgICBpZiAocnIpIHtcbiAgICAgIHJldHVybiBgJHtuc30vJHtycn1gXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBucztcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIEdlbmVyYXRlVVVJRChsZW5ndGggPSAzNikge1xuICAgIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgbGV0IGQyID0gMDtcbiAgICBsZXQgcGF0dGVybiA9IFwidXh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCI7XG4gIFxuICAgIGlmIChsZW5ndGggPD0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cigwLCBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYWRkX2xlbiA9IGxlbmd0aCAtIHBhdHRlcm4ubGVuZ3RoO1xuICAgICAgbGV0IHN1Yl9wYXR0ZXJuID0gXCIteHh4eXl4eHhcIjtcbiAgXG4gICAgICBsZXQgZ3JvdXBfbiA9IE1hdGguZmxvb3IoYWRkX2xlbiAvIHN1Yl9wYXR0ZXJuLmxlbmd0aCk7XG4gIFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cF9uOyBpKyspIHtcbiAgICAgICAgcGF0dGVybiArPSBzdWJfcGF0dGVybjtcbiAgICAgIH1cbiAgXG4gICAgICBncm91cF9uID0gYWRkX2xlbiAtIGdyb3VwX24gKiBzdWJfcGF0dGVybi5sZW5ndGg7XG4gICAgICBwYXR0ZXJuICs9IHN1Yl9wYXR0ZXJuLnN1YnN0cigwLCBncm91cF9uKTtcbiAgICB9XG4gIFxuICAgIGxldCB1dWlkID0gcGF0dGVybi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgICAgIGlmIChkID4gMCkge1xuICAgICAgICB2YXIgciA9IChkICsgcikgJSAxNiB8IDA7XG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IChkMiArIHIpICUgMTYgfCAwO1xuICAgICAgICBkMiA9IE1hdGguZmxvb3IoZDIgLyAxNik7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGMgPT0gXCJ4XCIgPyByIDogKHIgJiAweDcpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHV1aWQ7XG4gIH1cbiAgXG4gIHJldHVybiB7Z2V0Q29tbW9uUGFyYW1zLCBnZXRDb21tb25QYXJhbXNFeHRlbmQsIGdlbmVyYXRlU29ja2V0Q2xpZW50LCBHZW5lcmF0ZVVVSUR9O1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/socket-client/src/common-fun.js\n')},"./node_modules/@cocreate/socket-client/src/index.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./common-fun.js */ "./node_modules/@cocreate/socket-client/src/common-fun.js")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(commonFunc) {\n        \treturn factory(commonFunc, window, WebSocket, Blob)\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(typeof self !== \'undefined\' ? self : this, function (commonFunc, wnd, WebSocket, Blob) {\n\n    class CoCreateSocketClient\n\t{\n\t\tconstructor(prefix = "crud") {\n\t\t\tthis.prefix = prefix || "crud";\n\t\t\tthis.sockets = new Map();\n\t\t\tthis.listeners = new Map();\n\t\t\tthis.messageQueue =  new Map();\n\t\t\tthis.saveFileName =  \'\';\n\t\t\tthis.globalScope =  "";\n\t\t}\n\t\n\t\tsetGlobalScope(scope) {\n\t\t\tthis.globalScope = `${this.prefix}/${scope}`;\n\t\t}\n\t\t\n\t\tgetGlobalScope() {\n\t\t\treturn this.globalScope;\n\t\t}\n\t\t\n\t\t/**\n\t\t * config: {namespace, room, host}\n\t\t */\n\t\tcreate (config) {\n\t\t\t\n\t\t\tconst {namespace, room} = config;\n\t\t\tconst key = this.getKey(namespace, room);\n\t\t\tlet _this = this;\n\t\t\tif (namespace) {\n\t\t\t\tthis.setGlobalScope(namespace)\n\t\t\t}\n\t\t\t\n\t\t\tlet socket;\n\t\t\tif (this.sockets.get(key)) {\n\t\t\t\tsocket = this.sockets.get(key);\n\t\t\t\tconsole.log(\'SOcket already has been register\');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlet w_protocol = wnd.location.protocol;\t\t\n\t\t\tif (wnd.location.protocol === "about:") {\n\t\t\t\tw_protocol = wnd.parent.location.protocol;\n\t\t\t\tif (!config.host) {\n\t\t\t\t\tconfig.host = wnd.parent.location.host;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet protocol = w_protocol === \'http:\' ? \'ws\' : \'wss\';\n\t\t\t\n\t\t\tconst port = config.port ? config.port : 8088;\n\t\t\t\n\t\t\tlet socket_url = `${protocol}://${wnd.location.host}:${port}/${key}`;\n\t\t\t\n\t\t\tif (config.host) {\n\t\t\t\tif (config.host.includes("://")) {\n\t\t\t\t\tsocket_url = `${config.host}/${key}`;\n\t\t\t\t} else {\n\t\t\t\t\tif (config.host.includes(":")) {\n\t\t\t\t\t\tsocket_url = `${protocol}://${config.host}/${key}`;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsocket_url = `${protocol}://${config.host}:${port}/${key}`;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tlet token = null;\n\t\t\t\tif (wnd.localStorage) {\n\t\t\t\t\ttoken = wnd.localStorage.getItem("token");\n\t\t\t\t}\n\t\t\t\tsocket = new WebSocket(socket_url, token);\n\t\t\t} catch(error) {\n\t\t\t\tconsole.log(error)\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsocket.onopen = function(event) {\n\t\t\t\tconst messages = _this.messageQueue.get(key) || [];\n\t\t\t\tmessages.forEach(msg => socket.send(JSON.stringify(msg)));\n\t\t\t\t\n\t\t\t\t_this.sockets.set(key, socket);\n\t\t\t\t_this.messageQueue.set(key, []);\n\t\t\t}\n\t\t\t\n\t\t\tsocket.onclose = function(event) {\n\t\t\t\tswitch(event.code) {\n\t\t\t\t\tcase 1000: // close normal\n\t\t\t\t\t\tconsole.log("websocket: closed");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault: \n\t\t\t\t\t\t_this.destroy(socket, key);\n\t\t\t\t\t\t_this.reconnect(socket, config);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsocket.onerror = function(err) {\n\t\t\t\t_this.destroy(socket, key);\n\t\t\t\t_this.reconnect(socket, config);\n\t\t\t}\n\t\n\t\t\tsocket.onmessage = function(data) {\n\t\t\t\ttry {\n\t\t\t\t\tif (wnd.Blob) {\n\t\t\t\t\t\tif (data.data instanceof Blob) {\n\t\t\t\t\t\t\t_this.saveFile(data.data);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlet rev_data = JSON.parse(data.data);\n\n\t\t\t\t\tif (rev_data.data && rev_data.data.event) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (wnd.CustomEvent) {\n\t\t\t\t\t\t\tvar event = new wnd.CustomEvent(rev_data.data.event, {\n\t\t\t\t\t\t\t\tdetail: rev_data.data\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\twnd.document.dispatchEvent(event);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprocess.emit(rev_data.data.event, rev_data.data)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tlet action = rev_data.action;\n\t\t\t\t\tconst listeners = _this.listeners.get(rev_data.action);\n\t\t\t\t\tif (!listeners) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlisteners.forEach(listener => {\n\t\t\t\t\t\tlistener(rev_data.data, key);\n\t\t\t\t\t})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.log(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * \n\t\t */\n\t\tsend (action, data, room) {\n\t\t\tconst obj = {\n\t\t\t\taction: action,\n\t\t\t\tdata: {...data, uid: commonFunc.GenerateUUID()}\n\t\t\t}\n\t\t\tconst key = this.getKeyByRoom(room);\n\t\t\tconst socket = this.getByRoom(room);\n\n\t\t\tif (socket) {\n\t\t\t\tsocket.send(JSON.stringify(obj));\n\t\t\t} else {\n\t\t\t\tif (this.messageQueue.get(key)) {\n\t\t\t\t\tthis.messageQueue.get(key).push(obj);\n\t\t\t\t} else {\n\t\t\t\t\tthis.messageQueue.set(key, [obj]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsendFile (file, room) {\n\t\t\tconst socket = this.getByRoom(room);\n\t\t\tif (socket) {\n\t\t\t\tsocket.send(file);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t\t * scope: ns/room\n\t\t */\n\t\tlisten(type, callback) {\n\t\t\tif (!this.listeners.get(type)) {\n\t\t\t\tthis.listeners.set(type, [callback]);\n\t\t\t} else {\n\t\t\t\tthis.listeners.get(type).push(callback);\n\t\t\t}\n\t\t}\n\t\t\n\t\treconnect(socket, config) {\n\t\t\tlet _this = this;\n\t\t\tsetTimeout(function() {\n\t\t\t\t_this.create(config);\n\t\t\t}, 1000)\n\t\t}\n\t\t\n\t\tdestroy(socket, key) {\n\t\t\tif (socket) {\n\t\t\t\tsocket.onerror = socket.onopen = socket.onclose = null;\n\t\t\t\tsocket.close();\n\t\t\t\tsocket = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (this.sockets.get(key)) {\n\t\t\t\tthis.sockets.delete(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\tdestroyByKey(key) {\n\t\t\tlet socket = this.sockets.get(key) \n\t\t\tif (socket) {\n\t\t\t\tthis.destroy(socket, key);\n\t\t\t}\n\t\t}\n\t\t\n\t\tgetKey(namespace, room) {\n\t\t\tlet key = `${this.prefix}`;\n\t\t\tif (namespace && namespace != \'\') {\n\t\t\t\tif (room &&  room != \'\') {\n\t\t\t\t\tkey += `/${namespace}/${room}`;\n\t\t\t\t} else {\n\t\t\t\t\tkey +=`/${namespace}`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn key;\n\t\t}\n\t\t\n\t\tgetByRoom(room) {\n\t\t\tlet key = this.getKeyByRoom(room)\n\t\t\treturn this.sockets.get(key);\t\n\t\t}\n\t\t\n\t\tgetKeyByRoom(room) {\n\t\t\tlet key = this.globalScope;\n\t\t\tif (room) {\n\t\t\t\tkey = `${this.prefix}/${room}`;\n\t\t\t}\n\t\t\treturn key;\t\t\n\t\t}\n\t\t\n\t\t\n\t\tsaveFile(blob) {\n\t\t\tif (wnd.document) {\n\t\t\t\tconst file_name = this.saveFileName || \'downloadFile\';\n\t\t\t\tvar a = wnd.document.createElement("a");\n\t\t        wnd.document.body.appendChild(a);\n\t\t        a.style = "display: none";\n\t\t\n\t\t        let url = window.URL.createObjectURL(blob);\n\t\t        a.href = url;\n\t\t        a.download = file_name;\n\t\t        a.click();\n\t\t        wnd.URL.revokeObjectURL(url);\n\t\t\n\t\t        this.saveFileName = \'\'\n\t\t\t}\n\t\t}\n\t\t\n\t\tlistenAsync(eventname) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tif (wnd.document) { //. browser case\n\t\t\t\t\twnd.document.addEventListener(eventname, function(event) {\n\t\t\t\t\t    resolve(event.detail);\n\t\t\t\t\t}, { once: true })\n\t\t\t\t} else { //. node case\n\t\t\t\t\tprocess.once(eventname, (data) => {\n\t\t\t\t\t\tresolve(data)\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n    return CoCreateSocketClient\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9zb2NrZXQtY2xpZW50L3NyYy9pbmRleC5qcz9hOTA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xEO0FBQ0EsUUFBUSxpQ0FBTyxDQUFDLHNHQUFpQixDQUFDLG1DQUFFO0FBQ3BDO0FBQ0EsU0FBUztBQUFBLGtHQUFDO0FBQ1YsS0FBSyxNQUFNLEVBWVI7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLFlBQVksR0FBRyxNQUFNO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLFNBQVMsS0FBSyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsSUFBSTs7QUFFdEU7QUFDQTtBQUNBLHFCQUFxQixZQUFZLEdBQUcsSUFBSTtBQUN4QyxLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsU0FBUyxLQUFLLFlBQVksR0FBRyxJQUFJO0FBQ3ZELE1BQU07QUFDTixzQkFBc0IsU0FBUyxLQUFLLFlBQVksR0FBRyxLQUFLLEdBQUcsSUFBSSxFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxHQUFHLEtBQUs7QUFDbEMsS0FBSztBQUNMLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVksR0FBRyxLQUFLO0FBQ2pDO0FBQ0EsYztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsTUFBTSxHQUFHLGFBQWE7QUFDdEIsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9zb2NrZXQtY2xpZW50L3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnLi9jb21tb24tZnVuLmpzJ10sIGZ1bmN0aW9uKGNvbW1vbkZ1bmMpIHtcbiAgICAgICAgXHRyZXR1cm4gZmFjdG9yeShjb21tb25GdW5jLCB3aW5kb3csIFdlYlNvY2tldCwgQmxvYilcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBsZXQgd25kT2JqID0ge1xuICAgICAgICBcdGxvY2F0aW9uOiB7XG4gICAgICAgIFx0XHRwcm90b2NvbDogXCJcIlxuICAgICAgICBcdH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cyA9IHJlcXVpcmUoXCJ3c1wiKVxuICAgICAgICBjb25zdCBjb21tb25GdW5jID0gcmVxdWlyZShcIi4vY29tbW9uLWZ1bi5qc1wiKVxuICAgIFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGNvbW1vbkZ1bmMsIHduZE9iaiwgd3MsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpXG4gICAgICAgIHJvb3QucmV0dXJuRXhwb3J0cyA9IGZhY3Rvcnkocm9vdFtcIi4vY29tbW9uLWZ1bi5qc1wiXSwgd2luZG93LCBXZWJTb2NrZXQsIEJsb2IpO1xuICB9XG59KHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbiAoY29tbW9uRnVuYywgd25kLCBXZWJTb2NrZXQsIEJsb2IpIHtcblxuICAgIGNsYXNzIENvQ3JlYXRlU29ja2V0Q2xpZW50XG5cdHtcblx0XHRjb25zdHJ1Y3RvcihwcmVmaXggPSBcImNydWRcIikge1xuXHRcdFx0dGhpcy5wcmVmaXggPSBwcmVmaXggfHwgXCJjcnVkXCI7XG5cdFx0XHR0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG5cdFx0XHR0aGlzLmxpc3RlbmVycyA9IG5ldyBNYXAoKTtcblx0XHRcdHRoaXMubWVzc2FnZVF1ZXVlID0gIG5ldyBNYXAoKTtcblx0XHRcdHRoaXMuc2F2ZUZpbGVOYW1lID0gICcnO1xuXHRcdFx0dGhpcy5nbG9iYWxTY29wZSA9ICBcIlwiO1xuXHRcdH1cblx0XG5cdFx0c2V0R2xvYmFsU2NvcGUoc2NvcGUpIHtcblx0XHRcdHRoaXMuZ2xvYmFsU2NvcGUgPSBgJHt0aGlzLnByZWZpeH0vJHtzY29wZX1gO1xuXHRcdH1cblx0XHRcblx0XHRnZXRHbG9iYWxTY29wZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdsb2JhbFNjb3BlO1xuXHRcdH1cblx0XHRcblx0XHQvKipcblx0XHQgKiBjb25maWc6IHtuYW1lc3BhY2UsIHJvb20sIGhvc3R9XG5cdFx0ICovXG5cdFx0Y3JlYXRlIChjb25maWcpIHtcblx0XHRcdFxuXHRcdFx0Y29uc3Qge25hbWVzcGFjZSwgcm9vbX0gPSBjb25maWc7XG5cdFx0XHRjb25zdCBrZXkgPSB0aGlzLmdldEtleShuYW1lc3BhY2UsIHJvb20pO1xuXHRcdFx0bGV0IF90aGlzID0gdGhpcztcblx0XHRcdGlmIChuYW1lc3BhY2UpIHtcblx0XHRcdFx0dGhpcy5zZXRHbG9iYWxTY29wZShuYW1lc3BhY2UpXG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGxldCBzb2NrZXQ7XG5cdFx0XHRpZiAodGhpcy5zb2NrZXRzLmdldChrZXkpKSB7XG5cdFx0XHRcdHNvY2tldCA9IHRoaXMuc29ja2V0cy5nZXQoa2V5KTtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1NPY2tldCBhbHJlYWR5IGhhcyBiZWVuIHJlZ2lzdGVyJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0bGV0IHdfcHJvdG9jb2wgPSB3bmQubG9jYXRpb24ucHJvdG9jb2w7XHRcdFxuXHRcdFx0aWYgKHduZC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJhYm91dDpcIikge1xuXHRcdFx0XHR3X3Byb3RvY29sID0gd25kLnBhcmVudC5sb2NhdGlvbi5wcm90b2NvbDtcblx0XHRcdFx0aWYgKCFjb25maWcuaG9zdCkge1xuXHRcdFx0XHRcdGNvbmZpZy5ob3N0ID0gd25kLnBhcmVudC5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXQgcHJvdG9jb2wgPSB3X3Byb3RvY29sID09PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBwb3J0ID0gY29uZmlnLnBvcnQgPyBjb25maWcucG9ydCA6IDgwODg7XG5cdFx0XHRcblx0XHRcdGxldCBzb2NrZXRfdXJsID0gYCR7cHJvdG9jb2x9Oi8vJHt3bmQubG9jYXRpb24uaG9zdH06JHtwb3J0fS8ke2tleX1gO1xuXHRcdFx0XG5cdFx0XHRpZiAoY29uZmlnLmhvc3QpIHtcblx0XHRcdFx0aWYgKGNvbmZpZy5ob3N0LmluY2x1ZGVzKFwiOi8vXCIpKSB7XG5cdFx0XHRcdFx0c29ja2V0X3VybCA9IGAke2NvbmZpZy5ob3N0fS8ke2tleX1gO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChjb25maWcuaG9zdC5pbmNsdWRlcyhcIjpcIikpIHtcblx0XHRcdFx0XHRcdHNvY2tldF91cmwgPSBgJHtwcm90b2NvbH06Ly8ke2NvbmZpZy5ob3N0fS8ke2tleX1gO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzb2NrZXRfdXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtjb25maWcuaG9zdH06JHtwb3J0fS8ke2tleX1gO1x0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRsZXQgdG9rZW4gPSBudWxsO1xuXHRcdFx0XHRpZiAod25kLmxvY2FsU3RvcmFnZSkge1xuXHRcdFx0XHRcdHRva2VuID0gd25kLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwidG9rZW5cIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0c29ja2V0ID0gbmV3IFdlYlNvY2tldChzb2NrZXRfdXJsLCB0b2tlbik7XG5cdFx0XHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGVycm9yKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRjb25zdCBtZXNzYWdlcyA9IF90aGlzLm1lc3NhZ2VRdWV1ZS5nZXQoa2V5KSB8fCBbXTtcblx0XHRcdFx0bWVzc2FnZXMuZm9yRWFjaChtc2cgPT4gc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobXNnKSkpO1xuXHRcdFx0XHRcblx0XHRcdFx0X3RoaXMuc29ja2V0cy5zZXQoa2V5LCBzb2NrZXQpO1xuXHRcdFx0XHRfdGhpcy5tZXNzYWdlUXVldWUuc2V0KGtleSwgW10pO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHN3aXRjaChldmVudC5jb2RlKSB7XG5cdFx0XHRcdFx0Y2FzZSAxMDAwOiAvLyBjbG9zZSBub3JtYWxcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwid2Vic29ja2V0OiBjbG9zZWRcIik7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRkZWZhdWx0OiBcblx0XHRcdFx0XHRcdF90aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0XHRcdFx0X3RoaXMucmVjb25uZWN0KHNvY2tldCwgY29uZmlnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdF90aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0XHRfdGhpcy5yZWNvbm5lY3Qoc29ja2V0LCBjb25maWcpO1xuXHRcdFx0fVxuXHRcblx0XHRcdHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKHduZC5CbG9iKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5zYXZlRmlsZShkYXRhLmRhdGEpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCByZXZfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKTtcblxuXHRcdFx0XHRcdGlmIChyZXZfZGF0YS5kYXRhICYmIHJldl9kYXRhLmRhdGEuZXZlbnQpIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0aWYgKHduZC5DdXN0b21FdmVudCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXZlbnQgPSBuZXcgd25kLkN1c3RvbUV2ZW50KHJldl9kYXRhLmRhdGEuZXZlbnQsIHtcblx0XHRcdFx0XHRcdFx0XHRkZXRhaWw6IHJldl9kYXRhLmRhdGFcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0d25kLmRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzLmVtaXQocmV2X2RhdGEuZGF0YS5ldmVudCwgcmV2X2RhdGEuZGF0YSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCBhY3Rpb24gPSByZXZfZGF0YS5hY3Rpb247XG5cdFx0XHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gX3RoaXMubGlzdGVuZXJzLmdldChyZXZfZGF0YS5hY3Rpb24pO1xuXHRcdFx0XHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyKHJldl9kYXRhLmRhdGEsIGtleSk7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8qKlxuXHRcdCAqIFxuXHRcdCAqL1xuXHRcdHNlbmQgKGFjdGlvbiwgZGF0YSwgcm9vbSkge1xuXHRcdFx0Y29uc3Qgb2JqID0ge1xuXHRcdFx0XHRhY3Rpb246IGFjdGlvbixcblx0XHRcdFx0ZGF0YTogey4uLmRhdGEsIHVpZDogY29tbW9uRnVuYy5HZW5lcmF0ZVVVSUQoKX1cblx0XHRcdH1cblx0XHRcdGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5QnlSb29tKHJvb20pO1xuXHRcdFx0Y29uc3Qgc29ja2V0ID0gdGhpcy5nZXRCeVJvb20ocm9vbSk7XG5cblx0XHRcdGlmIChzb2NrZXQpIHtcblx0XHRcdFx0c29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5tZXNzYWdlUXVldWUuZ2V0KGtleSkpIHtcblx0XHRcdFx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5nZXQoa2V5KS5wdXNoKG9iaik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5tZXNzYWdlUXVldWUuc2V0KGtleSwgW29ial0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHNlbmRGaWxlIChmaWxlLCByb29tKSB7XG5cdFx0XHRjb25zdCBzb2NrZXQgPSB0aGlzLmdldEJ5Um9vbShyb29tKTtcblx0XHRcdGlmIChzb2NrZXQpIHtcblx0XHRcdFx0c29ja2V0LnNlbmQoZmlsZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcblx0XHQvKipcblx0XHQgKiBzY29wZTogbnMvcm9vbVxuXHRcdCAqL1xuXHRcdGxpc3Rlbih0eXBlLCBjYWxsYmFjaykge1xuXHRcdFx0aWYgKCF0aGlzLmxpc3RlbmVycy5nZXQodHlwZSkpIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5lcnMuc2V0KHR5cGUsIFtjYWxsYmFja10pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5saXN0ZW5lcnMuZ2V0KHR5cGUpLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRyZWNvbm5lY3Qoc29ja2V0LCBjb25maWcpIHtcblx0XHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdGhpcy5jcmVhdGUoY29uZmlnKTtcblx0XHRcdH0sIDEwMDApXG5cdFx0fVxuXHRcdFxuXHRcdGRlc3Ryb3koc29ja2V0LCBrZXkpIHtcblx0XHRcdGlmIChzb2NrZXQpIHtcblx0XHRcdFx0c29ja2V0Lm9uZXJyb3IgPSBzb2NrZXQub25vcGVuID0gc29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuXHRcdFx0XHRzb2NrZXQuY2xvc2UoKTtcblx0XHRcdFx0c29ja2V0ID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKHRoaXMuc29ja2V0cy5nZXQoa2V5KSkge1xuXHRcdFx0XHR0aGlzLnNvY2tldHMuZGVsZXRlKGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGRlc3Ryb3lCeUtleShrZXkpIHtcblx0XHRcdGxldCBzb2NrZXQgPSB0aGlzLnNvY2tldHMuZ2V0KGtleSkgXG5cdFx0XHRpZiAoc29ja2V0KSB7XG5cdFx0XHRcdHRoaXMuZGVzdHJveShzb2NrZXQsIGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGdldEtleShuYW1lc3BhY2UsIHJvb20pIHtcblx0XHRcdGxldCBrZXkgPSBgJHt0aGlzLnByZWZpeH1gO1xuXHRcdFx0aWYgKG5hbWVzcGFjZSAmJiBuYW1lc3BhY2UgIT0gJycpIHtcblx0XHRcdFx0aWYgKHJvb20gJiYgIHJvb20gIT0gJycpIHtcblx0XHRcdFx0XHRrZXkgKz0gYC8ke25hbWVzcGFjZX0vJHtyb29tfWA7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a2V5ICs9YC8ke25hbWVzcGFjZX1gO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblx0XHRcblx0XHRnZXRCeVJvb20ocm9vbSkge1xuXHRcdFx0bGV0IGtleSA9IHRoaXMuZ2V0S2V5QnlSb29tKHJvb20pXG5cdFx0XHRyZXR1cm4gdGhpcy5zb2NrZXRzLmdldChrZXkpO1x0XG5cdFx0fVxuXHRcdFxuXHRcdGdldEtleUJ5Um9vbShyb29tKSB7XG5cdFx0XHRsZXQga2V5ID0gdGhpcy5nbG9iYWxTY29wZTtcblx0XHRcdGlmIChyb29tKSB7XG5cdFx0XHRcdGtleSA9IGAke3RoaXMucHJlZml4fS8ke3Jvb219YDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBrZXk7XHRcdFxuXHRcdH1cblx0XHRcblx0XHRcblx0XHRzYXZlRmlsZShibG9iKSB7XG5cdFx0XHRpZiAod25kLmRvY3VtZW50KSB7XG5cdFx0XHRcdGNvbnN0IGZpbGVfbmFtZSA9IHRoaXMuc2F2ZUZpbGVOYW1lIHx8ICdkb3dubG9hZEZpbGUnO1xuXHRcdFx0XHR2YXIgYSA9IHduZC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0XHQgICAgICAgIHduZC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuXHRcdCAgICAgICAgYS5zdHlsZSA9IFwiZGlzcGxheTogbm9uZVwiO1xuXHRcdFxuXHRcdCAgICAgICAgbGV0IHVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdCAgICAgICAgYS5ocmVmID0gdXJsO1xuXHRcdCAgICAgICAgYS5kb3dubG9hZCA9IGZpbGVfbmFtZTtcblx0XHQgICAgICAgIGEuY2xpY2soKTtcblx0XHQgICAgICAgIHduZC5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG5cdFx0XG5cdFx0ICAgICAgICB0aGlzLnNhdmVGaWxlTmFtZSA9ICcnXG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGxpc3RlbkFzeW5jKGV2ZW50bmFtZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdFx0aWYgKHduZC5kb2N1bWVudCkgeyAvLy4gYnJvd3NlciBjYXNlXG5cdFx0XHRcdFx0d25kLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRuYW1lLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdCAgICByZXNvbHZlKGV2ZW50LmRldGFpbCk7XG5cdFx0XHRcdFx0fSwgeyBvbmNlOiB0cnVlIH0pXG5cdFx0XHRcdH0gZWxzZSB7IC8vLiBub2RlIGNhc2Vcblx0XHRcdFx0XHRwcm9jZXNzLm9uY2UoZXZlbnRuYW1lLCAoZGF0YSkgPT4ge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShkYXRhKVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXHR9XG4gICAgcmV0dXJuIENvQ3JlYXRlU29ja2V0Q2xpZW50XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/socket-client/src/index.js\n')},"./node_modules/@cocreate/utils/src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "generateUUID": () => (/* binding */ generateUUID),\n/* harmony export */   "getParentFromElement": () => (/* binding */ getParentFromElement),\n/* harmony export */   "isJsonString": () => (/* binding */ isJsonString),\n/* harmony export */   "getAttributes": () => (/* binding */ getAttributes),\n/* harmony export */   "checkValue": () => (/* binding */ checkValue),\n/* harmony export */   "allFrame": () => (/* binding */ allFrame),\n/* harmony export */   "cssPath": () => (/* binding */ cssPath),\n/* harmony export */   "getTopMostWindow": () => (/* binding */ getTopMostWindow),\n/* harmony export */   "findIframeFromElement": () => (/* binding */ findIframeFromElement),\n/* harmony export */   "getIframeFromPath": () => (/* binding */ getIframeFromPath),\n/* harmony export */   "configMatch": () => (/* binding */ configMatch),\n/* harmony export */   "configExecuter": () => (/* binding */ configExecuter),\n/* harmony export */   "UUID": () => (/* binding */ UUID),\n/* harmony export */   "parseTextToHtml": () => (/* binding */ parseTextToHtml),\n/* harmony export */   "splitBydelimiter": () => (/* binding */ splitBydelimiter),\n/* harmony export */   "joinBydelimiter": () => (/* binding */ joinBydelimiter),\n/* harmony export */   "isValidSelector": () => (/* binding */ isValidSelector),\n/* harmony export */   "getElementPath": () => (/* binding */ getElementPath),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Created by jin\n * 2020-04-03\n */\n\n\nfunction generateUUID(length = 36) {\n  // if (length == 10) {\n  //   var result           = \'\';\n  //   var characters       = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\';\n  //   var charactersLength = characters.length;\n  //   for ( var i = 0; i < length; i++ ) {\n  //     result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  //   }\n\n  //   var dd = new Date().toTimeString();\n  //   var random = dd.replace(/[\\W_]+/g, "").substr(0,6);\n  //   result += random;\n  //   return result;\n  // }\n\n  let d = new Date().getTime();\n  let d2 =\n    (window.performance &&\n      window.performance.now &&\n      window.performance.now() * 1000) ||\n    0;\n  let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n\n  if (length <= pattern.length) {\n    pattern = pattern.substr(0, length);\n  }\n  else {\n    let add_len = length - pattern.length;\n    let sub_pattern = "-xxxyyxxx";\n\n    let group_n = Math.floor(add_len / sub_pattern.length);\n\n    for (let i = 0; i < group_n; i++) {\n      pattern += sub_pattern;\n    }\n\n    group_n = add_len - group_n * sub_pattern.length;\n    pattern += sub_pattern.substr(0, group_n);\n  }\n\n  let uuid = pattern.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16;\n    if (d > 0) {\n      var r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    }\n    else {\n      var r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n    return (c == "x" ? r : (r & 0x7) | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction getParentFromElement(element, parent_class, attributes) {\n  if (parent_class) {\n    if (element.classList.contains(parent_class)) {\n      return element;\n    }\n\n    let node = element.parentNode;\n    while (node != null && node.classList) {\n      if (node.classList.contains(parent_class)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n  }\n  else if (attributes) {\n    if (attributes.every((attr) => element.attributes.hasOwnProperty(attr))) {\n      return element;\n    }\n\n    let node = element.parentNode;\n    while (node != null && node.attributes) {\n      if (attributes.every((attr) => node.attributes.hasOwnProperty(attr))) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n  }\n\n  return false;\n}\n\n\nfunction isJsonString(str_data) {\n  try {\n    let json_data = JSON.parse(str_data);\n    if (typeof json_data === "object" && json_data != null) {\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n  catch (e) {\n    return false;\n  }\n}\n\nfunction getAttributes(element) {\n  return element.getAttributeNames().reduce((attrMap, name) => {\n    attrMap[name] = element.getAttribute(name);\n    return attrMap;\n  }, {});\n}\n\nfunction checkValue(value) {\n  if (!value) return false;\n  if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n    return false;\n  }\n\n  return true;\n}\n// hosseins utills\n\n// function to go through all frames\nfunction allFrame(callback) {\n  let allFrames = [{ document, window }];\n  for (let frame of document.querySelectorAll("iframe")) {\n    let frameDocument = frame.contentDocument || frame.contentWindow.document;\n    let frameWindow = frame.contentWindow;\n    allFrames.push({\n      document: frameDocument,\n      window: frameWindow,\n      frameElement: frame,\n    });\n  }\n  let result = new Set();\n  for (let frame of allFrames) {\n    let callbackResult = callback(frame);\n    if (\n      callbackResult &&\n      typeof callbackResult[Symbol.iterator] === "function"\n    )\n      callbackResult.forEach((el) => result.add(el));\n    else if (callbackResult) result.add(callbackResult);\n  }\n\n  return Array.from(result);\n}\n\nfunction cssPath(node) {\n  let pathSplits = [];\n  do {\n    if (!node || !node.tagName) return false;\n    let pathSplit = node.tagName.toLowerCase();\n    if (node.id && node.tagName !== "BODY") pathSplit += "#" + node.id;\n\n    if (node.classList.length && node.tagName !== "BODY") {\n      node.classList.forEach((item) => {\n        if (item.indexOf(":") === -1) pathSplit += "." + item;\n      });\n    }\n\n    if (node.tagName !== "BODY" && node.parentNode) {\n      let index = Array.prototype.indexOf.call(\n        node.parentNode.children,\n        node\n      );\n      pathSplit += `:nth-child(${index + 1})`;\n    }\n\n    pathSplits.unshift(pathSplit);\n    node = node.parentNode;\n  } while (node.tagName !== "HTML");\n\n  return pathSplits.join(" > ");\n}\n\nfunction getTopMostWindow() {\n  let parentWindow = window;\n  while (parentWindow !== window.parent) parentWindow = window.parent;\n  return parentWindow;\n}\n\nfunction findIframeFromElement(windowObject, element) {\n  let frameElement;\n  allFrame((frame) => {\n    if (frame.document.contains(element)) frameElement = frame.frameElement;\n    // window.cc.findIframeFromElement(frame.window, element);\n  });\n  return frameElement;\n}\n\nfunction getIframeFromPath(path) {\n  let topWindow = getTopMostWindow;\n\n  path.forEach((selector) => {\n    if (topWindow) topWindow = topWindow.querySelector(selector);\n  });\n  return topWindow;\n}\n// DO NOT REMOVE\n\nfunction* configMatch(elementConfig, element) {\n  for (let config of elementConfig) {\n    // if (!Array.isArray(config.selector))\n    //   config.selector = [config.selector];\n\n    if (config.selector && element.matches(config.selector)) yield config;\n  }\n  return;\n}\n\n\n// export function configMatch2(elementConfig, element) {\n//   let result = [];\n//   for (let config of elementConfig) {\n//     if (config.selector && element.matches(config.selector)) result.push(config);\n//   }\n//   return result;\n// }\n\n// DO NOT REMOVE\n\n// an opiniated function uses configMatch2 to read configs\n// WARNING: the config iterated from top to bottom. for deseired effect elementConfig should be reveresed\n// typeof elementConfig: array of objects and every objects containing keys as false, true or a selector \n// element: the element to read attributes\n// key: the key in which is in elementConfig and on match onSuccess callback will be called\nfunction configExecuter(element, key, onSuccess, elementConfig) {\n  for (let config of configMatch(elementConfig || window.elementConfig, element))\n    if (config[key] === true) return onSuccess(element, config);\n    else if (config[key] === false) return false;\n  else if (config[key] === undefined) continue;\n  else if (isValidSelector(config[key]))\n    return onSuccess(element, config, true);\n  else console.warn("builder: wrong element config ", config);\n\n  return false;\n}\n\nfunction UUID(length = 10) {\n  var result = "";\n  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  var d = new Date().toTimeString();\n  var random = d.replace(/[\\W_]+/g, "").substr(0, 6);\n  result += random;\n  return result;\n}\n\nfunction parseTextToHtml(text) {\n  let doc = new DOMParser().parseFromString(text, "text/html");\n  if (doc.head.children[0]) return doc.head.children[0];\n  else return doc.body.children[0];\n}\n\nfunction splitBydelimiter(str, delimiter) {\n  return str.split(delimiter).map((s) => s.trim());\n}\n\nfunction joinBydelimiter(str, delimiter) {\n  return str.map((s) => s.trim()).join(delimiter);\n}\n\nfunction isValidSelector(selector) {\n  try {\n    document.createDocumentFragment().querySelector(selector);\n  }\n  catch (error) {\n    return false;\n  }\n  return true;\n}\n\nfunction getElementPath(element, returnContext) {\n  let path = [];\n\n  let topWindow = window;\n  let iframeElement = findIframeFromElement(topWindow, element);\n  let p = cssPath(iframeElement);\n  if (p) path.unshift(p);\n\n  return returnContext ? { path, document: iframeElement || document } : path;\n  //todo: support for nested iframe\n  // while(iframeElement !== findIframeFromElement(topWindow,iframeElement))\n  // {\n  //   iframeElement = findIframeFromElement(topWindow,iframeElement);\n  //   path.unshift(cssPath(iframeElement))\n  // }\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  getElementPath,\n  isValidSelector,\n  joinBydelimiter,\n  splitBydelimiter,\n  parseTextToHtml,\n  UUID,\n  configExecuter,\n  configMatch,\n  getIframeFromPath,\n  findIframeFromElement,\n  getTopMostWindow,\n  cssPath,\n  allFrame,\n  checkValue,\n  getAttributes,\n  isJsonString,\n  getParentFromElement,\n  generateUUID\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS91dGlscy9zcmMvaW5kZXguanM/NmIxOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFTztBQUNQO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTztBQUNQLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiw0Q0FBNEM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AY29jcmVhdGUvdXRpbHMvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IGppblxuICogMjAyMC0wNC0wM1xuICovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVVVJRChsZW5ndGggPSAzNikge1xuICAvLyBpZiAobGVuZ3RoID09IDEwKSB7XG4gIC8vICAgdmFyIHJlc3VsdCAgICAgICAgICAgPSAnJztcbiAgLy8gICB2YXIgY2hhcmFjdGVycyAgICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSc7XG4gIC8vICAgdmFyIGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgLy8gICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgLy8gICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSk7XG4gIC8vICAgfVxuXG4gIC8vICAgdmFyIGRkID0gbmV3IERhdGUoKS50b1RpbWVTdHJpbmcoKTtcbiAgLy8gICB2YXIgcmFuZG9tID0gZGQucmVwbGFjZSgvW1xcV19dKy9nLCBcIlwiKS5zdWJzdHIoMCw2KTtcbiAgLy8gICByZXN1bHQgKz0gcmFuZG9tO1xuICAvLyAgIHJldHVybiByZXN1bHQ7XG4gIC8vIH1cblxuICBsZXQgZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBsZXQgZDIgPVxuICAgICh3aW5kb3cucGVyZm9ybWFuY2UgJiZcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgJiZcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSAqIDEwMDApIHx8XG4gICAgMDtcbiAgbGV0IHBhdHRlcm4gPSBcInV4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eFwiO1xuXG4gIGlmIChsZW5ndGggPD0gcGF0dGVybi5sZW5ndGgpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMCwgbGVuZ3RoKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsZXQgYWRkX2xlbiA9IGxlbmd0aCAtIHBhdHRlcm4ubGVuZ3RoO1xuICAgIGxldCBzdWJfcGF0dGVybiA9IFwiLXh4eHl5eHh4XCI7XG5cbiAgICBsZXQgZ3JvdXBfbiA9IE1hdGguZmxvb3IoYWRkX2xlbiAvIHN1Yl9wYXR0ZXJuLmxlbmd0aCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwX247IGkrKykge1xuICAgICAgcGF0dGVybiArPSBzdWJfcGF0dGVybjtcbiAgICB9XG5cbiAgICBncm91cF9uID0gYWRkX2xlbiAtIGdyb3VwX24gKiBzdWJfcGF0dGVybi5sZW5ndGg7XG4gICAgcGF0dGVybiArPSBzdWJfcGF0dGVybi5zdWJzdHIoMCwgZ3JvdXBfbik7XG4gIH1cblxuICBsZXQgdXVpZCA9IHBhdHRlcm4ucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG4gICAgdmFyIHIgPSBNYXRoLnJhbmRvbSgpICogMTY7XG4gICAgaWYgKGQgPiAwKSB7XG4gICAgICB2YXIgciA9IChkICsgcikgJSAxNiB8IDA7XG4gICAgICBkID0gTWF0aC5mbG9vcihkIC8gMTYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciByID0gKGQyICsgcikgJSAxNiB8IDA7XG4gICAgICBkMiA9IE1hdGguZmxvb3IoZDIgLyAxNik7XG4gICAgfVxuICAgIHJldHVybiAoYyA9PSBcInhcIiA/IHIgOiAociAmIDB4NykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCwgcGFyZW50X2NsYXNzLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChwYXJlbnRfY2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMocGFyZW50X2NsYXNzKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT0gbnVsbCAmJiBub2RlLmNsYXNzTGlzdCkge1xuICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmVudF9jbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuZXZlcnkoKGF0dHIpID0+IGVsZW1lbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGxldCBub2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlcy5ldmVyeSgoYXR0cikgPT4gbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pzb25TdHJpbmcoc3RyX2RhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQganNvbl9kYXRhID0gSlNPTi5wYXJzZShzdHJfZGF0YSk7XG4gICAgaWYgKHR5cGVvZiBqc29uX2RhdGEgPT09IFwib2JqZWN0XCIgJiYganNvbl9kYXRhICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGVOYW1lcygpLnJlZHVjZSgoYXR0ck1hcCwgbmFtZSkgPT4ge1xuICAgIGF0dHJNYXBbbmFtZV0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gYXR0ck1hcDtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tWYWx1ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIGlmICgve3tcXHMqKFtcXHdcXFddKylcXHMqfX0vZy50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLy8gaG9zc2VpbnMgdXRpbGxzXG5cbi8vIGZ1bmN0aW9uIHRvIGdvIHRocm91Z2ggYWxsIGZyYW1lc1xuZXhwb3J0IGZ1bmN0aW9uIGFsbEZyYW1lKGNhbGxiYWNrKSB7XG4gIGxldCBhbGxGcmFtZXMgPSBbeyBkb2N1bWVudCwgd2luZG93IH1dO1xuICBmb3IgKGxldCBmcmFtZSBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaWZyYW1lXCIpKSB7XG4gICAgbGV0IGZyYW1lRG9jdW1lbnQgPSBmcmFtZS5jb250ZW50RG9jdW1lbnQgfHwgZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICBsZXQgZnJhbWVXaW5kb3cgPSBmcmFtZS5jb250ZW50V2luZG93O1xuICAgIGFsbEZyYW1lcy5wdXNoKHtcbiAgICAgIGRvY3VtZW50OiBmcmFtZURvY3VtZW50LFxuICAgICAgd2luZG93OiBmcmFtZVdpbmRvdyxcbiAgICAgIGZyYW1lRWxlbWVudDogZnJhbWUsXG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IG5ldyBTZXQoKTtcbiAgZm9yIChsZXQgZnJhbWUgb2YgYWxsRnJhbWVzKSB7XG4gICAgbGV0IGNhbGxiYWNrUmVzdWx0ID0gY2FsbGJhY2soZnJhbWUpO1xuICAgIGlmIChcbiAgICAgIGNhbGxiYWNrUmVzdWx0ICYmXG4gICAgICB0eXBlb2YgY2FsbGJhY2tSZXN1bHRbU3ltYm9sLml0ZXJhdG9yXSA9PT0gXCJmdW5jdGlvblwiXG4gICAgKVxuICAgICAgY2FsbGJhY2tSZXN1bHQuZm9yRWFjaCgoZWwpID0+IHJlc3VsdC5hZGQoZWwpKTtcbiAgICBlbHNlIGlmIChjYWxsYmFja1Jlc3VsdCkgcmVzdWx0LmFkZChjYWxsYmFja1Jlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShyZXN1bHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzUGF0aChub2RlKSB7XG4gIGxldCBwYXRoU3BsaXRzID0gW107XG4gIGRvIHtcbiAgICBpZiAoIW5vZGUgfHwgIW5vZGUudGFnTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBwYXRoU3BsaXQgPSBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZS5pZCAmJiBub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiKSBwYXRoU3BsaXQgKz0gXCIjXCIgKyBub2RlLmlkO1xuXG4gICAgaWYgKG5vZGUuY2xhc3NMaXN0Lmxlbmd0aCAmJiBub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiKSB7XG4gICAgICBub2RlLmNsYXNzTGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLmluZGV4T2YoXCI6XCIpID09PSAtMSkgcGF0aFNwbGl0ICs9IFwiLlwiICsgaXRlbTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZ05hbWUgIT09IFwiQk9EWVwiICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbGV0IGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLmNoaWxkcmVuLFxuICAgICAgICBub2RlXG4gICAgICApO1xuICAgICAgcGF0aFNwbGl0ICs9IGA6bnRoLWNoaWxkKCR7aW5kZXggKyAxfSlgO1xuICAgIH1cblxuICAgIHBhdGhTcGxpdHMudW5zaGlmdChwYXRoU3BsaXQpO1xuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH0gd2hpbGUgKG5vZGUudGFnTmFtZSAhPT0gXCJIVE1MXCIpO1xuXG4gIHJldHVybiBwYXRoU3BsaXRzLmpvaW4oXCIgPiBcIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BNb3N0V2luZG93KCkge1xuICBsZXQgcGFyZW50V2luZG93ID0gd2luZG93O1xuICB3aGlsZSAocGFyZW50V2luZG93ICE9PSB3aW5kb3cucGFyZW50KSBwYXJlbnRXaW5kb3cgPSB3aW5kb3cucGFyZW50O1xuICByZXR1cm4gcGFyZW50V2luZG93O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmluZElmcmFtZUZyb21FbGVtZW50KHdpbmRvd09iamVjdCwgZWxlbWVudCkge1xuICBsZXQgZnJhbWVFbGVtZW50O1xuICBhbGxGcmFtZSgoZnJhbWUpID0+IHtcbiAgICBpZiAoZnJhbWUuZG9jdW1lbnQuY29udGFpbnMoZWxlbWVudCkpIGZyYW1lRWxlbWVudCA9IGZyYW1lLmZyYW1lRWxlbWVudDtcbiAgICAvLyB3aW5kb3cuY2MuZmluZElmcmFtZUZyb21FbGVtZW50KGZyYW1lLndpbmRvdywgZWxlbWVudCk7XG4gIH0pO1xuICByZXR1cm4gZnJhbWVFbGVtZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWZyYW1lRnJvbVBhdGgocGF0aCkge1xuICBsZXQgdG9wV2luZG93ID0gZ2V0VG9wTW9zdFdpbmRvdztcblxuICBwYXRoLmZvckVhY2goKHNlbGVjdG9yKSA9PiB7XG4gICAgaWYgKHRvcFdpbmRvdykgdG9wV2luZG93ID0gdG9wV2luZG93LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9KTtcbiAgcmV0dXJuIHRvcFdpbmRvdztcbn1cbi8vIERPIE5PVCBSRU1PVkVcblxuZXhwb3J0IGZ1bmN0aW9uKiBjb25maWdNYXRjaChlbGVtZW50Q29uZmlnLCBlbGVtZW50KSB7XG4gIGZvciAobGV0IGNvbmZpZyBvZiBlbGVtZW50Q29uZmlnKSB7XG4gICAgLy8gaWYgKCFBcnJheS5pc0FycmF5KGNvbmZpZy5zZWxlY3RvcikpXG4gICAgLy8gICBjb25maWcuc2VsZWN0b3IgPSBbY29uZmlnLnNlbGVjdG9yXTtcblxuICAgIGlmIChjb25maWcuc2VsZWN0b3IgJiYgZWxlbWVudC5tYXRjaGVzKGNvbmZpZy5zZWxlY3RvcikpIHlpZWxkIGNvbmZpZztcbiAgfVxuICByZXR1cm47XG59XG5cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ01hdGNoMihlbGVtZW50Q29uZmlnLCBlbGVtZW50KSB7XG4vLyAgIGxldCByZXN1bHQgPSBbXTtcbi8vICAgZm9yIChsZXQgY29uZmlnIG9mIGVsZW1lbnRDb25maWcpIHtcbi8vICAgICBpZiAoY29uZmlnLnNlbGVjdG9yICYmIGVsZW1lbnQubWF0Y2hlcyhjb25maWcuc2VsZWN0b3IpKSByZXN1bHQucHVzaChjb25maWcpO1xuLy8gICB9XG4vLyAgIHJldHVybiByZXN1bHQ7XG4vLyB9XG5cbi8vIERPIE5PVCBSRU1PVkVcblxuLy8gYW4gb3BpbmlhdGVkIGZ1bmN0aW9uIHVzZXMgY29uZmlnTWF0Y2gyIHRvIHJlYWQgY29uZmlnc1xuLy8gV0FSTklORzogdGhlIGNvbmZpZyBpdGVyYXRlZCBmcm9tIHRvcCB0byBib3R0b20uIGZvciBkZXNlaXJlZCBlZmZlY3QgZWxlbWVudENvbmZpZyBzaG91bGQgYmUgcmV2ZXJlc2VkXG4vLyB0eXBlb2YgZWxlbWVudENvbmZpZzogYXJyYXkgb2Ygb2JqZWN0cyBhbmQgZXZlcnkgb2JqZWN0cyBjb250YWluaW5nIGtleXMgYXMgZmFsc2UsIHRydWUgb3IgYSBzZWxlY3RvciBcbi8vIGVsZW1lbnQ6IHRoZSBlbGVtZW50IHRvIHJlYWQgYXR0cmlidXRlc1xuLy8ga2V5OiB0aGUga2V5IGluIHdoaWNoIGlzIGluIGVsZW1lbnRDb25maWcgYW5kIG9uIG1hdGNoIG9uU3VjY2VzcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZ0V4ZWN1dGVyKGVsZW1lbnQsIGtleSwgb25TdWNjZXNzLCBlbGVtZW50Q29uZmlnKSB7XG4gIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdNYXRjaChlbGVtZW50Q29uZmlnIHx8IHdpbmRvdy5lbGVtZW50Q29uZmlnLCBlbGVtZW50KSlcbiAgICBpZiAoY29uZmlnW2tleV0gPT09IHRydWUpIHJldHVybiBvblN1Y2Nlc3MoZWxlbWVudCwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChjb25maWdba2V5XSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgZWxzZSBpZiAoY29uZmlnW2tleV0gPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gIGVsc2UgaWYgKGlzVmFsaWRTZWxlY3Rvcihjb25maWdba2V5XSkpXG4gICAgcmV0dXJuIG9uU3VjY2VzcyhlbGVtZW50LCBjb25maWcsIHRydWUpO1xuICBlbHNlIGNvbnNvbGUud2FybihcImJ1aWxkZXI6IHdyb25nIGVsZW1lbnQgY29uZmlnIFwiLCBjb25maWcpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFVVSUQobGVuZ3RoID0gMTApIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIHZhciBjaGFyYWN0ZXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5cbiAgdmFyIGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSk7XG4gIH1cblxuICB2YXIgZCA9IG5ldyBEYXRlKCkudG9UaW1lU3RyaW5nKCk7XG4gIHZhciByYW5kb20gPSBkLnJlcGxhY2UoL1tcXFdfXSsvZywgXCJcIikuc3Vic3RyKDAsIDYpO1xuICByZXN1bHQgKz0gcmFuZG9tO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUZXh0VG9IdG1sKHRleHQpIHtcbiAgbGV0IGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJ0ZXh0L2h0bWxcIik7XG4gIGlmIChkb2MuaGVhZC5jaGlsZHJlblswXSkgcmV0dXJuIGRvYy5oZWFkLmNoaWxkcmVuWzBdO1xuICBlbHNlIHJldHVybiBkb2MuYm9keS5jaGlsZHJlblswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QnlkZWxpbWl0ZXIoc3RyLCBkZWxpbWl0ZXIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChkZWxpbWl0ZXIpLm1hcCgocykgPT4gcy50cmltKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gam9pbkJ5ZGVsaW1pdGVyKHN0ciwgZGVsaW1pdGVyKSB7XG4gIHJldHVybiBzdHIubWFwKChzKSA9PiBzLnRyaW0oKSkuam9pbihkZWxpbWl0ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRQYXRoKGVsZW1lbnQsIHJldHVybkNvbnRleHQpIHtcbiAgbGV0IHBhdGggPSBbXTtcblxuICBsZXQgdG9wV2luZG93ID0gd2luZG93O1xuICBsZXQgaWZyYW1lRWxlbWVudCA9IGZpbmRJZnJhbWVGcm9tRWxlbWVudCh0b3BXaW5kb3csIGVsZW1lbnQpO1xuICBsZXQgcCA9IGNzc1BhdGgoaWZyYW1lRWxlbWVudCk7XG4gIGlmIChwKSBwYXRoLnVuc2hpZnQocCk7XG5cbiAgcmV0dXJuIHJldHVybkNvbnRleHQgPyB7IHBhdGgsIGRvY3VtZW50OiBpZnJhbWVFbGVtZW50IHx8IGRvY3VtZW50IH0gOiBwYXRoO1xuICAvL3RvZG86IHN1cHBvcnQgZm9yIG5lc3RlZCBpZnJhbWVcbiAgLy8gd2hpbGUoaWZyYW1lRWxlbWVudCAhPT0gZmluZElmcmFtZUZyb21FbGVtZW50KHRvcFdpbmRvdyxpZnJhbWVFbGVtZW50KSlcbiAgLy8ge1xuICAvLyAgIGlmcmFtZUVsZW1lbnQgPSBmaW5kSWZyYW1lRnJvbUVsZW1lbnQodG9wV2luZG93LGlmcmFtZUVsZW1lbnQpO1xuICAvLyAgIHBhdGgudW5zaGlmdChjc3NQYXRoKGlmcmFtZUVsZW1lbnQpKVxuICAvLyB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBnZXRFbGVtZW50UGF0aCxcbiAgaXNWYWxpZFNlbGVjdG9yLFxuICBqb2luQnlkZWxpbWl0ZXIsXG4gIHNwbGl0QnlkZWxpbWl0ZXIsXG4gIHBhcnNlVGV4dFRvSHRtbCxcbiAgVVVJRCxcbiAgY29uZmlnRXhlY3V0ZXIsXG4gIGNvbmZpZ01hdGNoLFxuICBnZXRJZnJhbWVGcm9tUGF0aCxcbiAgZmluZElmcmFtZUZyb21FbGVtZW50LFxuICBnZXRUb3BNb3N0V2luZG93LFxuICBjc3NQYXRoLFxuICBhbGxGcmFtZSxcbiAgY2hlY2tWYWx1ZSxcbiAgZ2V0QXR0cmlidXRlcyxcbiAgaXNKc29uU3RyaW5nLFxuICBnZXRQYXJlbnRGcm9tRWxlbWVudCxcbiAgZ2VuZXJhdGVVVUlEXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/utils/src/index.js\n')},"./src/index.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _codemirror = _interopRequireDefault(__webpack_require__(/*! codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n\nvar Y = _interopRequireWildcard(__webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.cjs\"));\n\nvar _yCodemirror = __webpack_require__(/*! ./js/y-codemirror */ \"./src/js/y-codemirror.js\");\n\nvar _crdt = _interopRequireDefault(__webpack_require__(/*! @cocreate/crdt */ \"./node_modules/@cocreate/crdt/src/index.js\"));\n\nvar _userCursor_class = __webpack_require__(/*! @cocreate/crdt/src/utils/cursor/userCursor_class */ \"./node_modules/@cocreate/crdt/src/utils/cursor/userCursor_class.js\");\n\nvar _crudClient = _interopRequireDefault(__webpack_require__(/*! @cocreate/crud-client */ \"./node_modules/@cocreate/crud-client/src/index.js\"));\n\nvar _form = _interopRequireDefault(__webpack_require__(/*! @cocreate/form */ \"./node_modules/@cocreate/form/src/index.js\"));\n\nvar _observer = _interopRequireDefault(__webpack_require__(/*! @cocreate/observer */ \"./node_modules/@cocreate/observer/src/index.js\"));\n\n__webpack_require__(/*! codemirror/mode/htmlmixed/htmlmixed.js */ \"./node_modules/codemirror/mode/htmlmixed/htmlmixed.js\");\n\n__webpack_require__(/*! codemirror/lib/codemirror.css */ \"./node_modules/codemirror/lib/codemirror.css\");\n\n__webpack_require__(/*! ./css/index.css */ \"./src/css/index.css\");\n\n__webpack_require__(/*! codemirror/addon/fold/foldcode.js */ \"./node_modules/codemirror/addon/fold/foldcode.js\");\n\n__webpack_require__(/*! codemirror/addon/fold/foldgutter.js */ \"./node_modules/codemirror/addon/fold/foldgutter.js\");\n\n__webpack_require__(/*! codemirror/addon/fold/brace-fold.js */ \"./node_modules/codemirror/addon/fold/brace-fold.js\");\n\n__webpack_require__(/*! codemirror/addon/fold/xml-fold.js */ \"./node_modules/codemirror/addon/fold/xml-fold.js\");\n\n__webpack_require__(/*! codemirror/addon/fold/indent-fold.js */ \"./node_modules/codemirror/addon/fold/indent-fold.js\");\n\n__webpack_require__(/*! codemirror/addon/fold/markdown-fold.js */ \"./node_modules/codemirror/addon/fold/markdown-fold.js\");\n\n__webpack_require__(/*! codemirror/addon/fold/comment-fold.js */ \"./node_modules/codemirror/addon/fold/comment-fold.js\");\n\n__webpack_require__(/*! codemirror/addon/selection/active-line.js */ \"./node_modules/codemirror/addon/selection/active-line.js\");\n\n__webpack_require__(/*! codemirror/addon/scroll/simplescrollbars.js */ \"./node_modules/codemirror/addon/scroll/simplescrollbars.js\");\n\n__webpack_require__(/*! codemirror/addon/edit/closetag.js */ \"./node_modules/codemirror/addon/edit/closetag.js\");\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//Folding CODE\nwindow.addEventListener('load', () => {\n  /**\n  * Create all  Codemirrors with class .codemirror\n  * @private\n  *\n  * @development jeanmendozar@gmail.com\n  * @param {None}\n  */\n  class CoCreateYjsCodemirror {\n    constructor() {\n      this.elements = [];\n      this.codemirrors = [];\n      this.bindings = [];\n      this.organization_Id = config.organization_Id || 'randomOrganizationID';\n    }\n\n    _createCodeMirror(editorContainer) {\n      const editor = (0, _codemirror.default)(editorContainer, {\n        mode: 'htmlmixed',\n        styleActiveLine: true,\n        scrollbarStyle: 'overlay',\n        autoCloseTags: true,\n        lineNumbers: true,\n        lineWrapping: true,\n        extraKeys: {\n          \"Ctrl-Q\": function (cm) {\n            cm.foldCode(cm.getCursor());\n          }\n        },\n        foldGutter: true,\n        gutters: [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"]\n      });\n      editor.setOption('element', editorContainer);\n      this.codemirrors.push(editor);\n      return editor;\n    }\n\n    _createBinding(type_element, editor, provider, realtime = true) {\n      console.log(provider);\n      let binding = new _yCodemirror.CodeMirrorBinding(type_element, editor, provider.awareness, realtime);\n      this.bindings.push(binding);\n      return binding;\n    }\n\n    _initYSocket(element, editor, isInit) {\n      const {\n        collection,\n        name,\n        document_id\n      } = _crudClient.default.getAttr(element);\n\n      const is_realtime = _crudClient.default.isRealtimeAttr(element);\n\n      if (collection && name && document_id) {\n        const id = _crdt.default.generateID(config.organization_Id, collection, document_id, name);\n\n        _crdt.default.createDoc(id, element);\n\n        let provider = _crdt.default.getProvider(id);\n\n        let doc_type = _crdt.default.getType(id);\n\n        let binding = this._createBinding(doc_type, editor, provider, is_realtime);\n        /*if (realtime) {\n          let binding = this._createBinding(doc_type, editor, provider)\n          // this.adapterDB(id, binding.awareness.doc);\n          \n          // CoCreate.crud.readDocument({\n          //   collection: collection,\n          //   document_id: document_id,\n          //   metadata: {\n          //   type: 'crdt'\n          // }\n          // })\n          \n          \n          // new UserCursor(provider);\n          \n        } else {\n          if (isInit) {\n            const old_string = doc_type.toString()\n            editor.setValue(old_string);\n            if(!old_string)\n               \n            //cmDoc.setValue(textType.toString())\n          }\n        }*/\n\n      }\n    }\n\n    init(container) {\n      this.initElement(container);\n      this.initSocketEvent();\n    }\n\n    initElement(container) {\n      const self = this;\n      const mainContainer = container || document;\n      let elements = mainContainer.querySelectorAll('.codemirror');\n\n      if (elements.length == 0 && mainContainer.classList && mainContainer.classList.contains('codemirror')) {\n        elements = [mainContainer];\n      }\n\n      elements.forEach(function (element, index) {\n        let template = element.closest('.template');\n\n        if (template) {\n          return;\n        }\n\n        if (_observer.default.getInitialized(element)) {\n          return;\n        }\n\n        try {\n          let editor = self._createCodeMirror(element);\n\n          self._initYSocket(element, editor, true);\n\n          self.initEvent(element, editor);\n\n          _observer.default.setInitialized(element);\n\n          self.elements.push(element);\n        } catch (error) {\n          return false;\n        }\n      }); //end forEach\n    }\n\n    initSocketEvent() {\n      const self = this; // CoCreateSocket.listen('readDocument', function(data) {\n      //   if (!data.metadata || data.metadata.type != \"crdt\") {\n      //     return;\n      //   }\n      //   self.elements.forEach((mirror) => {\n      //     const collection = mirror.getAttribute('data-collection')\n      // \tconst id = mirror.getAttribute('data-document_id')\n      // \tconst name = mirror.getAttribute('name')\n      // \tif (mirror.crudSetted === true) {\n      //       return;\n      //     }\n      // \tif (data['collection'] == collection && data['document_id'] == id && (name in data.data)) {\n      // \t // _this.sendChangeData(input, data['data'][name], 0, data['data'][name].length, false);\n      // \t  CoCreate.crdt.replaceText({\n      // \t    collection: collection,\n      // \t    document_id: id,\n      // \t    name: name,\n      // \t    value: data['data'][name],\n      // \t  })\n      //       mirror.crudSetted = true;\n      // \t}\n      //   });\n      // });\n    }\n\n    initEvent(element, editor) {\n      var charWidth = editor.defaultCharWidth(),\n          basePadding = 4;\n\n      var _this = this; //comment by jean mendoza 05-11-2020, codemirror no tab in editor\n      // editor.on(\"renderLine\", function(cm, line, elt) {\n      //   var off = CodeMirror.countColumn(line.text, null, cm.getOption(\"tabSize\")) * charWidth;\n      //   elt.style.textIndent = \"-\" + off + \"px\";\n      //   elt.style.paddingLeft = (basePadding + off) + \"px\";\n      // });\n\n\n      editor.refresh();\n      editor.on('change', function (codemirror, yjs_event) {\n        var value = codemirror.getValue();\n        var element = codemirror.getOption('element');\n        var id = element.getAttribute('id') || '';\n\n        _this.requestDocumentID(element);\n\n        if (!id) return;\n        var targets = document.querySelectorAll('[data-get_value=\"' + id + '\"]');\n        var is_fold = element.dataset['is_fold'] || false;\n\n        if (!is_fold) {\n          var fold_lines = element.dataset['fold'] || '';\n          fold_lines = fold_lines.split(',').filter(value => parseInt(value) - 1 >= 0).map(value => value - 1);\n          fold_lines.forEach(line => {\n            editor.foldCode(_codemirror.default.Pos(line, 0));\n            element.dataset['is_fold'] = true;\n          });\n        }\n\n        targets.forEach(target => {\n          if (target.nodeName == 'IFRAME') {\n            //tmp_target = target;\n            let document_iframe = target.contentDocument;\n            /*\n            document_iframe.open();\n            document_iframe.write(value);\n            document_iframe.close();\n            */\n\n            target.srcdoc = value;\n          } else {\n            if (typeof target.innerHTML != \"undefined\") {\n              target.innerHTML = value;\n            } else if (typeof target.value != \"undefined\") {\n              target.value = value;\n            } else if (typeof target.textContent != \"undefined\") {\n              target.textContent = value;\n            }\n          }\n        });\n      });\n      element.addEventListener('set-document_id', function (event) {\n        console.log('created document_id');\n\n        _this._initYSocket(element, editor);\n\n        _this.saveDataIntoDB(element, editor.getValue());\n      });\n      element.addEventListener('clicked-submitBtn', function () {\n        console.log('clicked save button');\n\n        _this.saveDataIntoDB(element, editor.getValue());\n      });\n    }\n\n    requestDocumentID(element) {\n      const document_id = element.getAttribute('data-document_id');\n\n      const realtime = _crudClient.default.isRealtimeAttr(element);\n\n      if (!document_id && realtime) {\n        _form.default.request({\n          element\n        });\n\n        element.setAttribute('data-document_id', 'pending');\n      }\n    }\n\n    saveDataIntoDB(element, value) {\n      const {\n        collection,\n        document_id,\n        name\n      } = _crudClient.default.getAttr(element);\n\n      _crudClient.default.updateDocument({\n        collection,\n        document_id,\n        data: {\n          [name]: value\n        }\n      });\n    }\n\n    parseTypeName(name) {\n      const data = JSON.parse(atob(name));\n      return data;\n    }\n\n  } //end Class CoCreateYjsCodemirror\n\n\n  const obj_cocreatecodemirror = new CoCreateYjsCodemirror();\n  /**\n  * Initialization all OBJS with class .codemirror\n  */\n  // @ts-ignore\n\n  window.CoCreateCodemirror = obj_cocreatecodemirror; //. register init function\n\n  CoCreateCodemirror.init();\n\n  if (_observer.default) {\n    _observer.default.init({\n      name: 'CoCreateCodemirror',\n      observe: ['subtree', 'childList'],\n      include: '.codemirror',\n      callback: function (mutation) {\n        CoCreateCodemirror.initElement(mutation.target);\n      }\n    });\n  }\n\n  if (_form.default) {\n    _form.default.init({\n      name: 'Codemirror',\n      selector: '.codemirror',\n      callback: function (el) {}\n    });\n  }\n}); //end window LOAD//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOlsid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsIkNvQ3JlYXRlWWpzQ29kZW1pcnJvciIsImNvbnN0cnVjdG9yIiwiZWxlbWVudHMiLCJjb2RlbWlycm9ycyIsImJpbmRpbmdzIiwib3JnYW5pemF0aW9uX0lkIiwiY29uZmlnIiwiX2NyZWF0ZUNvZGVNaXJyb3IiLCJlZGl0b3JDb250YWluZXIiLCJlZGl0b3IiLCJtb2RlIiwic3R5bGVBY3RpdmVMaW5lIiwic2Nyb2xsYmFyU3R5bGUiLCJhdXRvQ2xvc2VUYWdzIiwibGluZU51bWJlcnMiLCJsaW5lV3JhcHBpbmciLCJleHRyYUtleXMiLCJjbSIsImZvbGRDb2RlIiwiZ2V0Q3Vyc29yIiwiZm9sZEd1dHRlciIsImd1dHRlcnMiLCJzZXRPcHRpb24iLCJwdXNoIiwiX2NyZWF0ZUJpbmRpbmciLCJ0eXBlX2VsZW1lbnQiLCJwcm92aWRlciIsInJlYWx0aW1lIiwiY29uc29sZSIsImxvZyIsImJpbmRpbmciLCJDb2RlTWlycm9yQmluZGluZyIsImF3YXJlbmVzcyIsIl9pbml0WVNvY2tldCIsImVsZW1lbnQiLCJpc0luaXQiLCJjb2xsZWN0aW9uIiwibmFtZSIsImRvY3VtZW50X2lkIiwiY3J1ZCIsImdldEF0dHIiLCJpc19yZWFsdGltZSIsImlzUmVhbHRpbWVBdHRyIiwiaWQiLCJjcmR0IiwiZ2VuZXJhdGVJRCIsImNyZWF0ZURvYyIsImdldFByb3ZpZGVyIiwiZG9jX3R5cGUiLCJnZXRUeXBlIiwiaW5pdCIsImNvbnRhaW5lciIsImluaXRFbGVtZW50IiwiaW5pdFNvY2tldEV2ZW50Iiwic2VsZiIsIm1haW5Db250YWluZXIiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsZW5ndGgiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImZvckVhY2giLCJpbmRleCIsInRlbXBsYXRlIiwiY2xvc2VzdCIsIkNvQ3JlYXRlT2JzZXJ2ZXIiLCJnZXRJbml0aWFsaXplZCIsImluaXRFdmVudCIsInNldEluaXRpYWxpemVkIiwiZXJyb3IiLCJjaGFyV2lkdGgiLCJkZWZhdWx0Q2hhcldpZHRoIiwiYmFzZVBhZGRpbmciLCJfdGhpcyIsInJlZnJlc2giLCJvbiIsImNvZGVtaXJyb3IiLCJ5anNfZXZlbnQiLCJ2YWx1ZSIsImdldFZhbHVlIiwiZ2V0T3B0aW9uIiwiZ2V0QXR0cmlidXRlIiwicmVxdWVzdERvY3VtZW50SUQiLCJ0YXJnZXRzIiwiaXNfZm9sZCIsImRhdGFzZXQiLCJmb2xkX2xpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJwYXJzZUludCIsIm1hcCIsImxpbmUiLCJDb2RlTWlycm9yIiwiUG9zIiwidGFyZ2V0Iiwibm9kZU5hbWUiLCJkb2N1bWVudF9pZnJhbWUiLCJjb250ZW50RG9jdW1lbnQiLCJzcmNkb2MiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudCIsImV2ZW50Iiwic2F2ZURhdGFJbnRvREIiLCJDb0NyZWF0ZUZvcm0iLCJyZXF1ZXN0Iiwic2V0QXR0cmlidXRlIiwidXBkYXRlRG9jdW1lbnQiLCJkYXRhIiwicGFyc2VUeXBlTmFtZSIsIkpTT04iLCJwYXJzZSIsImF0b2IiLCJvYmpfY29jcmVhdGVjb2RlbWlycm9yIiwiQ29DcmVhdGVDb2RlbWlycm9yIiwib2JzZXJ2ZSIsImluY2x1ZGUiLCJjYWxsYmFjayIsIm11dGF0aW9uIiwic2VsZWN0b3IiLCJlbCJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7O0FBVkE7QUFhQUEsTUFBTSxDQUFDQyxnQkFBUCxDQUF3QixNQUF4QixFQUFnQyxNQUFNO0FBQ3BDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QixpQkFBYSxDQUFDdkUsSUFBRCxFQUFPO0FBQ2xCLFlBQU1zRSxJQUFJLEdBQUdFLElBQUksQ0FBQ0MsS0FBTCxDQUFXQyxJQUFJLENBQUMxRSxJQUFELENBQWYsQ0FBYjtBQUNBLGFBQU9zRSxJQUFQO0FBQ0Q7O0FBek95QixHQVRRLENBb1BuQzs7O0FBRUQsUUFBTUssc0JBQXNCLEdBQUcsSUFBSWhILHFCQUFKLEVBQS9CO0FBQ0E7QUFDRjtBQUNBO0FBRUU7O0FBQ0FGLFFBQU0sQ0FBQ21ILGtCQUFQLEdBQTRCRCxzQkFBNUIsQ0E1UG9DLENBOFBwQzs7QUFDQUMsb0JBQWtCLENBQUMvRCxJQUFuQjs7QUFFQSxNQUFJZSxpQkFBSixFQUFzQjtBQUNwQkEsc0JBQWlCZixJQUFqQixDQUFzQjtBQUNyQmIsVUFBSSxFQUFFLG9CQURlO0FBRXJCNkUsYUFBTyxFQUFFLENBQUMsU0FBRCxFQUFZLFdBQVosQ0FGWTtBQUdyQkMsYUFBTyxFQUFFLGFBSFk7QUFJckJDLGNBQVEsRUFBRSxVQUFTQyxRQUFULEVBQW1CO0FBQzVCSiwwQkFBa0IsQ0FBQzdELFdBQW5CLENBQStCaUUsUUFBUSxDQUFDdkIsTUFBeEM7QUFDQTtBQU5vQixLQUF0QjtBQVFEOztBQUVELE1BQUlTLGFBQUosRUFBa0I7QUFDaEJBLGtCQUFhckQsSUFBYixDQUFrQjtBQUNoQmIsVUFBSSxFQUFFLFlBRFU7QUFFaEJpRixjQUFRLEVBQUUsYUFGTTtBQUdoQkYsY0FBUSxFQUFFLFVBQVNHLEVBQVQsRUFBYSxDQUV0QjtBQUxlLEtBQWxCO0FBT0Q7QUFFRixDQXRSRCxFLENBc1JHIiwiZmlsZSI6Ii4vc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBDb2RlTWlycm9yIGZyb20gJ2NvZGVtaXJyb3InXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IENvZGVNaXJyb3JCaW5kaW5nIH0gZnJvbSAnLi9qcy95LWNvZGVtaXJyb3InICBcbmltcG9ydCBjcmR0IGZyb20gJ0Bjb2NyZWF0ZS9jcmR0J1xuaW1wb3J0IHsgVXNlckN1cnNvciB9IGZyb20gJ0Bjb2NyZWF0ZS9jcmR0L3NyYy91dGlscy9jdXJzb3IvdXNlckN1cnNvcl9jbGFzcydcbmltcG9ydCBjcnVkIGZyb20gJ0Bjb2NyZWF0ZS9jcnVkLWNsaWVudCdcbmltcG9ydCBDb0NyZWF0ZUZvcm0gZnJvbSAnQGNvY3JlYXRlL2Zvcm0nXG5pbXBvcnQgQ29DcmVhdGVPYnNlcnZlciBmcm9tICdAY29jcmVhdGUvb2JzZXJ2ZXInXG5cbmltcG9ydCAnY29kZW1pcnJvci9tb2RlL2h0bWxtaXhlZC9odG1sbWl4ZWQuanMnXG5pbXBvcnQgJ2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuY3NzJztcbmltcG9ydCAnLi9jc3MvaW5kZXguY3NzJztcblxuLy9Gb2xkaW5nIENPREVcbmltcG9ydCAnY29kZW1pcnJvci9hZGRvbi9mb2xkL2ZvbGRjb2RlLmpzJ1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL2ZvbGQvZm9sZGd1dHRlci5qcydcbmltcG9ydCAnY29kZW1pcnJvci9hZGRvbi9mb2xkL2JyYWNlLWZvbGQuanMnXG5pbXBvcnQgJ2NvZGVtaXJyb3IvYWRkb24vZm9sZC94bWwtZm9sZC5qcydcbmltcG9ydCAnY29kZW1pcnJvci9hZGRvbi9mb2xkL2luZGVudC1mb2xkLmpzJ1xuaW1wb3J0ICdjb2RlbWlycm9yL2FkZG9uL2ZvbGQvbWFya2Rvd24tZm9sZC5qcydcbmltcG9ydCAnY29kZW1pcnJvci9hZGRvbi9mb2xkL2NvbW1lbnQtZm9sZC5qcydcbmltcG9ydCAnY29kZW1pcnJvci9hZGRvbi9zZWxlY3Rpb24vYWN0aXZlLWxpbmUuanMnXG5pbXBvcnQgJ2NvZGVtaXJyb3IvYWRkb24vc2Nyb2xsL3NpbXBsZXNjcm9sbGJhcnMuanMnXG5pbXBvcnQgJ2NvZGVtaXJyb3IvYWRkb24vZWRpdC9jbG9zZXRhZy5qcydcblxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgLyoqXG4gICogQ3JlYXRlIGFsbCAgQ29kZW1pcnJvcnMgd2l0aCBjbGFzcyAuY29kZW1pcnJvclxuICAqIEBwcml2YXRlXG4gICpcbiAgKiBAZGV2ZWxvcG1lbnQgamVhbm1lbmRvemFyQGdtYWlsLmNvbVxuICAqIEBwYXJhbSB7Tm9uZX1cbiAgKi9cbiBcbiAgY2xhc3MgQ29DcmVhdGVZanNDb2RlbWlycm9yIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICAgIHRoaXMuY29kZW1pcnJvcnMgPSBbXTtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMub3JnYW5pemF0aW9uX0lkID0gY29uZmlnLm9yZ2FuaXphdGlvbl9JZCB8fCAncmFuZG9tT3JnYW5pemF0aW9uSUQnXG4gICAgfVxuICAgIFxuICAgIF9jcmVhdGVDb2RlTWlycm9yKGVkaXRvckNvbnRhaW5lcil7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBlZGl0b3IgPSBDb2RlTWlycm9yKGVkaXRvckNvbnRhaW5lciwge1xuICAgICAgICAgIG1vZGU6ICAnaHRtbG1peGVkJyxcbiAgICAgICAgICBzdHlsZUFjdGl2ZUxpbmU6IHRydWUsXG4gICAgICAgICAgc2Nyb2xsYmFyU3R5bGU6ICdvdmVybGF5JyxcbiAgICAgICAgICBhdXRvQ2xvc2VUYWdzOiB0cnVlLFxuICAgICAgICAgIGxpbmVOdW1iZXJzOiB0cnVlLFxuICAgICAgICAgIGxpbmVXcmFwcGluZzogdHJ1ZSxcbiAgICAgICAgICBleHRyYUtleXM6IHtcIkN0cmwtUVwiOiBmdW5jdGlvbihjbSl7IGNtLmZvbGRDb2RlKGNtLmdldEN1cnNvcigpKTsgfX0sXG4gICAgICAgICAgZm9sZEd1dHRlcjogdHJ1ZSxcbiAgICAgICAgICBndXR0ZXJzOiBbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIsIFwiQ29kZU1pcnJvci1mb2xkZ3V0dGVyXCJdLFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGVkaXRvci5zZXRPcHRpb24oJ2VsZW1lbnQnLGVkaXRvckNvbnRhaW5lcik7XG4gICAgICAgICAgXG4gICAgICAgIHRoaXMuY29kZW1pcnJvcnMucHVzaChlZGl0b3IpO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgXG4gICAgX2NyZWF0ZUJpbmRpbmcodHlwZV9lbGVtZW50LCBlZGl0b3IsIHByb3ZpZGVyICwgcmVhbHRpbWUgPSB0cnVlKXtcbiAgICAgIGNvbnNvbGUubG9nKHByb3ZpZGVyKVxuICAgICAgXG4gICAgICAgIGxldCBiaW5kaW5nID0gbmV3IENvZGVNaXJyb3JCaW5kaW5nKHR5cGVfZWxlbWVudCwgZWRpdG9yLCBwcm92aWRlci5hd2FyZW5lc3MgLHJlYWx0aW1lKVxuICAgICAgICB0aGlzLmJpbmRpbmdzLnB1c2goYmluZGluZyk7XG4gICAgICAgIHJldHVybiBiaW5kaW5nOyBcbiAgICB9XG4gICAgXG4gICAgX2luaXRZU29ja2V0KGVsZW1lbnQsIGVkaXRvciwgaXNJbml0KSB7XG4gICAgICBjb25zdCB7IGNvbGxlY3Rpb24sIG5hbWUsIGRvY3VtZW50X2lkIH0gPSBjcnVkLmdldEF0dHIoZWxlbWVudClcbiAgICAgIGNvbnN0IGlzX3JlYWx0aW1lID0gY3J1ZC5pc1JlYWx0aW1lQXR0cihlbGVtZW50KVxuXG4gICAgICBpZiAoY29sbGVjdGlvbiAmJiBuYW1lICYmIGRvY3VtZW50X2lkKSB7XG4gICAgICAgIGNvbnN0IGlkID0gY3JkdC5nZW5lcmF0ZUlEKGNvbmZpZy5vcmdhbml6YXRpb25fSWQsIGNvbGxlY3Rpb24sIGRvY3VtZW50X2lkLCBuYW1lKTtcbiAgICAgICAgY3JkdC5jcmVhdGVEb2MoaWQsIGVsZW1lbnQpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHByb3ZpZGVyID0gY3JkdC5nZXRQcm92aWRlcihpZClcbiAgICAgICAgbGV0IGRvY190eXBlID0gY3JkdC5nZXRUeXBlKGlkKVxuXG4gICAgICAgIGxldCBiaW5kaW5nID0gdGhpcy5fY3JlYXRlQmluZGluZyhkb2NfdHlwZSwgZWRpdG9yLCBwcm92aWRlciwgaXNfcmVhbHRpbWUpXG4gICAgICAgIC8qaWYgKHJlYWx0aW1lKSB7XG4gICAgICAgICAgbGV0IGJpbmRpbmcgPSB0aGlzLl9jcmVhdGVCaW5kaW5nKGRvY190eXBlLCBlZGl0b3IsIHByb3ZpZGVyKVxuICAgICAgICAgIC8vIHRoaXMuYWRhcHRlckRCKGlkLCBiaW5kaW5nLmF3YXJlbmVzcy5kb2MpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENvQ3JlYXRlLmNydWQucmVhZERvY3VtZW50KHtcbiAgICAgICAgICAvLyAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgICAgICAgLy8gICBkb2N1bWVudF9pZDogZG9jdW1lbnRfaWQsXG4gICAgICAgICAgLy8gICBtZXRhZGF0YToge1xuICAgICAgXHRcdCAgLy8gICB0eXBlOiAnY3JkdCdcbiAgICAgIFx0XHQgIC8vIH1cbiAgICAgICAgICAvLyB9KVxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgIC8vIG5ldyBVc2VyQ3Vyc29yKHByb3ZpZGVyKTtcbiAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNJbml0KSB7XG4gICAgICAgICAgICBjb25zdCBvbGRfc3RyaW5nID0gZG9jX3R5cGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKG9sZF9zdHJpbmcpO1xuICAgICAgICAgICAgaWYoIW9sZF9zdHJpbmcpXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY21Eb2Muc2V0VmFsdWUodGV4dFR5cGUudG9TdHJpbmcoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0qL1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpbml0KGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5pbml0RWxlbWVudChjb250YWluZXIpO1xuICAgICAgdGhpcy5pbml0U29ja2V0RXZlbnQoKTtcbiAgICB9XG4gICAgXG4gICAgaW5pdEVsZW1lbnQoY29udGFpbmVyKXtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgY29uc3QgbWFpbkNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudDtcbiAgICAgIGxldCBlbGVtZW50cyA9IG1haW5Db250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmNvZGVtaXJyb3InKVxuXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09IDAgJiYgbWFpbkNvbnRhaW5lci5jbGFzc0xpc3QgJiYgbWFpbkNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoJ2NvZGVtaXJyb3InKSkge1xuICAgICAgICBlbGVtZW50cyA9IFttYWluQ29udGFpbmVyXTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50LCBpbmRleCl7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IGVsZW1lbnQuY2xvc2VzdCgnLnRlbXBsYXRlJyk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29DcmVhdGVPYnNlcnZlci5nZXRJbml0aWFsaXplZChlbGVtZW50KSkge1xuICAgIFx0XHRcdHJldHVybjtcbiAgICBcdFx0fVxuXG4gICAgICAgIHRyeXsgIFxuICAgICAgICAgIFxuICAgICAgICAgIGxldCBlZGl0b3IgPSBzZWxmLl9jcmVhdGVDb2RlTWlycm9yKGVsZW1lbnQpO1xuICAgICAgICAgIHNlbGYuX2luaXRZU29ja2V0KGVsZW1lbnQsIGVkaXRvciwgdHJ1ZSlcbiAgICAgICAgICBzZWxmLmluaXRFdmVudChlbGVtZW50LCBlZGl0b3IpXG4gICAgICAgICAgQ29DcmVhdGVPYnNlcnZlci5zZXRJbml0aWFsaXplZChlbGVtZW50KVxuICAgICAgICAgIHNlbGYuZWxlbWVudHMucHVzaChlbGVtZW50KVxuICAgICAgICAgIFxuICAgICAgICB9Y2F0Y2goZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSk7Ly9lbmQgZm9yRWFjaFxuICAgICAgXG4gICAgfVxuICAgIFxuICAgIGluaXRTb2NrZXRFdmVudCgpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgLy8gQ29DcmVhdGVTb2NrZXQubGlzdGVuKCdyZWFkRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAvLyAgIGlmICghZGF0YS5tZXRhZGF0YSB8fCBkYXRhLm1ldGFkYXRhLnR5cGUgIT0gXCJjcmR0XCIpIHtcbiAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAvLyAgIH1cbiAgICAgICAgXG4gICAgICAvLyAgIHNlbGYuZWxlbWVudHMuZm9yRWFjaCgobWlycm9yKSA9PiB7XG4gICAgICAvLyAgICAgY29uc3QgY29sbGVjdGlvbiA9IG1pcnJvci5nZXRBdHRyaWJ1dGUoJ2RhdGEtY29sbGVjdGlvbicpXG4gICAgXHRcdC8vIFx0Y29uc3QgaWQgPSBtaXJyb3IuZ2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJylcbiAgICBcdFx0Ly8gXHRjb25zdCBuYW1lID0gbWlycm9yLmdldEF0dHJpYnV0ZSgnbmFtZScpXG4gICAgXHRcdC8vIFx0aWYgKG1pcnJvci5jcnVkU2V0dGVkID09PSB0cnVlKSB7XG4gICAgICAvLyAgICAgICByZXR1cm47XG4gICAgICAvLyAgICAgfVxuICAgIFx0XHQvLyBcdGlmIChkYXRhWydjb2xsZWN0aW9uJ10gPT0gY29sbGVjdGlvbiAmJiBkYXRhWydkb2N1bWVudF9pZCddID09IGlkICYmIChuYW1lIGluIGRhdGEuZGF0YSkpIHtcbiAgICBcdFx0Ly8gXHQgLy8gX3RoaXMuc2VuZENoYW5nZURhdGEoaW5wdXQsIGRhdGFbJ2RhdGEnXVtuYW1lXSwgMCwgZGF0YVsnZGF0YSddW25hbWVdLmxlbmd0aCwgZmFsc2UpO1xuICAgIFx0XHQvLyBcdCAgQ29DcmVhdGUuY3JkdC5yZXBsYWNlVGV4dCh7XG4gICAgXHRcdC8vIFx0ICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXG4gICAgXHRcdC8vIFx0ICAgIGRvY3VtZW50X2lkOiBpZCxcbiAgICBcdFx0Ly8gXHQgICAgbmFtZTogbmFtZSxcbiAgICBcdFx0Ly8gXHQgICAgdmFsdWU6IGRhdGFbJ2RhdGEnXVtuYW1lXSxcbiAgICBcdFx0Ly8gXHQgIH0pXG4gICAgICAvLyAgICAgICBtaXJyb3IuY3J1ZFNldHRlZCA9IHRydWU7XG4gICAgXHRcdC8vIFx0fVxuICAgICAgLy8gICB9KTtcbiAgICAgIC8vIH0pO1xuICAgIH1cbiAgICBcbiAgICBpbml0RXZlbnQoZWxlbWVudCwgZWRpdG9yKSB7XG4gICAgICB2YXIgY2hhcldpZHRoID0gZWRpdG9yLmRlZmF1bHRDaGFyV2lkdGgoKSwgYmFzZVBhZGRpbmcgPSA0O1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIC8vY29tbWVudCBieSBqZWFuIG1lbmRvemEgMDUtMTEtMjAyMCwgY29kZW1pcnJvciBubyB0YWIgaW4gZWRpdG9yXG4gICAgICAvLyBlZGl0b3Iub24oXCJyZW5kZXJMaW5lXCIsIGZ1bmN0aW9uKGNtLCBsaW5lLCBlbHQpIHtcbiAgICAgIC8vICAgdmFyIG9mZiA9IENvZGVNaXJyb3IuY291bnRDb2x1bW4obGluZS50ZXh0LCBudWxsLCBjbS5nZXRPcHRpb24oXCJ0YWJTaXplXCIpKSAqIGNoYXJXaWR0aDtcbiAgICAgIC8vICAgZWx0LnN0eWxlLnRleHRJbmRlbnQgPSBcIi1cIiArIG9mZiArIFwicHhcIjtcbiAgICAgIC8vICAgZWx0LnN0eWxlLnBhZGRpbmdMZWZ0ID0gKGJhc2VQYWRkaW5nICsgb2ZmKSArIFwicHhcIjtcbiAgICAgIC8vIH0pO1xuICAgICAgXG4gICAgICBlZGl0b3IucmVmcmVzaCgpO1xuICAgICAgXG4gICAgICBlZGl0b3Iub24oJ2NoYW5nZScsZnVuY3Rpb24oY29kZW1pcnJvciwgeWpzX2V2ZW50KXtcbiAgICAgICAgdmFyIHZhbHVlID0gY29kZW1pcnJvci5nZXRWYWx1ZSgpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGNvZGVtaXJyb3IuZ2V0T3B0aW9uKCdlbGVtZW50Jyk7XG4gICAgICAgIHZhciBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpIHx8ICcnO1xuXG4gICAgICAgIF90aGlzLnJlcXVlc3REb2N1bWVudElEKGVsZW1lbnQpXG4gICAgICAgIFxuICAgICAgICBpZiAoIWlkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICB2YXIgdGFyZ2V0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWdldF92YWx1ZT1cIicgKyBpZCArICdcIl0nKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBpc19mb2xkID0gZWxlbWVudC5kYXRhc2V0Wydpc19mb2xkJ10gfHwgZmFsc2U7XG4gICAgICAgIGlmKCFpc19mb2xkKXtcbiAgICAgICAgICB2YXIgZm9sZF9saW5lcyA9IGVsZW1lbnQuZGF0YXNldFsnZm9sZCddIHx8ICcnO1xuICAgICAgICAgIGZvbGRfbGluZXMgPSBmb2xkX2xpbmVzLnNwbGl0KCcsJykuZmlsdGVyKHZhbHVlPT5wYXJzZUludCh2YWx1ZSkgLTEgPj0gMCkubWFwKHZhbHVlID0+IHZhbHVlIC0gMSk7XG4gICAgICAgICAgZm9sZF9saW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICAgIGVkaXRvci5mb2xkQ29kZShDb2RlTWlycm9yLlBvcyhsaW5lLCAwKSk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuZGF0YXNldFsnaXNfZm9sZCddPXRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgICAgIGlmKHRhcmdldC5ub2RlTmFtZSA9PSAnSUZSQU1FJyl7XG4gICAgICAgICAgICAvL3RtcF90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgIGxldCBkb2N1bWVudF9pZnJhbWUgPSB0YXJnZXQuY29udGVudERvY3VtZW50O1xuICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICBkb2N1bWVudF9pZnJhbWUub3BlbigpO1xuICAgICAgICAgICAgICBkb2N1bWVudF9pZnJhbWUud3JpdGUodmFsdWUpO1xuICAgICAgICAgICAgXHRkb2N1bWVudF9pZnJhbWUuY2xvc2UoKTtcbiAgICAgICAgICAgIFx0Ki9cbiAgICAgICAgICAgIFx0dGFyZ2V0LnNyY2RvYyA9IHZhbHVlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YodGFyZ2V0LmlubmVySFRNTCkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgXHR0YXJnZXQuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgICAgICAgICB9ZWxzZSBpZiAodHlwZW9mKHRhcmdldC52YWx1ZSkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgXHR0YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHRhcmdldC50ZXh0Q29udGVudCkgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgXHR0YXJnZXQudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIFxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZXQtZG9jdW1lbnRfaWQnLCBmdW5jdGlvbihldmVudCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjcmVhdGVkIGRvY3VtZW50X2lkJyk7XG4gICAgICAgIF90aGlzLl9pbml0WVNvY2tldChlbGVtZW50LCBlZGl0b3IpO1xuICAgICAgICBfdGhpcy5zYXZlRGF0YUludG9EQihlbGVtZW50LCBlZGl0b3IuZ2V0VmFsdWUoKSk7XG4gICAgICB9KVxuICAgICAgXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrZWQtc3VibWl0QnRuJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdjbGlja2VkIHNhdmUgYnV0dG9uJylcblx0XHQgICAgX3RoaXMuc2F2ZURhdGFJbnRvREIoZWxlbWVudCwgZWRpdG9yLmdldFZhbHVlKCkpO1xuICAgICAgfSlcbiAgICB9XG4gICAgXG4gICAgcmVxdWVzdERvY3VtZW50SUQoZWxlbWVudCkge1xuICAgICAgY29uc3QgZG9jdW1lbnRfaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kb2N1bWVudF9pZCcpO1xuICAgICAgY29uc3QgcmVhbHRpbWUgPSBjcnVkLmlzUmVhbHRpbWVBdHRyKGVsZW1lbnQpO1xuICAgICAgaWYgKCFkb2N1bWVudF9pZCAmJiByZWFsdGltZSkge1xuICAgICAgICBDb0NyZWF0ZUZvcm0ucmVxdWVzdCh7ZWxlbWVudH0pXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWRvY3VtZW50X2lkJywgJ3BlbmRpbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2F2ZURhdGFJbnRvREIoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHsgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIG5hbWUgfSA9IGNydWQuZ2V0QXR0cihlbGVtZW50KVxuXG4gICAgICBjcnVkLnVwZGF0ZURvY3VtZW50KHtcbiAgICAgICAgY29sbGVjdGlvbiwgZG9jdW1lbnRfaWQsIFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgW25hbWVdOiB2YWx1ZVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBwYXJzZVR5cGVOYW1lKG5hbWUpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGF0b2IobmFtZSkpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIFxuICB9Ly9lbmQgQ2xhc3MgQ29DcmVhdGVZanNDb2RlbWlycm9yXG4gIFxuICBjb25zdCBvYmpfY29jcmVhdGVjb2RlbWlycm9yID0gbmV3IENvQ3JlYXRlWWpzQ29kZW1pcnJvcigpO1xuICAvKipcbiAgKiBJbml0aWFsaXphdGlvbiBhbGwgT0JKUyB3aXRoIGNsYXNzIC5jb2RlbWlycm9yXG4gICovXG5cbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuQ29DcmVhdGVDb2RlbWlycm9yID0gb2JqX2NvY3JlYXRlY29kZW1pcnJvclxuICBcbiAgLy8uIHJlZ2lzdGVyIGluaXQgZnVuY3Rpb25cbiAgQ29DcmVhdGVDb2RlbWlycm9yLmluaXQoKTtcblxuICBpZiAoQ29DcmVhdGVPYnNlcnZlcikge1xuICAgIENvQ3JlYXRlT2JzZXJ2ZXIuaW5pdCh7IFxuICAgIFx0bmFtZTogJ0NvQ3JlYXRlQ29kZW1pcnJvcicsIFxuICAgIFx0b2JzZXJ2ZTogWydzdWJ0cmVlJywgJ2NoaWxkTGlzdCddLFxuICAgIFx0aW5jbHVkZTogJy5jb2RlbWlycm9yJywgXG4gICAgXHRjYWxsYmFjazogZnVuY3Rpb24obXV0YXRpb24pIHtcbiAgICBcdFx0Q29DcmVhdGVDb2RlbWlycm9yLmluaXRFbGVtZW50KG11dGF0aW9uLnRhcmdldClcbiAgICBcdH1cbiAgICB9KVxuICB9XG4gIFxuICBpZiAoQ29DcmVhdGVGb3JtKSB7XG4gICAgQ29DcmVhdGVGb3JtLmluaXQoe1xuICAgICAgbmFtZTogJ0NvZGVtaXJyb3InLFxuICAgICAgc2VsZWN0b3I6ICcuY29kZW1pcnJvcicsXG4gICAgICBjYWxsYmFjazogZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG59KTsvL2VuZCB3aW5kb3cgTE9BRFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.js\n")},"./src/js/y-codemirror.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CodeMirrorBinding = exports.CodemirrorBinding = exports.cmOrigin = void 0;\n\nvar _mutex = __webpack_require__(/*! lib0/mutex.js */ \"./node_modules/lib0/mutex.js\");\n\nvar math = _interopRequireWildcard(__webpack_require__(/*! lib0/math.js */ \"./node_modules/lib0/math.js\"));\n\nvar Y = _interopRequireWildcard(__webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.cjs\"));\n\nvar func = _interopRequireWildcard(__webpack_require__(/*! lib0/function.js */ \"./node_modules/lib0/function.js\"));\n\nvar eventloop = _interopRequireWildcard(__webpack_require__(/*! lib0/eventloop.js */ \"./node_modules/lib0/eventloop.js\"));\n\nvar diff = _interopRequireWildcard(__webpack_require__(/*! lib0/diff.js */ \"./node_modules/lib0/diff.js\"));\n\nvar _codemirror = _interopRequireDefault(__webpack_require__(/*! codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n * @module bindings/textarea\n */\n//import * as Ys from './RelativePosition.js'\n// import {getState, followRedone, Item} from 'yjs/src/internals.js'\nconst debug = false;\nconst cmOrigin = 'prosemirror-binding';\n/**\n * @param {CodemirrorBinding} binding\n * @param {any} event\n */\n\nexports.cmOrigin = cmOrigin;\n\nconst typeObserver = (binding, event) => {\n  binding._mux(() => {\n    const cmDoc = binding.cmDoc;\n    const cm = cmDoc.getEditor(); // Normally the position is right-associated\n    // But when remote changes happen, it looks like the remote user is hijacking your position.\n    // Just for remote insertions, we make the collapsed cursor left-associated.\n    // If selection is not collapsed, we only make \"to\" left associated\n\n    let anchor = cm.indexFromPos(cm.getCursor('anchor'));\n    let head = cm.indexFromPos(cm.getCursor('head'));\n    const switchSel = head < anchor; // normalize selection so that anchor < head, switch back later\n\n    if (switchSel) {\n      const tmp = head;\n      head = anchor;\n      anchor = tmp;\n    }\n\n    const performChange = () => {\n      const delta = event.delta;\n      let index = 0;\n\n      for (let i = 0; i < event.delta.length; i++) {\n        const d = delta[i];\n\n        if (d.retain) {\n          index += d.retain;\n        } else if (d.insert) {\n          if (index < anchor || anchor < head && index === anchor) {\n            anchor += d.insert.length;\n          }\n\n          if (index < head) {\n            head += d.insert.length;\n          }\n\n          const pos = cmDoc.posFromIndex(index);\n          cmDoc.replaceRange(d.insert, pos, pos, cmOrigin);\n          index += d.insert.length;\n        } else if (d.delete) {\n          if (index < anchor) {\n            anchor = math.max(anchor - d.delete, index);\n          }\n\n          if (index < head) {\n            head = math.max(head - d.delete, index);\n          }\n\n          const start = cmDoc.posFromIndex(index);\n          const end = cmDoc.posFromIndex(index + d.delete);\n          cmDoc.replaceRange('', start, end, cmOrigin);\n        }\n      }\n    }; // if possible, bundle the changes using cm.operation\n\n\n    if (cm) {\n      cm.operation(performChange);\n    } else {\n      performChange();\n    }\n\n    if (switchSel) {\n      const tmp = head;\n      head = anchor;\n      anchor = tmp;\n    }\n\n    cm.setSelection(cm.posFromIndex(anchor), cm.posFromIndex(head));\n  });\n};\n\nconst targetObserver = (binding, changes) => {\n  binding._mux(() => {\n    binding.doc.transact(() => {\n      if (changes.length > 1) {\n        // If there are several consecutive changes, we can't reliably compute the positions anymore. See y-codemirror#11\n        // Instead, we will compute the diff and apply the changes\n        const d = diff.simpleDiffString(binding.type.toString(), binding.cmDoc.getValue());\n        binding.type.delete(d.index, d.remove);\n        binding.type.insert(d.index, d.insert);\n      } else {\n        const change = changes[0];\n        const start = binding.cmDoc.indexFromPos(change.from);\n        const delLen = change.removed.map(s => s.length).reduce(math.add) + change.removed.length - 1;\n\n        if (delLen > 0) {\n          binding.type.delete(start, delLen);\n        }\n\n        if (change.text.length > 0) {\n          binding.type.insert(start, change.text.join('\\n'));\n        }\n      }\n    }, binding);\n  });\n};\n\nconst createRemoteCaret = (username, color) => {\n  const caret = document.createElement('span');\n  caret.classList.add('remote-caret');\n  caret.setAttribute('style', `border-color: ${color}`);\n  const userDiv = document.createElement('div');\n  userDiv.setAttribute('style', `background-color: ${color}`);\n  userDiv.insertBefore(document.createTextNode(username), null);\n  caret.insertBefore(userDiv, null);\n  setTimeout(() => {\n    caret.classList.add('hide-name');\n  }, 2000);\n  return caret;\n};\n\nconst createEmptyLinePlaceholder = color => {\n  const el = document.createElement('span');\n  el.setAttribute('class', 'y-line-selection');\n  el.setAttribute('style', `display: inline-block; position: absolute; left: 4px; right: 4px; top: 0; bottom: 0; background-color: ${color}70`);\n  return el;\n}; // const testingFunc = (rpos, doc) => {\n//   const store = doc.store\n//   const rightID = rpos.item\n//   const typeID = rpos.type\n//   const tname = rpos.tname\n//   let type = null\n//   let index = 0\n//   if (rightID != null) {\n//     if (getState(store, rightID.client) <= rightID.clock) {\n//       return null\n//     }\n//     const res = followRedone(store, rightID)\n//     const right = res.item\n//     // if (!(right instanceof Item)) {\n//     //   return null\n//     // }\n//     type = /** @type {AbstractType<any>} */ (right.parent)\n//     if (type._item === null || !type._item.deleted) {\n//       index = right.deleted || !right.countable ? 0 : res.diff\n//       let n = right.left\n//       while (n !== null) {\n//         if (!n.deleted && n.countable) {\n//           index += n.length\n//         }\n//         n = n.left\n//       }\n//     }\n//   }\n//   console.log('00000000000000000000000000000000000000000000000000000000000')\n//   console.log(type, index);\n// }\n//comment by jeanMendoza 17/10/2020\n// const updateRemoteSelection = (y, cm, type, cursors, clientId, awareness) => {\n//   // redraw caret and selection for clientId\n//   const aw = awareness.getStates().get(clientId)\n//   // destroy current text mark\n//   const m = cursors.get(clientId)\n//   if (m !== undefined) {\n//     if (m.caret) {\n//       m.caret.clear()\n//     }\n//     m.sel.forEach(sel => sel.clear())\n//     cursors.delete(clientId)\n//   }\n//   if (aw === undefined) {\n//     return\n//   }\n//   const user = aw.user || {}\n//   if (user.color == null) {\n//     user.color = '#ffa500'\n//   }\n//   if (user.name == null) {\n//     user.name = `User: ${clientId}`\n//   }\n//   const cursor = aw.cursor\n//   if (cursor == null || cursor.anchor == null || cursor.head == null) {\n//     return\n//   }\n//   // testingFunc(JSON.parse(cursor.anchor), y);  \n//   // Ys\n//   const anchor = Ys.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.anchor), y)\n//   const head = Ys.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.head), y)\n//   // const anchor = Y.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.anchor), y)\n//   // const head = Y.createAbsolutePositionFromRelativePosition(JSON.parse(cursor.head), y)\n//   if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n//     const headpos = cm.posFromIndex(head.index)\n//     const anchorpos = cm.posFromIndex(anchor.index)\n//     let from, to\n//     if (head.index < anchor.index) {\n//       from = headpos\n//       to = anchorpos\n//     } else {\n//       from = anchorpos\n//       to = headpos\n//     }\n//     const caretEl = createRemoteCaret(user.name, user.color)\n//     // if position was \"relatively\" the same, do not show name again and hide instead\n//     if (m && func.equalityFlat(aw.cursor.anchor, m.awCursor.anchor) && func.equalityFlat(aw.cursor.head, m.awCursor.head)) {\n//       caretEl.classList.add('hide-name')\n//     }\n//     const sel = []\n//     if (head.index !== anchor.index) {\n//       if (from.line !== to.line && from.ch !== 0) {\n//         // start of selection will only be a simple text-selection\n//         sel.push(cm.markText(from, new CodeMirror.Pos(from.line + 1, 0), { css: `background-color: ${user.color}70;`, inclusiveRight: false, inclusiveLeft: false }))\n//         from = new CodeMirror.Pos(from.line + 1, 0)\n//       }\n//       while (from.line !== to.line) {\n//         // middle of selection is always a whole-line selection. We add a widget at the first position which will fill the background.\n//         sel.push(cm.setBookmark(new CodeMirror.Pos(from.line, 0), { widget: createEmptyLinePlaceholder(user.color) }))\n//         from = new CodeMirror.Pos(from.line + 1, 0)\n//       }\n//       sel.push(cm.markText(from, to, { css: `background-color: ${user.color}70;`, inclusiveRight: false, inclusiveLeft: false }))\n//     }\n//     // only render caret if not the complete last line was selected (in this case headpos.ch === 0)\n//     const caret = sel.length > 0 && to === headpos && headpos.ch === 0 ? null : cm.setBookmark(headpos, { widget: caretEl, insertLeft: true })\n//     cursors.set(clientId, { caret, sel, awCursor: cursor })\n//   }\n// }\n\n\nconst updateRemoteSelection = (y, cm, type, cursors, clientId, awareness) => {\n  // destroy current text mark\n  const m = cursors.get(clientId);\n\n  if (m !== undefined) {\n    m.caret.clear();\n\n    if (m.sel !== null) {\n      m.sel.clear();\n    }\n\n    cursors.delete(clientId);\n  } // redraw caret and selection for clientId\n\n\n  const aw = awareness.getStates().get(clientId);\n\n  if (aw === undefined) {\n    return;\n  }\n\n  const user = aw.user || {};\n\n  if (user.color == null) {\n    user.color = '#ffa500';\n  }\n\n  if (user.name == null) {\n    user.name = `User: ${clientId}`;\n  }\n\n  const cursor = aw.cursor;\n\n  if (cursor == null || cursor.anchor == null || cursor.head == null) {\n    return;\n  }\n\n  console.log(cursor.anchor);\n  let cursor_anchor = typeof cursor.anchor == 'object' ? cursor.anchor : JSON.parse(cursor.anchor);\n  const anchor = Y.createAbsolutePositionFromRelativePosition(cursor_anchor, y); // const anchor = Ys.createAbsolutePositionFromRelativePosition(Y.createRelativePositionFromJSON(cursor.anchor), y)\n\n  let cursor_head = typeof cursor.head == 'object' ? cursor.head : JSON.parse(cursor.head);\n  const head = Y.createAbsolutePositionFromRelativePosition(cursor_head, y); // const head = Ys.createAbsolutePositionFromRelativePosition(Y.createRelativePositionFromJSON(cursor.head), y)\n\n  /*console.log(\"TYPE comparation \",anchor.type == type)\n  console.log(\"TYPE  \",type)\n  console.log(\"TYPE  anchor \",anchor.type)*/\n\n  if (anchor !== null && head !== null && anchor.type === type && head.type === type) {\n    const headpos = cm.posFromIndex(head.index);\n    const anchorpos = cm.posFromIndex(anchor.index);\n    let from, to;\n\n    if (head.index < anchor.index) {\n      from = headpos;\n      to = anchorpos;\n    } else {\n      from = anchorpos;\n      to = headpos;\n    }\n\n    if (debug) console.log(\" From \", from, \" to \", to); //console.log(\"awareness \",awareness)\n\n    const caretEl = createRemoteCaret(user.name, user.color);\n    const caret = cm.setBookmark(headpos, {\n      widget: caretEl,\n      insertLeft: true\n    });\n    let sel = null;\n\n    if (head.index !== anchor.index) {\n      sel = cm.markText(from, to, {\n        css: `background-color: ${user.color}70`,\n        inclusiveRight: true,\n        inclusiveLeft: false\n      });\n    }\n\n    cursors.set(clientId, {\n      caret,\n      sel\n    });\n    if (debug) console.log(\"updateRemoteSelection from codemirror \");\n  }\n}; /// comment by jean mendoza 17/10/2020\n// const codemirrorCursorActivity = (y, cm, type, awareness) => {\n//   const aw = awareness.getLocalState()\n//   if (!cm.hasFocus() || aw == null || !cm.display.wrapper.ownerDocument.hasFocus()) {\n//     return\n//   }\n//   const newAnchor = Y.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('anchor')))\n//   const newHead = Y.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('head')))\n//   let currentAnchor = null\n//   let currentHead = null\n//   if (aw.cursor != null) {\n//     currentAnchor = Y.createRelativePositionFromJSON(JSON.parse(aw.cursor.anchor))\n//     currentHead = Y.createRelativePositionFromJSON(JSON.parse(aw.cursor.head))\n//   }\n//   if (aw.cursor == null || !Y.compareRelativePositions(currentAnchor, newAnchor) || !Y.compareRelativePositions(currentHead, newHead)) {\n//     awareness.setLocalStateField('cursor', {\n//       anchor: JSON.stringify(newAnchor),\n//       head: JSON.stringify(newHead)\n//     })\n//   }\n// }\n\n\nconst codemirrorCursorActivity = (y, cm, type, awareness) => {\n  if (!cm.hasFocus()) {\n    return;\n  }\n\n  if (debug) {\n    console.log(\"codemirrorCursorActivity start \", cm.indexFromPos(cm.getCursor('anchor')), \" end \", cm.indexFromPos(cm.getCursor('head')));\n    console.log(\" Type codemirror \", type);\n  }\n\n  const newAnchor = Y.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('anchor')));\n  const newHead = Y.createRelativePositionFromTypeIndex(type, cm.indexFromPos(cm.getCursor('head')));\n  const aw = awareness.getLocalState();\n  let currentAnchor = null;\n  let currentHead = null;\n\n  if (aw.cursor != null) {\n    currentAnchor = aw.cursor.anchor; // Y.createAbsolutePositionFromRelativePosition(JSON.parse(aw.cursor.anchor), y)\n\n    currentHead = aw.cursor.head; // Y.createAbsolutePositionFromRelativePosition(JSON.parse(aw.cursor.head), y)\n  }\n\n  if (aw.cursor == null || !Y.compareRelativePositions(currentAnchor, newAnchor) || !Y.compareRelativePositions(currentHead, newHead)) {\n    awareness.setLocalStateField('cursor', {\n      anchor: newAnchor,\n      head: newHead\n    });\n    if (debug) console.log(\"Send cursor  from codemirrorCursorActivity  \", {\n      anchor: newAnchor,\n      head: newHead\n    });\n  } else {\n    let start = cm.indexFromPos(cm.getCursor('anchor'));\n    let end = cm.indexFromPos(cm.getCursor('head'));\n    if (debug) console.log(\"Else codemirrorCursorActivity\", start, end);\n\n    if (start == end) {\n      const newAnchor = Y.createRelativePositionFromTypeIndex(type, start);\n      const newHead = Y.createRelativePositionFromTypeIndex(type, end);\n      awareness.setLocalStateField('cursor', {\n        anchor: newAnchor,\n        head: newHead\n      });\n      if (debug) console.log(\"SEND Postion targetObserver  \", start + end);\n    }\n  } //console.log('---------------------cm----------------------')\n  //console.log(currentAnchor, currentHead, newAnchor, newHead);\n\n};\n/**\n * A binding that binds a YText to a CodeMirror editor.\n *\n * @example\n *   const ytext = ydocument.define('codemirror', Y.Text)\n *   const editor = new CodeMirror(document.querySelector('#container'), {\n *     mode: 'javascript',\n *     lineNumbers: true\n *   })\n *   const binding = new CodemirrorBinding(ytext, editor)\n *\n */\n\n\nclass CodemirrorBinding {\n  /**\n   * @param {Y.Text} textType\n   * @param {import('codemirror').Editor} codeMirror\n   * @param {any} [awareness]\n   */\n  constructor(textType, codeMirror, awareness, realtime = true) {\n    const doc = textType.doc;\n    const cmDoc = codeMirror.getDoc();\n    this.doc = doc;\n    this.type = textType;\n    this.cm = codeMirror;\n    this.cmDoc = cmDoc;\n    this.awareness = awareness; // this.undoManager = new Y.UndoManager(textType, { trackedOrigins: new Set([this]) })\n\n    this._mux = (0, _mutex.createMutex)(); // set initial value\n\n    console.log(\"---------------------\", textType.toString()); //cmDoc.setValue(textType.toString())\n    // observe type and target\n\n    this._typeObserver = event => typeObserver(this, event);\n\n    this._targetObserver = (instance, changes) => {\n      if (instance.getDoc() === cmDoc) {\n        targetObserver(this, changes);\n      }\n    };\n\n    this._cursors = new Map();\n    this._changedCursors = new Set();\n    this._debounceCursorEvent = eventloop.createDebouncer(10);\n\n    this._awarenessListener = event => {\n      if (codeMirror.getDoc() !== cmDoc) {\n        return;\n      }\n\n      const f = clientId => {\n        if (clientId !== doc.clientID) {\n          this._changedCursors.add(clientId);\n        }\n      };\n\n      event.added.forEach(f);\n      event.removed.forEach(f);\n      event.updated.forEach(f);\n\n      if (this._changedCursors.size > 0) {\n        this._debounceCursorEvent(() => {\n          this._changedCursors.forEach(clientId => {\n            updateRemoteSelection(doc, codeMirror, textType, this._cursors, clientId, awareness);\n          });\n\n          this._changedCursors.clear();\n        });\n      }\n    };\n\n    this._cursorListener = () => {\n      if (codeMirror.getDoc() === cmDoc) {\n        setTimeout(() => {\n          codemirrorCursorActivity(doc, codeMirror, textType, awareness);\n        }, 0);\n      }\n    };\n\n    this._blurListeer = () => awareness.setLocalStateField('cursor', null);\n\n    textType.observe(this._typeObserver); // @ts-ignore\n\n    if (realtime) codeMirror.on('changes', this._targetObserver);\n\n    if (awareness) {\n      codeMirror.on('swapDoc', this._blurListeer);\n      awareness.on('change', this._awarenessListener); // @ts-ignore\n\n      codeMirror.on('cursorActivity', this._cursorListener);\n      codeMirror.on('blur', this._blurListeer);\n      codeMirror.on('focus', this._cursorListener);\n    }\n  }\n\n  destroy() {\n    this.type.unobserve(this._typeObserver);\n    this.cm.off('swapDoc', this._blurListeer); // @ts-ignore\n\n    this.cm.off('changes', this._targetObserver); // @ts-ignore\n\n    this.cm.off('cursorActivity', this._cursorListener);\n    this.cm.off('focus', this._cursorListener);\n    this.cm.off('blur', this._blurListeer);\n\n    if (this.awareness) {\n      this.awareness.off('change', this._awarenessListener);\n    }\n\n    this.type = null;\n    this.cm = null;\n    this.cmDoc = null; // this.undoManager.destroy()\n  }\n\n}\n\nexports.CodemirrorBinding = CodemirrorBinding;\nconst CodeMirrorBinding = CodemirrorBinding;\nexports.CodeMirrorBinding = CodeMirrorBinding;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vc3JjL2pzL3ktY29kZW1pcnJvci5qcz8xYWQ5Il0sIm5hbWVzIjpbImRlYnVnIiwiY21PcmlnaW4iLCJ0eXBlT2JzZXJ2ZXIiLCJiaW5kaW5nIiwiZXZlbnQiLCJfbXV4IiwiY21Eb2MiLCJjbSIsImdldEVkaXRvciIsImFuY2hvciIsImluZGV4RnJvbVBvcyIsImdldEN1cnNvciIsImhlYWQiLCJzd2l0Y2hTZWwiLCJ0bXAiLCJwZXJmb3JtQ2hhbmdlIiwiZGVsdGEiLCJpbmRleCIsImkiLCJsZW5ndGgiLCJkIiwicmV0YWluIiwiaW5zZXJ0IiwicG9zIiwicG9zRnJvbUluZGV4IiwicmVwbGFjZVJhbmdlIiwiZGVsZXRlIiwibWF0aCIsIm1heCIsInN0YXJ0IiwiZW5kIiwib3BlcmF0aW9uIiwic2V0U2VsZWN0aW9uIiwidGFyZ2V0T2JzZXJ2ZXIiLCJjaGFuZ2VzIiwiZG9jIiwidHJhbnNhY3QiLCJkaWZmIiwic2ltcGxlRGlmZlN0cmluZyIsInR5cGUiLCJ0b1N0cmluZyIsImdldFZhbHVlIiwicmVtb3ZlIiwiY2hhbmdlIiwiZnJvbSIsImRlbExlbiIsInJlbW92ZWQiLCJtYXAiLCJzIiwicmVkdWNlIiwiYWRkIiwidGV4dCIsImpvaW4iLCJjcmVhdGVSZW1vdGVDYXJldCIsInVzZXJuYW1lIiwiY29sb3IiLCJjYXJldCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsInNldEF0dHJpYnV0ZSIsInVzZXJEaXYiLCJpbnNlcnRCZWZvcmUiLCJjcmVhdGVUZXh0Tm9kZSIsInNldFRpbWVvdXQiLCJjcmVhdGVFbXB0eUxpbmVQbGFjZWhvbGRlciIsImVsIiwidXBkYXRlUmVtb3RlU2VsZWN0aW9uIiwieSIsImN1cnNvcnMiLCJjbGllbnRJZCIsImF3YXJlbmVzcyIsIm0iLCJnZXQiLCJ1bmRlZmluZWQiLCJjbGVhciIsInNlbCIsImF3IiwiZ2V0U3RhdGVzIiwidXNlciIsIm5hbWUiLCJjdXJzb3IiLCJjb25zb2xlIiwibG9nIiwiY3Vyc29yX2FuY2hvciIsIkpTT04iLCJwYXJzZSIsIlkiLCJjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24iLCJjdXJzb3JfaGVhZCIsImhlYWRwb3MiLCJhbmNob3Jwb3MiLCJ0byIsImNhcmV0RWwiLCJzZXRCb29rbWFyayIsIndpZGdldCIsImluc2VydExlZnQiLCJtYXJrVGV4dCIsImNzcyIsImluY2x1c2l2ZVJpZ2h0IiwiaW5jbHVzaXZlTGVmdCIsInNldCIsImNvZGVtaXJyb3JDdXJzb3JBY3Rpdml0eSIsImhhc0ZvY3VzIiwibmV3QW5jaG9yIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgiLCJuZXdIZWFkIiwiZ2V0TG9jYWxTdGF0ZSIsImN1cnJlbnRBbmNob3IiLCJjdXJyZW50SGVhZCIsImNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyIsInNldExvY2FsU3RhdGVGaWVsZCIsIkNvZGVtaXJyb3JCaW5kaW5nIiwiY29uc3RydWN0b3IiLCJ0ZXh0VHlwZSIsImNvZGVNaXJyb3IiLCJyZWFsdGltZSIsImdldERvYyIsIl90eXBlT2JzZXJ2ZXIiLCJfdGFyZ2V0T2JzZXJ2ZXIiLCJpbnN0YW5jZSIsIl9jdXJzb3JzIiwiTWFwIiwiX2NoYW5nZWRDdXJzb3JzIiwiU2V0IiwiX2RlYm91bmNlQ3Vyc29yRXZlbnQiLCJldmVudGxvb3AiLCJjcmVhdGVEZWJvdW5jZXIiLCJfYXdhcmVuZXNzTGlzdGVuZXIiLCJmIiwiY2xpZW50SUQiLCJhZGRlZCIsImZvckVhY2giLCJ1cGRhdGVkIiwic2l6ZSIsIl9jdXJzb3JMaXN0ZW5lciIsIl9ibHVyTGlzdGVlciIsIm9ic2VydmUiLCJvbiIsImRlc3Ryb3kiLCJ1bm9ic2VydmUiLCJvZmYiLCJDb2RlTWlycm9yQmluZGluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUlBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztB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YUFBekI7QUFDQSxTQUFLL0csRUFBTCxDQUFRc0ksR0FBUixDQUFZLFNBQVosRUFBdUIsS0FBS0wsWUFBNUIsRUFGUyxDQUdUOztBQUNBLFNBQUtqSSxFQUFMLENBQVFzSSxHQUFSLENBQVksU0FBWixFQUF1QixLQUFLdEIsZUFBNUIsRUFKUyxDQUtUOztBQUNBLFNBQUtoSCxFQUFMLENBQVFzSSxHQUFSLENBQVksZ0JBQVosRUFBOEIsS0FBS04sZUFBbkM7QUFDQSxTQUFLaEksRUFBTCxDQUFRc0ksR0FBUixDQUFZLE9BQVosRUFBcUIsS0FBS04sZUFBMUI7QUFDQSxTQUFLaEksRUFBTCxDQUFRc0ksR0FBUixDQUFZLE1BQVosRUFBb0IsS0FBS0wsWUFBekI7O0FBQ0EsUUFBSSxLQUFLakUsU0FBVCxFQUFvQjtBQUNsQixXQUFLQSxTQUFMLENBQWVzRSxHQUFmLENBQW1CLFFBQW5CLEVBQTZCLEtBQUtiLGtCQUFsQztBQUNEOztBQUNELFNBQUt6RixJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUtoQyxFQUFMLEdBQVUsSUFBVjtBQUNBLFNBQUtELEtBQUwsR0FBYSxJQUFiLENBZFMsQ0FlVDtBQUNEOztBQXpGNEI7OztBQThGeEIsTUFBTXdJLGlCQUFpQixHQUFHOUIsaUJBQTFCIiwiZmlsZSI6Ii4vc3JjL2pzL3ktY29kZW1pcnJvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBiaW5kaW5ncy90ZXh0YXJlYVxuICovXG5cbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleC5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgKiBhcyBmdW5jIGZyb20gJ2xpYjAvZnVuY3Rpb24uanMnXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnbGliMC9ldmVudGxvb3AuanMnXG5pbXBvcnQgKiBhcyBkaWZmIGZyb20gJ2xpYjAvZGlmZi5qcydcbmltcG9ydCBDb2RlTWlycm9yIGZyb20gJ2NvZGVtaXJyb3InXG4vL2ltcG9ydCAqIGFzIFlzIGZyb20gJy4vUmVsYXRpdmVQb3NpdGlvbi5qcydcblxuLy8gaW1wb3J0IHtnZXRTdGF0ZSwgZm9sbG93UmVkb25lLCBJdGVtfSBmcm9tICd5anMvc3JjL2ludGVybmFscy5qcydcblxuY29uc3QgZGVidWcgPSBmYWxzZTtcblxuZXhwb3J0IGNvbnN0IGNtT3JpZ2luID0gJ3Byb3NlbWlycm9yLWJpbmRpbmcnXG5cbi8qKlxuICogQHBhcmFtIHtDb2RlbWlycm9yQmluZGluZ30gYmluZGluZ1xuICogQHBhcmFtIHthbnl9IGV2ZW50XG4gKi9cbmNvbnN0IHR5cGVPYnNlcnZlciA9IChiaW5kaW5nLCBldmVudCkgPT4ge1xuICBiaW5kaW5nLl9tdXgoKCkgPT4ge1xuICAgIGNvbnN0IGNtRG9jID0gYmluZGluZy5jbURvY1xuICAgIGNvbnN0IGNtID0gY21Eb2MuZ2V0RWRpdG9yKClcbiAgICAvLyBOb3JtYWxseSB0aGUgcG9zaXRpb24gaXMgcmlnaHQtYXNzb2NpYXRlZFxuICAgIC8vIEJ1dCB3aGVuIHJlbW90ZSBjaGFuZ2VzIGhhcHBlbiwgaXQgbG9va3MgbGlrZSB0aGUgcmVtb3RlIHVzZXIgaXMgaGlqYWNraW5nIHlvdXIgcG9zaXRpb24uXG4gICAgLy8gSnVzdCBmb3IgcmVtb3RlIGluc2VydGlvbnMsIHdlIG1ha2UgdGhlIGNvbGxhcHNlZCBjdXJzb3IgbGVmdC1hc3NvY2lhdGVkLlxuICAgIC8vIElmIHNlbGVjdGlvbiBpcyBub3QgY29sbGFwc2VkLCB3ZSBvbmx5IG1ha2UgXCJ0b1wiIGxlZnQgYXNzb2NpYXRlZFxuICAgIGxldCBhbmNob3IgPSBjbS5pbmRleEZyb21Qb3MoY20uZ2V0Q3Vyc29yKCdhbmNob3InKSlcbiAgICBsZXQgaGVhZCA9IGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2hlYWQnKSlcbiAgICBjb25zdCBzd2l0Y2hTZWwgPSBoZWFkIDwgYW5jaG9yXG4gICAgLy8gbm9ybWFsaXplIHNlbGVjdGlvbiBzbyB0aGF0IGFuY2hvciA8IGhlYWQsIHN3aXRjaCBiYWNrIGxhdGVyXG4gICAgaWYgKHN3aXRjaFNlbCkge1xuICAgICAgY29uc3QgdG1wID0gaGVhZFxuICAgICAgaGVhZCA9IGFuY2hvclxuICAgICAgYW5jaG9yID0gdG1wXG4gICAgfVxuICAgIGNvbnN0IHBlcmZvcm1DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhXG4gICAgICBsZXQgaW5kZXggPSAwXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGQgPSBkZWx0YVtpXVxuICAgICAgICBpZiAoZC5yZXRhaW4pIHtcbiAgICAgICAgICBpbmRleCArPSBkLnJldGFpblxuICAgICAgICB9IGVsc2UgaWYgKGQuaW5zZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgYW5jaG9yIHx8IChhbmNob3IgPCBoZWFkICYmIGluZGV4ID09PSBhbmNob3IpKSB7XG4gICAgICAgICAgICBhbmNob3IgKz0gZC5pbnNlcnQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmRleCA8IGhlYWQpIHtcbiAgICAgICAgICAgIGhlYWQgKz0gZC5pbnNlcnQubGVuZ3RoXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvcyA9IGNtRG9jLnBvc0Zyb21JbmRleChpbmRleClcbiAgICAgICAgICBjbURvYy5yZXBsYWNlUmFuZ2UoZC5pbnNlcnQsIHBvcywgcG9zLCBjbU9yaWdpbilcbiAgICAgICAgICBpbmRleCArPSBkLmluc2VydC5sZW5ndGhcbiAgICAgICAgfSBlbHNlIGlmIChkLmRlbGV0ZSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGFuY2hvcikge1xuICAgICAgICAgICAgYW5jaG9yID0gbWF0aC5tYXgoYW5jaG9yIC0gZC5kZWxldGUsIGluZGV4KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5kZXggPCBoZWFkKSB7XG4gICAgICAgICAgICBoZWFkID0gbWF0aC5tYXgoaGVhZCAtIGQuZGVsZXRlLCBpbmRleClcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBjbURvYy5wb3NGcm9tSW5kZXgoaW5kZXgpXG4gICAgICAgICAgY29uc3QgZW5kID0gY21Eb2MucG9zRnJvbUluZGV4KGluZGV4ICsgZC5kZWxldGUpXG4gICAgICAgICAgY21Eb2MucmVwbGFjZVJhbmdlKCcnLCBzdGFydCwgZW5kLCBjbU9yaWdpbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBwb3NzaWJsZSwgYnVuZGxlIHRoZSBjaGFuZ2VzIHVzaW5nIGNtLm9wZXJhdGlvblxuICAgIGlmIChjbSkge1xuICAgICAgY20ub3BlcmF0aW9uKHBlcmZvcm1DaGFuZ2UpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBlcmZvcm1DaGFuZ2UoKVxuICAgIH1cbiAgICBpZiAoc3dpdGNoU2VsKSB7XG4gICAgICBjb25zdCB0bXAgPSBoZWFkXG4gICAgICBoZWFkID0gYW5jaG9yXG4gICAgICBhbmNob3IgPSB0bXBcbiAgICB9XG4gICAgY20uc2V0U2VsZWN0aW9uKGNtLnBvc0Zyb21JbmRleChhbmNob3IpLCBjbS5wb3NGcm9tSW5kZXgoaGVhZCkpXG4gIH0pXG59XG5cbmNvbnN0IHRhcmdldE9ic2VydmVyID0gKGJpbmRpbmcsIGNoYW5nZXMpID0+IHtcbiAgYmluZGluZy5fbXV4KCgpID0+IHtcbiAgICBiaW5kaW5nLmRvYy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBzZXZlcmFsIGNvbnNlY3V0aXZlIGNoYW5nZXMsIHdlIGNhbid0IHJlbGlhYmx5IGNvbXB1dGUgdGhlIHBvc2l0aW9ucyBhbnltb3JlLiBTZWUgeS1jb2RlbWlycm9yIzExXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHdpbGwgY29tcHV0ZSB0aGUgZGlmZiBhbmQgYXBwbHkgdGhlIGNoYW5nZXNcbiAgICAgICAgY29uc3QgZCA9IGRpZmYuc2ltcGxlRGlmZlN0cmluZyhiaW5kaW5nLnR5cGUudG9TdHJpbmcoKSwgYmluZGluZy5jbURvYy5nZXRWYWx1ZSgpKVxuICAgICAgICBiaW5kaW5nLnR5cGUuZGVsZXRlKGQuaW5kZXgsIGQucmVtb3ZlKVxuICAgICAgICBiaW5kaW5nLnR5cGUuaW5zZXJ0KGQuaW5kZXgsIGQuaW5zZXJ0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gY2hhbmdlc1swXVxuICAgICAgICBjb25zdCBzdGFydCA9IGJpbmRpbmcuY21Eb2MuaW5kZXhGcm9tUG9zKGNoYW5nZS5mcm9tKVxuICAgICAgICBjb25zdCBkZWxMZW4gPSBjaGFuZ2UucmVtb3ZlZC5tYXAocyA9PiBzLmxlbmd0aCkucmVkdWNlKG1hdGguYWRkKSArIGNoYW5nZS5yZW1vdmVkLmxlbmd0aCAtIDFcbiAgICAgICAgaWYgKGRlbExlbiA+IDApIHtcbiAgICAgICAgICBiaW5kaW5nLnR5cGUuZGVsZXRlKHN0YXJ0LCBkZWxMZW4pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZS50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBiaW5kaW5nLnR5cGUuaW5zZXJ0KHN0YXJ0LCBjaGFuZ2UudGV4dC5qb2luKCdcXG4nKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGJpbmRpbmcpXG4gIH0pXG59XG5cbmNvbnN0IGNyZWF0ZVJlbW90ZUNhcmV0ID0gKHVzZXJuYW1lLCBjb2xvcikgPT4ge1xuICBjb25zdCBjYXJldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICBjYXJldC5jbGFzc0xpc3QuYWRkKCdyZW1vdGUtY2FyZXQnKVxuICBjYXJldC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJvcmRlci1jb2xvcjogJHtjb2xvcn1gKVxuICBjb25zdCB1c2VyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgdXNlckRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9YClcbiAgdXNlckRpdi5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodXNlcm5hbWUpLCBudWxsKVxuICBjYXJldC5pbnNlcnRCZWZvcmUodXNlckRpdiwgbnVsbClcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgY2FyZXQuY2xhc3NMaXN0LmFkZCgnaGlkZS1uYW1lJylcbiAgfSwgMjAwMClcbiAgcmV0dXJuIGNhcmV0XG59XG5cbmNvbnN0IGNyZWF0ZUVtcHR5TGluZVBsYWNlaG9sZGVyID0gKGNvbG9yKSA9PiB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpXG4gIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAneS1saW5lLXNlbGVjdGlvbicpXG4gIGVsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgZGlzcGxheTogaW5saW5lLWJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDRweDsgcmlnaHQ6IDRweDsgdG9wOiAwOyBib3R0b206IDA7IGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3J9NzBgKVxuICByZXR1cm4gZWxcbn1cblxuLy8gY29uc3QgdGVzdGluZ0Z1bmMgPSAocnBvcywgZG9jKSA9PiB7XG4vLyAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4vLyAgIGNvbnN0IHJpZ2h0SUQgPSBycG9zLml0ZW1cbi8vICAgY29uc3QgdHlwZUlEID0gcnBvcy50eXBlXG4vLyAgIGNvbnN0IHRuYW1lID0gcnBvcy50bmFtZVxuLy8gICBsZXQgdHlwZSA9IG51bGxcbi8vICAgbGV0IGluZGV4ID0gMFxuLy8gICBpZiAocmlnaHRJRCAhPSBudWxsKSB7XG4vLyAgICAgaWYgKGdldFN0YXRlKHN0b3JlLCByaWdodElELmNsaWVudCkgPD0gcmlnaHRJRC5jbG9jaykge1xuLy8gICAgICAgcmV0dXJuIG51bGxcbi8vICAgICB9XG4vLyAgICAgY29uc3QgcmVzID0gZm9sbG93UmVkb25lKHN0b3JlLCByaWdodElEKVxuLy8gICAgIGNvbnN0IHJpZ2h0ID0gcmVzLml0ZW1cbi8vICAgICAvLyBpZiAoIShyaWdodCBpbnN0YW5jZW9mIEl0ZW0pKSB7XG4vLyAgICAgLy8gICByZXR1cm4gbnVsbFxuLy8gICAgIC8vIH1cbi8vICAgICB0eXBlID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudClcbi8vICAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4vLyAgICAgICBpbmRleCA9IHJpZ2h0LmRlbGV0ZWQgfHwgIXJpZ2h0LmNvdW50YWJsZSA/IDAgOiByZXMuZGlmZlxuLy8gICAgICAgbGV0IG4gPSByaWdodC5sZWZ0XG4vLyAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuLy8gICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuLy8gICAgICAgICAgIGluZGV4ICs9IG4ubGVuZ3RoXG4vLyAgICAgICAgIH1cbi8vICAgICAgICAgbiA9IG4ubGVmdFxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgfVxuICBcbi8vICAgY29uc29sZS5sb2coJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJylcbi8vICAgY29uc29sZS5sb2codHlwZSwgaW5kZXgpO1xuLy8gfVxuXG4vL2NvbW1lbnQgYnkgamVhbk1lbmRvemEgMTcvMTAvMjAyMFxuLy8gY29uc3QgdXBkYXRlUmVtb3RlU2VsZWN0aW9uID0gKHksIGNtLCB0eXBlLCBjdXJzb3JzLCBjbGllbnRJZCwgYXdhcmVuZXNzKSA9PiB7XG4vLyAgIC8vIHJlZHJhdyBjYXJldCBhbmQgc2VsZWN0aW9uIGZvciBjbGllbnRJZFxuLy8gICBjb25zdCBhdyA9IGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5nZXQoY2xpZW50SWQpXG4vLyAgIC8vIGRlc3Ryb3kgY3VycmVudCB0ZXh0IG1hcmtcbi8vICAgY29uc3QgbSA9IGN1cnNvcnMuZ2V0KGNsaWVudElkKVxuLy8gICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4vLyAgICAgaWYgKG0uY2FyZXQpIHtcbi8vICAgICAgIG0uY2FyZXQuY2xlYXIoKVxuLy8gICAgIH1cbi8vICAgICBtLnNlbC5mb3JFYWNoKHNlbCA9PiBzZWwuY2xlYXIoKSlcbi8vICAgICBjdXJzb3JzLmRlbGV0ZShjbGllbnRJZClcbi8vICAgfVxuLy8gICBpZiAoYXcgPT09IHVuZGVmaW5lZCkge1xuLy8gICAgIHJldHVyblxuLy8gICB9XG4vLyAgIGNvbnN0IHVzZXIgPSBhdy51c2VyIHx8IHt9XG4vLyAgIGlmICh1c2VyLmNvbG9yID09IG51bGwpIHtcbi8vICAgICB1c2VyLmNvbG9yID0gJyNmZmE1MDAnXG4vLyAgIH1cbi8vICAgaWYgKHVzZXIubmFtZSA9PSBudWxsKSB7XG4vLyAgICAgdXNlci5uYW1lID0gYFVzZXI6ICR7Y2xpZW50SWR9YFxuLy8gICB9XG4vLyAgIGNvbnN0IGN1cnNvciA9IGF3LmN1cnNvclxuLy8gICBpZiAoY3Vyc29yID09IG51bGwgfHwgY3Vyc29yLmFuY2hvciA9PSBudWxsIHx8IGN1cnNvci5oZWFkID09IG51bGwpIHtcbi8vICAgICByZXR1cm5cbi8vICAgfVxuXG4vLyAgIC8vIHRlc3RpbmdGdW5jKEpTT04ucGFyc2UoY3Vyc29yLmFuY2hvciksIHkpOyAgXG4vLyAgIC8vIFlzXG4gIFxuLy8gICBjb25zdCBhbmNob3IgPSBZcy5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oSlNPTi5wYXJzZShjdXJzb3IuYW5jaG9yKSwgeSlcbi8vICAgY29uc3QgaGVhZCA9IFlzLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihKU09OLnBhcnNlKGN1cnNvci5oZWFkKSwgeSlcbi8vICAgLy8gY29uc3QgYW5jaG9yID0gWS5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oSlNPTi5wYXJzZShjdXJzb3IuYW5jaG9yKSwgeSlcbi8vICAgLy8gY29uc3QgaGVhZCA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKEpTT04ucGFyc2UoY3Vyc29yLmhlYWQpLCB5KVxuLy8gICBpZiAoYW5jaG9yICE9PSBudWxsICYmIGhlYWQgIT09IG51bGwgJiYgYW5jaG9yLnR5cGUgPT09IHR5cGUgJiYgaGVhZC50eXBlID09PSB0eXBlKSB7XG4vLyAgICAgY29uc3QgaGVhZHBvcyA9IGNtLnBvc0Zyb21JbmRleChoZWFkLmluZGV4KVxuLy8gICAgIGNvbnN0IGFuY2hvcnBvcyA9IGNtLnBvc0Zyb21JbmRleChhbmNob3IuaW5kZXgpXG4vLyAgICAgbGV0IGZyb20sIHRvXG4vLyAgICAgaWYgKGhlYWQuaW5kZXggPCBhbmNob3IuaW5kZXgpIHtcbi8vICAgICAgIGZyb20gPSBoZWFkcG9zXG4vLyAgICAgICB0byA9IGFuY2hvcnBvc1xuLy8gICAgIH0gZWxzZSB7XG4vLyAgICAgICBmcm9tID0gYW5jaG9ycG9zXG4vLyAgICAgICB0byA9IGhlYWRwb3Ncbi8vICAgICB9XG4vLyAgICAgY29uc3QgY2FyZXRFbCA9IGNyZWF0ZVJlbW90ZUNhcmV0KHVzZXIubmFtZSwgdXNlci5jb2xvcilcbi8vICAgICAvLyBpZiBwb3NpdGlvbiB3YXMgXCJyZWxhdGl2ZWx5XCIgdGhlIHNhbWUsIGRvIG5vdCBzaG93IG5hbWUgYWdhaW4gYW5kIGhpZGUgaW5zdGVhZFxuLy8gICAgIGlmIChtICYmIGZ1bmMuZXF1YWxpdHlGbGF0KGF3LmN1cnNvci5hbmNob3IsIG0uYXdDdXJzb3IuYW5jaG9yKSAmJiBmdW5jLmVxdWFsaXR5RmxhdChhdy5jdXJzb3IuaGVhZCwgbS5hd0N1cnNvci5oZWFkKSkge1xuLy8gICAgICAgY2FyZXRFbC5jbGFzc0xpc3QuYWRkKCdoaWRlLW5hbWUnKVxuLy8gICAgIH1cbi8vICAgICBjb25zdCBzZWwgPSBbXVxuXG4vLyAgICAgaWYgKGhlYWQuaW5kZXggIT09IGFuY2hvci5pbmRleCkge1xuLy8gICAgICAgaWYgKGZyb20ubGluZSAhPT0gdG8ubGluZSAmJiBmcm9tLmNoICE9PSAwKSB7XG4vLyAgICAgICAgIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiB3aWxsIG9ubHkgYmUgYSBzaW1wbGUgdGV4dC1zZWxlY3Rpb25cbi8vICAgICAgICAgc2VsLnB1c2goY20ubWFya1RleHQoZnJvbSwgbmV3IENvZGVNaXJyb3IuUG9zKGZyb20ubGluZSArIDEsIDApLCB7IGNzczogYGJhY2tncm91bmQtY29sb3I6ICR7dXNlci5jb2xvcn03MDtgLCBpbmNsdXNpdmVSaWdodDogZmFsc2UsIGluY2x1c2l2ZUxlZnQ6IGZhbHNlIH0pKVxuLy8gICAgICAgICBmcm9tID0gbmV3IENvZGVNaXJyb3IuUG9zKGZyb20ubGluZSArIDEsIDApXG4vLyAgICAgICB9XG4vLyAgICAgICB3aGlsZSAoZnJvbS5saW5lICE9PSB0by5saW5lKSB7XG4vLyAgICAgICAgIC8vIG1pZGRsZSBvZiBzZWxlY3Rpb24gaXMgYWx3YXlzIGEgd2hvbGUtbGluZSBzZWxlY3Rpb24uIFdlIGFkZCBhIHdpZGdldCBhdCB0aGUgZmlyc3QgcG9zaXRpb24gd2hpY2ggd2lsbCBmaWxsIHRoZSBiYWNrZ3JvdW5kLlxuLy8gICAgICAgICBzZWwucHVzaChjbS5zZXRCb29rbWFyayhuZXcgQ29kZU1pcnJvci5Qb3MoZnJvbS5saW5lLCAwKSwgeyB3aWRnZXQ6IGNyZWF0ZUVtcHR5TGluZVBsYWNlaG9sZGVyKHVzZXIuY29sb3IpIH0pKVxuLy8gICAgICAgICBmcm9tID0gbmV3IENvZGVNaXJyb3IuUG9zKGZyb20ubGluZSArIDEsIDApXG4vLyAgICAgICB9XG4vLyAgICAgICBzZWwucHVzaChjbS5tYXJrVGV4dChmcm9tLCB0bywgeyBjc3M6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9NzA7YCwgaW5jbHVzaXZlUmlnaHQ6IGZhbHNlLCBpbmNsdXNpdmVMZWZ0OiBmYWxzZSB9KSlcbi8vICAgICB9XG4vLyAgICAgLy8gb25seSByZW5kZXIgY2FyZXQgaWYgbm90IHRoZSBjb21wbGV0ZSBsYXN0IGxpbmUgd2FzIHNlbGVjdGVkIChpbiB0aGlzIGNhc2UgaGVhZHBvcy5jaCA9PT0gMClcbi8vICAgICBjb25zdCBjYXJldCA9IHNlbC5sZW5ndGggPiAwICYmIHRvID09PSBoZWFkcG9zICYmIGhlYWRwb3MuY2ggPT09IDAgPyBudWxsIDogY20uc2V0Qm9va21hcmsoaGVhZHBvcywgeyB3aWRnZXQ6IGNhcmV0RWwsIGluc2VydExlZnQ6IHRydWUgfSlcbi8vICAgICBjdXJzb3JzLnNldChjbGllbnRJZCwgeyBjYXJldCwgc2VsLCBhd0N1cnNvcjogY3Vyc29yIH0pXG4vLyAgIH1cbi8vIH1cbmNvbnN0IHVwZGF0ZVJlbW90ZVNlbGVjdGlvbiA9ICh5LCBjbSwgdHlwZSwgY3Vyc29ycywgY2xpZW50SWQsIGF3YXJlbmVzcykgPT4ge1xuICAvLyBkZXN0cm95IGN1cnJlbnQgdGV4dCBtYXJrXG4gIGNvbnN0IG0gPSBjdXJzb3JzLmdldChjbGllbnRJZClcbiAgaWYgKG0gIT09IHVuZGVmaW5lZCkge1xuICAgIG0uY2FyZXQuY2xlYXIoKVxuICAgIGlmIChtLnNlbCAhPT0gbnVsbCkge1xuICAgICAgbS5zZWwuY2xlYXIoKVxuICAgIH1cbiAgICBjdXJzb3JzLmRlbGV0ZShjbGllbnRJZClcbiAgfVxuICAvLyByZWRyYXcgY2FyZXQgYW5kIHNlbGVjdGlvbiBmb3IgY2xpZW50SWRcbiAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZ2V0KGNsaWVudElkKTtcbiAgaWYgKGF3ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCB1c2VyID0gYXcudXNlciB8fCB7fVxuICBpZiAodXNlci5jb2xvciA9PSBudWxsKSB7XG4gICAgdXNlci5jb2xvciA9ICcjZmZhNTAwJ1xuICB9XG4gIGlmICh1c2VyLm5hbWUgPT0gbnVsbCkge1xuICAgIHVzZXIubmFtZSA9IGBVc2VyOiAke2NsaWVudElkfWBcbiAgfVxuICBjb25zdCBjdXJzb3IgPSBhdy5jdXJzb3JcbiAgaWYgKGN1cnNvciA9PSBudWxsIHx8IGN1cnNvci5hbmNob3IgPT0gbnVsbCB8fCBjdXJzb3IuaGVhZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc29sZS5sb2coY3Vyc29yLmFuY2hvcilcbiAgbGV0IGN1cnNvcl9hbmNob3IgPSB0eXBlb2YgY3Vyc29yLmFuY2hvciA9PSAnb2JqZWN0JyA/IGN1cnNvci5hbmNob3IgOiBKU09OLnBhcnNlKGN1cnNvci5hbmNob3IpO1xuICBjb25zdCBhbmNob3IgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihjdXJzb3JfYW5jaG9yLCB5KVxuXG4gIC8vIGNvbnN0IGFuY2hvciA9IFlzLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihjdXJzb3IuYW5jaG9yKSwgeSlcbiAgbGV0IGN1cnNvcl9oZWFkID0gdHlwZW9mIGN1cnNvci5oZWFkID09ICdvYmplY3QnID8gY3Vyc29yLmhlYWQgOiBKU09OLnBhcnNlKGN1cnNvci5oZWFkKTtcbiAgY29uc3QgaGVhZCA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKGN1cnNvcl9oZWFkLCB5KVxuICAvLyBjb25zdCBoZWFkID0gWXMuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnNvci5oZWFkKSwgeSlcblxuICAvKmNvbnNvbGUubG9nKFwiVFlQRSBjb21wYXJhdGlvbiBcIixhbmNob3IudHlwZSA9PSB0eXBlKVxuICBjb25zb2xlLmxvZyhcIlRZUEUgIFwiLHR5cGUpXG4gIGNvbnNvbGUubG9nKFwiVFlQRSAgYW5jaG9yIFwiLGFuY2hvci50eXBlKSovXG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgaGVhZCAhPT0gbnVsbCAmJiBhbmNob3IudHlwZSA9PT0gdHlwZSAmJiBoZWFkLnR5cGUgPT09IHR5cGUpIHtcbiAgICBjb25zdCBoZWFkcG9zID0gY20ucG9zRnJvbUluZGV4KGhlYWQuaW5kZXgpXG4gICAgY29uc3QgYW5jaG9ycG9zID0gY20ucG9zRnJvbUluZGV4KGFuY2hvci5pbmRleClcbiAgICBsZXQgZnJvbSwgdG9cbiAgICBpZiAoaGVhZC5pbmRleCA8IGFuY2hvci5pbmRleCkge1xuICAgICAgZnJvbSA9IGhlYWRwb3NcbiAgICAgIHRvID0gYW5jaG9ycG9zXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb20gPSBhbmNob3Jwb3NcbiAgICAgIHRvID0gaGVhZHBvc1xuICAgIH1cbiAgICBpZihkZWJ1ZylcbiAgICBjb25zb2xlLmxvZyhcIiBGcm9tIFwiLGZyb20sXCIgdG8gXCIsdG8pXG4gICAgLy9jb25zb2xlLmxvZyhcImF3YXJlbmVzcyBcIixhd2FyZW5lc3MpXG4gICAgY29uc3QgY2FyZXRFbCA9IGNyZWF0ZVJlbW90ZUNhcmV0KHVzZXIubmFtZSwgdXNlci5jb2xvcilcbiAgICBjb25zdCBjYXJldCA9IGNtLnNldEJvb2ttYXJrKGhlYWRwb3MsIHsgd2lkZ2V0OiBjYXJldEVsLCBpbnNlcnRMZWZ0OiB0cnVlIH0pXG4gICAgbGV0IHNlbCA9IG51bGxcbiAgICBpZiAoaGVhZC5pbmRleCAhPT0gYW5jaG9yLmluZGV4KSB7XG4gICAgICBzZWwgPSBjbS5tYXJrVGV4dChmcm9tLCB0bywgeyBjc3M6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9NzBgLCBpbmNsdXNpdmVSaWdodDogdHJ1ZSwgaW5jbHVzaXZlTGVmdDogZmFsc2UgfSlcbiAgICB9XG4gICAgY3Vyc29ycy5zZXQoY2xpZW50SWQsIHsgY2FyZXQsIHNlbCB9KVxuICAgIGlmKGRlYnVnKVxuICAgICAgY29uc29sZS5sb2coXCJ1cGRhdGVSZW1vdGVTZWxlY3Rpb24gZnJvbSBjb2RlbWlycm9yIFwiKVxuICAgIFxuICB9XG59XG5cblxuXG4vLy8gY29tbWVudCBieSBqZWFuIG1lbmRvemEgMTcvMTAvMjAyMFxuLy8gY29uc3QgY29kZW1pcnJvckN1cnNvckFjdGl2aXR5ID0gKHksIGNtLCB0eXBlLCBhd2FyZW5lc3MpID0+IHtcbi8vICAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpXG4vLyAgIGlmICghY20uaGFzRm9jdXMoKSB8fCBhdyA9PSBudWxsIHx8ICFjbS5kaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5oYXNGb2N1cygpKSB7XG4vLyAgICAgcmV0dXJuXG4vLyAgIH1cbi8vICAgY29uc3QgbmV3QW5jaG9yID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCBjbS5pbmRleEZyb21Qb3MoY20uZ2V0Q3Vyc29yKCdhbmNob3InKSkpXG4vLyAgIGNvbnN0IG5ld0hlYWQgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2hlYWQnKSkpXG4vLyAgIGxldCBjdXJyZW50QW5jaG9yID0gbnVsbFxuLy8gICBsZXQgY3VycmVudEhlYWQgPSBudWxsXG4vLyAgIGlmIChhdy5jdXJzb3IgIT0gbnVsbCkge1xuLy8gICAgIGN1cnJlbnRBbmNob3IgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihKU09OLnBhcnNlKGF3LmN1cnNvci5hbmNob3IpKVxuLy8gICAgIGN1cnJlbnRIZWFkID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oSlNPTi5wYXJzZShhdy5jdXJzb3IuaGVhZCkpXG4vLyAgIH1cbi8vICAgaWYgKGF3LmN1cnNvciA9PSBudWxsIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50QW5jaG9yLCBuZXdBbmNob3IpIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50SGVhZCwgbmV3SGVhZCkpIHtcbi8vICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCdjdXJzb3InLCB7XG4vLyAgICAgICBhbmNob3I6IEpTT04uc3RyaW5naWZ5KG5ld0FuY2hvciksXG4vLyAgICAgICBoZWFkOiBKU09OLnN0cmluZ2lmeShuZXdIZWFkKVxuLy8gICAgIH0pXG4vLyAgIH1cbi8vIH1cblxuY29uc3QgY29kZW1pcnJvckN1cnNvckFjdGl2aXR5ID0gKHksIGNtLCB0eXBlLCBhd2FyZW5lc3MpID0+IHtcbiAgaWYgKCFjbS5oYXNGb2N1cygpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYoZGVidWcpe1xuICAgIGNvbnNvbGUubG9nKFwiY29kZW1pcnJvckN1cnNvckFjdGl2aXR5IHN0YXJ0IFwiLGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2FuY2hvcicpKSxcIiBlbmQgXCIsY20uaW5kZXhGcm9tUG9zKGNtLmdldEN1cnNvcignaGVhZCcpKSlcbiAgICBjb25zb2xlLmxvZyhcIiBUeXBlIGNvZGVtaXJyb3IgXCIsdHlwZSlcbiAgICBcbiAgfVxuICBjb25zdCBuZXdBbmNob3IgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2FuY2hvcicpKSlcbiAgY29uc3QgbmV3SGVhZCA9IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgodHlwZSwgY20uaW5kZXhGcm9tUG9zKGNtLmdldEN1cnNvcignaGVhZCcpKSlcbiAgY29uc3QgYXcgPSBhd2FyZW5lc3MuZ2V0TG9jYWxTdGF0ZSgpXG4gIGxldCBjdXJyZW50QW5jaG9yID0gbnVsbFxuICBsZXQgY3VycmVudEhlYWQgPSBudWxsXG4gIGlmIChhdy5jdXJzb3IgIT0gbnVsbCkge1xuICAgIGN1cnJlbnRBbmNob3IgPSBhdy5jdXJzb3IuYW5jaG9yOy8vIFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKEpTT04ucGFyc2UoYXcuY3Vyc29yLmFuY2hvciksIHkpXG4gICAgY3VycmVudEhlYWQgPSBhdy5jdXJzb3IuaGVhZDsgLy8gWS5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oSlNPTi5wYXJzZShhdy5jdXJzb3IuaGVhZCksIHkpXG4gIH1cbiAgaWYgKGF3LmN1cnNvciA9PSBudWxsIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50QW5jaG9yLCBuZXdBbmNob3IpIHx8ICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhjdXJyZW50SGVhZCwgbmV3SGVhZCkpIHtcbiAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKCdjdXJzb3InLCB7XG4gICAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICAgIGhlYWQ6IG5ld0hlYWRcbiAgICB9KVxuICAgIGlmKGRlYnVnKVxuICAgICAgY29uc29sZS5sb2coXCJTZW5kIGN1cnNvciAgZnJvbSBjb2RlbWlycm9yQ3Vyc29yQWN0aXZpdHkgIFwiLHtcbiAgICAgICAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICAgICAgICBoZWFkOiBuZXdIZWFkXG4gICAgICAgIH0pICBcbiAgfWVsc2Uge1xuICAgIGxldCBzdGFydCA9IGNtLmluZGV4RnJvbVBvcyhjbS5nZXRDdXJzb3IoJ2FuY2hvcicpKTtcbiAgICBsZXQgZW5kID0gY20uaW5kZXhGcm9tUG9zKGNtLmdldEN1cnNvcignaGVhZCcpKTtcbiAgICBpZihkZWJ1ZylcbiAgICBjb25zb2xlLmxvZyhcIkVsc2UgY29kZW1pcnJvckN1cnNvckFjdGl2aXR5XCIsc3RhcnQsZW5kKSAgXG4gICAgXG4gICAgaWYoc3RhcnQgPT0gZW5kKXtcbiAgICAgICAgY29uc3QgbmV3QW5jaG9yID0gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IG5ld0hlYWQgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIGVuZCk7XG4gICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIHtcbiAgICAgICAgICBhbmNob3I6IG5ld0FuY2hvcixcbiAgICAgICAgICBoZWFkOiBuZXdIZWFkXG4gICAgICAgIH0pO1xuICAgICAgICBpZihkZWJ1ZylcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNFTkQgUG9zdGlvbiB0YXJnZXRPYnNlcnZlciAgXCIsKHN0YXJ0K2VuZCkpIFxuICAgICAgfVxuICAgICAgXG4gIH1cbiAgXG4gIC8vY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLWNtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpXG4gIC8vY29uc29sZS5sb2coY3VycmVudEFuY2hvciwgY3VycmVudEhlYWQsIG5ld0FuY2hvciwgbmV3SGVhZCk7XG59XG5cbi8qKlxuICogQSBiaW5kaW5nIHRoYXQgYmluZHMgYSBZVGV4dCB0byBhIENvZGVNaXJyb3IgZWRpdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IHl0ZXh0ID0geWRvY3VtZW50LmRlZmluZSgnY29kZW1pcnJvcicsIFkuVGV4dClcbiAqICAgY29uc3QgZWRpdG9yID0gbmV3IENvZGVNaXJyb3IoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvbnRhaW5lcicpLCB7XG4gKiAgICAgbW9kZTogJ2phdmFzY3JpcHQnLFxuICogICAgIGxpbmVOdW1iZXJzOiB0cnVlXG4gKiAgIH0pXG4gKiAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgQ29kZW1pcnJvckJpbmRpbmcoeXRleHQsIGVkaXRvcilcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDb2RlbWlycm9yQmluZGluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuVGV4dH0gdGV4dFR5cGVcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2NvZGVtaXJyb3InKS5FZGl0b3J9IGNvZGVNaXJyb3JcbiAgICogQHBhcmFtIHthbnl9IFthd2FyZW5lc3NdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGV4dFR5cGUsIGNvZGVNaXJyb3IsIGF3YXJlbmVzcyxyZWFsdGltZT10cnVlKSB7XG4gICAgY29uc3QgZG9jID0gdGV4dFR5cGUuZG9jXG4gICAgY29uc3QgY21Eb2MgPSBjb2RlTWlycm9yLmdldERvYygpXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICB0aGlzLnR5cGUgPSB0ZXh0VHlwZVxuICAgIHRoaXMuY20gPSBjb2RlTWlycm9yXG4gICAgdGhpcy5jbURvYyA9IGNtRG9jXG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3NcbiAgICAvLyB0aGlzLnVuZG9NYW5hZ2VyID0gbmV3IFkuVW5kb01hbmFnZXIodGV4dFR5cGUsIHsgdHJhY2tlZE9yaWdpbnM6IG5ldyBTZXQoW3RoaXNdKSB9KVxuICAgIHRoaXMuX211eCA9IGNyZWF0ZU11dGV4KClcbiAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgIGNvbnNvbGUubG9nKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIsdGV4dFR5cGUudG9TdHJpbmcoKSlcbiAgICAvL2NtRG9jLnNldFZhbHVlKHRleHRUeXBlLnRvU3RyaW5nKCkpXG4gICAgLy8gb2JzZXJ2ZSB0eXBlIGFuZCB0YXJnZXRcbiAgICB0aGlzLl90eXBlT2JzZXJ2ZXIgPSBldmVudCA9PiB0eXBlT2JzZXJ2ZXIodGhpcywgZXZlbnQpXG4gICAgdGhpcy5fdGFyZ2V0T2JzZXJ2ZXIgPSAoaW5zdGFuY2UsIGNoYW5nZXMpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZS5nZXREb2MoKSA9PT0gY21Eb2MpIHtcbiAgICAgICAgdGFyZ2V0T2JzZXJ2ZXIodGhpcywgY2hhbmdlcylcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY3Vyc29ycyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX2NoYW5nZWRDdXJzb3JzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fZGVib3VuY2VDdXJzb3JFdmVudCA9IGV2ZW50bG9vcC5jcmVhdGVEZWJvdW5jZXIoMTApXG4gICAgdGhpcy5fYXdhcmVuZXNzTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICBpZiAoY29kZU1pcnJvci5nZXREb2MoKSAhPT0gY21Eb2MpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBmID0gY2xpZW50SWQgPT4ge1xuICAgICAgICBpZiAoY2xpZW50SWQgIT09IGRvYy5jbGllbnRJRCkge1xuICAgICAgICAgIHRoaXMuX2NoYW5nZWRDdXJzb3JzLmFkZChjbGllbnRJZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQuYWRkZWQuZm9yRWFjaChmKVxuICAgICAgZXZlbnQucmVtb3ZlZC5mb3JFYWNoKGYpXG4gICAgICBldmVudC51cGRhdGVkLmZvckVhY2goZilcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VkQ3Vyc29ycy5zaXplID4gMCkge1xuICAgICAgICB0aGlzLl9kZWJvdW5jZUN1cnNvckV2ZW50KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9jaGFuZ2VkQ3Vyc29ycy5mb3JFYWNoKGNsaWVudElkID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVJlbW90ZVNlbGVjdGlvbihkb2MsIGNvZGVNaXJyb3IsIHRleHRUeXBlLCB0aGlzLl9jdXJzb3JzLCBjbGllbnRJZCwgYXdhcmVuZXNzKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgdGhpcy5fY2hhbmdlZEN1cnNvcnMuY2xlYXIoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jdXJzb3JMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIGlmIChjb2RlTWlycm9yLmdldERvYygpID09PSBjbURvYykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb2RlbWlycm9yQ3Vyc29yQWN0aXZpdHkoZG9jLCBjb2RlTWlycm9yLCB0ZXh0VHlwZSwgYXdhcmVuZXNzKVxuICAgICAgICB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9ibHVyTGlzdGVlciA9ICgpID0+IGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIG51bGwpXG5cbiAgICB0ZXh0VHlwZS5vYnNlcnZlKHRoaXMuX3R5cGVPYnNlcnZlcilcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYocmVhbHRpbWUpXG4gICAgICBjb2RlTWlycm9yLm9uKCdjaGFuZ2VzJywgdGhpcy5fdGFyZ2V0T2JzZXJ2ZXIpXG4gICAgaWYgKGF3YXJlbmVzcykge1xuICAgICAgY29kZU1pcnJvci5vbignc3dhcERvYycsIHRoaXMuX2JsdXJMaXN0ZWVyKVxuICAgICAgYXdhcmVuZXNzLm9uKCdjaGFuZ2UnLCB0aGlzLl9hd2FyZW5lc3NMaXN0ZW5lcilcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvZGVNaXJyb3Iub24oJ2N1cnNvckFjdGl2aXR5JywgdGhpcy5fY3Vyc29yTGlzdGVuZXIpXG4gICAgICBjb2RlTWlycm9yLm9uKCdibHVyJywgdGhpcy5fYmx1ckxpc3RlZXIpXG4gICAgICBjb2RlTWlycm9yLm9uKCdmb2N1cycsIHRoaXMuX2N1cnNvckxpc3RlbmVyKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMudHlwZS51bm9ic2VydmUodGhpcy5fdHlwZU9ic2VydmVyKVxuICAgIHRoaXMuY20ub2ZmKCdzd2FwRG9jJywgdGhpcy5fYmx1ckxpc3RlZXIpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY20ub2ZmKCdjaGFuZ2VzJywgdGhpcy5fdGFyZ2V0T2JzZXJ2ZXIpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuY20ub2ZmKCdjdXJzb3JBY3Rpdml0eScsIHRoaXMuX2N1cnNvckxpc3RlbmVyKVxuICAgIHRoaXMuY20ub2ZmKCdmb2N1cycsIHRoaXMuX2N1cnNvckxpc3RlbmVyKVxuICAgIHRoaXMuY20ub2ZmKCdibHVyJywgdGhpcy5fYmx1ckxpc3RlZXIpXG4gICAgaWYgKHRoaXMuYXdhcmVuZXNzKSB7XG4gICAgICB0aGlzLmF3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIHRoaXMuX2F3YXJlbmVzc0xpc3RlbmVyKVxuICAgIH1cbiAgICB0aGlzLnR5cGUgPSBudWxsXG4gICAgdGhpcy5jbSA9IG51bGxcbiAgICB0aGlzLmNtRG9jID0gbnVsbFxuICAgIC8vIHRoaXMudW5kb01hbmFnZXIuZGVzdHJveSgpXG4gIH1cbn1cblxuXG5cbmV4cG9ydCBjb25zdCBDb2RlTWlycm9yQmluZGluZyA9IENvZGVtaXJyb3JCaW5kaW5nXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/js/y-codemirror.js\n")},"./node_modules/codemirror/addon/edit/closetag.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an "autoCloseTags" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the \'/\' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final \'>\' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n * `emptyTags` (default is none)\n *   An array of XML tag names that should be autoclosed with \'/>\'.\n *\n * See demos/closetag.html for a usage example.\n */\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ../fold/xml-fold */ "./node_modules/codemirror/addon/fold/xml-fold.js"));\n  else {}\n})(function(CodeMirror) {\n  CodeMirror.defineOption("autoCloseTags", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap("autoCloseTags");\n    if (!val) return;\n    var map = {name: "autoCloseTags"};\n    if (typeof val != "object" || val.whenClosing !== false)\n      map["\'/\'"] = function(cm) { return autoCloseSlash(cm); };\n    if (typeof val != "object" || val.whenOpening !== false)\n      map["\'>\'"] = function(cm) { return autoCloseGT(cm); };\n    cm.addKeyMap(map);\n  });\n\n  var htmlDontClose = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param",\n                       "source", "track", "wbr"];\n  var htmlIndent = ["applet", "blockquote", "body", "button", "div", "dl", "fieldset", "form", "frameset", "h1", "h2", "h3", "h4",\n                    "h5", "h6", "head", "html", "iframe", "layer", "legend", "object", "ol", "p", "select", "table", "ul"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption("disableInput")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    var opt = cm.getOption("autoCloseTags");\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state)\n      var tagName = tagInfo && tagInfo.name\n      if (!tagName) return CodeMirror.Pass\n\n      var html = inner.mode.configuration == "html";\n      var dontCloseTags = (typeof opt == "object" && opt.dontCloseTags) || (html && htmlDontClose);\n      var indentTags = (typeof opt == "object" && opt.indentTags) || (html && htmlIndent);\n\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase();\n      // Don\'t process the \'>\' at the end of an end-tag or self-closing tag\n      if (!tagName ||\n          tok.type == "string" && (tok.end != pos.ch || !/[\\"\\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\n          tok.type == "tag" && tagInfo.close ||\n          tok.string.indexOf("/") == (pos.ch - tok.start - 1) || // match something like <someTagName />\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\n          closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state) || [], tagName, pos, true))\n        return CodeMirror.Pass;\n\n      var emptyTags = typeof opt == "object" && opt.emptyTags;\n      if (emptyTags && indexOf(emptyTags, tagName) > -1) {\n        replacements[i] = { text: "/>", newPos: CodeMirror.Pos(pos.line, pos.ch + 2) };\n        continue;\n      }\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {indent: indent,\n                         text: ">" + (indent ? "\\n\\n" : "") + "</" + tagName + ">",\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\n    }\n\n    var dontIndentOnAutoClose = (typeof opt == "object" && opt.dontIndentOnAutoClose);\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {head: info.newPos, anchor: info.newPos};\n      cm.setSelections(sel);\n      if (!dontIndentOnAutoClose && info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(), replacements = [];\n    var head = typingSlash ? "/" : "</";\n    var opt = cm.getOption("autoCloseTags");\n    var dontIndentOnAutoClose = (typeof opt == "object" && opt.dontIndentOnSlash);\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (typingSlash && (tok.type == "string" || tok.string.charAt(0) != "<" ||\n                          tok.start != pos.ch - 1))\n        return CodeMirror.Pass;\n      // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n      var replacement, mixed = inner.mode.name != "xml" && cm.getMode().name == "htmlmixed"\n      if (mixed && inner.mode.name == "javascript") {\n        replacement = head + "script";\n      } else if (mixed && inner.mode.name == "css") {\n        replacement = head + "style";\n      } else {\n        var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state)\n        var top = context.length ? context[context.length - 1] : ""\n        if (!context || (context.length && closingTagExists(cm, context, top, pos)))\n          return CodeMirror.Pass;\n        replacement = head + top\n      }\n      if (cm.getLine(pos.line).charAt(tok.end) != ">") replacement += ">";\n      replacements[i] = replacement;\n    }\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n    if (!dontIndentOnAutoClose) {\n        for (var i = 0; i < ranges.length; i++)\n            if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n                cm.indentLine(ranges[i].head.line);\n    }\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption("disableInput")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n  function closingTagExists(cm, context, tagName, pos, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false;\n    // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n    var onCx = newTag ? 1 : 0\n    for (var i = context.length - 1; i >= 0; i--) {\n      if (context[i] == tagName) ++onCx\n      else break\n    }\n    pos = nextClose.to;\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n    return true;\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZWRpdC9jbG9zZXRhZy5qcz8wNWRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyx5RUFBc0IsR0FBRyxtQkFBTyxDQUFDLDBFQUFrQjtBQUNuRSxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RDtBQUNBLGlDQUFpQyx3QkFBd0I7QUFDekQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsNkJBQTZCOztBQUU1RTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9lZGl0L2Nsb3NldGFnLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLyoqXG4gKiBUYWctY2xvc2VyIGV4dGVuc2lvbiBmb3IgQ29kZU1pcnJvci5cbiAqXG4gKiBUaGlzIGV4dGVuc2lvbiBhZGRzIGFuIFwiYXV0b0Nsb3NlVGFnc1wiIG9wdGlvbiB0aGF0IGNhbiBiZSBzZXQgdG9cbiAqIGVpdGhlciB0cnVlIHRvIGdldCB0aGUgZGVmYXVsdCBiZWhhdmlvciwgb3IgYW4gb2JqZWN0IHRvIGZ1cnRoZXJcbiAqIGNvbmZpZ3VyZSBpdHMgYmVoYXZpb3IuXG4gKlxuICogVGhlc2UgYXJlIHN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIGB3aGVuQ2xvc2luZ2AgKGRlZmF1bHQgdHJ1ZSlcbiAqICAgV2hldGhlciB0byBhdXRvY2xvc2Ugd2hlbiB0aGUgJy8nIG9mIGEgY2xvc2luZyB0YWcgaXMgdHlwZWQuXG4gKiBgd2hlbk9wZW5pbmdgIChkZWZhdWx0IHRydWUpXG4gKiAgIFdoZXRoZXIgdG8gYXV0b2Nsb3NlIHRoZSB0YWcgd2hlbiB0aGUgZmluYWwgJz4nIG9mIGFuIG9wZW5pbmdcbiAqICAgdGFnIGlzIHR5cGVkLlxuICogYGRvbnRDbG9zZVRhZ3NgIChkZWZhdWx0IGlzIGVtcHR5IHRhZ3MgZm9yIEhUTUwsIG5vbmUgZm9yIFhNTClcbiAqICAgQW4gYXJyYXkgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkIG5vdCBiZSBhdXRvY2xvc2VkLlxuICogYGluZGVudFRhZ3NgIChkZWZhdWx0IGlzIGJsb2NrIHRhZ3MgZm9yIEhUTUwsIG5vbmUgZm9yIFhNTClcbiAqICAgQW4gYXJyYXkgb2YgdGFnIG5hbWVzIHRoYXQgc2hvdWxkLCB3aGVuIG9wZW5lZCwgY2F1c2UgYVxuICogICBibGFuayBsaW5lIHRvIGJlIGFkZGVkIGluc2lkZSB0aGUgdGFnLCBhbmQgdGhlIGJsYW5rIGxpbmUgYW5kXG4gKiAgIGNsb3NpbmcgbGluZSB0byBiZSBpbmRlbnRlZC5cbiAqIGBlbXB0eVRhZ3NgIChkZWZhdWx0IGlzIG5vbmUpXG4gKiAgIEFuIGFycmF5IG9mIFhNTCB0YWcgbmFtZXMgdGhhdCBzaG91bGQgYmUgYXV0b2Nsb3NlZCB3aXRoICcvPicuXG4gKlxuICogU2VlIGRlbW9zL2Nsb3NldGFnLmh0bWwgZm9yIGEgdXNhZ2UgZXhhbXBsZS5cbiAqL1xuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi4vZm9sZC94bWwtZm9sZFwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL2ZvbGQveG1sLWZvbGRcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiYXV0b0Nsb3NlVGFnc1wiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgaWYgKG9sZCAhPSBDb2RlTWlycm9yLkluaXQgJiYgb2xkKVxuICAgICAgY20ucmVtb3ZlS2V5TWFwKFwiYXV0b0Nsb3NlVGFnc1wiKTtcbiAgICBpZiAoIXZhbCkgcmV0dXJuO1xuICAgIHZhciBtYXAgPSB7bmFtZTogXCJhdXRvQ2xvc2VUYWdzXCJ9O1xuICAgIGlmICh0eXBlb2YgdmFsICE9IFwib2JqZWN0XCIgfHwgdmFsLndoZW5DbG9zaW5nICE9PSBmYWxzZSlcbiAgICAgIG1hcFtcIicvJ1wiXSA9IGZ1bmN0aW9uKGNtKSB7IHJldHVybiBhdXRvQ2xvc2VTbGFzaChjbSk7IH07XG4gICAgaWYgKHR5cGVvZiB2YWwgIT0gXCJvYmplY3RcIiB8fCB2YWwud2hlbk9wZW5pbmcgIT09IGZhbHNlKVxuICAgICAgbWFwW1wiJz4nXCJdID0gZnVuY3Rpb24oY20pIHsgcmV0dXJuIGF1dG9DbG9zZUdUKGNtKTsgfTtcbiAgICBjbS5hZGRLZXlNYXAobWFwKTtcbiAgfSk7XG5cbiAgdmFyIGh0bWxEb250Q2xvc2UgPSBbXCJhcmVhXCIsIFwiYmFzZVwiLCBcImJyXCIsIFwiY29sXCIsIFwiY29tbWFuZFwiLCBcImVtYmVkXCIsIFwiaHJcIiwgXCJpbWdcIiwgXCJpbnB1dFwiLCBcImtleWdlblwiLCBcImxpbmtcIiwgXCJtZXRhXCIsIFwicGFyYW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgXCJzb3VyY2VcIiwgXCJ0cmFja1wiLCBcIndiclwiXTtcbiAgdmFyIGh0bWxJbmRlbnQgPSBbXCJhcHBsZXRcIiwgXCJibG9ja3F1b3RlXCIsIFwiYm9keVwiLCBcImJ1dHRvblwiLCBcImRpdlwiLCBcImRsXCIsIFwiZmllbGRzZXRcIiwgXCJmb3JtXCIsIFwiZnJhbWVzZXRcIiwgXCJoMVwiLCBcImgyXCIsIFwiaDNcIiwgXCJoNFwiLFxuICAgICAgICAgICAgICAgICAgICBcImg1XCIsIFwiaDZcIiwgXCJoZWFkXCIsIFwiaHRtbFwiLCBcImlmcmFtZVwiLCBcImxheWVyXCIsIFwibGVnZW5kXCIsIFwib2JqZWN0XCIsIFwib2xcIiwgXCJwXCIsIFwic2VsZWN0XCIsIFwidGFibGVcIiwgXCJ1bFwiXTtcblxuICBmdW5jdGlvbiBhdXRvQ2xvc2VHVChjbSkge1xuICAgIGlmIChjbS5nZXRPcHRpb24oXCJkaXNhYmxlSW5wdXRcIikpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHJlcGxhY2VtZW50cyA9IFtdO1xuICAgIHZhciBvcHQgPSBjbS5nZXRPcHRpb24oXCJhdXRvQ2xvc2VUYWdzXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXJhbmdlc1tpXS5lbXB0eSgpKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgdmFyIHBvcyA9IHJhbmdlc1tpXS5oZWFkLCB0b2sgPSBjbS5nZXRUb2tlbkF0KHBvcyk7XG4gICAgICB2YXIgaW5uZXIgPSBDb2RlTWlycm9yLmlubmVyTW9kZShjbS5nZXRNb2RlKCksIHRvay5zdGF0ZSksIHN0YXRlID0gaW5uZXIuc3RhdGU7XG4gICAgICB2YXIgdGFnSW5mbyA9IGlubmVyLm1vZGUueG1sQ3VycmVudFRhZyAmJiBpbm5lci5tb2RlLnhtbEN1cnJlbnRUYWcoc3RhdGUpXG4gICAgICB2YXIgdGFnTmFtZSA9IHRhZ0luZm8gJiYgdGFnSW5mby5uYW1lXG4gICAgICBpZiAoIXRhZ05hbWUpIHJldHVybiBDb2RlTWlycm9yLlBhc3NcblxuICAgICAgdmFyIGh0bWwgPSBpbm5lci5tb2RlLmNvbmZpZ3VyYXRpb24gPT0gXCJodG1sXCI7XG4gICAgICB2YXIgZG9udENsb3NlVGFncyA9ICh0eXBlb2Ygb3B0ID09IFwib2JqZWN0XCIgJiYgb3B0LmRvbnRDbG9zZVRhZ3MpIHx8IChodG1sICYmIGh0bWxEb250Q2xvc2UpO1xuICAgICAgdmFyIGluZGVudFRhZ3MgPSAodHlwZW9mIG9wdCA9PSBcIm9iamVjdFwiICYmIG9wdC5pbmRlbnRUYWdzKSB8fCAoaHRtbCAmJiBodG1sSW5kZW50KTtcblxuICAgICAgaWYgKHRvay5lbmQgPiBwb3MuY2gpIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKDAsIHRhZ05hbWUubGVuZ3RoIC0gdG9rLmVuZCArIHBvcy5jaCk7XG4gICAgICB2YXIgbG93ZXJUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyB0aGUgJz4nIGF0IHRoZSBlbmQgb2YgYW4gZW5kLXRhZyBvciBzZWxmLWNsb3NpbmcgdGFnXG4gICAgICBpZiAoIXRhZ05hbWUgfHxcbiAgICAgICAgICB0b2sudHlwZSA9PSBcInN0cmluZ1wiICYmICh0b2suZW5kICE9IHBvcy5jaCB8fCAhL1tcXFwiXFwnXS8udGVzdCh0b2suc3RyaW5nLmNoYXJBdCh0b2suc3RyaW5nLmxlbmd0aCAtIDEpKSB8fCB0b2suc3RyaW5nLmxlbmd0aCA9PSAxKSB8fFxuICAgICAgICAgIHRvay50eXBlID09IFwidGFnXCIgJiYgdGFnSW5mby5jbG9zZSB8fFxuICAgICAgICAgIHRvay5zdHJpbmcuaW5kZXhPZihcIi9cIikgPT0gKHBvcy5jaCAtIHRvay5zdGFydCAtIDEpIHx8IC8vIG1hdGNoIHNvbWV0aGluZyBsaWtlIDxzb21lVGFnTmFtZSAvPlxuICAgICAgICAgIGRvbnRDbG9zZVRhZ3MgJiYgaW5kZXhPZihkb250Q2xvc2VUYWdzLCBsb3dlclRhZ05hbWUpID4gLTEgfHxcbiAgICAgICAgICBjbG9zaW5nVGFnRXhpc3RzKGNtLCBpbm5lci5tb2RlLnhtbEN1cnJlbnRDb250ZXh0ICYmIGlubmVyLm1vZGUueG1sQ3VycmVudENvbnRleHQoc3RhdGUpIHx8IFtdLCB0YWdOYW1lLCBwb3MsIHRydWUpKVxuICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuXG4gICAgICB2YXIgZW1wdHlUYWdzID0gdHlwZW9mIG9wdCA9PSBcIm9iamVjdFwiICYmIG9wdC5lbXB0eVRhZ3M7XG4gICAgICBpZiAoZW1wdHlUYWdzICYmIGluZGV4T2YoZW1wdHlUYWdzLCB0YWdOYW1lKSA+IC0xKSB7XG4gICAgICAgIHJlcGxhY2VtZW50c1tpXSA9IHsgdGV4dDogXCIvPlwiLCBuZXdQb3M6IENvZGVNaXJyb3IuUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAyKSB9O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudCA9IGluZGVudFRhZ3MgJiYgaW5kZXhPZihpbmRlbnRUYWdzLCBsb3dlclRhZ05hbWUpID4gLTE7XG4gICAgICByZXBsYWNlbWVudHNbaV0gPSB7aW5kZW50OiBpbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogXCI+XCIgKyAoaW5kZW50ID8gXCJcXG5cXG5cIiA6IFwiXCIpICsgXCI8L1wiICsgdGFnTmFtZSArIFwiPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1BvczogaW5kZW50ID8gQ29kZU1pcnJvci5Qb3MocG9zLmxpbmUgKyAxLCAwKSA6IENvZGVNaXJyb3IuUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAxKX07XG4gICAgfVxuXG4gICAgdmFyIGRvbnRJbmRlbnRPbkF1dG9DbG9zZSA9ICh0eXBlb2Ygb3B0ID09IFwib2JqZWN0XCIgJiYgb3B0LmRvbnRJbmRlbnRPbkF1dG9DbG9zZSk7XG4gICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGluZm8gPSByZXBsYWNlbWVudHNbaV07XG4gICAgICBjbS5yZXBsYWNlUmFuZ2UoaW5mby50ZXh0LCByYW5nZXNbaV0uaGVhZCwgcmFuZ2VzW2ldLmFuY2hvciwgXCIraW5zZXJ0XCIpO1xuICAgICAgdmFyIHNlbCA9IGNtLmxpc3RTZWxlY3Rpb25zKCkuc2xpY2UoMCk7XG4gICAgICBzZWxbaV0gPSB7aGVhZDogaW5mby5uZXdQb3MsIGFuY2hvcjogaW5mby5uZXdQb3N9O1xuICAgICAgY20uc2V0U2VsZWN0aW9ucyhzZWwpO1xuICAgICAgaWYgKCFkb250SW5kZW50T25BdXRvQ2xvc2UgJiYgaW5mby5pbmRlbnQpIHtcbiAgICAgICAgY20uaW5kZW50TGluZShpbmZvLm5ld1Bvcy5saW5lLCBudWxsLCB0cnVlKTtcbiAgICAgICAgY20uaW5kZW50TGluZShpbmZvLm5ld1Bvcy5saW5lICsgMSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXV0b0Nsb3NlQ3VycmVudChjbSwgdHlwaW5nU2xhc2gpIHtcbiAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgcmVwbGFjZW1lbnRzID0gW107XG4gICAgdmFyIGhlYWQgPSB0eXBpbmdTbGFzaCA/IFwiL1wiIDogXCI8L1wiO1xuICAgIHZhciBvcHQgPSBjbS5nZXRPcHRpb24oXCJhdXRvQ2xvc2VUYWdzXCIpO1xuICAgIHZhciBkb250SW5kZW50T25BdXRvQ2xvc2UgPSAodHlwZW9mIG9wdCA9PSBcIm9iamVjdFwiICYmIG9wdC5kb250SW5kZW50T25TbGFzaCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcmFuZ2VzW2ldLmVtcHR5KCkpIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICB2YXIgcG9zID0gcmFuZ2VzW2ldLmhlYWQsIHRvayA9IGNtLmdldFRva2VuQXQocG9zKTtcbiAgICAgIHZhciBpbm5lciA9IENvZGVNaXJyb3IuaW5uZXJNb2RlKGNtLmdldE1vZGUoKSwgdG9rLnN0YXRlKSwgc3RhdGUgPSBpbm5lci5zdGF0ZTtcbiAgICAgIGlmICh0eXBpbmdTbGFzaCAmJiAodG9rLnR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0b2suc3RyaW5nLmNoYXJBdCgwKSAhPSBcIjxcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b2suc3RhcnQgIT0gcG9zLmNoIC0gMSkpXG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAvLyBLbHVkZ2UgdG8gZ2V0IGFyb3VuZCB0aGUgZmFjdCB0aGF0IHdlIGFyZSBub3QgaW4gWE1MIG1vZGVcbiAgICAgIC8vIHdoZW4gY29tcGxldGluZyBpbiBKUy9DU1Mgc25pcHBldCBpbiBodG1sbWl4ZWQgbW9kZS4gRG9lcyBub3RcbiAgICAgIC8vIHdvcmsgZm9yIG90aGVyIFhNTCBlbWJlZGRlZCBsYW5ndWFnZXMgKHRoZXJlIGlzIG5vIGdlbmVyYWxcbiAgICAgIC8vIHdheSB0byBnbyBmcm9tIGEgbWl4ZWQgbW9kZSB0byBpdHMgY3VycmVudCBYTUwgc3RhdGUpLlxuICAgICAgdmFyIHJlcGxhY2VtZW50LCBtaXhlZCA9IGlubmVyLm1vZGUubmFtZSAhPSBcInhtbFwiICYmIGNtLmdldE1vZGUoKS5uYW1lID09IFwiaHRtbG1peGVkXCJcbiAgICAgIGlmIChtaXhlZCAmJiBpbm5lci5tb2RlLm5hbWUgPT0gXCJqYXZhc2NyaXB0XCIpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBoZWFkICsgXCJzY3JpcHRcIjtcbiAgICAgIH0gZWxzZSBpZiAobWl4ZWQgJiYgaW5uZXIubW9kZS5uYW1lID09IFwiY3NzXCIpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBoZWFkICsgXCJzdHlsZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBpbm5lci5tb2RlLnhtbEN1cnJlbnRDb250ZXh0ICYmIGlubmVyLm1vZGUueG1sQ3VycmVudENvbnRleHQoc3RhdGUpXG4gICAgICAgIHZhciB0b3AgPSBjb250ZXh0Lmxlbmd0aCA/IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA6IFwiXCJcbiAgICAgICAgaWYgKCFjb250ZXh0IHx8IChjb250ZXh0Lmxlbmd0aCAmJiBjbG9zaW5nVGFnRXhpc3RzKGNtLCBjb250ZXh0LCB0b3AsIHBvcykpKVxuICAgICAgICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gaGVhZCArIHRvcFxuICAgICAgfVxuICAgICAgaWYgKGNtLmdldExpbmUocG9zLmxpbmUpLmNoYXJBdCh0b2suZW5kKSAhPSBcIj5cIikgcmVwbGFjZW1lbnQgKz0gXCI+XCI7XG4gICAgICByZXBsYWNlbWVudHNbaV0gPSByZXBsYWNlbWVudDtcbiAgICB9XG4gICAgY20ucmVwbGFjZVNlbGVjdGlvbnMocmVwbGFjZW1lbnRzKTtcbiAgICByYW5nZXMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgIGlmICghZG9udEluZGVudE9uQXV0b0Nsb3NlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGkgPT0gcmFuZ2VzLmxlbmd0aCAtIDEgfHwgcmFuZ2VzW2ldLmhlYWQubGluZSA8IHJhbmdlc1tpICsgMV0uaGVhZC5saW5lKVxuICAgICAgICAgICAgICAgIGNtLmluZGVudExpbmUocmFuZ2VzW2ldLmhlYWQubGluZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXV0b0Nsb3NlU2xhc2goY20pIHtcbiAgICBpZiAoY20uZ2V0T3B0aW9uKFwiZGlzYWJsZUlucHV0XCIpKSByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgIHJldHVybiBhdXRvQ2xvc2VDdXJyZW50KGNtLCB0cnVlKTtcbiAgfVxuXG4gIENvZGVNaXJyb3IuY29tbWFuZHMuY2xvc2VUYWcgPSBmdW5jdGlvbihjbSkgeyByZXR1cm4gYXV0b0Nsb3NlQ3VycmVudChjbSk7IH07XG5cbiAgZnVuY3Rpb24gaW5kZXhPZihjb2xsZWN0aW9uLCBlbHQpIHtcbiAgICBpZiAoY29sbGVjdGlvbi5pbmRleE9mKSByZXR1cm4gY29sbGVjdGlvbi5pbmRleE9mKGVsdCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBjb2xsZWN0aW9uLmxlbmd0aDsgaSA8IGU7ICsraSlcbiAgICAgIGlmIChjb2xsZWN0aW9uW2ldID09IGVsdCkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gSWYgeG1sLWZvbGQgaXMgbG9hZGVkLCB3ZSB1c2UgaXRzIGZ1bmN0aW9uYWxpdHkgdG8gdHJ5IGFuZCB2ZXJpZnlcbiAgLy8gd2hldGhlciBhIGdpdmVuIHRhZyBpcyBhY3R1YWxseSB1bmNsb3NlZC5cbiAgZnVuY3Rpb24gY2xvc2luZ1RhZ0V4aXN0cyhjbSwgY29udGV4dCwgdGFnTmFtZSwgcG9zLCBuZXdUYWcpIHtcbiAgICBpZiAoIUNvZGVNaXJyb3Iuc2NhbkZvckNsb3NpbmdUYWcpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSArIDEsIHBvcy5saW5lICsgNTAwKTtcbiAgICB2YXIgbmV4dENsb3NlID0gQ29kZU1pcnJvci5zY2FuRm9yQ2xvc2luZ1RhZyhjbSwgcG9zLCBudWxsLCBlbmQpO1xuICAgIGlmICghbmV4dENsb3NlIHx8IG5leHRDbG9zZS50YWcgIT0gdGFnTmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIElmIHRoZSBpbW1lZGlhdGUgd3JhcHBpbmcgY29udGV4dCBjb250YWlucyBvbkN4IGluc3RhbmNlcyBvZlxuICAgIC8vIHRoZSBzYW1lIHRhZywgYSBjbG9zaW5nIHRhZyBvbmx5IGV4aXN0cyBpZiB0aGVyZSBhcmUgYXQgbGVhc3RcbiAgICAvLyB0aGF0IG1hbnkgY2xvc2luZyB0YWdzIG9mIHRoYXQgdHlwZSBmb2xsb3dpbmcuXG4gICAgdmFyIG9uQ3ggPSBuZXdUYWcgPyAxIDogMFxuICAgIGZvciAodmFyIGkgPSBjb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoY29udGV4dFtpXSA9PSB0YWdOYW1lKSArK29uQ3hcbiAgICAgIGVsc2UgYnJlYWtcbiAgICB9XG4gICAgcG9zID0gbmV4dENsb3NlLnRvO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb25DeDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IENvZGVNaXJyb3Iuc2NhbkZvckNsb3NpbmdUYWcoY20sIHBvcywgbnVsbCwgZW5kKTtcbiAgICAgIGlmICghbmV4dCB8fCBuZXh0LnRhZyAhPSB0YWdOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgICBwb3MgPSBuZXh0LnRvO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/edit/closetag.js\n')},"./node_modules/codemirror/addon/fold/brace-fold.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nCodeMirror.registerHelper("fold", "brace", function(cm, start) {\n  var line = start.line, lineText = cm.getLine(line);\n  var tokenType;\n\n  function findOpening(openCh) {\n    for (var at = start.ch, pass = 0;;) {\n      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);\n      if (found == -1) {\n        if (pass == 1) break;\n        pass = 1;\n        at = lineText.length;\n        continue;\n      }\n      if (pass == 1 && found < start.ch) break;\n      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));\n      if (!/^(comment|string)/.test(tokenType)) return found + 1;\n      at = found - 1;\n    }\n  }\n\n  var startBrace = findOpening("{"), startBracket = findOpening("[")\n  var startToken, endToken, startCh\n  if (startBrace != null && (startBracket == null || startBracket > startBrace)) {\n    startCh = startBrace; startToken = "{"; endToken = "}"\n  } else if (startBracket != null) {\n    startCh = startBracket; startToken = "["; endToken = "]"\n  } else {\n    return\n  }\n\n  var count = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {\n        if (pos == nextOpen) ++count;\n        else if (!--count) { end = i; endCh = pos; break outer; }\n      }\n      ++pos;\n    }\n  }\n  if (end == null || line == end) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\nCodeMirror.registerHelper("fold", "import", function(cm, start) {\n  function hasImport(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type != "keyword" || start.string != "import") return null;\n    // Now find closing semicolon, return its position\n    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {\n      var text = cm.getLine(i), semi = text.indexOf(";");\n      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};\n    }\n  }\n\n  var startLine = start.line, has = hasImport(startLine), prev;\n  if (!has || hasImport(startLine - 1) || ((prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1))\n    return null;\n  for (var end = has.end;;) {\n    var next = hasImport(end.line + 1);\n    if (next == null) break;\n    end = next.end;\n  }\n  return {from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)), to: end};\n});\n\nCodeMirror.registerHelper("fold", "include", function(cm, start) {\n  function hasInclude(line) {\n    if (line < cm.firstLine() || line > cm.lastLine()) return null;\n    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));\n    if (!/\\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));\n    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;\n  }\n\n  var startLine = start.line, has = hasInclude(startLine);\n  if (has == null || hasInclude(startLine - 1) != null) return null;\n  for (var end = startLine;;) {\n    var next = hasInclude(end + 1);\n    if (next == null) break;\n    ++end;\n  }\n  return {from: CodeMirror.Pos(startLine, has + 1),\n          to: cm.clipPos(CodeMirror.Pos(end))};\n});\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9icmFjZS1mb2xkLmpzP2FlZGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsRUFBRSxjQUFjO0FBQ3pELEdBQUc7QUFDSCwyQkFBMkIsa0JBQWtCO0FBQzdDLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUyxhQUFhLGFBQWE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUTtBQUN0RSxzREFBc0Q7QUFDdEQsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLENBQUM7O0FBRUQsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL2ZvbGQvYnJhY2UtZm9sZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJicmFjZVwiLCBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgdmFyIGxpbmUgPSBzdGFydC5saW5lLCBsaW5lVGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gIHZhciB0b2tlblR5cGU7XG5cbiAgZnVuY3Rpb24gZmluZE9wZW5pbmcob3BlbkNoKSB7XG4gICAgZm9yICh2YXIgYXQgPSBzdGFydC5jaCwgcGFzcyA9IDA7Oykge1xuICAgICAgdmFyIGZvdW5kID0gYXQgPD0gMCA/IC0xIDogbGluZVRleHQubGFzdEluZGV4T2Yob3BlbkNoLCBhdCAtIDEpO1xuICAgICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICAgIGlmIChwYXNzID09IDEpIGJyZWFrO1xuICAgICAgICBwYXNzID0gMTtcbiAgICAgICAgYXQgPSBsaW5lVGV4dC5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhc3MgPT0gMSAmJiBmb3VuZCA8IHN0YXJ0LmNoKSBicmVhaztcbiAgICAgIHRva2VuVHlwZSA9IGNtLmdldFRva2VuVHlwZUF0KENvZGVNaXJyb3IuUG9zKGxpbmUsIGZvdW5kICsgMSkpO1xuICAgICAgaWYgKCEvXihjb21tZW50fHN0cmluZykvLnRlc3QodG9rZW5UeXBlKSkgcmV0dXJuIGZvdW5kICsgMTtcbiAgICAgIGF0ID0gZm91bmQgLSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGFydEJyYWNlID0gZmluZE9wZW5pbmcoXCJ7XCIpLCBzdGFydEJyYWNrZXQgPSBmaW5kT3BlbmluZyhcIltcIilcbiAgdmFyIHN0YXJ0VG9rZW4sIGVuZFRva2VuLCBzdGFydENoXG4gIGlmIChzdGFydEJyYWNlICE9IG51bGwgJiYgKHN0YXJ0QnJhY2tldCA9PSBudWxsIHx8IHN0YXJ0QnJhY2tldCA+IHN0YXJ0QnJhY2UpKSB7XG4gICAgc3RhcnRDaCA9IHN0YXJ0QnJhY2U7IHN0YXJ0VG9rZW4gPSBcIntcIjsgZW5kVG9rZW4gPSBcIn1cIlxuICB9IGVsc2UgaWYgKHN0YXJ0QnJhY2tldCAhPSBudWxsKSB7XG4gICAgc3RhcnRDaCA9IHN0YXJ0QnJhY2tldDsgc3RhcnRUb2tlbiA9IFwiW1wiOyBlbmRUb2tlbiA9IFwiXVwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY291bnQgPSAxLCBsYXN0TGluZSA9IGNtLmxhc3RMaW5lKCksIGVuZCwgZW5kQ2g7XG4gIG91dGVyOiBmb3IgKHZhciBpID0gbGluZTsgaSA8PSBsYXN0TGluZTsgKytpKSB7XG4gICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGkpLCBwb3MgPSBpID09IGxpbmUgPyBzdGFydENoIDogMDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV4dE9wZW4gPSB0ZXh0LmluZGV4T2Yoc3RhcnRUb2tlbiwgcG9zKSwgbmV4dENsb3NlID0gdGV4dC5pbmRleE9mKGVuZFRva2VuLCBwb3MpO1xuICAgICAgaWYgKG5leHRPcGVuIDwgMCkgbmV4dE9wZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChuZXh0Q2xvc2UgPCAwKSBuZXh0Q2xvc2UgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHBvcyA9IE1hdGgubWluKG5leHRPcGVuLCBuZXh0Q2xvc2UpO1xuICAgICAgaWYgKHBvcyA9PSB0ZXh0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBpZiAoY20uZ2V0VG9rZW5UeXBlQXQoQ29kZU1pcnJvci5Qb3MoaSwgcG9zICsgMSkpID09IHRva2VuVHlwZSkge1xuICAgICAgICBpZiAocG9zID09IG5leHRPcGVuKSArK2NvdW50O1xuICAgICAgICBlbHNlIGlmICghLS1jb3VudCkgeyBlbmQgPSBpOyBlbmRDaCA9IHBvczsgYnJlYWsgb3V0ZXI7IH1cbiAgICAgIH1cbiAgICAgICsrcG9zO1xuICAgIH1cbiAgfVxuICBpZiAoZW5kID09IG51bGwgfHwgbGluZSA9PSBlbmQpIHJldHVybjtcbiAgcmV0dXJuIHtmcm9tOiBDb2RlTWlycm9yLlBvcyhsaW5lLCBzdGFydENoKSxcbiAgICAgICAgICB0bzogQ29kZU1pcnJvci5Qb3MoZW5kLCBlbmRDaCl9O1xufSk7XG5cbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJmb2xkXCIsIFwiaW1wb3J0XCIsIGZ1bmN0aW9uKGNtLCBzdGFydCkge1xuICBmdW5jdGlvbiBoYXNJbXBvcnQobGluZSkge1xuICAgIGlmIChsaW5lIDwgY20uZmlyc3RMaW5lKCkgfHwgbGluZSA+IGNtLmxhc3RMaW5lKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBzdGFydCA9IGNtLmdldFRva2VuQXQoQ29kZU1pcnJvci5Qb3MobGluZSwgMSkpO1xuICAgIGlmICghL1xcUy8udGVzdChzdGFydC5zdHJpbmcpKSBzdGFydCA9IGNtLmdldFRva2VuQXQoQ29kZU1pcnJvci5Qb3MobGluZSwgc3RhcnQuZW5kICsgMSkpO1xuICAgIGlmIChzdGFydC50eXBlICE9IFwia2V5d29yZFwiIHx8IHN0YXJ0LnN0cmluZyAhPSBcImltcG9ydFwiKSByZXR1cm4gbnVsbDtcbiAgICAvLyBOb3cgZmluZCBjbG9zaW5nIHNlbWljb2xvbiwgcmV0dXJuIGl0cyBwb3NpdGlvblxuICAgIGZvciAodmFyIGkgPSBsaW5lLCBlID0gTWF0aC5taW4oY20ubGFzdExpbmUoKSwgbGluZSArIDEwKTsgaSA8PSBlOyArK2kpIHtcbiAgICAgIHZhciB0ZXh0ID0gY20uZ2V0TGluZShpKSwgc2VtaSA9IHRleHQuaW5kZXhPZihcIjtcIik7XG4gICAgICBpZiAoc2VtaSAhPSAtMSkgcmV0dXJuIHtzdGFydENoOiBzdGFydC5lbmQsIGVuZDogQ29kZU1pcnJvci5Qb3MoaSwgc2VtaSl9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGFydExpbmUgPSBzdGFydC5saW5lLCBoYXMgPSBoYXNJbXBvcnQoc3RhcnRMaW5lKSwgcHJldjtcbiAgaWYgKCFoYXMgfHwgaGFzSW1wb3J0KHN0YXJ0TGluZSAtIDEpIHx8ICgocHJldiA9IGhhc0ltcG9ydChzdGFydExpbmUgLSAyKSkgJiYgcHJldi5lbmQubGluZSA9PSBzdGFydExpbmUgLSAxKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgZm9yICh2YXIgZW5kID0gaGFzLmVuZDs7KSB7XG4gICAgdmFyIG5leHQgPSBoYXNJbXBvcnQoZW5kLmxpbmUgKyAxKTtcbiAgICBpZiAobmV4dCA9PSBudWxsKSBicmVhaztcbiAgICBlbmQgPSBuZXh0LmVuZDtcbiAgfVxuICByZXR1cm4ge2Zyb206IGNtLmNsaXBQb3MoQ29kZU1pcnJvci5Qb3Moc3RhcnRMaW5lLCBoYXMuc3RhcnRDaCArIDEpKSwgdG86IGVuZH07XG59KTtcblxuQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJpbmNsdWRlXCIsIGZ1bmN0aW9uKGNtLCBzdGFydCkge1xuICBmdW5jdGlvbiBoYXNJbmNsdWRlKGxpbmUpIHtcbiAgICBpZiAobGluZSA8IGNtLmZpcnN0TGluZSgpIHx8IGxpbmUgPiBjbS5sYXN0TGluZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3RhcnQgPSBjbS5nZXRUb2tlbkF0KENvZGVNaXJyb3IuUG9zKGxpbmUsIDEpKTtcbiAgICBpZiAoIS9cXFMvLnRlc3Qoc3RhcnQuc3RyaW5nKSkgc3RhcnQgPSBjbS5nZXRUb2tlbkF0KENvZGVNaXJyb3IuUG9zKGxpbmUsIHN0YXJ0LmVuZCArIDEpKTtcbiAgICBpZiAoc3RhcnQudHlwZSA9PSBcIm1ldGFcIiAmJiBzdGFydC5zdHJpbmcuc2xpY2UoMCwgOCkgPT0gXCIjaW5jbHVkZVwiKSByZXR1cm4gc3RhcnQuc3RhcnQgKyA4O1xuICB9XG5cbiAgdmFyIHN0YXJ0TGluZSA9IHN0YXJ0LmxpbmUsIGhhcyA9IGhhc0luY2x1ZGUoc3RhcnRMaW5lKTtcbiAgaWYgKGhhcyA9PSBudWxsIHx8IGhhc0luY2x1ZGUoc3RhcnRMaW5lIC0gMSkgIT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIGZvciAodmFyIGVuZCA9IHN0YXJ0TGluZTs7KSB7XG4gICAgdmFyIG5leHQgPSBoYXNJbmNsdWRlKGVuZCArIDEpO1xuICAgIGlmIChuZXh0ID09IG51bGwpIGJyZWFrO1xuICAgICsrZW5kO1xuICB9XG4gIHJldHVybiB7ZnJvbTogQ29kZU1pcnJvci5Qb3Moc3RhcnRMaW5lLCBoYXMgKyAxKSxcbiAgICAgICAgICB0bzogY20uY2xpcFBvcyhDb2RlTWlycm9yLlBvcyhlbmQpKX07XG59KTtcblxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/brace-fold.js\n')},"./node_modules/codemirror/addon/fold/comment-fold.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nCodeMirror.registerGlobalHelper("fold", "comment", function(mode) {\n  return mode.blockCommentStart && mode.blockCommentEnd;\n}, function(cm, start) {\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\n  if (!startToken || !endToken) return;\n  var line = start.line, lineText = cm.getLine(line);\n\n  var startCh;\n  for (var at = start.ch, pass = 0;;) {\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\n    if (found == -1) {\n      if (pass == 1) return;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n    if (pass == 1 && found < start.ch) return;\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\n      startCh = found + startToken.length;\n      break;\n    }\n    at = found - 1;\n  }\n\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (pos == nextOpen) ++depth;\n      else if (!--depth) { end = i; endCh = pos; break outer; }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9jb21tZW50LWZvbGQuanM/MTY0YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMseUVBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZUFBZTtBQUMxQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUyxhQUFhLGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxDQUFDOztBQUVELENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9mb2xkL2NvbW1lbnQtZm9sZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlcihcImZvbGRcIiwgXCJjb21tZW50XCIsIGZ1bmN0aW9uKG1vZGUpIHtcbiAgcmV0dXJuIG1vZGUuYmxvY2tDb21tZW50U3RhcnQgJiYgbW9kZS5ibG9ja0NvbW1lbnRFbmQ7XG59LCBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQoc3RhcnQpLCBzdGFydFRva2VuID0gbW9kZS5ibG9ja0NvbW1lbnRTdGFydCwgZW5kVG9rZW4gPSBtb2RlLmJsb2NrQ29tbWVudEVuZDtcbiAgaWYgKCFzdGFydFRva2VuIHx8ICFlbmRUb2tlbikgcmV0dXJuO1xuICB2YXIgbGluZSA9IHN0YXJ0LmxpbmUsIGxpbmVUZXh0ID0gY20uZ2V0TGluZShsaW5lKTtcblxuICB2YXIgc3RhcnRDaDtcbiAgZm9yICh2YXIgYXQgPSBzdGFydC5jaCwgcGFzcyA9IDA7Oykge1xuICAgIHZhciBmb3VuZCA9IGF0IDw9IDAgPyAtMSA6IGxpbmVUZXh0Lmxhc3RJbmRleE9mKHN0YXJ0VG9rZW4sIGF0IC0gMSk7XG4gICAgaWYgKGZvdW5kID09IC0xKSB7XG4gICAgICBpZiAocGFzcyA9PSAxKSByZXR1cm47XG4gICAgICBwYXNzID0gMTtcbiAgICAgIGF0ID0gbGluZVRleHQubGVuZ3RoO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwYXNzID09IDEgJiYgZm91bmQgPCBzdGFydC5jaCkgcmV0dXJuO1xuICAgIGlmICgvY29tbWVudC8udGVzdChjbS5nZXRUb2tlblR5cGVBdChDb2RlTWlycm9yLlBvcyhsaW5lLCBmb3VuZCArIDEpKSkgJiZcbiAgICAgICAgKGZvdW5kID09IDAgfHwgbGluZVRleHQuc2xpY2UoZm91bmQgLSBlbmRUb2tlbi5sZW5ndGgsIGZvdW5kKSA9PSBlbmRUb2tlbiB8fFxuICAgICAgICAgIS9jb21tZW50Ly50ZXN0KGNtLmdldFRva2VuVHlwZUF0KENvZGVNaXJyb3IuUG9zKGxpbmUsIGZvdW5kKSkpKSkge1xuICAgICAgc3RhcnRDaCA9IGZvdW5kICsgc3RhcnRUb2tlbi5sZW5ndGg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYXQgPSBmb3VuZCAtIDE7XG4gIH1cblxuICB2YXIgZGVwdGggPSAxLCBsYXN0TGluZSA9IGNtLmxhc3RMaW5lKCksIGVuZCwgZW5kQ2g7XG4gIG91dGVyOiBmb3IgKHZhciBpID0gbGluZTsgaSA8PSBsYXN0TGluZTsgKytpKSB7XG4gICAgdmFyIHRleHQgPSBjbS5nZXRMaW5lKGkpLCBwb3MgPSBpID09IGxpbmUgPyBzdGFydENoIDogMDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV4dE9wZW4gPSB0ZXh0LmluZGV4T2Yoc3RhcnRUb2tlbiwgcG9zKSwgbmV4dENsb3NlID0gdGV4dC5pbmRleE9mKGVuZFRva2VuLCBwb3MpO1xuICAgICAgaWYgKG5leHRPcGVuIDwgMCkgbmV4dE9wZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChuZXh0Q2xvc2UgPCAwKSBuZXh0Q2xvc2UgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHBvcyA9IE1hdGgubWluKG5leHRPcGVuLCBuZXh0Q2xvc2UpO1xuICAgICAgaWYgKHBvcyA9PSB0ZXh0Lmxlbmd0aCkgYnJlYWs7XG4gICAgICBpZiAocG9zID09IG5leHRPcGVuKSArK2RlcHRoO1xuICAgICAgZWxzZSBpZiAoIS0tZGVwdGgpIHsgZW5kID0gaTsgZW5kQ2ggPSBwb3M7IGJyZWFrIG91dGVyOyB9XG4gICAgICArK3BvcztcbiAgICB9XG4gIH1cbiAgaWYgKGVuZCA9PSBudWxsIHx8IGxpbmUgPT0gZW5kICYmIGVuZENoID09IHN0YXJ0Q2gpIHJldHVybjtcbiAgcmV0dXJuIHtmcm9tOiBDb2RlTWlycm9yLlBvcyhsaW5lLCBzdGFydENoKSxcbiAgICAgICAgICB0bzogQ29kZU1pcnJvci5Qb3MoZW5kLCBlbmRDaCl9O1xufSk7XG5cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/comment-fold.js\n')},"./node_modules/codemirror/addon/fold/foldcode.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n  "use strict";\n\n  function doFold(cm, pos, options, force) {\n    if (options && options.call) {\n      var finder = options;\n      options = null;\n    } else {\n      var finder = getOption(cm, options, "rangeFinder");\n    }\n    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);\n    var minSize = getOption(cm, options, "minFoldSize");\n\n    function getRange(allowFolded) {\n      var range = finder(cm, pos);\n      if (!range || range.to.line - range.from.line < minSize) return null;\n      var marks = cm.findMarksAt(range.from);\n      for (var i = 0; i < marks.length; ++i) {\n        if (marks[i].__isFold && force !== "fold") {\n          if (!allowFolded) return null;\n          range.cleared = true;\n          marks[i].clear();\n        }\n      }\n      return range;\n    }\n\n    var range = getRange(true);\n    if (getOption(cm, options, "scanUp")) while (!range && pos.line > cm.firstLine()) {\n      pos = CodeMirror.Pos(pos.line - 1, 0);\n      range = getRange(false);\n    }\n    if (!range || range.cleared || force === "unfold") return;\n\n    var myWidget = makeWidget(cm, options, range);\n    CodeMirror.on(myWidget, "mousedown", function(e) {\n      myRange.clear();\n      CodeMirror.e_preventDefault(e);\n    });\n    var myRange = cm.markText(range.from, range.to, {\n      replacedWith: myWidget,\n      clearOnEnter: getOption(cm, options, "clearOnEnter"),\n      __isFold: true\n    });\n    myRange.on("clear", function(from, to) {\n      CodeMirror.signal(cm, "unfold", cm, from, to);\n    });\n    CodeMirror.signal(cm, "fold", cm, range.from, range.to);\n  }\n\n  function makeWidget(cm, options, range) {\n    var widget = getOption(cm, options, "widget");\n\n    if (typeof widget == "function") {\n      widget = widget(range.from, range.to);\n    }\n\n    if (typeof widget == "string") {\n      var text = document.createTextNode(widget);\n      widget = document.createElement("span");\n      widget.appendChild(text);\n      widget.className = "CodeMirror-foldmarker";\n    } else if (widget) {\n      widget = widget.cloneNode(true)\n    }\n    return widget;\n  }\n\n  // Clumsy backwards-compatible interface\n  CodeMirror.newFoldFunction = function(rangeFinder, widget) {\n    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };\n  };\n\n  // New-style interface\n  CodeMirror.defineExtension("foldCode", function(pos, options, force) {\n    doFold(this, pos, options, force);\n  });\n\n  CodeMirror.defineExtension("isFolded", function(pos) {\n    var marks = this.findMarksAt(pos);\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold) return true;\n  });\n\n  CodeMirror.commands.toggleFold = function(cm) {\n    cm.foldCode(cm.getCursor());\n  };\n  CodeMirror.commands.fold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, "fold");\n  };\n  CodeMirror.commands.unfold = function(cm) {\n    cm.foldCode(cm.getCursor(), null, "unfold");\n  };\n  CodeMirror.commands.foldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");\n    });\n  };\n  CodeMirror.commands.unfoldAll = function(cm) {\n    cm.operation(function() {\n      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)\n        cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");\n    });\n  };\n\n  CodeMirror.registerHelper("fold", "combine", function() {\n    var funcs = Array.prototype.slice.call(arguments, 0);\n    return function(cm, start) {\n      for (var i = 0; i < funcs.length; ++i) {\n        var found = funcs[i](cm, start);\n        if (found) return found;\n      }\n    };\n  });\n\n  CodeMirror.registerHelper("fold", "auto", function(cm, start) {\n    var helpers = cm.getHelpers(start, "fold");\n    for (var i = 0; i < helpers.length; i++) {\n      var cur = helpers[i](cm, start);\n      if (cur) return cur;\n    }\n  });\n\n  var defaultOptions = {\n    rangeFinder: CodeMirror.fold.auto,\n    widget: "\\u2194",\n    minFoldSize: 0,\n    scanUp: false,\n    clearOnEnter: true\n  };\n\n  CodeMirror.defineOption("foldOptions", null);\n\n  function getOption(cm, options, name) {\n    if (options && options[name] !== undefined)\n      return options[name];\n    var editorOptions = cm.options.foldOptions;\n    if (editorOptions && editorOptions[name] !== undefined)\n      return editorOptions[name];\n    return defaultOptions[name];\n  }\n\n  CodeMirror.defineExtension("foldOption", function(options, name) {\n    return getOption(this, options, name);\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9mb2xkY29kZS5qcz80ODk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0IseUNBQXlDLEVBQUU7QUFDM0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9mb2xkL2ZvbGRjb2RlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gZG9Gb2xkKGNtLCBwb3MsIG9wdGlvbnMsIGZvcmNlKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYWxsKSB7XG4gICAgICB2YXIgZmluZGVyID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmluZGVyID0gZ2V0T3B0aW9uKGNtLCBvcHRpb25zLCBcInJhbmdlRmluZGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHBvcyA9PSBcIm51bWJlclwiKSBwb3MgPSBDb2RlTWlycm9yLlBvcyhwb3MsIDApO1xuICAgIHZhciBtaW5TaXplID0gZ2V0T3B0aW9uKGNtLCBvcHRpb25zLCBcIm1pbkZvbGRTaXplXCIpO1xuXG4gICAgZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsb3dGb2xkZWQpIHtcbiAgICAgIHZhciByYW5nZSA9IGZpbmRlcihjbSwgcG9zKTtcbiAgICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UudG8ubGluZSAtIHJhbmdlLmZyb20ubGluZSA8IG1pblNpemUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG1hcmtzID0gY20uZmluZE1hcmtzQXQocmFuZ2UuZnJvbSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChtYXJrc1tpXS5fX2lzRm9sZCAmJiBmb3JjZSAhPT0gXCJmb2xkXCIpIHtcbiAgICAgICAgICBpZiAoIWFsbG93Rm9sZGVkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICByYW5nZS5jbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICBtYXJrc1tpXS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgdmFyIHJhbmdlID0gZ2V0UmFuZ2UodHJ1ZSk7XG4gICAgaWYgKGdldE9wdGlvbihjbSwgb3B0aW9ucywgXCJzY2FuVXBcIikpIHdoaWxlICghcmFuZ2UgJiYgcG9zLmxpbmUgPiBjbS5maXJzdExpbmUoKSkge1xuICAgICAgcG9zID0gQ29kZU1pcnJvci5Qb3MocG9zLmxpbmUgLSAxLCAwKTtcbiAgICAgIHJhbmdlID0gZ2V0UmFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLmNsZWFyZWQgfHwgZm9yY2UgPT09IFwidW5mb2xkXCIpIHJldHVybjtcblxuICAgIHZhciBteVdpZGdldCA9IG1ha2VXaWRnZXQoY20sIG9wdGlvbnMsIHJhbmdlKTtcbiAgICBDb2RlTWlycm9yLm9uKG15V2lkZ2V0LCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICBteVJhbmdlLmNsZWFyKCk7XG4gICAgICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgfSk7XG4gICAgdmFyIG15UmFuZ2UgPSBjbS5tYXJrVGV4dChyYW5nZS5mcm9tLCByYW5nZS50bywge1xuICAgICAgcmVwbGFjZWRXaXRoOiBteVdpZGdldCxcbiAgICAgIGNsZWFyT25FbnRlcjogZ2V0T3B0aW9uKGNtLCBvcHRpb25zLCBcImNsZWFyT25FbnRlclwiKSxcbiAgICAgIF9faXNGb2xkOiB0cnVlXG4gICAgfSk7XG4gICAgbXlSYW5nZS5vbihcImNsZWFyXCIsIGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJ1bmZvbGRcIiwgY20sIGZyb20sIHRvKTtcbiAgICB9KTtcbiAgICBDb2RlTWlycm9yLnNpZ25hbChjbSwgXCJmb2xkXCIsIGNtLCByYW5nZS5mcm9tLCByYW5nZS50byk7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlV2lkZ2V0KGNtLCBvcHRpb25zLCByYW5nZSkge1xuICAgIHZhciB3aWRnZXQgPSBnZXRPcHRpb24oY20sIG9wdGlvbnMsIFwid2lkZ2V0XCIpO1xuXG4gICAgaWYgKHR5cGVvZiB3aWRnZXQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3aWRnZXQgPSB3aWRnZXQocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2lkZ2V0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUod2lkZ2V0KTtcbiAgICAgIHdpZGdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgd2lkZ2V0LmFwcGVuZENoaWxkKHRleHQpO1xuICAgICAgd2lkZ2V0LmNsYXNzTmFtZSA9IFwiQ29kZU1pcnJvci1mb2xkbWFya2VyXCI7XG4gICAgfSBlbHNlIGlmICh3aWRnZXQpIHtcbiAgICAgIHdpZGdldCA9IHdpZGdldC5jbG9uZU5vZGUodHJ1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHdpZGdldDtcbiAgfVxuXG4gIC8vIENsdW1zeSBiYWNrd2FyZHMtY29tcGF0aWJsZSBpbnRlcmZhY2VcbiAgQ29kZU1pcnJvci5uZXdGb2xkRnVuY3Rpb24gPSBmdW5jdGlvbihyYW5nZUZpbmRlciwgd2lkZ2V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNtLCBwb3MpIHsgZG9Gb2xkKGNtLCBwb3MsIHtyYW5nZUZpbmRlcjogcmFuZ2VGaW5kZXIsIHdpZGdldDogd2lkZ2V0fSk7IH07XG4gIH07XG5cbiAgLy8gTmV3LXN0eWxlIGludGVyZmFjZVxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbihcImZvbGRDb2RlXCIsIGZ1bmN0aW9uKHBvcywgb3B0aW9ucywgZm9yY2UpIHtcbiAgICBkb0ZvbGQodGhpcywgcG9zLCBvcHRpb25zLCBmb3JjZSk7XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lRXh0ZW5zaW9uKFwiaXNGb2xkZWRcIiwgZnVuY3Rpb24ocG9zKSB7XG4gICAgdmFyIG1hcmtzID0gdGhpcy5maW5kTWFya3NBdChwb3MpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyArK2kpXG4gICAgICBpZiAobWFya3NbaV0uX19pc0ZvbGQpIHJldHVybiB0cnVlO1xuICB9KTtcblxuICBDb2RlTWlycm9yLmNvbW1hbmRzLnRvZ2dsZUZvbGQgPSBmdW5jdGlvbihjbSkge1xuICAgIGNtLmZvbGRDb2RlKGNtLmdldEN1cnNvcigpKTtcbiAgfTtcbiAgQ29kZU1pcnJvci5jb21tYW5kcy5mb2xkID0gZnVuY3Rpb24oY20pIHtcbiAgICBjbS5mb2xkQ29kZShjbS5nZXRDdXJzb3IoKSwgbnVsbCwgXCJmb2xkXCIpO1xuICB9O1xuICBDb2RlTWlycm9yLmNvbW1hbmRzLnVuZm9sZCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgY20uZm9sZENvZGUoY20uZ2V0Q3Vyc29yKCksIG51bGwsIFwidW5mb2xkXCIpO1xuICB9O1xuICBDb2RlTWlycm9yLmNvbW1hbmRzLmZvbGRBbGwgPSBmdW5jdGlvbihjbSkge1xuICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSBjbS5maXJzdExpbmUoKSwgZSA9IGNtLmxhc3RMaW5lKCk7IGkgPD0gZTsgaSsrKVxuICAgICAgICBjbS5mb2xkQ29kZShDb2RlTWlycm9yLlBvcyhpLCAwKSwgbnVsbCwgXCJmb2xkXCIpO1xuICAgIH0pO1xuICB9O1xuICBDb2RlTWlycm9yLmNvbW1hbmRzLnVuZm9sZEFsbCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IGNtLmZpcnN0TGluZSgpLCBlID0gY20ubGFzdExpbmUoKTsgaSA8PSBlOyBpKyspXG4gICAgICAgIGNtLmZvbGRDb2RlKENvZGVNaXJyb3IuUG9zKGksIDApLCBudWxsLCBcInVuZm9sZFwiKTtcbiAgICB9KTtcbiAgfTtcblxuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiZm9sZFwiLCBcImNvbWJpbmVcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZ1bmNzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oY20sIHN0YXJ0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmb3VuZCA9IGZ1bmNzW2ldKGNtLCBzdGFydCk7XG4gICAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJmb2xkXCIsIFwiYXV0b1wiLCBmdW5jdGlvbihjbSwgc3RhcnQpIHtcbiAgICB2YXIgaGVscGVycyA9IGNtLmdldEhlbHBlcnMoc3RhcnQsIFwiZm9sZFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlbHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBoZWxwZXJzW2ldKGNtLCBzdGFydCk7XG4gICAgICBpZiAoY3VyKSByZXR1cm4gY3VyO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHJhbmdlRmluZGVyOiBDb2RlTWlycm9yLmZvbGQuYXV0byxcbiAgICB3aWRnZXQ6IFwiXFx1MjE5NFwiLFxuICAgIG1pbkZvbGRTaXplOiAwLFxuICAgIHNjYW5VcDogZmFsc2UsXG4gICAgY2xlYXJPbkVudGVyOiB0cnVlXG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVPcHRpb24oXCJmb2xkT3B0aW9uc1wiLCBudWxsKTtcblxuICBmdW5jdGlvbiBnZXRPcHRpb24oY20sIG9wdGlvbnMsIG5hbWUpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zW25hbWVdICE9PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gb3B0aW9uc1tuYW1lXTtcbiAgICB2YXIgZWRpdG9yT3B0aW9ucyA9IGNtLm9wdGlvbnMuZm9sZE9wdGlvbnM7XG4gICAgaWYgKGVkaXRvck9wdGlvbnMgJiYgZWRpdG9yT3B0aW9uc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGVkaXRvck9wdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIGRlZmF1bHRPcHRpb25zW25hbWVdO1xuICB9XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24oXCJmb2xkT3B0aW9uXCIsIGZ1bmN0aW9uKG9wdGlvbnMsIG5hbWUpIHtcbiAgICByZXR1cm4gZ2V0T3B0aW9uKHRoaXMsIG9wdGlvbnMsIG5hbWUpO1xuICB9KTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/foldcode.js\n')},"./node_modules/codemirror/addon/fold/foldgutter.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ./foldcode */ "./node_modules/codemirror/addon/fold/foldcode.js"));\n  else {}\n})(function(CodeMirror) {\n  "use strict";\n\n  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off("gutterClick", onGutterClick);\n      cm.off("changes", onChange);\n      cm.off("viewportChange", onViewportChange);\n      cm.off("fold", onFold);\n      cm.off("unfold", onFold);\n      cm.off("swapDoc", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on("gutterClick", onGutterClick);\n      cm.on("changes", onChange);\n      cm.on("viewportChange", onViewportChange);\n      cm.on("fold", onFold);\n      cm.on("unfold", onFold);\n      cm.on("swapDoc", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i) {\n      if (marks[i].__isFold) {\n        var fromPos = marks[i].find(-1);\n        if (fromPos && fromPos.line === line)\n          return marks[i];\n      }\n    }\n  }\n\n  function marker(spec) {\n    if (typeof spec == "string") {\n      var elt = document.createElement("div");\n      elt.className = spec + " CodeMirror-guttermarker-subtle";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from - 1;\n    var minSize = cm.foldOption(opts, "minFoldSize");\n    var func = cm.foldOption(opts, "rangeFinder");\n    // we can reuse the built-in indicator element if its className matches the new state\n    var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);\n    var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);\n    cm.eachLine(from, to, function(line) {\n      ++cur;\n      var mark = null;\n      var old = line.gutterMarkers;\n      if (old) old = old[opts.gutter];\n      if (isFolded(cm, cur)) {\n        if (clsFolded && old && clsFolded.test(old.className)) return;\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize) {\n          if (clsOpen && old && clsOpen.test(old.className)) return;\n          mark = marker(opts.indicatorOpen);\n        }\n      }\n      if (!mark && !old) return;\n      cm.setGutterMarker(line, opts.gutter, mark);\n    });\n  }\n\n  // copied from CodeMirror/src/util/dom.js\n  function classTest(cls) { return new RegExp("(^|\\\\s)" + cls + "(?:$|\\\\s)\\\\s*") }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9mb2xkZ3V0dGVyLmpzP2NiYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQixHQUFHLG1CQUFPLENBQUMsb0VBQVk7QUFDN0QsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCLEVBQUU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9mb2xkL2ZvbGRndXR0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpLCByZXF1aXJlKFwiLi9mb2xkY29kZVwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4vZm9sZGNvZGVcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uKFwiZm9sZEd1dHRlclwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgaWYgKG9sZCAmJiBvbGQgIT0gQ29kZU1pcnJvci5Jbml0KSB7XG4gICAgICBjbS5jbGVhckd1dHRlcihjbS5zdGF0ZS5mb2xkR3V0dGVyLm9wdGlvbnMuZ3V0dGVyKTtcbiAgICAgIGNtLnN0YXRlLmZvbGRHdXR0ZXIgPSBudWxsO1xuICAgICAgY20ub2ZmKFwiZ3V0dGVyQ2xpY2tcIiwgb25HdXR0ZXJDbGljayk7XG4gICAgICBjbS5vZmYoXCJjaGFuZ2VzXCIsIG9uQ2hhbmdlKTtcbiAgICAgIGNtLm9mZihcInZpZXdwb3J0Q2hhbmdlXCIsIG9uVmlld3BvcnRDaGFuZ2UpO1xuICAgICAgY20ub2ZmKFwiZm9sZFwiLCBvbkZvbGQpO1xuICAgICAgY20ub2ZmKFwidW5mb2xkXCIsIG9uRm9sZCk7XG4gICAgICBjbS5vZmYoXCJzd2FwRG9jXCIsIG9uQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKHZhbCkge1xuICAgICAgY20uc3RhdGUuZm9sZEd1dHRlciA9IG5ldyBTdGF0ZShwYXJzZU9wdGlvbnModmFsKSk7XG4gICAgICB1cGRhdGVJblZpZXdwb3J0KGNtKTtcbiAgICAgIGNtLm9uKFwiZ3V0dGVyQ2xpY2tcIiwgb25HdXR0ZXJDbGljayk7XG4gICAgICBjbS5vbihcImNoYW5nZXNcIiwgb25DaGFuZ2UpO1xuICAgICAgY20ub24oXCJ2aWV3cG9ydENoYW5nZVwiLCBvblZpZXdwb3J0Q2hhbmdlKTtcbiAgICAgIGNtLm9uKFwiZm9sZFwiLCBvbkZvbGQpO1xuICAgICAgY20ub24oXCJ1bmZvbGRcIiwgb25Gb2xkKTtcbiAgICAgIGNtLm9uKFwic3dhcERvY1wiLCBvbkNoYW5nZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgUG9zID0gQ29kZU1pcnJvci5Qb3M7XG5cbiAgZnVuY3Rpb24gU3RhdGUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5mcm9tID0gdGhpcy50byA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0cykge1xuICAgIGlmIChvcHRzID09PSB0cnVlKSBvcHRzID0ge307XG4gICAgaWYgKG9wdHMuZ3V0dGVyID09IG51bGwpIG9wdHMuZ3V0dGVyID0gXCJDb2RlTWlycm9yLWZvbGRndXR0ZXJcIjtcbiAgICBpZiAob3B0cy5pbmRpY2F0b3JPcGVuID09IG51bGwpIG9wdHMuaW5kaWNhdG9yT3BlbiA9IFwiQ29kZU1pcnJvci1mb2xkZ3V0dGVyLW9wZW5cIjtcbiAgICBpZiAob3B0cy5pbmRpY2F0b3JGb2xkZWQgPT0gbnVsbCkgb3B0cy5pbmRpY2F0b3JGb2xkZWQgPSBcIkNvZGVNaXJyb3ItZm9sZGd1dHRlci1mb2xkZWRcIjtcbiAgICByZXR1cm4gb3B0cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRm9sZGVkKGNtLCBsaW5lKSB7XG4gICAgdmFyIG1hcmtzID0gY20uZmluZE1hcmtzKFBvcyhsaW5lLCAwKSwgUG9zKGxpbmUgKyAxLCAwKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKG1hcmtzW2ldLl9faXNGb2xkKSB7XG4gICAgICAgIHZhciBmcm9tUG9zID0gbWFya3NbaV0uZmluZCgtMSk7XG4gICAgICAgIGlmIChmcm9tUG9zICYmIGZyb21Qb3MubGluZSA9PT0gbGluZSlcbiAgICAgICAgICByZXR1cm4gbWFya3NbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya2VyKHNwZWMpIHtcbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFyIGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbHQuY2xhc3NOYW1lID0gc3BlYyArIFwiIENvZGVNaXJyb3ItZ3V0dGVybWFya2VyLXN1YnRsZVwiO1xuICAgICAgcmV0dXJuIGVsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNwZWMuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZvbGRJbmZvKGNtLCBmcm9tLCB0bykge1xuICAgIHZhciBvcHRzID0gY20uc3RhdGUuZm9sZEd1dHRlci5vcHRpb25zLCBjdXIgPSBmcm9tIC0gMTtcbiAgICB2YXIgbWluU2l6ZSA9IGNtLmZvbGRPcHRpb24ob3B0cywgXCJtaW5Gb2xkU2l6ZVwiKTtcbiAgICB2YXIgZnVuYyA9IGNtLmZvbGRPcHRpb24ob3B0cywgXCJyYW5nZUZpbmRlclwiKTtcbiAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIGJ1aWx0LWluIGluZGljYXRvciBlbGVtZW50IGlmIGl0cyBjbGFzc05hbWUgbWF0Y2hlcyB0aGUgbmV3IHN0YXRlXG4gICAgdmFyIGNsc0ZvbGRlZCA9IHR5cGVvZiBvcHRzLmluZGljYXRvckZvbGRlZCA9PSBcInN0cmluZ1wiICYmIGNsYXNzVGVzdChvcHRzLmluZGljYXRvckZvbGRlZCk7XG4gICAgdmFyIGNsc09wZW4gPSB0eXBlb2Ygb3B0cy5pbmRpY2F0b3JPcGVuID09IFwic3RyaW5nXCIgJiYgY2xhc3NUZXN0KG9wdHMuaW5kaWNhdG9yT3Blbik7XG4gICAgY20uZWFjaExpbmUoZnJvbSwgdG8sIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICsrY3VyO1xuICAgICAgdmFyIG1hcmsgPSBudWxsO1xuICAgICAgdmFyIG9sZCA9IGxpbmUuZ3V0dGVyTWFya2VycztcbiAgICAgIGlmIChvbGQpIG9sZCA9IG9sZFtvcHRzLmd1dHRlcl07XG4gICAgICBpZiAoaXNGb2xkZWQoY20sIGN1cikpIHtcbiAgICAgICAgaWYgKGNsc0ZvbGRlZCAmJiBvbGQgJiYgY2xzRm9sZGVkLnRlc3Qob2xkLmNsYXNzTmFtZSkpIHJldHVybjtcbiAgICAgICAgbWFyayA9IG1hcmtlcihvcHRzLmluZGljYXRvckZvbGRlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9zID0gUG9zKGN1ciwgMCk7XG4gICAgICAgIHZhciByYW5nZSA9IGZ1bmMgJiYgZnVuYyhjbSwgcG9zKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLnRvLmxpbmUgLSByYW5nZS5mcm9tLmxpbmUgPj0gbWluU2l6ZSkge1xuICAgICAgICAgIGlmIChjbHNPcGVuICYmIG9sZCAmJiBjbHNPcGVuLnRlc3Qob2xkLmNsYXNzTmFtZSkpIHJldHVybjtcbiAgICAgICAgICBtYXJrID0gbWFya2VyKG9wdHMuaW5kaWNhdG9yT3Blbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbWFyayAmJiAhb2xkKSByZXR1cm47XG4gICAgICBjbS5zZXRHdXR0ZXJNYXJrZXIobGluZSwgb3B0cy5ndXR0ZXIsIG1hcmspO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY29waWVkIGZyb20gQ29kZU1pcnJvci9zcmMvdXRpbC9kb20uanNcbiAgZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xzICsgXCIoPzokfFxcXFxzKVxcXFxzKlwiKSB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSW5WaWV3cG9ydChjbSkge1xuICAgIHZhciB2cCA9IGNtLmdldFZpZXdwb3J0KCksIHN0YXRlID0gY20uc3RhdGUuZm9sZEd1dHRlcjtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgdXBkYXRlRm9sZEluZm8oY20sIHZwLmZyb20sIHZwLnRvKTtcbiAgICB9KTtcbiAgICBzdGF0ZS5mcm9tID0gdnAuZnJvbTsgc3RhdGUudG8gPSB2cC50bztcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uR3V0dGVyQ2xpY2soY20sIGxpbmUsIGd1dHRlcikge1xuICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmZvbGRHdXR0ZXI7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgIHZhciBvcHRzID0gc3RhdGUub3B0aW9ucztcbiAgICBpZiAoZ3V0dGVyICE9IG9wdHMuZ3V0dGVyKSByZXR1cm47XG4gICAgdmFyIGZvbGRlZCA9IGlzRm9sZGVkKGNtLCBsaW5lKTtcbiAgICBpZiAoZm9sZGVkKSBmb2xkZWQuY2xlYXIoKTtcbiAgICBlbHNlIGNtLmZvbGRDb2RlKFBvcyhsaW5lLCAwKSwgb3B0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZShjbSkge1xuICAgIHZhciBzdGF0ZSA9IGNtLnN0YXRlLmZvbGRHdXR0ZXI7XG4gICAgaWYgKCFzdGF0ZSkgcmV0dXJuO1xuICAgIHZhciBvcHRzID0gc3RhdGUub3B0aW9ucztcbiAgICBzdGF0ZS5mcm9tID0gc3RhdGUudG8gPSAwO1xuICAgIGNsZWFyVGltZW91dChzdGF0ZS5jaGFuZ2VVcGRhdGUpO1xuICAgIHN0YXRlLmNoYW5nZVVwZGF0ZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHVwZGF0ZUluVmlld3BvcnQoY20pOyB9LCBvcHRzLmZvbGRPbkNoYW5nZVRpbWVTcGFuIHx8IDYwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblZpZXdwb3J0Q2hhbmdlKGNtKSB7XG4gICAgdmFyIHN0YXRlID0gY20uc3RhdGUuZm9sZEd1dHRlcjtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdmFyIG9wdHMgPSBzdGF0ZS5vcHRpb25zO1xuICAgIGNsZWFyVGltZW91dChzdGF0ZS5jaGFuZ2VVcGRhdGUpO1xuICAgIHN0YXRlLmNoYW5nZVVwZGF0ZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdnAgPSBjbS5nZXRWaWV3cG9ydCgpO1xuICAgICAgaWYgKHN0YXRlLmZyb20gPT0gc3RhdGUudG8gfHwgdnAuZnJvbSAtIHN0YXRlLnRvID4gMjAgfHwgc3RhdGUuZnJvbSAtIHZwLnRvID4gMjApIHtcbiAgICAgICAgdXBkYXRlSW5WaWV3cG9ydChjbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHZwLmZyb20gPCBzdGF0ZS5mcm9tKSB7XG4gICAgICAgICAgICB1cGRhdGVGb2xkSW5mbyhjbSwgdnAuZnJvbSwgc3RhdGUuZnJvbSk7XG4gICAgICAgICAgICBzdGF0ZS5mcm9tID0gdnAuZnJvbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZwLnRvID4gc3RhdGUudG8pIHtcbiAgICAgICAgICAgIHVwZGF0ZUZvbGRJbmZvKGNtLCBzdGF0ZS50bywgdnAudG8pO1xuICAgICAgICAgICAgc3RhdGUudG8gPSB2cC50bztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIG9wdHMudXBkYXRlVmlld3BvcnRUaW1lU3BhbiB8fCA0MDApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Gb2xkKGNtLCBmcm9tKSB7XG4gICAgdmFyIHN0YXRlID0gY20uc3RhdGUuZm9sZEd1dHRlcjtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm47XG4gICAgdmFyIGxpbmUgPSBmcm9tLmxpbmU7XG4gICAgaWYgKGxpbmUgPj0gc3RhdGUuZnJvbSAmJiBsaW5lIDwgc3RhdGUudG8pXG4gICAgICB1cGRhdGVGb2xkSW5mbyhjbSwgbGluZSwgbGluZSArIDEpO1xuICB9XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/foldgutter.js\n')},"./node_modules/codemirror/addon/fold/indent-fold.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nfunction lineIndent(cm, lineNo) {\n  var text = cm.getLine(lineNo)\n  var spaceTo = text.search(/\\S/)\n  if (spaceTo == -1 || /\\bcomment\\b/.test(cm.getTokenTypeAt(CodeMirror.Pos(lineNo, spaceTo + 1))))\n    return -1\n  return CodeMirror.countColumn(text, null, cm.getOption("tabSize"))\n}\n\nCodeMirror.registerHelper("fold", "indent", function(cm, start) {\n  var myIndent = lineIndent(cm, start.line)\n  if (myIndent < 0) return\n  var lastLineInFold = null\n\n  // Go through lines until we find a line that definitely doesn\'t belong in\n  // the block we\'re folding, or to the end.\n  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {\n    var indent = lineIndent(cm, i)\n    if (indent == -1) {\n    } else if (indent > myIndent) {\n      // Lines with a greater indent are considered part of the block.\n      lastLineInFold = i;\n    } else {\n      // If this line has non-space, non-comment content, and is\n      // indented less or equal to the start line, it is the start of\n      // another block.\n      break;\n    }\n  }\n  if (lastLineInFold) return {\n    from: CodeMirror.Pos(start.line, cm.getLine(start.line).length),\n    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)\n  };\n});\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9pbmRlbnQtZm9sZC5qcz84ZDcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9pbmRlbnQtZm9sZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbGluZUluZGVudChjbSwgbGluZU5vKSB7XG4gIHZhciB0ZXh0ID0gY20uZ2V0TGluZShsaW5lTm8pXG4gIHZhciBzcGFjZVRvID0gdGV4dC5zZWFyY2goL1xcUy8pXG4gIGlmIChzcGFjZVRvID09IC0xIHx8IC9cXGJjb21tZW50XFxiLy50ZXN0KGNtLmdldFRva2VuVHlwZUF0KENvZGVNaXJyb3IuUG9zKGxpbmVObywgc3BhY2VUbyArIDEpKSkpXG4gICAgcmV0dXJuIC0xXG4gIHJldHVybiBDb2RlTWlycm9yLmNvdW50Q29sdW1uKHRleHQsIG51bGwsIGNtLmdldE9wdGlvbihcInRhYlNpemVcIikpXG59XG5cbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJmb2xkXCIsIFwiaW5kZW50XCIsIGZ1bmN0aW9uKGNtLCBzdGFydCkge1xuICB2YXIgbXlJbmRlbnQgPSBsaW5lSW5kZW50KGNtLCBzdGFydC5saW5lKVxuICBpZiAobXlJbmRlbnQgPCAwKSByZXR1cm5cbiAgdmFyIGxhc3RMaW5lSW5Gb2xkID0gbnVsbFxuXG4gIC8vIEdvIHRocm91Z2ggbGluZXMgdW50aWwgd2UgZmluZCBhIGxpbmUgdGhhdCBkZWZpbml0ZWx5IGRvZXNuJ3QgYmVsb25nIGluXG4gIC8vIHRoZSBibG9jayB3ZSdyZSBmb2xkaW5nLCBvciB0byB0aGUgZW5kLlxuICBmb3IgKHZhciBpID0gc3RhcnQubGluZSArIDEsIGVuZCA9IGNtLmxhc3RMaW5lKCk7IGkgPD0gZW5kOyArK2kpIHtcbiAgICB2YXIgaW5kZW50ID0gbGluZUluZGVudChjbSwgaSlcbiAgICBpZiAoaW5kZW50ID09IC0xKSB7XG4gICAgfSBlbHNlIGlmIChpbmRlbnQgPiBteUluZGVudCkge1xuICAgICAgLy8gTGluZXMgd2l0aCBhIGdyZWF0ZXIgaW5kZW50IGFyZSBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIGJsb2NrLlxuICAgICAgbGFzdExpbmVJbkZvbGQgPSBpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGlzIGxpbmUgaGFzIG5vbi1zcGFjZSwgbm9uLWNvbW1lbnQgY29udGVudCwgYW5kIGlzXG4gICAgICAvLyBpbmRlbnRlZCBsZXNzIG9yIGVxdWFsIHRvIHRoZSBzdGFydCBsaW5lLCBpdCBpcyB0aGUgc3RhcnQgb2ZcbiAgICAgIC8vIGFub3RoZXIgYmxvY2suXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RMaW5lSW5Gb2xkKSByZXR1cm4ge1xuICAgIGZyb206IENvZGVNaXJyb3IuUG9zKHN0YXJ0LmxpbmUsIGNtLmdldExpbmUoc3RhcnQubGluZSkubGVuZ3RoKSxcbiAgICB0bzogQ29kZU1pcnJvci5Qb3MobGFzdExpbmVJbkZvbGQsIGNtLmdldExpbmUobGFzdExpbmVJbkZvbGQpLmxlbmd0aClcbiAgfTtcbn0pO1xuXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/indent-fold.js\n')},"./node_modules/codemirror/addon/fold/markdown-fold.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nCodeMirror.registerHelper("fold", "markdown", function(cm, start) {\n  var maxDepth = 100;\n\n  function isHeader(lineNo) {\n    var tokentype = cm.getTokenTypeAt(CodeMirror.Pos(lineNo, 0));\n    return tokentype && /\\bheader\\b/.test(tokentype);\n  }\n\n  function headerLevel(lineNo, line, nextLine) {\n    var match = line && line.match(/^#+/);\n    if (match && isHeader(lineNo)) return match[0].length;\n    match = nextLine && nextLine.match(/^[=\\-]+\\s*$/);\n    if (match && isHeader(lineNo + 1)) return nextLine[0] == "=" ? 1 : 2;\n    return maxDepth;\n  }\n\n  var firstLine = cm.getLine(start.line), nextLine = cm.getLine(start.line + 1);\n  var level = headerLevel(start.line, firstLine, nextLine);\n  if (level === maxDepth) return undefined;\n\n  var lastLineNo = cm.lastLine();\n  var end = start.line, nextNextLine = cm.getLine(end + 2);\n  while (end < lastLineNo) {\n    if (headerLevel(end + 1, nextLine, nextNextLine) <= level) break;\n    ++end;\n    nextLine = nextNextLine;\n    nextNextLine = cm.getLine(end + 2);\n  }\n\n  return {\n    from: CodeMirror.Pos(start.line, firstLine.length),\n    to: CodeMirror.Pos(end, cm.getLine(end).length)\n  };\n});\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC9tYXJrZG93bi1mb2xkLmpzPzlmMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9mb2xkL21hcmtkb3duLWZvbGQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbkNvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIoXCJmb2xkXCIsIFwibWFya2Rvd25cIiwgZnVuY3Rpb24oY20sIHN0YXJ0KSB7XG4gIHZhciBtYXhEZXB0aCA9IDEwMDtcblxuICBmdW5jdGlvbiBpc0hlYWRlcihsaW5lTm8pIHtcbiAgICB2YXIgdG9rZW50eXBlID0gY20uZ2V0VG9rZW5UeXBlQXQoQ29kZU1pcnJvci5Qb3MobGluZU5vLCAwKSk7XG4gICAgcmV0dXJuIHRva2VudHlwZSAmJiAvXFxiaGVhZGVyXFxiLy50ZXN0KHRva2VudHlwZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoZWFkZXJMZXZlbChsaW5lTm8sIGxpbmUsIG5leHRMaW5lKSB7XG4gICAgdmFyIG1hdGNoID0gbGluZSAmJiBsaW5lLm1hdGNoKC9eIysvKTtcbiAgICBpZiAobWF0Y2ggJiYgaXNIZWFkZXIobGluZU5vKSkgcmV0dXJuIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBtYXRjaCA9IG5leHRMaW5lICYmIG5leHRMaW5lLm1hdGNoKC9eWz1cXC1dK1xccyokLyk7XG4gICAgaWYgKG1hdGNoICYmIGlzSGVhZGVyKGxpbmVObyArIDEpKSByZXR1cm4gbmV4dExpbmVbMF0gPT0gXCI9XCIgPyAxIDogMjtcbiAgICByZXR1cm4gbWF4RGVwdGg7XG4gIH1cblxuICB2YXIgZmlyc3RMaW5lID0gY20uZ2V0TGluZShzdGFydC5saW5lKSwgbmV4dExpbmUgPSBjbS5nZXRMaW5lKHN0YXJ0LmxpbmUgKyAxKTtcbiAgdmFyIGxldmVsID0gaGVhZGVyTGV2ZWwoc3RhcnQubGluZSwgZmlyc3RMaW5lLCBuZXh0TGluZSk7XG4gIGlmIChsZXZlbCA9PT0gbWF4RGVwdGgpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgdmFyIGxhc3RMaW5lTm8gPSBjbS5sYXN0TGluZSgpO1xuICB2YXIgZW5kID0gc3RhcnQubGluZSwgbmV4dE5leHRMaW5lID0gY20uZ2V0TGluZShlbmQgKyAyKTtcbiAgd2hpbGUgKGVuZCA8IGxhc3RMaW5lTm8pIHtcbiAgICBpZiAoaGVhZGVyTGV2ZWwoZW5kICsgMSwgbmV4dExpbmUsIG5leHROZXh0TGluZSkgPD0gbGV2ZWwpIGJyZWFrO1xuICAgICsrZW5kO1xuICAgIG5leHRMaW5lID0gbmV4dE5leHRMaW5lO1xuICAgIG5leHROZXh0TGluZSA9IGNtLmdldExpbmUoZW5kICsgMik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZyb206IENvZGVNaXJyb3IuUG9zKHN0YXJ0LmxpbmUsIGZpcnN0TGluZS5sZW5ndGgpLFxuICAgIHRvOiBDb2RlTWlycm9yLlBvcyhlbmQsIGNtLmdldExpbmUoZW5kKS5sZW5ndGgpXG4gIH07XG59KTtcblxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/markdown-fold.js\n')},"./node_modules/codemirror/addon/fold/xml-fold.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n  "use strict";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = "A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD";\n  var nameChar = nameStartChar + "\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040";\n  var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(">", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf("/", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? "selfClose" : "regular";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf("/", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? "selfClose" : "regular";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == "selfClose") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == "selfClose") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper("fold", "xml", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter)\n      if (!openTag || iter.line != start.line) return\n      var end = toTagEnd(iter)\n      if (!end) return\n      if (!openTag[1] && end != "selfClose") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && cmp(endPos.from, startPos) > 0 ? {from: startPos, to: endPos.from} : null\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == "selfClose") return {open: here, close: null, at: "open"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: "close"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: "open"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vZm9sZC94bWwtZm9sZC5qcz9hMmMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXVEO0FBQzdELFFBQVEsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDdEMsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBLHNCQUFzQix1Q0FBdUM7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHFCQUFxQiw4QkFBOEIsYUFBYTtBQUNoRSxpQ0FBaUMsa0JBQWtCLFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxxQkFBcUIsOEJBQThCLGFBQWE7QUFDaEUsaUNBQWlDLGNBQWMsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEIsYUFBYTtBQUM5RCwwQ0FBMEMsMkJBQTJCLFVBQVU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHFCQUFxQiw4QkFBOEIsYUFBYTtBQUNoRSxpQ0FBaUMsY0FBYyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLFVBQVU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsT0FBTyxPQUFPO0FBQ2Qsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdDQUFnQztBQUMzRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixvQ0FBb0M7O0FBRXBDLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsS0FBSyxPQUFPO0FBQ1o7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUI7QUFDdEU7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9mb2xkL3htbC1mb2xkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIFBvcyA9IENvZGVNaXJyb3IuUG9zO1xuICBmdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYS5saW5lIC0gYi5saW5lIHx8IGEuY2ggLSBiLmNoOyB9XG5cbiAgdmFyIG5hbWVTdGFydENoYXIgPSBcIkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuICB2YXIgbmFtZUNoYXIgPSBuYW1lU3RhcnRDaGFyICsgXCJcXC1cXDpcXC4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuICB2YXIgeG1sVGFnU3RhcnQgPSBuZXcgUmVnRXhwKFwiPCgvPykoW1wiICsgbmFtZVN0YXJ0Q2hhciArIFwiXVtcIiArIG5hbWVDaGFyICsgXCJdKilcIiwgXCJnXCIpO1xuXG4gIGZ1bmN0aW9uIEl0ZXIoY20sIGxpbmUsIGNoLCByYW5nZSkge1xuICAgIHRoaXMubGluZSA9IGxpbmU7IHRoaXMuY2ggPSBjaDtcbiAgICB0aGlzLmNtID0gY207IHRoaXMudGV4dCA9IGNtLmdldExpbmUobGluZSk7XG4gICAgdGhpcy5taW4gPSByYW5nZSA/IE1hdGgubWF4KHJhbmdlLmZyb20sIGNtLmZpcnN0TGluZSgpKSA6IGNtLmZpcnN0TGluZSgpO1xuICAgIHRoaXMubWF4ID0gcmFuZ2UgPyBNYXRoLm1pbihyYW5nZS50byAtIDEsIGNtLmxhc3RMaW5lKCkpIDogY20ubGFzdExpbmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRhZ0F0KGl0ZXIsIGNoKSB7XG4gICAgdmFyIHR5cGUgPSBpdGVyLmNtLmdldFRva2VuVHlwZUF0KFBvcyhpdGVyLmxpbmUsIGNoKSk7XG4gICAgcmV0dXJuIHR5cGUgJiYgL1xcYnRhZ1xcYi8udGVzdCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRMaW5lKGl0ZXIpIHtcbiAgICBpZiAoaXRlci5saW5lID49IGl0ZXIubWF4KSByZXR1cm47XG4gICAgaXRlci5jaCA9IDA7XG4gICAgaXRlci50ZXh0ID0gaXRlci5jbS5nZXRMaW5lKCsraXRlci5saW5lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBwcmV2TGluZShpdGVyKSB7XG4gICAgaWYgKGl0ZXIubGluZSA8PSBpdGVyLm1pbikgcmV0dXJuO1xuICAgIGl0ZXIudGV4dCA9IGl0ZXIuY20uZ2V0TGluZSgtLWl0ZXIubGluZSk7XG4gICAgaXRlci5jaCA9IGl0ZXIudGV4dC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB0b1RhZ0VuZChpdGVyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGd0ID0gaXRlci50ZXh0LmluZGV4T2YoXCI+XCIsIGl0ZXIuY2gpO1xuICAgICAgaWYgKGd0ID09IC0xKSB7IGlmIChuZXh0TGluZShpdGVyKSkgY29udGludWU7IGVsc2UgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRhZ0F0KGl0ZXIsIGd0ICsgMSkpIHsgaXRlci5jaCA9IGd0ICsgMTsgY29udGludWU7IH1cbiAgICAgIHZhciBsYXN0U2xhc2ggPSBpdGVyLnRleHQubGFzdEluZGV4T2YoXCIvXCIsIGd0KTtcbiAgICAgIHZhciBzZWxmQ2xvc2UgPSBsYXN0U2xhc2ggPiAtMSAmJiAhL1xcUy8udGVzdChpdGVyLnRleHQuc2xpY2UobGFzdFNsYXNoICsgMSwgZ3QpKTtcbiAgICAgIGl0ZXIuY2ggPSBndCArIDE7XG4gICAgICByZXR1cm4gc2VsZkNsb3NlID8gXCJzZWxmQ2xvc2VcIiA6IFwicmVndWxhclwiO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b1RhZ1N0YXJ0KGl0ZXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbHQgPSBpdGVyLmNoID8gaXRlci50ZXh0Lmxhc3RJbmRleE9mKFwiPFwiLCBpdGVyLmNoIC0gMSkgOiAtMTtcbiAgICAgIGlmIChsdCA9PSAtMSkgeyBpZiAocHJldkxpbmUoaXRlcikpIGNvbnRpbnVlOyBlbHNlIHJldHVybjsgfVxuICAgICAgaWYgKCF0YWdBdChpdGVyLCBsdCArIDEpKSB7IGl0ZXIuY2ggPSBsdDsgY29udGludWU7IH1cbiAgICAgIHhtbFRhZ1N0YXJ0Lmxhc3RJbmRleCA9IGx0O1xuICAgICAgaXRlci5jaCA9IGx0O1xuICAgICAgdmFyIG1hdGNoID0geG1sVGFnU3RhcnQuZXhlYyhpdGVyLnRleHQpO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID09IGx0KSByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9OZXh0VGFnKGl0ZXIpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB4bWxUYWdTdGFydC5sYXN0SW5kZXggPSBpdGVyLmNoO1xuICAgICAgdmFyIGZvdW5kID0geG1sVGFnU3RhcnQuZXhlYyhpdGVyLnRleHQpO1xuICAgICAgaWYgKCFmb3VuZCkgeyBpZiAobmV4dExpbmUoaXRlcikpIGNvbnRpbnVlOyBlbHNlIHJldHVybjsgfVxuICAgICAgaWYgKCF0YWdBdChpdGVyLCBmb3VuZC5pbmRleCArIDEpKSB7IGl0ZXIuY2ggPSBmb3VuZC5pbmRleCArIDE7IGNvbnRpbnVlOyB9XG4gICAgICBpdGVyLmNoID0gZm91bmQuaW5kZXggKyBmb3VuZFswXS5sZW5ndGg7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRvUHJldlRhZyhpdGVyKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGd0ID0gaXRlci5jaCA/IGl0ZXIudGV4dC5sYXN0SW5kZXhPZihcIj5cIiwgaXRlci5jaCAtIDEpIDogLTE7XG4gICAgICBpZiAoZ3QgPT0gLTEpIHsgaWYgKHByZXZMaW5lKGl0ZXIpKSBjb250aW51ZTsgZWxzZSByZXR1cm47IH1cbiAgICAgIGlmICghdGFnQXQoaXRlciwgZ3QgKyAxKSkgeyBpdGVyLmNoID0gZ3Q7IGNvbnRpbnVlOyB9XG4gICAgICB2YXIgbGFzdFNsYXNoID0gaXRlci50ZXh0Lmxhc3RJbmRleE9mKFwiL1wiLCBndCk7XG4gICAgICB2YXIgc2VsZkNsb3NlID0gbGFzdFNsYXNoID4gLTEgJiYgIS9cXFMvLnRlc3QoaXRlci50ZXh0LnNsaWNlKGxhc3RTbGFzaCArIDEsIGd0KSk7XG4gICAgICBpdGVyLmNoID0gZ3QgKyAxO1xuICAgICAgcmV0dXJuIHNlbGZDbG9zZSA/IFwic2VsZkNsb3NlXCIgOiBcInJlZ3VsYXJcIjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdDbG9zZShpdGVyLCB0YWcpIHtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgbmV4dCA9IHRvTmV4dFRhZyhpdGVyKSwgZW5kLCBzdGFydExpbmUgPSBpdGVyLmxpbmUsIHN0YXJ0Q2ggPSBpdGVyLmNoIC0gKG5leHQgPyBuZXh0WzBdLmxlbmd0aCA6IDApO1xuICAgICAgaWYgKCFuZXh0IHx8ICEoZW5kID0gdG9UYWdFbmQoaXRlcikpKSByZXR1cm47XG4gICAgICBpZiAoZW5kID09IFwic2VsZkNsb3NlXCIpIGNvbnRpbnVlO1xuICAgICAgaWYgKG5leHRbMV0pIHsgLy8gY2xvc2luZyB0YWdcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBpZiAoc3RhY2tbaV0gPT0gbmV4dFsyXSkge1xuICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCAwICYmICghdGFnIHx8IHRhZyA9PSBuZXh0WzJdKSkgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IG5leHRbMl0sXG4gICAgICAgICAgZnJvbTogUG9zKHN0YXJ0TGluZSwgc3RhcnRDaCksXG4gICAgICAgICAgdG86IFBvcyhpdGVyLmxpbmUsIGl0ZXIuY2gpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgeyAvLyBvcGVuaW5nIHRhZ1xuICAgICAgICBzdGFjay5wdXNoKG5leHRbMl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdPcGVuKGl0ZXIsIHRhZykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBwcmV2ID0gdG9QcmV2VGFnKGl0ZXIpO1xuICAgICAgaWYgKCFwcmV2KSByZXR1cm47XG4gICAgICBpZiAocHJldiA9PSBcInNlbGZDbG9zZVwiKSB7IHRvVGFnU3RhcnQoaXRlcik7IGNvbnRpbnVlOyB9XG4gICAgICB2YXIgZW5kTGluZSA9IGl0ZXIubGluZSwgZW5kQ2ggPSBpdGVyLmNoO1xuICAgICAgdmFyIHN0YXJ0ID0gdG9UYWdTdGFydChpdGVyKTtcbiAgICAgIGlmICghc3RhcnQpIHJldHVybjtcbiAgICAgIGlmIChzdGFydFsxXSkgeyAvLyBjbG9zaW5nIHRhZ1xuICAgICAgICBzdGFjay5wdXNoKHN0YXJ0WzJdKTtcbiAgICAgIH0gZWxzZSB7IC8vIG9wZW5pbmcgdGFnXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgaWYgKHN0YWNrW2ldID09IHN0YXJ0WzJdKSB7XG4gICAgICAgICAgc3RhY2subGVuZ3RoID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA8IDAgJiYgKCF0YWcgfHwgdGFnID09IHN0YXJ0WzJdKSkgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IHN0YXJ0WzJdLFxuICAgICAgICAgIGZyb206IFBvcyhpdGVyLmxpbmUsIGl0ZXIuY2gpLFxuICAgICAgICAgIHRvOiBQb3MoZW5kTGluZSwgZW5kQ2gpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcImZvbGRcIiwgXCJ4bWxcIiwgZnVuY3Rpb24oY20sIHN0YXJ0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgSXRlcihjbSwgc3RhcnQubGluZSwgMCk7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIG9wZW5UYWcgPSB0b05leHRUYWcoaXRlcilcbiAgICAgIGlmICghb3BlblRhZyB8fCBpdGVyLmxpbmUgIT0gc3RhcnQubGluZSkgcmV0dXJuXG4gICAgICB2YXIgZW5kID0gdG9UYWdFbmQoaXRlcilcbiAgICAgIGlmICghZW5kKSByZXR1cm5cbiAgICAgIGlmICghb3BlblRhZ1sxXSAmJiBlbmQgIT0gXCJzZWxmQ2xvc2VcIikge1xuICAgICAgICB2YXIgc3RhcnRQb3MgPSBQb3MoaXRlci5saW5lLCBpdGVyLmNoKTtcbiAgICAgICAgdmFyIGVuZFBvcyA9IGZpbmRNYXRjaGluZ0Nsb3NlKGl0ZXIsIG9wZW5UYWdbMl0pO1xuICAgICAgICByZXR1cm4gZW5kUG9zICYmIGNtcChlbmRQb3MuZnJvbSwgc3RhcnRQb3MpID4gMCA/IHtmcm9tOiBzdGFydFBvcywgdG86IGVuZFBvcy5mcm9tfSA6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBDb2RlTWlycm9yLmZpbmRNYXRjaGluZ1RhZyA9IGZ1bmN0aW9uKGNtLCBwb3MsIHJhbmdlKSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgSXRlcihjbSwgcG9zLmxpbmUsIHBvcy5jaCwgcmFuZ2UpO1xuICAgIGlmIChpdGVyLnRleHQuaW5kZXhPZihcIj5cIikgPT0gLTEgJiYgaXRlci50ZXh0LmluZGV4T2YoXCI8XCIpID09IC0xKSByZXR1cm47XG4gICAgdmFyIGVuZCA9IHRvVGFnRW5kKGl0ZXIpLCB0byA9IGVuZCAmJiBQb3MoaXRlci5saW5lLCBpdGVyLmNoKTtcbiAgICB2YXIgc3RhcnQgPSBlbmQgJiYgdG9UYWdTdGFydChpdGVyKTtcbiAgICBpZiAoIWVuZCB8fCAhc3RhcnQgfHwgY21wKGl0ZXIsIHBvcykgPiAwKSByZXR1cm47XG4gICAgdmFyIGhlcmUgPSB7ZnJvbTogUG9zKGl0ZXIubGluZSwgaXRlci5jaCksIHRvOiB0bywgdGFnOiBzdGFydFsyXX07XG4gICAgaWYgKGVuZCA9PSBcInNlbGZDbG9zZVwiKSByZXR1cm4ge29wZW46IGhlcmUsIGNsb3NlOiBudWxsLCBhdDogXCJvcGVuXCJ9O1xuXG4gICAgaWYgKHN0YXJ0WzFdKSB7IC8vIGNsb3NpbmcgdGFnXG4gICAgICByZXR1cm4ge29wZW46IGZpbmRNYXRjaGluZ09wZW4oaXRlciwgc3RhcnRbMl0pLCBjbG9zZTogaGVyZSwgYXQ6IFwiY2xvc2VcIn07XG4gICAgfSBlbHNlIHsgLy8gb3BlbmluZyB0YWdcbiAgICAgIGl0ZXIgPSBuZXcgSXRlcihjbSwgdG8ubGluZSwgdG8uY2gsIHJhbmdlKTtcbiAgICAgIHJldHVybiB7b3BlbjogaGVyZSwgY2xvc2U6IGZpbmRNYXRjaGluZ0Nsb3NlKGl0ZXIsIHN0YXJ0WzJdKSwgYXQ6IFwib3BlblwifTtcbiAgICB9XG4gIH07XG5cbiAgQ29kZU1pcnJvci5maW5kRW5jbG9zaW5nVGFnID0gZnVuY3Rpb24oY20sIHBvcywgcmFuZ2UsIHRhZykge1xuICAgIHZhciBpdGVyID0gbmV3IEl0ZXIoY20sIHBvcy5saW5lLCBwb3MuY2gsIHJhbmdlKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgb3BlbiA9IGZpbmRNYXRjaGluZ09wZW4oaXRlciwgdGFnKTtcbiAgICAgIGlmICghb3BlbikgYnJlYWs7XG4gICAgICB2YXIgZm9yd2FyZCA9IG5ldyBJdGVyKGNtLCBwb3MubGluZSwgcG9zLmNoLCByYW5nZSk7XG4gICAgICB2YXIgY2xvc2UgPSBmaW5kTWF0Y2hpbmdDbG9zZShmb3J3YXJkLCBvcGVuLnRhZyk7XG4gICAgICBpZiAoY2xvc2UpIHJldHVybiB7b3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBieSBhZGRvbi9lZGl0L2Nsb3NldGFnLmpzXG4gIENvZGVNaXJyb3Iuc2NhbkZvckNsb3NpbmdUYWcgPSBmdW5jdGlvbihjbSwgcG9zLCBuYW1lLCBlbmQpIHtcbiAgICB2YXIgaXRlciA9IG5ldyBJdGVyKGNtLCBwb3MubGluZSwgcG9zLmNoLCBlbmQgPyB7ZnJvbTogMCwgdG86IGVuZH0gOiBudWxsKTtcbiAgICByZXR1cm4gZmluZE1hdGNoaW5nQ2xvc2UoaXRlciwgbmFtZSk7XG4gIH07XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/fold/xml-fold.js\n')},"./node_modules/codemirror/addon/scroll/simplescrollbars.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n  "use strict";\n\n  function Bar(cls, orientation, scroll) {\n    this.orientation = orientation;\n    this.scroll = scroll;\n    this.screen = this.total = this.size = 1;\n    this.pos = 0;\n\n    this.node = document.createElement("div");\n    this.node.className = cls + "-" + orientation;\n    this.inner = this.node.appendChild(document.createElement("div"));\n\n    var self = this;\n    CodeMirror.on(this.inner, "mousedown", function(e) {\n      if (e.which != 1) return;\n      CodeMirror.e_preventDefault(e);\n      var axis = self.orientation == "horizontal" ? "pageX" : "pageY";\n      var start = e[axis], startpos = self.pos;\n      function done() {\n        CodeMirror.off(document, "mousemove", move);\n        CodeMirror.off(document, "mouseup", done);\n      }\n      function move(e) {\n        if (e.which != 1) return done();\n        self.moveTo(startpos + (e[axis] - start) * (self.total / self.size));\n      }\n      CodeMirror.on(document, "mousemove", move);\n      CodeMirror.on(document, "mouseup", done);\n    });\n\n    CodeMirror.on(this.node, "click", function(e) {\n      CodeMirror.e_preventDefault(e);\n      var innerBox = self.inner.getBoundingClientRect(), where;\n      if (self.orientation == "horizontal")\n        where = e.clientX < innerBox.left ? -1 : e.clientX > innerBox.right ? 1 : 0;\n      else\n        where = e.clientY < innerBox.top ? -1 : e.clientY > innerBox.bottom ? 1 : 0;\n      self.moveTo(self.pos + where * self.screen);\n    });\n\n    function onWheel(e) {\n      var moved = CodeMirror.wheelEventPixels(e)[self.orientation == "horizontal" ? "x" : "y"];\n      var oldPos = self.pos;\n      self.moveTo(self.pos + moved);\n      if (self.pos != oldPos) CodeMirror.e_preventDefault(e);\n    }\n    CodeMirror.on(this.node, "mousewheel", onWheel);\n    CodeMirror.on(this.node, "DOMMouseScroll", onWheel);\n  }\n\n  Bar.prototype.setPos = function(pos, force) {\n    if (pos < 0) pos = 0;\n    if (pos > this.total - this.screen) pos = this.total - this.screen;\n    if (!force && pos == this.pos) return false;\n    this.pos = pos;\n    this.inner.style[this.orientation == "horizontal" ? "left" : "top"] =\n      (pos * (this.size / this.total)) + "px";\n    return true\n  };\n\n  Bar.prototype.moveTo = function(pos) {\n    if (this.setPos(pos)) this.scroll(pos, this.orientation);\n  }\n\n  var minButtonSize = 10;\n\n  Bar.prototype.update = function(scrollSize, clientSize, barSize) {\n    var sizeChanged = this.screen != clientSize || this.total != scrollSize || this.size != barSize\n    if (sizeChanged) {\n      this.screen = clientSize;\n      this.total = scrollSize;\n      this.size = barSize;\n    }\n\n    var buttonSize = this.screen * (this.size / this.total);\n    if (buttonSize < minButtonSize) {\n      this.size -= minButtonSize - buttonSize;\n      buttonSize = minButtonSize;\n    }\n    this.inner.style[this.orientation == "horizontal" ? "width" : "height"] =\n      buttonSize + "px";\n    this.setPos(this.pos, sizeChanged);\n  };\n\n  function SimpleScrollbars(cls, place, scroll) {\n    this.addClass = cls;\n    this.horiz = new Bar(cls, "horizontal", scroll);\n    place(this.horiz.node);\n    this.vert = new Bar(cls, "vertical", scroll);\n    place(this.vert.node);\n    this.width = null;\n  }\n\n  SimpleScrollbars.prototype.update = function(measure) {\n    if (this.width == null) {\n      var style = window.getComputedStyle ? window.getComputedStyle(this.horiz.node) : this.horiz.node.currentStyle;\n      if (style) this.width = parseInt(style.height);\n    }\n    var width = this.width || 0;\n\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    this.vert.node.style.display = needsV ? "block" : "none";\n    this.horiz.node.style.display = needsH ? "block" : "none";\n\n    if (needsV) {\n      this.vert.update(measure.scrollHeight, measure.clientHeight,\n                       measure.viewHeight - (needsH ? width : 0));\n      this.vert.node.style.bottom = needsH ? width + "px" : "0";\n    }\n    if (needsH) {\n      this.horiz.update(measure.scrollWidth, measure.clientWidth,\n                        measure.viewWidth - (needsV ? width : 0) - measure.barLeft);\n      this.horiz.node.style.right = needsV ? width + "px" : "0";\n      this.horiz.node.style.left = measure.barLeft + "px";\n    }\n\n    return {right: needsV ? width : 0, bottom: needsH ? width : 0};\n  };\n\n  SimpleScrollbars.prototype.setScrollTop = function(pos) {\n    this.vert.setPos(pos);\n  };\n\n  SimpleScrollbars.prototype.setScrollLeft = function(pos) {\n    this.horiz.setPos(pos);\n  };\n\n  SimpleScrollbars.prototype.clear = function() {\n    var parent = this.horiz.node.parentNode;\n    parent.removeChild(this.horiz.node);\n    parent.removeChild(this.vert.node);\n  };\n\n  CodeMirror.scrollbarModel.simple = function(place, scroll) {\n    return new SimpleScrollbars("CodeMirror-simplescroll", place, scroll);\n  };\n  CodeMirror.scrollbarModel.overlay = function(place, scroll) {\n    return new SimpleScrollbars("CodeMirror-overlayscroll", place, scroll);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2Nyb2xsL3NpbXBsZXNjcm9sbGJhcnMuanM/MWZkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMseUVBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2FkZG9uL3Njcm9sbC9zaW1wbGVzY3JvbGxiYXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZnVuY3Rpb24gQmFyKGNscywgb3JpZW50YXRpb24sIHNjcm9sbCkge1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB0aGlzLnNjcmVlbiA9IHRoaXMudG90YWwgPSB0aGlzLnNpemUgPSAxO1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5ub2RlLmNsYXNzTmFtZSA9IGNscyArIFwiLVwiICsgb3JpZW50YXRpb247XG4gICAgdGhpcy5pbm5lciA9IHRoaXMubm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBDb2RlTWlycm9yLm9uKHRoaXMuaW5uZXIsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLndoaWNoICE9IDEpIHJldHVybjtcbiAgICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHZhciBheGlzID0gc2VsZi5vcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIiA/IFwicGFnZVhcIiA6IFwicGFnZVlcIjtcbiAgICAgIHZhciBzdGFydCA9IGVbYXhpc10sIHN0YXJ0cG9zID0gc2VsZi5wb3M7XG4gICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICBDb2RlTWlycm9yLm9mZihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgICAgIENvZGVNaXJyb3Iub2ZmKGRvY3VtZW50LCBcIm1vdXNldXBcIiwgZG9uZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3ZlKGUpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggIT0gMSkgcmV0dXJuIGRvbmUoKTtcbiAgICAgICAgc2VsZi5tb3ZlVG8oc3RhcnRwb3MgKyAoZVtheGlzXSAtIHN0YXJ0KSAqIChzZWxmLnRvdGFsIC8gc2VsZi5zaXplKSk7XG4gICAgICB9XG4gICAgICBDb2RlTWlycm9yLm9uKGRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3ZlKTtcbiAgICAgIENvZGVNaXJyb3Iub24oZG9jdW1lbnQsIFwibW91c2V1cFwiLCBkb25lKTtcbiAgICB9KTtcblxuICAgIENvZGVNaXJyb3Iub24odGhpcy5ub2RlLCBcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHZhciBpbm5lckJveCA9IHNlbGYuaW5uZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdoZXJlO1xuICAgICAgaWYgKHNlbGYub3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIpXG4gICAgICAgIHdoZXJlID0gZS5jbGllbnRYIDwgaW5uZXJCb3gubGVmdCA/IC0xIDogZS5jbGllbnRYID4gaW5uZXJCb3gucmlnaHQgPyAxIDogMDtcbiAgICAgIGVsc2VcbiAgICAgICAgd2hlcmUgPSBlLmNsaWVudFkgPCBpbm5lckJveC50b3AgPyAtMSA6IGUuY2xpZW50WSA+IGlubmVyQm94LmJvdHRvbSA/IDEgOiAwO1xuICAgICAgc2VsZi5tb3ZlVG8oc2VsZi5wb3MgKyB3aGVyZSAqIHNlbGYuc2NyZWVuKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG9uV2hlZWwoZSkge1xuICAgICAgdmFyIG1vdmVkID0gQ29kZU1pcnJvci53aGVlbEV2ZW50UGl4ZWxzKGUpW3NlbGYub3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIgPyBcInhcIiA6IFwieVwiXTtcbiAgICAgIHZhciBvbGRQb3MgPSBzZWxmLnBvcztcbiAgICAgIHNlbGYubW92ZVRvKHNlbGYucG9zICsgbW92ZWQpO1xuICAgICAgaWYgKHNlbGYucG9zICE9IG9sZFBvcykgQ29kZU1pcnJvci5lX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgIH1cbiAgICBDb2RlTWlycm9yLm9uKHRoaXMubm9kZSwgXCJtb3VzZXdoZWVsXCIsIG9uV2hlZWwpO1xuICAgIENvZGVNaXJyb3Iub24odGhpcy5ub2RlLCBcIkRPTU1vdXNlU2Nyb2xsXCIsIG9uV2hlZWwpO1xuICB9XG5cbiAgQmFyLnByb3RvdHlwZS5zZXRQb3MgPSBmdW5jdGlvbihwb3MsIGZvcmNlKSB7XG4gICAgaWYgKHBvcyA8IDApIHBvcyA9IDA7XG4gICAgaWYgKHBvcyA+IHRoaXMudG90YWwgLSB0aGlzLnNjcmVlbikgcG9zID0gdGhpcy50b3RhbCAtIHRoaXMuc2NyZWVuO1xuICAgIGlmICghZm9yY2UgJiYgcG9zID09IHRoaXMucG9zKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5pbm5lci5zdHlsZVt0aGlzLm9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiID8gXCJsZWZ0XCIgOiBcInRvcFwiXSA9XG4gICAgICAocG9zICogKHRoaXMuc2l6ZSAvIHRoaXMudG90YWwpKSArIFwicHhcIjtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIEJhci5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgaWYgKHRoaXMuc2V0UG9zKHBvcykpIHRoaXMuc2Nyb2xsKHBvcywgdGhpcy5vcmllbnRhdGlvbik7XG4gIH1cblxuICB2YXIgbWluQnV0dG9uU2l6ZSA9IDEwO1xuXG4gIEJhci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oc2Nyb2xsU2l6ZSwgY2xpZW50U2l6ZSwgYmFyU2l6ZSkge1xuICAgIHZhciBzaXplQ2hhbmdlZCA9IHRoaXMuc2NyZWVuICE9IGNsaWVudFNpemUgfHwgdGhpcy50b3RhbCAhPSBzY3JvbGxTaXplIHx8IHRoaXMuc2l6ZSAhPSBiYXJTaXplXG4gICAgaWYgKHNpemVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLnNjcmVlbiA9IGNsaWVudFNpemU7XG4gICAgICB0aGlzLnRvdGFsID0gc2Nyb2xsU2l6ZTtcbiAgICAgIHRoaXMuc2l6ZSA9IGJhclNpemU7XG4gICAgfVxuXG4gICAgdmFyIGJ1dHRvblNpemUgPSB0aGlzLnNjcmVlbiAqICh0aGlzLnNpemUgLyB0aGlzLnRvdGFsKTtcbiAgICBpZiAoYnV0dG9uU2l6ZSA8IG1pbkJ1dHRvblNpemUpIHtcbiAgICAgIHRoaXMuc2l6ZSAtPSBtaW5CdXR0b25TaXplIC0gYnV0dG9uU2l6ZTtcbiAgICAgIGJ1dHRvblNpemUgPSBtaW5CdXR0b25TaXplO1xuICAgIH1cbiAgICB0aGlzLmlubmVyLnN0eWxlW3RoaXMub3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9XG4gICAgICBidXR0b25TaXplICsgXCJweFwiO1xuICAgIHRoaXMuc2V0UG9zKHRoaXMucG9zLCBzaXplQ2hhbmdlZCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gU2ltcGxlU2Nyb2xsYmFycyhjbHMsIHBsYWNlLCBzY3JvbGwpIHtcbiAgICB0aGlzLmFkZENsYXNzID0gY2xzO1xuICAgIHRoaXMuaG9yaXogPSBuZXcgQmFyKGNscywgXCJob3Jpem9udGFsXCIsIHNjcm9sbCk7XG4gICAgcGxhY2UodGhpcy5ob3Jpei5ub2RlKTtcbiAgICB0aGlzLnZlcnQgPSBuZXcgQmFyKGNscywgXCJ2ZXJ0aWNhbFwiLCBzY3JvbGwpO1xuICAgIHBsYWNlKHRoaXMudmVydC5ub2RlKTtcbiAgICB0aGlzLndpZHRoID0gbnVsbDtcbiAgfVxuXG4gIFNpbXBsZVNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG1lYXN1cmUpIHtcbiAgICBpZiAodGhpcy53aWR0aCA9PSBudWxsKSB7XG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaG9yaXoubm9kZSkgOiB0aGlzLmhvcml6Lm5vZGUuY3VycmVudFN0eWxlO1xuICAgICAgaWYgKHN0eWxlKSB0aGlzLndpZHRoID0gcGFyc2VJbnQoc3R5bGUuaGVpZ2h0KTtcbiAgICB9XG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCB8fCAwO1xuXG4gICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcbiAgICB2YXIgbmVlZHNWID0gbWVhc3VyZS5zY3JvbGxIZWlnaHQgPiBtZWFzdXJlLmNsaWVudEhlaWdodCArIDE7XG4gICAgdGhpcy52ZXJ0Lm5vZGUuc3R5bGUuZGlzcGxheSA9IG5lZWRzViA/IFwiYmxvY2tcIiA6IFwibm9uZVwiO1xuICAgIHRoaXMuaG9yaXoubm9kZS5zdHlsZS5kaXNwbGF5ID0gbmVlZHNIID8gXCJibG9ja1wiIDogXCJub25lXCI7XG5cbiAgICBpZiAobmVlZHNWKSB7XG4gICAgICB0aGlzLnZlcnQudXBkYXRlKG1lYXN1cmUuc2Nyb2xsSGVpZ2h0LCBtZWFzdXJlLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgbWVhc3VyZS52aWV3SGVpZ2h0IC0gKG5lZWRzSCA/IHdpZHRoIDogMCkpO1xuICAgICAgdGhpcy52ZXJ0Lm5vZGUuc3R5bGUuYm90dG9tID0gbmVlZHNIID8gd2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICB9XG4gICAgaWYgKG5lZWRzSCkge1xuICAgICAgdGhpcy5ob3Jpei51cGRhdGUobWVhc3VyZS5zY3JvbGxXaWR0aCwgbWVhc3VyZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lYXN1cmUudmlld1dpZHRoIC0gKG5lZWRzViA/IHdpZHRoIDogMCkgLSBtZWFzdXJlLmJhckxlZnQpO1xuICAgICAgdGhpcy5ob3Jpei5ub2RlLnN0eWxlLnJpZ2h0ID0gbmVlZHNWID8gd2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHRoaXMuaG9yaXoubm9kZS5zdHlsZS5sZWZ0ID0gbWVhc3VyZS5iYXJMZWZ0ICsgXCJweFwiO1xuICAgIH1cblxuICAgIHJldHVybiB7cmlnaHQ6IG5lZWRzViA/IHdpZHRoIDogMCwgYm90dG9tOiBuZWVkc0ggPyB3aWR0aCA6IDB9O1xuICB9O1xuXG4gIFNpbXBsZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMudmVydC5zZXRQb3MocG9zKTtcbiAgfTtcblxuICBTaW1wbGVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdGhpcy5ob3Jpei5zZXRQb3MocG9zKTtcbiAgfTtcblxuICBTaW1wbGVTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmhvcml6Lm5vZGUucGFyZW50Tm9kZTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpei5ub2RlKTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy52ZXJ0Lm5vZGUpO1xuICB9O1xuXG4gIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwuc2ltcGxlID0gZnVuY3Rpb24ocGxhY2UsIHNjcm9sbCkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlU2Nyb2xsYmFycyhcIkNvZGVNaXJyb3Itc2ltcGxlc2Nyb2xsXCIsIHBsYWNlLCBzY3JvbGwpO1xuICB9O1xuICBDb2RlTWlycm9yLnNjcm9sbGJhck1vZGVsLm92ZXJsYXkgPSBmdW5jdGlvbihwbGFjZSwgc2Nyb2xsKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVTY3JvbGxiYXJzKFwiQ29kZU1pcnJvci1vdmVybGF5c2Nyb2xsXCIsIHBsYWNlLCBzY3JvbGwpO1xuICB9O1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/scroll/simplescrollbars.js\n')},"./node_modules/codemirror/addon/selection/active-line.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n  "use strict";\n  var WRAP_CLASS = "CodeMirror-activeline";\n  var BACK_CLASS = "CodeMirror-activeline-background";\n  var GUTT_CLASS = "CodeMirror-activeline-gutter";\n\n  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off("beforeSelectionChange", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on("beforeSelectionChange", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], "gutter", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption("styleActiveLine");\n      if (typeof option == "object" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], "wrap", WRAP_CLASS);\n        cm.addLineClass(active[i], "background", BACK_CLASS);\n        cm.addLineClass(active[i], "gutter", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvYWRkb24vc2VsZWN0aW9uL2FjdGl2ZS1saW5lLmpzPzMxYzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9hZGRvbi9zZWxlY3Rpb24vYWN0aXZlLWxpbmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcbiAgdmFyIFdSQVBfQ0xBU1MgPSBcIkNvZGVNaXJyb3ItYWN0aXZlbGluZVwiO1xuICB2YXIgQkFDS19DTEFTUyA9IFwiQ29kZU1pcnJvci1hY3RpdmVsaW5lLWJhY2tncm91bmRcIjtcbiAgdmFyIEdVVFRfQ0xBU1MgPSBcIkNvZGVNaXJyb3ItYWN0aXZlbGluZS1ndXR0ZXJcIjtcblxuICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbihcInN0eWxlQWN0aXZlTGluZVwiLCBmYWxzZSwgZnVuY3Rpb24oY20sIHZhbCwgb2xkKSB7XG4gICAgdmFyIHByZXYgPSBvbGQgPT0gQ29kZU1pcnJvci5Jbml0ID8gZmFsc2UgOiBvbGQ7XG4gICAgaWYgKHZhbCA9PSBwcmV2KSByZXR1cm5cbiAgICBpZiAocHJldikge1xuICAgICAgY20ub2ZmKFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIHNlbGVjdGlvbkNoYW5nZSk7XG4gICAgICBjbGVhckFjdGl2ZUxpbmVzKGNtKTtcbiAgICAgIGRlbGV0ZSBjbS5zdGF0ZS5hY3RpdmVMaW5lcztcbiAgICB9XG4gICAgaWYgKHZhbCkge1xuICAgICAgY20uc3RhdGUuYWN0aXZlTGluZXMgPSBbXTtcbiAgICAgIHVwZGF0ZUFjdGl2ZUxpbmVzKGNtLCBjbS5saXN0U2VsZWN0aW9ucygpKTtcbiAgICAgIGNtLm9uKFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIHNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjbGVhckFjdGl2ZUxpbmVzKGNtKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5zdGF0ZS5hY3RpdmVMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY20ucmVtb3ZlTGluZUNsYXNzKGNtLnN0YXRlLmFjdGl2ZUxpbmVzW2ldLCBcIndyYXBcIiwgV1JBUF9DTEFTUyk7XG4gICAgICBjbS5yZW1vdmVMaW5lQ2xhc3MoY20uc3RhdGUuYWN0aXZlTGluZXNbaV0sIFwiYmFja2dyb3VuZFwiLCBCQUNLX0NMQVNTKTtcbiAgICAgIGNtLnJlbW92ZUxpbmVDbGFzcyhjbS5zdGF0ZS5hY3RpdmVMaW5lc1tpXSwgXCJndXR0ZXJcIiwgR1VUVF9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FtZUFycmF5KGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICBpZiAoYVtpXSAhPSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVBY3RpdmVMaW5lcyhjbSwgcmFuZ2VzKSB7XG4gICAgdmFyIGFjdGl2ZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICB2YXIgb3B0aW9uID0gY20uZ2V0T3B0aW9uKFwic3R5bGVBY3RpdmVMaW5lXCIpO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gXCJvYmplY3RcIiAmJiBvcHRpb24ubm9uRW1wdHkgPyByYW5nZS5hbmNob3IubGluZSAhPSByYW5nZS5oZWFkLmxpbmUgOiAhcmFuZ2UuZW1wdHkoKSlcbiAgICAgICAgY29udGludWVcbiAgICAgIHZhciBsaW5lID0gY20uZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0KHJhbmdlLmhlYWQubGluZSk7XG4gICAgICBpZiAoYWN0aXZlW2FjdGl2ZS5sZW5ndGggLSAxXSAhPSBsaW5lKSBhY3RpdmUucHVzaChsaW5lKTtcbiAgICB9XG4gICAgaWYgKHNhbWVBcnJheShjbS5zdGF0ZS5hY3RpdmVMaW5lcywgYWN0aXZlKSkgcmV0dXJuO1xuICAgIGNtLm9wZXJhdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyQWN0aXZlTGluZXMoY20pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY20uYWRkTGluZUNsYXNzKGFjdGl2ZVtpXSwgXCJ3cmFwXCIsIFdSQVBfQ0xBU1MpO1xuICAgICAgICBjbS5hZGRMaW5lQ2xhc3MoYWN0aXZlW2ldLCBcImJhY2tncm91bmRcIiwgQkFDS19DTEFTUyk7XG4gICAgICAgIGNtLmFkZExpbmVDbGFzcyhhY3RpdmVbaV0sIFwiZ3V0dGVyXCIsIEdVVFRfQ0xBU1MpO1xuICAgICAgfVxuICAgICAgY20uc3RhdGUuYWN0aXZlTGluZXMgPSBhY3RpdmU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25DaGFuZ2UoY20sIHNlbCkge1xuICAgIHVwZGF0ZUFjdGl2ZUxpbmVzKGNtLCBzZWwucmFuZ2VzKTtcbiAgfVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/addon/selection/active-line.js\n')},"./node_modules/codemirror/lib/codemirror.js":function(module){eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser\'s DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { \'use strict\';\n\n  // Kludges for bugs and behavior differences that can\'t be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp("(^|\\\\s)" + cls + "(?:$|\\\\s)\\\\s*") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute("role", "presentation");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd("character", end);\n    r.moveStart("character", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(" ");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf("\\t", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal \'I\'m not\n  // handling this\'.\n  var Pass = {toString: function(){return "CodeMirror.Pass"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf("\\t", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [""];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + " "); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > "\\x80" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf("\\\\w") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don\'t know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, "ltr", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, "ltr"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == "before") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != "before") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return "R" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return "r" }\n      else if (0x2000 <= code && code <= 0x200b) { return "w" }\n      else if (code == 0x200c) { return "b" }\n      else { return "L" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == "ltr" ? "L" : "R";\n\n      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == "m") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }\n        else if (type$2 == "," && prev$1 == types[i$3+1] &&\n                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == ",") { types[i$4] = "N"; }\n        else if (type$3 == "%") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == "L";\n          var after = (end$1 < len ? types[end$1] : outerType) == "L";\n          var replace$1 = before == after ? (before ? "L" : "R") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn\'t take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == "ltr") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == "rtl" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent("on" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent("on" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == "string")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor\'s prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn\'t get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt(\'div\');\n    return "draggable" in div || "dragDrop" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt("span", "\\u200b");\n      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt("span", "\\u200b") :\n      elt("span", "\\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");\n    node.setAttribute("cm-text", "");\n    return node\n  }\n\n  // Feature-detect IE\'s crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\\u062eA"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if "".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = "\\n\\nb".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf("\\n", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n      var rt = line.indexOf("\\r");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints("StartToEnd", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt("div");\n    if ("oncopy" in e) { return true }\n    e.setAttribute("oncopy", "return;");\n    return typeof e.oncopy == "function"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt("span", "x"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode\'s dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == "string") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode("application/xml")\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode("application/json")\n    }\n    if (typeof spec == "string") { return {name: spec} }\n    else { return spec || {name: "null"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, "text/plain") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == "string") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == "string") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, ""),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there\'s a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, "overlay " + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don\'t save a style array. Used for lines that\n  // aren\'t currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == "") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error("Mode " + mode.name + " failed to advance stream.")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? "bgClass" : "textClass";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp("(?:^|\\\\s)" + lineClass[2] + "(?:$|\\\\s)")).test(output[prop]))\n        { output[prop] += " " + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode\'s parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don\'t store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that \'stick out\' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn\'t create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don\'t have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to \'clip\' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line\'s height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, "cm-$&"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a \'line map\', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a \'border\', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);\n    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption("lineWrapping")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))\n        { builder.content.className = "cm-tab-wrap-hack"; }\n    }\n\n    signal(cm, "renderLine", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt("span", "\\u2022", "cm-invalidchar");\n    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n    token.setAttribute("aria-label", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == "\\t") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n          txt$1.setAttribute("role", "presentation");\n          txt$1.setAttribute("cm-text", "\\t");\n          builder.col += tabWidth;\n        } else if (m[0] == "\\r" || m[0] == "\\n") {\n          txt$1 = content.appendChild(elt("span", m[0] == "\\r" ? "\\u240d" : "\\u2424", "cm-invalidchar"));\n          txt$1.setAttribute("cm-text", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute("cm-text", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || "";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt("span", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = "";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = "\\u00a0"; }\n      result += ch;\n      spaceBefore = ch == " ";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + " cm-force-border" : "cm-force-border";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement("span")); }\n      widget.setAttribute("cm-marker", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = "", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = "";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = "";\n            }\n            if (m.className) { spanStyle += " " + m.className; }\n            if (m.css) { css = (css ? css + ";" : "") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = "";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don\'t want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line\'s\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == "text") { updateLineText(cm, lineView); }\n      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == "class") { updateLineClasses(cm, lineView); }\n      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt("div", null, null, "position: relative");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;\n    if (cls) { cls += " CodeMirror-linebackground"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line\'s text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = ""; }\n    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;\n    lineView.text.className = textClass || "";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,\n                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));\n      gutterWrap.setAttribute("aria-hidden", "true");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += " " + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt("div", lineNumberFor(cm.options, lineN),\n              "CodeMirror-linenumber CodeMirror-gutter-elt",\n              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",\n                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest("CodeMirror-linewidget");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line\'s DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));\n      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, "redraw");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + "px";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + "px";\n      }\n      node.style.width = width + "px";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = "relative";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = "position: relative;";\n      if (widget.coverGutter)\n        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }\n      if (widget.noHScroll)\n        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }\n      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that\'s not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || ""), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = "left";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = "right"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))\n          { collapse = bias; }\n        if (bias == "left" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = "left";\n          } }\n        if (bias == "right" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = "right";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == "left") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = "right";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = "right"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // "line", "div" (display.lineDiv), "local"./null (editor), "window",\n  // or "page".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == "line") { return rect }\n    if (!context) { context = "local"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == "local") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == "page" || context == "window") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from "div" coords to another coordinate system.\n  // Context may be "window", "page", "div", or "local"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == "div") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into "page" coordinate system\n    if (context == "page") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == "local" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // \'other\' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, "after") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = "before";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = "after";\n    }\n    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == "before");\n    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line\'s\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local ("div" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn\'t plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part\'s range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? "after" : "before";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it\'s vertical position to the\n      // coordinates\n      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        "after" : "before";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),\n                                     "line", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn\'t the first part, the part\'s start is also after\n    // the coordinates, and the coordinates aren\'t on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),\n                               "line", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don\'t correspond to the ordering in our `order` array at\n    // all, so a binary search doesn\'t work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren\'t on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt("pre", null, "CodeMirror-line-like");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode("x"));\n        measureText.appendChild(elt("br"));\n      }\n      measureText.appendChild(document.createTextNode("x"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt("span", "xxxxxxxxxx");\n    var pre = elt("pre", [anchor], "CodeMirror-line-like");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don\'t interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn\'t visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of "text",\n  // "gutter", "class", "widget"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt("div", "\\u00a0", "CodeMirror-cursor"));\n    cursor.style.left = pos.left + "px";\n    cursor.style.top = pos.top + "px";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a \'jump\' in bi-directional text\n      var otherCursor = output.appendChild(elt("div", "\\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));\n      otherCursor.style.display = "";\n      otherCursor.style.left = pos.other.left + "px";\n      otherCursor.style.top = pos.other.top + "px";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == "ltr";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\\n                             height: " + (bottom - top) + "px")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";\n        var ch = side == "after" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == "ltr";\n        var fromPos = coords(from, ltr ? "left" : "right");\n        var toPos = coords(to - 1, ltr ? "right" : "left");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, "before");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = "";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = "hidden"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == "nocursor") { return }\n    if (!cm.state.focused) {\n      signal(cm, "focus", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, "CodeMirror-focused");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, "blur", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, "CodeMirror-focused");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don\'t extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt("div", "\\u200b", null, ("position: absolute;\\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may \'drift\' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, "before"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;\n      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // \'simulates\' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");\n    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, "scroll", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }\n    });\n    on(horiz, "scroll", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = "block";\n      this.vert.style.bottom = needsH ? sWidth + "px" : "0";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";\n    } else {\n      this.vert.style.display = "";\n      this.vert.firstChild.style.height = "0";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = "block";\n      this.horiz.style.right = needsV ? sWidth + "px" : "0";\n      this.horiz.style.left = measure.barLeft + "px";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";\n    } else {\n      this.horiz.style.display = "";\n      this.horiz.firstChild.style.width = "0";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? "12px" : "18px";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = "auto";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it\'s hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.pointerEvents = "none"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";\n    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = "block";\n      d.scrollbarFiller.style.height = sizes.bottom + "px";\n      d.scrollbarFiller.style.width = sizes.right + "px";\n    } else { d.scrollbarFiller.style.display = ""; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = "block";\n      d.gutterFiller.style.height = sizes.bottom + "px";\n      d.gutterFiller.style.width = measure.gutterWidth + "px";\n    } else { d.gutterFiller.style.display = ""; }\n  }\n\n  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, "mousedown", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute("cm-not-content", "true");\n    }, function (pos, axis) {\n      if (axis == "horizontal") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won\'t have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document\'s width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, "changes", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], "text"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we\'ll need later (but don\'t want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + "px";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + "px";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = ""; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, "update", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = "none"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + "px";\n    // Send an event to consumers responding to changes in gutter width.\n    signalLater(display, "gutterChanged", display);\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + "px";\n    cm.display.heightForcer.style.top = measure.docHeight + "px";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + "px";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + "px"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt("div", [elt("div", last)],\n                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = "";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + "px";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != "string") { style = name.style; name = name.className; }\n      if (name == "CodeMirror-linenumbers") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == "CodeMirror-linenumbers") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + "px";\n      }\n    }\n    gutters.style.display = specs.length ? "" : "none";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n    d.scrollbarFiller.setAttribute("cm-not-content", "true");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n    d.gutterFiller.setAttribute("cm-not-content", "true");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP("div", null, "CodeMirror-code");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n    d.cursorDiv = elt("div", null, "CodeMirror-cursors");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt("div", null, "CodeMirror-measure");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt("div", null, "CodeMirror-measure");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, "position: relative; outline: none");\n    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");\n    // Moved around its parent to cover visible view.\n    d.mover = elt("div", [lines], null, "position: relative");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");\n    // Will contain the gutters, if any.\n    d.gutters = elt("div", null, "CodeMirror-gutters");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n    d.scroller.setAttribute("tabIndex", "-1");\n    // The element in which the editor lives.\n    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don\'t have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there\'s nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It\'ll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // \'Project\' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that\'s scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. \'Consumes\' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its \'to\' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be "start" or "around".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == "around") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, "change", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, "change", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error("This document is already in use.") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(prev) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = prev ? prev.undoDepth : Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with "+") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == "*")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don\'t want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, "historyAdded"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == "*" ||\n      ch == "+" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the \'done\' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don\'t allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change["spans_" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change["spans_" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The \'scroll\' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, "beforeSelectionChange", doc, obj);\n    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, "cursorActivity", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, "beforeCursorEnter");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow "beforeChange" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, "beforeChange", doc, obj);\n    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document\'s\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document\'s history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won\'t\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, "gutter"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, "text"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, "change", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == "string") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything \'behind\' it, is discarded. If the change is\n  // before the event, the event\'s positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset \'at\'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, "delete");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset \'at\', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it\'s never spliced.\n            // Instead, small slices are taken. They\'re taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, "widget");\n      });\n      signalLater(cm, "lineWidgetCleared", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, "widget", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, "clear")) {\n      var found = this.find();\n      if (found) { signalLater(this, "clear", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == "bookmark") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker\'s widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, "markerChanged", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don\'t connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, "markerAdded", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, "clear");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == "rtl") ? "rtl" : "ltr";\n    this.extend = false;\n\n    if (typeof text == "string") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: "setValue", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == "number") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == "head") { pos = range.head; }\n      else if (start == "anchor") { pos = range.anchor; }\n      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head || ranges[i].anchor)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || "+input");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, "gutter", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, "gutter", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == "number") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {\n        var prop = where == "text" ? "textClass"\n                 : where == "background" ? "bgClass"\n                 : where == "gutter" ? "gutterClass" : "wrapClass";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += " " + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {\n        var prop = where == "text" ? "textClass"\n                 : where == "background" ? "bgClass"\n                 : where == "gutter" ? "gutterClass" : "wrapClass";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, "bookmark")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || "\\n" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != "rtl") { dir = "ltr"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it\'ll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: "paste"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don\'t do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData("Text");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }\n          cm.replaceSelection(text$1, "around", "paste");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData("Text", cm.getSelection());\n    e.dataTransfer.effectAllowed = "copyMove";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don\'t do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won\'t use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, "resize", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, "blur", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",\n    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",\n    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",\n    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",\n    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",\n    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\\\",\n    221: "]", 222: "\'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",\n    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",\n    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",\n    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",\n    "Tab": "defaultTab", "Shift-Tab": "indentAuto",\n    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",\n    "Esc": "singleSelection"\n  };\n  // Note that the save and find-related commands aren\'t defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",\n    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",\n    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",\n    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",\n    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",\n    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",\n    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",\n    "fallthrough": "basic"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",\n    "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp",\n    "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine",\n    "Ctrl-T": "transposeChars", "Ctrl-O": "openLine"\n  };\n  keyMap.macDefault = {\n    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",\n    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",\n    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",\n    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",\n    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",\n    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",\n    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",\n    "fallthrough": ["basic", "emacsy"]\n  };\n  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error("Unrecognized modifier name: " + mod) }\n    }\n    if (alt) { name = "Alt-" + name; }\n    if (ctrl) { name = "Ctrl-" + name; }\n    if (cmd) { name = "Cmd-" + name; }\n    if (shift) { name = "Shift-" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == "...") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(" "), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(" ");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(" ");\n          val = "...";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return "nothing" }\n    if (found === "...") { return "multi" }\n    if (found != null && handle(found)) { return "handled" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don\'t count as \'real\' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == "string" ? value : keyNames[value.keyCode];\n    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != "Alt") { name = "Alt-" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }\n    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event["char"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we\'ll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == "string" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == "rtl") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? "after" : "before";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == "rtl") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = "before";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = "after";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == "rtl" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? "before" : "after";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), "before")\n        : new Pos(start.line, ch, "after"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, "div").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, "div");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, "div").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: "+move", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: "+move", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: "+move", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, "div").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, "div").top + 5;\n      return cm.coordsChar({left: 0, top: top}, "div")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, "div").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, "div");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, "line"); },\n    goLineDown: function (cm) { return cm.moveV(1, "line"); },\n    goPageUp: function (cm) { return cm.moveV(-1, "page"); },\n    goPageDown: function (cm) { return cm.moveV(1, "page"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },\n    goCharRight: function (cm) { return cm.moveH(1, "char"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },\n    goColumnRight: function (cm) { return cm.moveH(1, "column"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },\n    goGroupRight: function (cm) { return cm.moveH(1, "group"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },\n    goWordRight: function (cm) { return cm.moveH(1, "word"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },\n    indentAuto: function (cm) { return cm.indentSelection("smart"); },\n    indentMore: function (cm) { return cm.indentSelection("add"); },\n    indentLess: function (cm) { return cm.indentSelection("subtract"); },\n    insertTab: function (cm) { return cm.replaceSelection("\\t"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection("add"); }\n      else { cm.execCommand("insertTab"); }\n    },\n    // Swap the two chars left and right of each selection\'s head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn\'t consider line feeds a character.\n    // Doesn\'t scan more than one line above to find a character.\n    // Doesn\'t do anything on an empty line.\n    // Doesn\'t do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, "+transpose");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection("\\n", "start"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == "string") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return "handled" }\n      if (/\\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == "multi")\n      { cm.state.keySeq = name; }\n    if (result == "handled")\n      { signalLater(cm, "keyHandled", cm, name, e); }\n\n    if (result == "handled" || result == "multi") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including \'Shift-\'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // \'go\') bound to the keyname without \'Shift-\'.\n      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, "\'" + ch + "\'", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection("", null, "cut"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand("cut"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, "CodeMirror-crosshair");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, "CodeMirror-crosshair");\n        off(document, "keyup", up);\n        off(document, "mouseover", up);\n      }\n    }\n    on(document, "keyup", up);\n    on(document, "mouseover", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == "\\x08") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return "triple"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return "double"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return "single"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";\n    window.focus();\n\n    // #3261: make sure, that we\'re not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = "Click";\n    if (repeat == "double") { name = "Double" + name; }\n    else if (repeat == "triple") { name = "Triple" + name; }\n    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == "string") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption("configureMouse");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == "single" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn\'t.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, "mouseup", dragEnd);\n      off(display.wrapper.ownerDocument, "mousemove", mouseMove);\n      off(display.scroller, "dragstart", dragStart);\n      off(display.scroller, "drop", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, "mouseup", dragEnd);\n    on(display.wrapper.ownerDocument, "mousemove", mouseMove);\n    on(display.scroller, "dragstart", dragStart);\n    on(display.scroller, "drop", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE\'s approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == "char") { return new Range(pos, pos) }\n    if (unit == "word") { return cm.findWordAt(pos) }\n    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == "rectangle") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: "*mouse"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: "*mouse"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == "rectangle") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: "*mouse", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don\'t fire when another extend\n    // happened in the meantime (clearTimeout isn\'t reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, "mousemove", move);\n      off(display.wrapper.ownerDocument, "mouseup", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, "mousemove", move);\n    on(display.wrapper.ownerDocument, "mouseup", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, "gutterClick", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, "contextmenu")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, "gutterContextMenu")) { return false }\n    return gutterEvent(cm, e, "gutterContextMenu", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return "CodeMirror.Init"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option("value", "", function (cm, val) { return cm.setValue(val); }, true);\n    option("mode", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option("indentUnit", 2, loadMode, true);\n    option("indentWithTabs", false);\n    option("smartIndent", true);\n    option("tabSize", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option("lineSeparator", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option("specialChars", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test("\\t") ? "" : "|\\t"), "g");\n      if (old != Init) { cm.refresh(); }\n    });\n    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option("electricChars", true);\n    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {\n      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME\n    }, true);\n    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option("rtlMoveVisually", !windows);\n    option("wholeLineUpdateBefore", true);\n\n    option("theme", "default", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option("keyMap", "default", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option("extraKeys", null);\n    option("configureMouse", null);\n\n    option("lineWrapping", false, wrappingChanged, true);\n    option("gutters", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option("fixedGutter", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n      cm.refresh();\n    }, true);\n    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);\n    option("scrollbarStyle", "native", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option("lineNumbers", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option("firstLineNumber", 1, updateGutters, true);\n    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);\n    option("showCursorWhenSelecting", false, updateSelection, true);\n\n    option("resetSelectionOnContextMenu", true);\n    option("lineWiseCopyCut", true);\n    option("pasteLinesPerSelection", true);\n    option("selectionsMayTouch", false);\n\n    option("readOnly", false, function (cm, val) {\n      if (val == "nocursor") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option("screenReaderLabel", null, function (cm, val) {\n      val = (val === \'\') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option("dragDrop", true, dragDropChanged);\n    option("allowDropFileTypes", null);\n\n    option("cursorBlinkRate", 530);\n    option("cursorScrollMargin", 0);\n    option("cursorHeight", 1, updateSelection, true);\n    option("singleCursorHeightPerLine", true, updateSelection, true);\n    option("workTime", 100);\n    option("workDelay", 100);\n    option("flattenSpans", true, resetModeState, true);\n    option("addModeClass", false, resetModeState, true);\n    option("pollInterval", 100);\n    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option("historyEventDelay", 1250);\n    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);\n    option("maxHighlightLength", 10000, resetModeState, true);\n    option("moveInputWithCursor", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });\n    option("autofocus", null);\n    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option("phrases", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, "dragstart", funcs.start);\n      toggle(cm.display.scroller, "dragenter", funcs.enter);\n      toggle(cm.display.scroller, "dragover", funcs.over);\n      toggle(cm.display.scroller, "dragleave", funcs.leave);\n      toggle(cm.display.scroller, "drop", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, "CodeMirror-wrap");\n      cm.display.sizer.style.minWidth = "";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, "CodeMirror-wrap");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += " CodeMirror-wrap"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")\n      { display.lineDiv.style.textRendering = "auto"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, "mousedown", operation(cm, onMouseDown));\n    // Older IE\'s will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, "dblclick", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can\'t mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), "contextmenu", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, "touchstart", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, "touchmove", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, "touchend", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, "page"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, "touchcancel", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, "scroll", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, "scroll", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, "keydown", operation(cm, onKeyDown));\n    on(inp, "keypress", operation(cm, onKeyPress));\n    on(inp, "focus", function (e) { return onFocus(cm, e); });\n    on(inp, "blur", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be "smart",\n  // "add"/null, "subtract", or "prev". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = "add"; }\n    if (how == "smart") {\n      // Fall back to "prev" when the mode doesn\'t have an indentation\n      // method.\n      if (!doc.mode.indent) { how = "prev"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = "not";\n    } else if (how == "smart") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = "prev";\n      }\n    }\n    if (how == "prev") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == "add") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == "subtract") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == "number") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = "", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\\t";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == "paste" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join("\\n") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\\n") == textLines.join("\\n"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, "inputRead", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData("Text");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an \'electric\' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, "smart");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, "smart"); }\n      }\n      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute("autocorrect", autocorrect ? "" : "off");\n    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");\n    field.setAttribute("spellcheck", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");\n    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it\'ll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = "1000px"; }\n    else { te.setAttribute("wrap", "off"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = "1px solid black"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // \'wrap f in an operation, performed on its `this` parameter\'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != "mode") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, "optionChange", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error("Overlays may not be stateful.") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == "string" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != "string" && typeof dir != "number") {\n          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }\n          else { dir = dir ? "add" : "subtract"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf("overlay ") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == "string") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == "object") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || "page")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || "page")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || "page");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == "number") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = "absolute";\n        node.setAttribute("cm-ignore-events", "true");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == "over") {\n          top = pos.top;\n        } else if (vert == "above" || vert == "near") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == \'above\' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + "px";\n        node.style.left = node.style.right = "";\n        if (horiz == "right") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = "0px";\n        } else {\n          if (horiz == "left") { left = 0; }\n          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + "px";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection("", null, "+delete"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, "div");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, "div");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == "page" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, "wordChars");\n          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }\n        else\n          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }\n\n        signal(this, "overwriteToggle", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == "number") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, "refresh", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, "refresh", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, "swapDoc", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be "codepoint", "char", "column" (like char, but\n  // doesn\'t cross line boundaries), "word" (across next word), or\n  // "group" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == "codepoint") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == "char" || unit == "codepoint") {\n      moveOnce();\n    } else if (unit == "column") {\n      moveOnce(true);\n    } else if (unit == "word" || unit == "group") {\n      var sawType = null, group = unit == "group";\n      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || "\\n";\n        var type = isWordChar(cur, helper) ? "w"\n          : group && cur == "\\n" ? "n"\n          : !group || /\\s/.test(cur) ? null\n          : "p";\n        if (group && !first && !type) { type = "s"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // "page" or "line". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == "page") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == "line") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    div.contentEditable = true;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, "paste", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn\'t fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, "compositionstart", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, "compositionupdate", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, "compositionend", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, "touchstart", function () { return input.forceCompositionEnd(); });\n\n    on(div, "input", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == "cut") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection("", null, "cut");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join("\\n");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData("Text", content);\n        if (e.clipboardData.getData("Text") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join("\\n");\n      var hadFocus = activeElt();\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, "copy", onCopyCut);\n    on(div, "cut", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute(\'aria-label\', label);\n    } else {\n      this.div.removeAttribute(\'aria-label\');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = activeElt() == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != "nocursor") {\n      if (!this.selectionInEditor() || activeElt() != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it\'s not editable, hide the virtual keyboard.\n    // Because Android doesn\'t allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, "");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, "");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, "+input");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = "false";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != "nocursor");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = "left";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? "right" : "left";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == "right" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute("cm-text");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute("cm-marker"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute("contenteditable") == "false") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, "").replace(/\\u00a0/g, " "));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = "";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like \'keypress\' or \'input\') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn\'t seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = "0px"; }\n\n    on(te, "input", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, "paste", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == "cut") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = "";\n          te.value = ranges.text.join("\\n");\n          selectInput(te);\n        }\n      }\n      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, "cut", prepareCopyCut);\n    on(te, "copy", prepareCopyCut);\n\n    on(display.scroller, "paste", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it\'s handled by its event listener.\n      var event = new Event("paste");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, "selectstart", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, "compositionstart", function () {\n      var start = cm.getCursor("from");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})\n      };\n    });\n    on(te, "compositionend", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute(\'aria-label\', label);\n    } else {\n      this.textarea.removeAttribute(\'aria-label\');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + "px";\n      this.wrapper.style.left = drawn.teLeft + "px";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = "";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = "";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = "\\u200b"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? "*compose" : null);\n\n      // Don\'t leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf("\\n") > -1) { input.value = this$1.prevInput = ""; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),\n                                           {className: "CodeMirror-composing"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and \'resetSelectionOnContextMenu\' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = "position: static";\n    te.style.cssText = "position: absolute; width: 30px; height: 30px;\\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds "Select all" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there\'s nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = "\\u200b" + (selected ? te.value : "");\n        te.value = "\\u21da"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? "" : "\\u200b";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == "\\u200b") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, "mouseup", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, "mouseup", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == "nocursor";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, "submit", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = "";\n        if (textarea.form) {\n          off(textarea.form, "submit", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = "none";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror\'s prototype to redirect to the editor\'s document.\n  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};\n\n  // Extra arguments are stored as the mode\'s dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, …*/) {\n    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME("text/plain", "null");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = "5.61.0";\n\n  return CodeMirror;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuanM/NTZiMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDd0Q7QUFDMUQsQ0FBQyxxQkFBcUI7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkUsK0NBQStDLGdCQUFnQixlQUFlO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsV0FBVztBQUNwRCxPQUFPLDZCQUE2QjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxnQkFBZ0IseUJBQXlCO0FBQ3pDLHFDQUFxQyxpREFBaUQ7QUFDdEYsdUJBQXVCLGdCQUFnQixvQkFBb0IsT0FBTywyQkFBMkIsRUFBRTtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFFBQVE7QUFDUjtBQUNBLFNBQVMsc0NBQXNDO0FBQy9DLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRCw0QkFBNEI7QUFDNUIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0RBQXdEO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qyw4Q0FBOEM7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEMsT0FBTywwQ0FBMEMsa0JBQWtCLEVBQUU7QUFDckU7QUFDQTs7QUFFQSxvQ0FBb0MsZUFBZTtBQUNuRDtBQUNBLEtBQUssK0JBQStCLHlCQUF5Qix1Q0FBdUMsR0FBRztBQUN2RztBQUNBLEtBQUssK0JBQStCLE1BQU0sZUFBZSxFQUFFLGFBQWEsR0FBRzs7QUFFM0U7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0EsT0FBTztBQUNQLFNBQVMsMEJBQTBCLEVBQUU7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxPQUFPLHVCQUF1QixXQUFXO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7O0FBRW5DO0FBQ0Esd0JBQXdCLGNBQWMsZUFBZSxpQkFBaUIsY0FBYzs7QUFFcEY7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0NBQXNDO0FBQzdDO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQixPQUFPLHlCQUF5QjtBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpRUFBaUUsT0FBTztBQUN4RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsbUVBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsdUNBQXVDLGVBQWU7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDLDBDQUEwQztBQUMxQztBQUNBLHdGQUF3RixZQUFZO0FBQ3BHO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCx1QkFBdUI7QUFDdkI7QUFDQSx3QkFBd0I7QUFDeEIsc0JBQXNCLFVBQVU7QUFDaEMsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSx1REFBdUQsV0FBVztBQUNsRSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRCxnQ0FBZ0M7QUFDaEMsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBLHVFQUF1RTtBQUN2RTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFNBQVMseUNBQXlDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxXQUFXO0FBQ3BEO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QyxjQUFjLGFBQWE7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RCx5Q0FBeUMsY0FBYyxxQkFBcUIsa0JBQWtCLEVBQUU7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQSxvRUFBb0Usa0JBQWtCO0FBQ3RGO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0EsMkJBQTJCLFNBQVMsT0FBTyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RCx5Q0FBeUMsZ0JBQWdCO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhLFNBQVMsd0JBQXdCO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QztBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQixnQ0FBZ0M7QUFDckQsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQSw4QkFBOEIsZ0RBQWdELGFBQWE7QUFDM0Y7QUFDQSx5QkFBeUIsMkNBQTJDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxPQUFPO0FBQzNCO0FBQ0EsMEJBQTBCLGdEQUFnRDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBeUQ7QUFDakY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUE4RDtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLG1CQUFtQixxQkFBcUIsT0FBTywrQkFBK0I7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sTUFBTSxxQ0FBcUMsOEJBQThCLElBQUk7QUFDcEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxtQkFBbUIsZ0JBQWdCLE9BQU87QUFDMUMsT0FBTyxrQkFBa0IsRUFBRTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQyxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCxVQUFVLHVCQUF1QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7O0FBRTFDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQyw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEIsT0FBTztBQUNyQztBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyRkFBMkY7QUFDcEc7QUFDQTtBQUNBLHlEQUF5RCxZQUFZO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZUFBZTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsaUNBQWlDOztBQUUxRDtBQUNBLFNBQVM7QUFDVCxjQUFjO0FBQ2QsR0FBRztBQUNIO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixxQ0FBcUM7QUFDckM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sOERBQThEO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsVUFBVSxhQUFhO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLFdBQVc7QUFDdEQsVUFBVSxpQkFBaUIsYUFBYTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDJDQUEyQyxxQ0FBcUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0NBQXNDO0FBQ2hFLHlCQUF5QjtBQUN6QixPQUFPLDBDQUEwQyxFQUFFOztBQUVuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JELFVBQVUsc0RBQXNEO0FBQ2hFLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVk7QUFDekU7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrREFBa0Q7QUFDcEY7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEI7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFDQUFxQztBQUNyQyx1Q0FBdUMsNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RCw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUIsRUFBRSxFQUFFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQixHQUFHLGdCQUFnQixrQkFBa0IsRUFBRTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QyxzQkFBc0I7QUFDdEIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEIsaUNBQWlDOztBQUVqQyx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxzQkFBc0I7QUFDdEIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0IsT0FBTyxpQ0FBaUM7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxPQUFPLHdCQUF3QjtBQUMvQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSw0QkFBNEIsRUFBRTtBQUN0RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNDQUFzQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw4QkFBOEI7O0FBRWpELFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRCxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0EsU0FBUyxpRkFBaUY7QUFDMUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9DQUFvQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQjtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLGtCQUFrQix3Q0FBd0M7QUFDMUQ7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyRUFBMkU7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDO0FBQ0EsU0FBUyxvQ0FBb0M7QUFDN0MsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUVBQXFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBc0Q7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0Isa0JBQWtCO0FBQ2xEO0FBQ0Esa0NBQWtDO0FBQ2xDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxPQUFPLHdCQUF3QixnQ0FBZ0MsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLDhCQUE4Qix1REFBdUQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNDQUFzQztBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBLHlCQUF5QixzQ0FBc0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hELGdDQUFnQyw4QkFBOEI7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtCQUFrQixvQkFBb0I7QUFDL0MsV0FBVztBQUNYLGFBQWEsdUZBQXVGLEVBQUUsRUFBRTtBQUN4Ryx1QkFBdUIsV0FBVztBQUNsQyxTQUFTLDZCQUE2QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQiw2QkFBNkI7QUFDMUU7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELE9BQU87QUFDUCxLQUFLO0FBQ0wsbUJBQW1CO0FBQ25CLGtCQUFrQixtQkFBbUI7QUFDckMsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHlCQUF5QixFQUFFO0FBQ3REO0FBQ0EsV0FBVyxnQkFBZ0IscUJBQXFCLEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUIsa0JBQWtCO0FBQ3JDLE9BQU8sa0NBQWtDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixtQkFBbUIsa0JBQWtCO0FBQ3JDLE9BQU8sa0NBQWtDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0IsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CO0FBQzVCLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0Esc0VBQXNFLG1CQUFtQjtBQUN6RixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixnQkFBZ0I7QUFDOUM7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQ0FBbUM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGtDQUFrQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxPQUFPLGtDQUFrQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQixnQkFBZ0I7QUFDN0Q7QUFDQSxpQ0FBaUM7QUFDakMsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQztBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQSw0QkFBNEI7QUFDNUIsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQSw4QkFBOEIsR0FBRztBQUNqQyx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0EsMkJBQTJCO0FBQzNCLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xELHNCQUFzQixvQkFBb0I7QUFDMUMsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlEQUFpRDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUErRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRkFBaUY7QUFDNUY7QUFDQSxXQUFXLHVGQUF1RjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0EsU0FBUywyRkFBMkY7O0FBRXBHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsU0FBUyxtRUFBbUU7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQWdEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQSxPQUFPLGlGQUFpRjs7QUFFeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlDQUF5QztBQUM5RSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQ0FBcUMsMkNBQTJDO0FBQ2hGLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRCxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsV0FBVyw0Q0FBNEMsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUEyRDtBQUM1RTtBQUNBO0FBQ0EsU0FBUyxzRUFBc0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLFNBQVMsd0hBQXdIO0FBQ2pJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdDQUFnQztBQUM5RCx3QkFBd0Isc0JBQXNCLGdCQUFnQjtBQUM5RCxpREFBaUQsc0NBQXNDO0FBQ3ZGLG9EQUFvRCx5REFBeUQ7QUFDN0c7QUFDQTtBQUNBLDBCQUEwQixnQ0FBZ0MsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDLDhCQUE4QjtBQUMvRTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0Isd0JBQXdCO0FBQ2xFLFdBQVcsd0NBQXdDLHNDQUFzQyxFQUFFLEVBQUU7O0FBRTdGLGtEQUFrRCxrQkFBa0IsNkJBQTZCO0FBQ2pHLFdBQVcscURBQXFELEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QixZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQyxTQUFTLHlCQUF5QjtBQUNsQyxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYSx3RUFBd0UsRUFBRTtBQUN2RjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQixTQUFTLDRCQUE0QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDLEVBQUU7QUFDaEU7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0IsT0FBTyxjQUFjO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsa0NBQWtDLDZDQUE2QztBQUMvRSxpQ0FBaUMsaUNBQWlDO0FBQ2xFLGtDQUFrQyx1Q0FBdUM7QUFDekU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUVBQXFFO0FBQzlFO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0EsZ0JBQWdCLHFDQUFxQztBQUNyRCxZQUFZLGlFQUFpRSw0QkFBNEI7QUFDekcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpRUFBaUU7QUFDeEU7QUFDQSxPQUFPLDhCQUE4QjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUF5RDtBQUNsRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEVBQTRFLHFEQUFxRDtBQUNqSSxvQkFBb0IsZ0JBQWdCLG1DQUFtQztBQUN2RTtBQUNBO0FBQ0EsV0FBVztBQUNYLDZFQUE2RSw2Q0FBNkM7QUFDMUgsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0EsOERBQThELE1BQU07QUFDcEU7QUFDQSwwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQsMEJBQTBCLHNDQUFzQzs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsMEJBQTBCO0FBQ2xFLE9BQU8sbUVBQW1FLEVBQUU7QUFDNUU7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBLHNDQUFzQywrQ0FBK0M7QUFDckY7QUFDQTtBQUNBO0FBQ0EsU0FBUywyREFBMkQ7QUFDcEU7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1REFBdUQ7QUFDckY7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGNBQWM7QUFDZDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLFNBQVMsd0VBQXdFLEVBQUU7QUFDbkY7QUFDQSxTQUFTLGlFQUFpRSxFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSxnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0RBQWtELCtCQUErQjtBQUNqRjtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxTQUFTLHlEQUF5RDtBQUN6RSxtQkFBbUIsMEJBQTBCO0FBQzdDLE9BQU87QUFDUCxTQUFTLFNBQVMsaUVBQWlFLEVBQUU7QUFDckYscUJBQXFCLDRCQUE0QjtBQUNqRCxPQUFPO0FBQ1AsU0FBUyxTQUFTLG1GQUFtRixFQUFFO0FBQ3ZHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNENBQTRDOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxTQUFTLDREQUE0RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDZCQUE2QjtBQUN0RDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLGtCQUFrQjtBQUMzRCxpREFBaUQ7QUFDakQsS0FBSyxFQUFFLE9BQU8saUNBQWlDLFVBQVU7QUFDekQsbURBQW1EO0FBQ25ELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qix1QkFBdUIsU0FBUyxTQUFTO0FBQ3pDLCtGQUErRixTQUFTO0FBQ3hHLCtIQUErSCxPQUFPO0FBQ3RJO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0Q7QUFDQSxXQUFXLHNFQUFzRTtBQUNqRixvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNERBQTREO0FBQzlGLEtBQUssT0FBTztBQUNaLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBLFNBQVMsc0RBQXNEO0FBQy9EO0FBQ0EsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVMsbUdBQW1HO0FBQ3JIO0FBQ0EsU0FBUyxpQkFBaUI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyxPQUFPLHdCQUF3QixRQUFRO0FBQ3ZDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pELGdEQUFnRCxvQkFBb0IsdUJBQXVCOztBQUUzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQiwwQkFBMEI7QUFDcEUsU0FBUyxpQ0FBaUMsRUFBRTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsT0FBTyxrREFBa0Q7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsZ0JBQWdCLDRCQUE0QixPQUFPO0FBQzdFLE9BQU8sNENBQTRDLEVBQUUsRUFBRTtBQUN2RDtBQUNBOztBQUVBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsNEJBQTRCO0FBQzVCLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdELFVBQVUsK0JBQStCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxtQkFBbUIscUNBQXFDO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFzRDtBQUNqRjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQixFQUFFLE9BQU8sa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFvRDtBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0IsT0FBTzs7QUFFdkI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFFQUFxRSxFQUFFO0FBQ2hILG1DQUFtQyw2REFBNkQsRUFBRTtBQUNsRyxZQUFZO0FBQ1o7O0FBRUE7QUFDQSwyQkFBMkIsc0RBQXNEO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQSw0QkFBNEIsU0FBUyw2Q0FBNkM7QUFDbEYsd0JBQXdCLFNBQVMsNkNBQTZDO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUNBQW1DO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDZDQUE2QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBLHlCQUF5QixnQkFBZ0IseUJBQXlCO0FBQ2xFLHFDQUFxQyx5Q0FBeUM7QUFDOUUsT0FBTzs7QUFFUDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1DQUFtQztBQUN4RSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQSxTQUFTLDRCQUE0QiwyQkFBMkI7QUFDaEUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMscUJBQXFCLGlDQUFpQztBQUN0RCxtQkFBbUIsYUFBYTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrQ0FBa0M7O0FBRXpDOztBQUVBLGlDQUFpQztBQUNqQztBQUNBLFNBQVMsZUFBZTtBQUN4QixLQUFLLG1DQUFtQztBQUN4QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkRBQTZEO0FBQ2xFO0FBQ0EsS0FBSyxxQ0FBcUM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSyxpQ0FBaUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBLFNBQVMsaUNBQWlDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxpQ0FBaUM7O0FBRXhDLDREQUE0RDtBQUM1RDtBQUNBLGdDQUFnQztBQUNoQztBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBUywwQkFBMEI7QUFDMUM7QUFDQSxtQkFBbUIsV0FBVztBQUM5QixPQUFPLG1CQUFtQjtBQUMxQjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFNBQVMsZ0ZBQWdGO0FBQ3pGO0FBQ0EsU0FBUyw0REFBNEQ7QUFDckU7QUFDQTtBQUNBLFNBQVMsNEVBQTRFO0FBQ3JGO0FBQ0EsU0FBUyw2REFBNkQ7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBLHFFQUFxRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QywrQ0FBK0M7QUFDL0M7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSx3RkFBd0Ysc0JBQXNCLGtEQUFrRCw2REFBNkQ7QUFDN047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0RBQWdEO0FBQzNGO0FBQ0E7O0FBRUEsc0RBQXNELGlCQUFpQjtBQUN2RSwwQ0FBMEMsZUFBZTtBQUN6RCxrREFBa0QsZUFBZTtBQUNqRSx3Q0FBd0MsYUFBYTtBQUNyRCxPQUFPO0FBQ1AsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxREFBcUQ7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNkJBQTZCLFlBQVk7QUFDekM7QUFDQSxPQUFPLDhCQUE4QjtBQUNyQztBQUNBLE9BQU8sK0NBQStDO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0EsK0RBQStELG9DQUFvQzs7QUFFbkcsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUIscUNBQXFDLEVBQUUsTUFBTSxFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QiwwQkFBMEIsRUFBRSxFQUFFO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEVBQTBFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCLHFCQUFxQjtBQUM1RCxXQUFXLGlDQUFpQyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQix5QkFBeUI7QUFDaEU7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25ELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPLFNBQVMsT0FBTyxVQUFVO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRCxxR0FBcUcsa0JBQWtCO0FBQ3ZIO0FBQ0EsdUVBQXVFLG1HQUFtRywwR0FBMEcsdURBQXVELHdEQUF3RDtBQUNuWTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDBDQUEwQztBQUNoRix1Q0FBdUMseUNBQXlDO0FBQ2hGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQSwwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQSxPQUFPLHVCQUF1QjtBQUM5QjtBQUNBLE9BQU8sK0VBQStFO0FBQ3RGO0FBQ0EsT0FBTywrREFBK0Q7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pELG9CQUFvQix5QkFBeUI7QUFDN0Msb0JBQW9CLHdCQUF3QjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLGlCQUFpQiwwQkFBMEIsU0FBUyxFQUFFO0FBQ3REO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUM7QUFDcEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBLGdEQUFnRCxzQ0FBc0M7QUFDdEY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFLEtBQUs7QUFDTDtBQUNBLDhCQUE4Qix3Q0FBd0M7QUFDdEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsK0JBQStCLGdFQUFnRTtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBLHVDQUF1Qyw2QkFBNkI7QUFDcEUsNEJBQTRCLGlFQUFpRTtBQUM3Rjs7QUFFQTtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEUsMkJBQTJCLDhEQUE4RDtBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pELFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFpRCxTQUFTLG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7QUFDQSxtQkFBbUIsbUZBQW1GO0FBQ3RHO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssT0FBTyxzQ0FBc0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE9BQU8sbUNBQW1DO0FBQy9DOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUE2RDtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUIsaUNBQWlDLEVBQUUsS0FBSztBQUNoRyxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLHdCQUF3QjtBQUN6RCxZQUFZLDBCQUEwQjtBQUN0QyxLQUFLO0FBQ0w7QUFDQSxPQUFPLDhEQUE4RDtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQkFBcUIsc0JBQXNCO0FBQzNDLFNBQVMsOEJBQThCO0FBQ3ZDO0FBQ0EsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLE9BQU8seUJBQXlCO0FBQ2hDLHFCQUFxQixrQkFBa0I7QUFDdkMsT0FBTywyQkFBMkI7QUFDbEMscUJBQXFCLGtCQUFrQjtBQUN2QyxPQUFPLDJCQUEyQjtBQUNsQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLE9BQU8sMkJBQTJCO0FBQ2xDLHFCQUFxQixrQkFBa0I7QUFDdkMsT0FBTywrQkFBK0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQ0FBMEM7QUFDeEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCOztBQUV6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8seURBQXlEO0FBQ2hFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxRkFBcUY7QUFDOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxpRUFBaUU7QUFDeEU7QUFDQSxPQUFPLHFDQUFxQztBQUM1QztBQUNBLE9BQU8sc0NBQXNDOztBQUU3Qyw4QkFBOEIsa0JBQWtCOztBQUVoRDtBQUNBLE9BQU8sbUNBQW1DO0FBQzFDLG9CQUFvQixvQkFBb0I7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQSw0QkFBNEIsa0NBQWtDOztBQUU5RDtBQUNBO0FBQ0EsT0FBTyxrREFBa0Q7O0FBRXpEO0FBQ0EsK0JBQStCLGdEQUFnRDs7QUFFL0UsZ0NBQWdDLDhDQUE4QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQixtQkFBbUI7QUFDcEQsT0FBTywrQkFBK0IsMkJBQTJCLEVBQUUsRUFBRTtBQUNyRSxtQkFBbUIsa0JBQWtCLHVCQUF1QjtBQUM1RCxPQUFPLGtDQUFrQyxpQ0FBaUMsRUFBRSxFQUFFOztBQUU5RTtBQUNBLE9BQU8sK0NBQStDOztBQUV0RDtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7QUFDakQ7QUFDQSxPQUFPLG9CQUFvQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsU0FBUztBQUNULGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsV0FBVztBQUNYLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsV0FBVztBQUNYLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU8seURBQXlEO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0EsdUJBQXVCLG1DQUFtQyxPQUFPLDJDQUEyQztBQUM1Ryx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxXQUFXLHFDQUFxQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHFCQUFxQix5QkFBeUI7QUFDOUMsU0FBUyw0Q0FBNEM7QUFDckQsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDZCQUE2QjtBQUNwQztBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQyxPQUFPLG9DQUFvQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDJEQUEyRDtBQUMzRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsOENBQThDO0FBQ2hILDBEQUEwRCxvQ0FBb0M7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYSwwRkFBMEY7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2QkFBNkI7QUFDdEM7QUFDQSxTQUFTLG1DQUFtQztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQSw0QkFBNEIsb0VBQW9FO0FBQ2hHO0FBQ0E7QUFDQSxPQUFPLE9BQU87QUFDZCxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUIsT0FBTztBQUMzQztBQUNBO0FBQ0EsV0FBVyxrQ0FBa0M7QUFDN0M7QUFDQSxXQUFXLDRDQUE0QztBQUN2RDtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixrQkFBa0I7QUFDcEQsU0FBUyw0QkFBNEIsRUFBRTtBQUN2QyxLQUFLO0FBQ0w7QUFDQSxPQUFPLHNEQUFzRDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQSxvQ0FBb0Msb0JBQW9CLHVCQUF1QjtBQUMvRTtBQUNBLDJCQUEyQjtBQUMzQixjQUFjLHVCQUF1QjtBQUNyQztBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQSx5Q0FBeUMsY0FBYyxpREFBaUQsRUFBRTtBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0IsWUFBWTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDZCQUE2QixtQ0FBbUM7QUFDL0Ysd0NBQXdDLDZCQUE2Qjs7QUFFckU7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVELFlBQVksa0JBQWtCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsbUJBQW1CLHlCQUF5QjtBQUM1QyxvQkFBb0IsMEJBQTBCO0FBQzlDLG9CQUFvQiwyQkFBMkI7O0FBRS9DO0FBQ0E7QUFDQSxnRUFBZ0UsZUFBZTtBQUMvRSw4REFBOEQsZUFBZTtBQUM3RSwwQkFBMEIsbUJBQW1CO0FBQzdDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGVBQWU7QUFDekUsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4RUFBOEU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUIsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0QsWUFBWSxrREFBa0Q7QUFDOUQsK0JBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hELDZCQUE2QjtBQUM3QjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQSx3QkFBd0I7QUFDeEIseUZBQXlGO0FBQ3pGLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLE9BQU8sa0ZBQWtGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLE9BQU8sK0JBQStCLGNBQWM7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLGVBQWUsV0FBVztBQUMxQixtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEMsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDLEVBQUU7QUFDbkU7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxtQ0FBbUM7O0FBRW5DO0FBQ0EscUNBQXFDLDJDQUEyQztBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRCx3QkFBd0Isb0JBQW9CO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDLFNBQVMsNkRBQTZEO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtCQUErQjtBQUNsRCx5QkFBeUIsOEJBQThCO0FBQ3ZELEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUNBQXVDO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCLHVCQUF1QjtBQUM5RDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLG9DQUFvQyxnRkFBZ0YsRUFBRTtBQUN0SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQyxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDRDQUE0QztBQUNyRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUNBQXVDO0FBQzlDO0FBQ0EsT0FBTyx3Q0FBd0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtQ0FBbUM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0I7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQXdELHlCQUF5QjtBQUMxRjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLDhDQUE4QyxZQUFZLHlCQUF5QixFQUFFO0FBQ3JGLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0MsT0FBTyx1Q0FBdUM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixxQkFBcUI7O0FBRXJCLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDLGFBQWEsdUNBQXVDLGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckMscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBLHlCQUF5QixvREFBb0Q7QUFDN0UsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIseURBQXlEO0FBQ2xGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUMsT0FBTyxpRUFBaUU7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUMsV0FBVztBQUNYLG1FQUFtRTtBQUNuRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFzRDtBQUN2RSxtQ0FBbUM7QUFDbkMsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sZ0RBQWdEOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLDZCQUE2QjtBQUNwQzs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQiw2QkFBNkI7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEVBQThFO0FBQzNGO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtFQUFrRTtBQUM3RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxZQUFZO0FBQ1osS0FBSztBQUNMLGdEQUFnRDtBQUNoRCxZQUFZO0FBQ1osS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCLCtCQUErQjtBQUNoRCxlQUFlLDJCQUEyQjtBQUMxQyxpQkFBaUIsaUJBQWlCO0FBQ2xDLGlDQUFpQyxxQkFBcUI7QUFDdEQsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCLDZDQUE2Qzs7QUFFOUQ7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QyxTQUFTLHVCQUF1QiwwRkFBMEYsRUFBRTtBQUM1SCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEZBQThGO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBa0Q7QUFDakU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0IseUNBQXlDLEVBQUU7QUFDNUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsNENBQTRDLFVBQVU7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsTUFBTSxFQUFFO0FBQ1I7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLFNBQVMsb0NBQW9DO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiwrQ0FBK0M7QUFDbkUsaUJBQWlCLG9EQUFvRDtBQUNyRSxVQUFVLCtCQUErQjtBQUN6Qzs7QUFFQTtBQUNBLE9BQU8sc0JBQXNCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxPQUFPLDBCQUEwQjs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLCtCQUErQiwrQkFBK0I7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEI7QUFDQSxPQUFPLHNDQUFzQztBQUM3QztBQUNBLE9BQU8sZ0RBQWdEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9DQUFvQztBQUM5RCwyQkFBMkIsK0RBQStEO0FBQzFGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsV0FBVztBQUN6Qiw0QkFBNEIseURBQXlEO0FBQ3JGLGtDQUFrQyw2QkFBNkI7QUFDL0QscUJBQXFCLCtDQUErQztBQUNwRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUMsbUJBQW1CO0FBQzlFLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRDQUE0QztBQUNoRixVQUFVLHFCQUFxQjtBQUMvQixxQkFBcUI7QUFDckIsaUNBQWlDLHVDQUF1QztBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyQkFBMkI7O0FBRXREO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0IsT0FBTyx3QkFBd0I7QUFDdEUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsU0FBUywwQkFBMEIsY0FBYztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1CQUFtQjs7QUFFOUM7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEIscUJBQXFCO0FBQzVFLCtCQUErQjtBQUMvQjtBQUNBLFNBQVMsT0FBTyxVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQiwwQkFBMEIsT0FBTyxrQ0FBa0M7QUFDeEYsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLGlDQUFpQztBQUNqQztBQUNBLFNBQVMsT0FBTyxVQUFVO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0MsT0FBTywwQkFBMEIsRUFBRSxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG1CQUFtQixlQUFlLE9BQU8scUJBQXFCLG1CQUFtQixFQUFFO0FBQ25GLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQix3Q0FBd0MsNENBQTRDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDBCQUEwQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFELFlBQVksbUZBQW1GO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSxxR0FBcUc7QUFDbEg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0Esa0JBQWtCLGtEQUFrRDtBQUNwRTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0Esa0NBQWtDLHlDQUF5QztBQUMzRTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdEQUFnRDtBQUN6RDtBQUNBLDJEQUEyRCxrQkFBa0IseUJBQXlCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsOENBQThDLDZCQUE2QjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0EsYUFBYSxzREFBc0Q7QUFDbkUsaUJBQWlCLGtCQUFrQjtBQUNuQyxzQkFBc0IscUJBQXFCO0FBQzNDOztBQUVBLGlFQUFpRTtBQUNqRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVTtBQUM1RDtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLCtDQUErQztBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3RUFBd0U7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBNEQ7QUFDbkcsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTywwQkFBMEIsdUNBQXVDLGdCQUFnQjs7QUFFeEY7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0IscURBQXFELDJCQUEyQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQixvQ0FBb0MsMkJBQTJCO0FBQy9ELEtBQUssRUFBRTs7QUFFUCw4QkFBOEIsOENBQThDLHVCQUF1QixFQUFFLEVBQUU7O0FBRXZHO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQjtBQUN6RDtBQUNBLFNBQVMsdUNBQXVDO0FBQ2hEO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QixjQUFjLE9BQU8sOEJBQThCLEVBQUU7QUFDdEYsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLE9BQU8sMEJBQTBCO0FBQ2pDOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxPQUFPLHlCQUF5QjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBNkM7QUFDaEU7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDLFNBQVMsOEJBQThCLFNBQVM7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDRGQUE0RixpQkFBaUIsRUFBRTtBQUMvRzs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1QkFBdUIsRUFBRTtBQUM1RSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw0QkFBNEIsZUFBZTs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsOEJBQThCO0FBQ2hFLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQThDO0FBQzdELFlBQVksc0RBQXNEO0FBQ2xFLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQixPQUFPLDJCQUEyQjtBQUN6RTtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsc0NBQXNDLEVBQUU7O0FBRXJFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLG9GQUFvRjtBQUNwRixvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLOztBQUVMLDZCQUE2QixpQ0FBaUMsb0JBQW9COztBQUVsRixtQ0FBbUMseUJBQXlCLDhCQUE4QjtBQUMxRixtQ0FBbUMsb0JBQW9COztBQUV2RDtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQSxLQUFLOztBQUVMLDJCQUEyQixpQkFBaUI7QUFDNUMsMkJBQTJCLGtCQUFrQjtBQUM3QywwQkFBMEIsa0NBQWtDOztBQUU1RCw0QkFBNEIsMEJBQTBCOztBQUV0RDtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRCxtQ0FBbUMsb0JBQW9CO0FBQ3ZELG9FQUFvRSxrQkFBa0I7QUFDdEYsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLHlCQUF5QjtBQUN6RCxtQ0FBbUMsb0NBQW9DOztBQUV2RTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEMsU0FBUztBQUNULDhFQUE4RTtBQUM5RSw0QkFBNEIsMkRBQTJEO0FBQ3ZGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsWUFBWTtBQUNaLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBLGdDQUFnQyxpREFBaUQ7QUFDakY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pELFNBQVMsZUFBZTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQsU0FBUyxnQ0FBZ0M7QUFDekMsbUJBQW1CLDBDQUEwQztBQUM3RCx5QkFBeUIsOEJBQThCO0FBQ3ZELEtBQUs7QUFDTCxrQ0FBa0MscUNBQXFDO0FBQ3ZFLGtDQUFrQyxxQ0FBcUM7QUFDdkUsMkNBQTJDLDJDQUEyQztBQUN0RiwyQ0FBMkMsMkNBQTJDOztBQUV0RixpQ0FBaUMsbUJBQW1CO0FBQ3BELDhCQUE4QixtQkFBbUI7O0FBRWpEO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCLE9BQU8sNEJBQTRCLFFBQVEsRUFBRTtBQUN4Rix1QkFBdUIsMEJBQTBCLFNBQVMsZ0NBQWdDLFVBQVUsRUFBRTtBQUN0RyxjQUFjO0FBQ2QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMscUNBQXFDLEVBQUU7QUFDOUUsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTLCtFQUErRTtBQUN4RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBLHlDQUF5QywyQkFBMkI7QUFDcEU7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjtBQUN6RTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLE9BQU87QUFDUDtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QyxtREFBbUQ7QUFDbkQsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxnQkFBZ0IsRUFBRTs7QUFFMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0Isa0JBQWtCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaURBQWlEO0FBQzVELE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQ0FBK0M7QUFDNUQsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQixnQkFBZ0I7QUFDbEQsV0FBVywyQkFBMkIsNkJBQTZCLEVBQUUsRUFBRTtBQUN2RSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0Usa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBLCtCQUErQjtBQUMvQixPQUFPLEVBQUUsMENBQTBDLDBDQUEwQztBQUM3RixzQkFBc0IsMERBQTBEO0FBQ2hGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNELHdCQUF3QixnQkFBZ0Isd0JBQXdCO0FBQ2hFO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw4QkFBOEIsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQ0FBaUMscUJBQXFCOztBQUV0RCx5QkFBeUIsaUJBQWlCO0FBQzFDLDJCQUEyQixlQUFlOztBQUUxQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLEtBQUs7QUFDTCwrQkFBK0IsOEJBQThCOztBQUU3RDtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDLGtDQUFrQztBQUNsQztBQUNBLGlDQUFpQywwQkFBMEIsRUFBRTtBQUM3RCxvQkFBb0IsMkJBQTJCO0FBQy9DLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHdEQUF3RCxrQkFBa0IsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0IsT0FBTywrQkFBK0I7QUFDN0UsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBLHlCQUF5QixrQkFBa0IsdUJBQXVCO0FBQ2xFLGFBQWEsNEVBQTRFLEVBQUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUUsV0FBVztBQUNsRixnRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVMsUUFBUTtBQUN6RSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUNBQWlDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCLG9CQUFvQixPQUFPLGVBQWU7QUFDL0QsS0FBSyxFQUFFO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsT0FBTyxPQUFPO0FBQ2QsS0FBSztBQUNMO0FBQ0Esb0NBQW9DLGtDQUFrQyxFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUSxPQUFPLGlEQUFpRDtBQUNqRjtBQUNBLG9CQUFvQixXQUFXLFNBQVMsMENBQTBDO0FBQ2xGO0FBQ0EsbUJBQW1CLFdBQVcsU0FBUyx5REFBeUQ7O0FBRWhHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRCx1Q0FBdUMsWUFBWTtBQUNuRCxpREFBaUQsYUFBYTtBQUM5RCx5Q0FBeUMsY0FBYztBQUN2RCxZQUFZO0FBQ1o7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQyxlQUFlLHVCQUF1QjtBQUN0QyxjQUFjLHNCQUFzQjtBQUNwQyxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSw2REFBNkQ7QUFDN0QsMkJBQTJCLHdCQUF3Qjs7QUFFbkQ7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTCw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQix5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlELDBFQUEwRSx1QkFBdUI7QUFDakcseUVBQXlFLHNCQUFzQjtBQUMvRix3REFBd0Qsd0JBQXdCO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMkNBQTJDLG1CQUFtQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDLFNBQVMsK0RBQStEO0FBQ3hFO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsWUFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyREFBMkQsRUFBRTtBQUNyRyxtQ0FBbUMsd0NBQXdDO0FBQzNFLFNBQVMsT0FBTyxvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLHdFQUF3RTtBQUMxRztBQUNBO0FBQ0EscUNBQXFDLFNBQVMsZ0NBQWdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0EsMkNBQTJDOztBQUUzQyxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0ZBQXNGLEVBQUU7QUFDNUgsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUyxrREFBa0Q7QUFDdEU7QUFDQSxXQUFXLFNBQVMsZ0RBQWdEO0FBQ3BFLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLLEVBQUUsRUFBRTtBQUNULCtCQUErQixrREFBa0Q7QUFDakY7QUFDQTtBQUNBLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNiLGdDQUFnQyxrREFBa0Q7QUFDbEY7QUFDQSxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDYix1Q0FBdUM7QUFDdkM7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JELGNBQWM7QUFDZCxLQUFLLEVBQUUsRUFBRTtBQUNULHdDQUF3QztBQUN4QztBQUNBLG9DQUFvQyxxREFBcUQ7QUFDekYsY0FBYztBQUNkLEtBQUssRUFBRSxFQUFFO0FBQ1QseUJBQXlCLGtCQUFrQixFQUFFO0FBQzdDLHlCQUF5QixrQkFBa0IsRUFBRTtBQUM3QyxrQ0FBa0MsMkJBQTJCLEVBQUU7QUFDL0Qsa0NBQWtDLDJCQUEyQixFQUFFO0FBQy9ELCtCQUErQixtREFBbUQsRUFBRTtBQUNwRiw2QkFBNkIsK0NBQStDLEVBQUU7QUFDOUUsZ0NBQWdDLGdEQUFnRCx1Q0FBdUMsRUFBRTtBQUN6SCxPQUFPO0FBQ1AsTUFBTSxFQUFFO0FBQ1IscUNBQXFDLGdEQUFnRCx1Q0FBdUMsRUFBRTtBQUM5SCxPQUFPO0FBQ1AsTUFBTSxFQUFFO0FBQ1IsOEJBQThCLGdEQUFnRCxxQ0FBcUMsRUFBRTtBQUNySCxPQUFPO0FBQ1AsTUFBTSxFQUFFO0FBQ1IsZ0NBQWdDO0FBQ2hDO0FBQ0EsNEJBQTRCLHFEQUFxRDtBQUNqRixLQUFLLFlBQVksRUFBRTtBQUNuQiwrQkFBK0I7QUFDL0I7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLEtBQUssWUFBWSxFQUFFO0FBQ25CLG9DQUFvQztBQUNwQztBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsdURBQXVEO0FBQ3ZEO0FBQ0EsS0FBSyxZQUFZLEVBQUU7QUFDbkIsNkJBQTZCLDZCQUE2QixFQUFFO0FBQzVELCtCQUErQiw0QkFBNEIsRUFBRTtBQUM3RCw2QkFBNkIsNkJBQTZCLEVBQUU7QUFDNUQsK0JBQStCLDRCQUE0QixFQUFFO0FBQzdELCtCQUErQiw2QkFBNkIsRUFBRTtBQUM5RCxnQ0FBZ0MsNEJBQTRCLEVBQUU7QUFDOUQsaUNBQWlDLCtCQUErQixFQUFFO0FBQ2xFLGtDQUFrQyw4QkFBOEIsRUFBRTtBQUNsRSwrQkFBK0IsNkJBQTZCLEVBQUU7QUFDOUQsaUNBQWlDLDZCQUE2QixFQUFFO0FBQ2hFLGdDQUFnQyw4QkFBOEIsRUFBRTtBQUNoRSxnQ0FBZ0MsNEJBQTRCLEVBQUU7QUFDOUQsa0NBQWtDLG9DQUFvQyxFQUFFO0FBQ3hFLGlDQUFpQyw4QkFBOEIsRUFBRTtBQUNqRSxrQ0FBa0MsK0JBQStCLEVBQUU7QUFDbkUsaUNBQWlDLDhCQUE4QixFQUFFO0FBQ2pFLG1DQUFtQyxnQ0FBZ0MsRUFBRTtBQUNyRSxrQ0FBa0MsK0JBQStCLEVBQUU7QUFDbkUsK0JBQStCLG9DQUFvQyxFQUFFO0FBQ3JFLCtCQUErQixrQ0FBa0MsRUFBRTtBQUNuRSwrQkFBK0IsdUNBQXVDLEVBQUU7QUFDeEUsOEJBQThCLGtDQUFrQyxFQUFFO0FBQ2xFO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlELFlBQVksNkJBQTZCO0FBQ3pDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxzQ0FBc0MscUNBQXFDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSxFQUFFO0FBQ1QscUNBQXFDO0FBQ3JDO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0MsU0FBUyxpRkFBaUY7QUFDMUY7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDLFNBQVMsa0RBQWtEO0FBQzNEO0FBQ0EsS0FBSyxFQUFFLEVBQUU7QUFDVCw2QkFBNkIsMkNBQTJDLEVBQUU7QUFDMUUsb0NBQW9DLDZCQUE2QjtBQUNqRTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNELHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU8sd0JBQXdCO0FBQy9CO0FBQ0EsT0FBTyw0Q0FBNEM7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxxQ0FBcUMsRUFBRTtBQUN0RztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLGNBQWM7QUFDZCxLQUFLO0FBQ0wsb0RBQW9ELCtCQUErQixFQUFFO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RCxxQ0FBcUMsRUFBRTtBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxtREFBbUQsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBc0M7QUFDL0M7QUFDQTtBQUNBLE9BQU8sNkJBQTZCOztBQUVwQztBQUNBO0FBQ0EsT0FBTyxtQkFBbUI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsOEdBQThHO0FBQzlHO0FBQ0EsOENBQThDLHNCQUFzQixxQkFBcUI7QUFDekYsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBDQUEwQyxFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDJCQUEyQjs7QUFFbEMsZ0VBQWdFOztBQUVoRTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQsaURBQWlELHFCQUFxQjtBQUN0RSxLQUFLO0FBQ0wsZ0JBQWdCLDhCQUE4QjtBQUM5Qyw4QkFBOEIsOEJBQThCLEVBQUU7QUFDOUQsS0FBSztBQUNMLDhCQUE4QixtQ0FBbUM7QUFDakUsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRCxrQ0FBa0Msd0JBQXdCO0FBQzFEOztBQUVBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLDhCQUE4QiwrQkFBK0I7QUFDN0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdEQUFnRDtBQUNoRywrQkFBK0Isb0RBQW9EO0FBQ25GLG1DQUFtQywwREFBMEQ7QUFDN0Y7QUFDQTs7QUFFQTtBQUNBLGFBQWEsc0NBQXNDO0FBQ25ELFVBQVUsOEJBQThCOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywrQ0FBK0M7QUFDdEQ7QUFDQSxPQUFPLDRDQUE0QztBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0EsNEJBQTRCLG9DQUFvQztBQUNoRSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEU7QUFDQTtBQUNBLFdBQVcseUJBQXlCLDBDQUEwQyxvQkFBb0IsRUFBRSx3QkFBd0IsTUFBTTtBQUNsSTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBcUI7QUFDdEQ7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEIsRUFBRTtBQUM1RDtBQUNBLG9DQUFvQyw2QkFBNkI7QUFDakU7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBLFNBQVMsb0NBQW9DO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFNBQVMsNkVBQTZFO0FBQ3RGO0FBQ0EsU0FBUyxrQkFBa0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhLGdFQUFnRTtBQUM3RTtBQUNBLGFBQWEseUZBQXlGO0FBQ3RHO0FBQ0EsNkJBQTZCLHNDQUFzQztBQUNuRTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1Q0FBdUMsMEJBQTBCLFdBQVcsR0FBRyxRQUFRO0FBQ2xHLE9BQU87QUFDUDtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRCxZQUFZLFdBQVc7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0EsU0FBUyxvQkFBb0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyxnQkFBZ0IsZ0JBQWdCO0FBQzNDLGtCQUFrQjtBQUNsQjtBQUNBLDZFQUE2RTtBQUM3RSxrQkFBa0IscUJBQXFCOztBQUV2QztBQUNBOztBQUVBLHVEQUF1RDtBQUN2RDs7QUFFQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsK0NBQStDO0FBQy9DLDZCQUE2QixtQ0FBbUM7QUFDaEU7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMscUJBQXFCOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw2Q0FBNkMsa0JBQWtCLHNCQUFzQixHQUFHLFVBQVU7QUFDbEc7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLHlCQUF5QixFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3Q0FBd0MsUUFBUTtBQUNoRCxTQUFTLCtGQUErRjtBQUN4RyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLEtBQUs7QUFDTCxtRkFBbUYscUJBQXFCLEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9EQUFvRCw0Q0FBNEMsRUFBRTtBQUNsRyxxREFBcUQsNkNBQTZDLEVBQUU7QUFDcEcsd0RBQXdELGdEQUFnRCxFQUFFO0FBQzFHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1QkFBdUI7QUFDdkQsd0JBQXdCLCtCQUErQjtBQUN2RCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0RBQStELDZCQUE2QixFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0RBQXNELGdCQUFnQixFQUFFO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxzREFBc0QsV0FBVywwQkFBMEIsR0FBRztBQUM5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCx1Q0FBdUMsRUFBRTtBQUMxRjtBQUNBLGdEQUFnRCxxQkFBcUIsRUFBRTtBQUN2RTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRCxLQUFLOztBQUVMLGlEQUFpRCx5REFBeUQsRUFBRTtBQUM1RztBQUNBLG1EQUFtRCxpQ0FBaUMsRUFBRTtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkIsRUFBRTtBQUMzRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsa0ZBQWtGO0FBQ25ILDRCQUE0QiwrQkFBK0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0RBQXNEO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsdUJBQXVCOztBQUU5RDtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5Qix5Q0FBeUMsRUFBRSxNQUFNOztBQUUxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCx5REFBeUQsaUJBQWlCO0FBQzFFLE9BQU8sTUFBTTtBQUNiO0FBQ0EsT0FBTyxjQUFjOztBQUVyQixxQ0FBcUM7QUFDckMsT0FBTywrQ0FBK0MsRUFBRTtBQUN4RDtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQsbUJBQW1CLHNCQUFzQixPQUFPLG9CQUFvQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw4Q0FBOEM7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9DQUFvQztBQUNwQztBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVjtBQUNBLE9BQU8sMENBQTBDLHFEQUFxRCxFQUFFLEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDZCQUE2QixFQUFFO0FBQy9FO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRSxLQUFLOztBQUVMO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxnREFBZ0QsNkJBQTZCLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQSxXQUFXLDRFQUE0RTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLDZCQUE2QixFQUFFO0FBQzlFLG1EQUFtRCw2QkFBNkIsRUFBRTs7QUFFbEY7QUFDQSx5Q0FBeUMsdURBQXVELEVBQUU7O0FBRWxHO0FBQ0EsMkJBQTJCLDZCQUE2QixXQUFXLEdBQUc7QUFDdEUsMEJBQTBCLDZCQUE2QixtQkFBbUIsV0FBVyxHQUFHO0FBQ3hGLDJCQUEyQiwyQkFBMkIsRUFBRTtBQUN4RDtBQUNBLDJCQUEyQiw2QkFBNkIscUJBQXFCO0FBQzdFOztBQUVBO0FBQ0EsbUNBQW1DLDRCQUE0QixFQUFFO0FBQ2pFO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCLEVBQUU7QUFDNUQsa0NBQWtDLHNCQUFzQixFQUFFO0FBQzFEOztBQUVBO0FBQ0EsNENBQTRDLDBCQUEwQjs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsY0FBYztBQUMzQyxZQUFZLHVDQUF1QztBQUNuRDs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtFQUFrRTtBQUM1RixZQUFZLGlCQUFpQjtBQUM3QixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLGdEQUFnRCxHQUFHLE9BQU8sZUFBZSx1QkFBdUI7QUFDdkcsNEJBQTRCLDZDQUE2Qzs7QUFFekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCO0FBQ3JELGFBQWEscURBQXFEO0FBQ2xFO0FBQ0EsT0FBTztBQUNQLGtEQUFrRCxZQUFZLEVBQUU7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUEwQztBQUNyRDtBQUNBLFdBQVcsK0ZBQStGO0FBQzFHO0FBQ0EsV0FBVywrQkFBK0I7QUFDMUM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sK0JBQStCOztBQUV0QztBQUNBLG1DQUFtQyxvQ0FBb0M7QUFDdkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQixxREFBcUQsRUFBRSxFQUFFO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0EsV0FBVyxxREFBcUQ7QUFDaEU7QUFDQSxxQkFBcUIsdURBQXVEO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsY0FBYyxZQUFZLFlBQVksYUFBYTtBQUNoSCx1REFBdUQsb0JBQW9CLFlBQVksYUFBYTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUMsVUFBVSxnQ0FBZ0M7QUFDMUMsb0JBQW9CO0FBQ3BCLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixlQUFlLDZCQUE2Qjs7QUFFcEU7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEU7QUFDQSxPQUFPOztBQUVQLG1DQUFtQyw0QkFBNEI7QUFDL0QsMEJBQTBCLGdCQUFnQjs7QUFFMUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QyxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPOztBQUVQO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxzQkFBc0I7QUFDdEIsbUVBQW1FO0FBQ25FLHlDQUF5Qyx5QkFBeUIsRUFBRTtBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSw0QkFBNEIsbURBQW1EO0FBQy9FLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQSxrQ0FBa0Msc0NBQXNDO0FBQ3hFLE9BQU87QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEMsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBLGVBQWUsc0ZBQXNGO0FBQ3JHLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOENBQThDLDJCQUEyQjtBQUN6RTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEMsY0FBYyxRQUFRO0FBQ3RCO0FBQ0Esc0RBQXNELGFBQWE7QUFDbkUsOENBQThDLGtCQUFrQjtBQUNoRSxnQkFBZ0IsNEJBQTRCO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9ELFNBQVM7QUFDVCx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDLDRDQUE0QyxnQ0FBZ0M7QUFDNUUsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx3Q0FBd0MscUJBQXFCO0FBQzdEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RCxpQ0FBaUMsYUFBYSxZQUFZO0FBQzFEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0EsT0FBTzs7QUFFUCxxQ0FBcUMsa0NBQWtDO0FBQ3ZFLG9DQUFvQyxpQ0FBaUM7O0FBRXJFLCtCQUErQixTQUFTLHNEQUFzRDs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLGtDQUFrQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0NBQWdDLFVBQVU7QUFDMUMsdUNBQXVDLDJEQUEyRDtBQUNsRztBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QixzRkFBc0YsRUFBRTtBQUMxSCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTzs7QUFFUCxnREFBZ0QsNkJBQTZCLEVBQUU7O0FBRS9FO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVSxrQkFBa0I7QUFDckQ7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSw4QkFBOEIsNEJBQTRCLElBQUk7QUFDOUQsV0FBVyxFQUFFO0FBQ2IsT0FBTzs7QUFFUDtBQUNBO0FBQ0EseUJBQXlCLFVBQVUsa0JBQWtCO0FBQ3JEO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlDQUF5QyxpQ0FBaUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwRUFBMEU7QUFDdkY7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCLGdCQUFnQiwyQkFBMkI7QUFDdEUsV0FBVyx5Q0FBeUMsRUFBRTtBQUN0RCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxTQUFTLEVBQUUsT0FBTyxPQUFPO0FBQ2pHO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVELG9EQUFvRCxzQkFBc0I7QUFDMUUsNkJBQTZCLDRDQUE0QztBQUN6RSw4REFBOEQsU0FBUztBQUN2RSxnRUFBZ0UsT0FBTztBQUN2RTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLFdBQVcsMERBQTBEO0FBQ3JFO0FBQ0EsV0FBVyx5REFBeUQ7O0FBRXBFO0FBQ0EsT0FBTztBQUNQLDRCQUE0QixzREFBc0Q7QUFDbEYsOEJBQThCLHdEQUF3RDs7QUFFdEYsMENBQTBDLDRCQUE0QixFQUFFO0FBQ3hFO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLCtCQUErQiwwQ0FBMEM7QUFDekUsU0FBUztBQUNULG1CQUFtQjtBQUNuQixTQUFTO0FBQ1QsbUJBQW1CO0FBQ25CO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsd0NBQXdDLCtFQUErRTtBQUN2SCw0QkFBNEIscURBQXFEO0FBQ2pGLDZCQUE2Qix1REFBdUQ7QUFDcEYsd0NBQXdDLGlDQUFpQztBQUN6RTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQix5QkFBeUI7QUFDdEUsYUFBYSxpQ0FBaUMseUNBQXlDLFFBQVEsRUFBRTtBQUNqRztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTzs7QUFFUCw2QkFBNkIsd0JBQXdCO0FBQ3JELGlDQUFpQyw0QkFBNEI7QUFDN0QsK0JBQStCLDBCQUEwQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkJBQTJCO0FBQ3RDO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsZ0NBQWdDLHFDQUFxQztBQUNyRSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLHFDQUFxQyw2QkFBNkI7QUFDbEUsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMscUNBQXFDLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsK0RBQStEO0FBQzFFO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBLHdCQUF3QixRQUFRLFlBQVk7QUFDNUM7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw0QkFBNEI7QUFDNUIsK0NBQStDLHVCQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsR0FBRztBQUMvQix1QkFBdUI7QUFDdkIsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLDZCQUE2Qix1Q0FBdUMsK0JBQStCLEVBQUUsT0FBTztBQUM1RyxLQUFLOztBQUVMO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTDtBQUNBLDhCQUE4QixxQkFBcUIsMkJBQTJCO0FBQzlFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx1Q0FBdUMsb0NBQW9DLEVBQUU7O0FBRTdFO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RCxLQUFLOztBQUVMO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsdUJBQXVCLDBDQUEwQztBQUNqRSw4QkFBOEIsc0NBQXNDO0FBQ3BFLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQsa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsNkRBQTZEO0FBQ3RFLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CO0FBQzdELHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtDQUFrQyxnREFBZ0QsRUFBRSxFQUFFO0FBQy9GLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1EQUFtRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsaUJBQWlCO0FBQ3RFLHlEQUF5RDs7QUFFekQsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBLE9BQU8sK0JBQStCLCtDQUErQyxFQUFFLEVBQUU7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNEQUFzRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUMsa0NBQWtDO0FBQ3JFLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrRUFBa0U7QUFDekU7QUFDQSxPQUFPLDBCQUEwQjtBQUNqQyx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZSxlQUFlLFVBQVU7QUFDakYsMENBQTBDLGlCQUFpQixpQkFBaUIsWUFBWTtBQUN4RixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFVBQVU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU8sK0JBQStCLDZCQUE2QixFQUFFLEVBQUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxPQUFPLGtIQUFrSDtBQUN6SDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsT0FBTyx3REFBd0QsY0FBYztBQUM3RTtBQUNBOztBQUVBLDZCQUE2QixXQUFXLGdCQUFnQixFQUFFOztBQUUxRDtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQix3QkFBd0IsRUFBRTtBQUN2RjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlFQUFpRTtBQUM5RTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0EsMkVBQTJFOztBQUUzRSxzQkFBc0IsU0FBUztBQUMvQix1QkFBdUIsNEJBQTRCO0FBQ25ELFdBQVcsMEJBQTBCOztBQUVyQywrQ0FBK0MsdUJBQXVCO0FBQ3RFLHNCQUFzQixnQkFBZ0I7QUFDdEMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixLQUFLO0FBQ0wsNEJBQTRCO0FBQzVCLDBEQUEwRDtBQUMxRCwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQSwyQ0FBMkMsOEJBQThCO0FBQ3pFOztBQUVBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0NBQWdDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxtR0FBbUcsT0FBTztBQUMxRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxrQ0FBa0M7QUFDM0M7QUFDQSwrREFBK0QsUUFBUTtBQUN2RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUyxxQ0FBcUM7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsd0JBQXdCOztBQUV0QztBQUNBLHlEQUF5RCw0QkFBNEI7QUFDckY7QUFDQSxLQUFLOztBQUVMO0FBQ0Esd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGtDQUFrQztBQUNsQztBQUNBLHVCQUF1QiwwQ0FBMEM7QUFDakUsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RCxLQUFLOztBQUVMO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQSx1REFBdUQsa0NBQWtDO0FBQ3pGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RCxrQ0FBa0MsNkJBQTZCO0FBQy9ELEtBQUs7QUFDTDtBQUNBLGtDQUFrQywwQkFBMEI7QUFDNUQ7QUFDQTs7QUFFQSxrREFBa0Q7O0FBRWxELHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBLDhDQUE4QyxzQkFBc0I7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsaUJBQWlCOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEUsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLFFBQVE7O0FBRXJGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCxxQ0FBcUM7QUFDL0YsWUFBWSx5QkFBeUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQ0FBa0M7QUFDOUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7O0FBRUE7QUFDQSxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQSx5QkFBeUIsU0FBUzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDJFQUEyRTs7QUFFbEY7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWEsY0FBYyx3REFBd0QsbURBQW1ELHNCQUFzQix1RUFBdUUsc0JBQXNCLGlCQUFpQixlQUFlLGtCQUFrQixjQUFjLDBCQUEwQjtBQUM5WDtBQUNBLGlCQUFpQiw2QkFBNkIsRUFBRTtBQUNoRDtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxrQ0FBa0M7QUFDcEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5RUFBeUU7O0FBRTFHO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sc0NBQXNDO0FBQzdDO0FBQ0EsT0FBTyw0Q0FBNEM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxpQkFBaUI7QUFDckQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQ0FBbUM7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHFFQUFxRSxFQUFFO0FBQ2hIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLEtBQUs7QUFDTCx5QkFBeUI7QUFDekIsS0FBSyx1QkFBdUIsRUFBRTs7QUFFOUI7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlDQUFpQztBQUN2RjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkNBQTZDLFVBQVUsMEJBQTBCLDJCQUEyQixHQUFHLEVBQUUsRUFBRTtBQUNuSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gVGhpcyBpcyBDb2RlTWlycm9yIChodHRwczovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxuLy8gaW1wbGVtZW50ZWQgaW4gSmF2YVNjcmlwdCBvbiB0b3Agb2YgdGhlIGJyb3dzZXIncyBET00uXG4vL1xuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcbi8vIGF0IGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy8jY20taW50ZXJuYWxzIC5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Db2RlTWlycm9yID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxuICAvLyBkZXRlY3RlZCBhcmUgZW5hYmxlZCBiYXNlZCBvbiB1c2VyQWdlbnQgZXRjIHNuaWZmaW5nLlxuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgdmFyIHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtO1xuXG4gIHZhciBnZWNrbyA9IC9nZWNrb1xcL1xcZC9pLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcZC8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xuICB2YXIgZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XG4gIHZhciBpZSA9IGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGVkZ2U7XG4gIHZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogKyhlZGdlIHx8IGllXzExdXApWzFdKTtcbiAgdmFyIHdlYmtpdCA9ICFlZGdlICYmIC9XZWJLaXRcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHF0d2Via2l0ID0gd2Via2l0ICYmIC9RdFxcL1xcZCtcXC5cXGQrLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBjaHJvbWUgPSAhZWRnZSAmJiAvQ2hyb21lXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBwcmVzdG8gPSAvT3BlcmFcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHNhZmFyaSA9IC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KHVzZXJBZ2VudCk7XG5cbiAgdmFyIGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QodXNlckFnZW50KSB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyKTtcbiAgdmFyIGFuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpO1xuICAvLyBUaGlzIGlzIHdvZWZ1bGx5IGluY29tcGxldGUuIFN1Z2dlc3Rpb25zIGZvciBhbHRlcm5hdGl2ZSBtZXRob2RzIHdlbGNvbWUuXG4gIHZhciBtb2JpbGUgPSBpb3MgfHwgYW5kcm9pZCB8fCAvd2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBtYWMgPSBpb3MgfHwgL01hYy8udGVzdChwbGF0Zm9ybSk7XG4gIHZhciBjaHJvbWVPUyA9IC9cXGJDck9TXFxiLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciB3aW5kb3dzID0gL3dpbi9pLnRlc3QocGxhdGZvcm0pO1xuXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7XG4gIGlmIChwcmVzdG9fdmVyc2lvbikgeyBwcmVzdG9fdmVyc2lvbiA9IE51bWJlcihwcmVzdG9fdmVyc2lvblsxXSk7IH1cbiAgaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XG4gIC8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXG4gIHZhciBmbGlwQ3RybENtZCA9IG1hYyAmJiAocXR3ZWJraXQgfHwgcHJlc3RvICYmIChwcmVzdG9fdmVyc2lvbiA9PSBudWxsIHx8IHByZXN0b192ZXJzaW9uIDwgMTIuMTEpKTtcbiAgdmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSk7XG5cbiAgZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xzICsgXCIoPzokfFxcXFxzKVxcXFxzKlwiKSB9XG5cbiAgdmFyIHJtQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBjdXJyZW50LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3VycmVudC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAoYWZ0ZXIgPyBtYXRjaFsxXSArIGFmdGVyIDogXCJcIik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcbiAgICBmb3IgKHZhciBjb3VudCA9IGUuY2hpbGROb2Rlcy5sZW5ndGg7IGNvdW50ID4gMDsgLS1jb3VudClcbiAgICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpOyB9XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xuICAgIHJldHVybiByZW1vdmVDaGlsZHJlbihwYXJlbnQpLmFwcGVuZENoaWxkKGUpXG4gIH1cblxuICBmdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNsYXNzTmFtZSkgeyBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuICAgIGlmIChzdHlsZSkgeyBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKSB7IGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpOyB9XG4gICAgZWxzZSBpZiAoY29udGVudCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyArK2kpIHsgZS5hcHBlbmRDaGlsZChjb250ZW50W2ldKTsgfSB9XG4gICAgcmV0dXJuIGVcbiAgfVxuICAvLyB3cmFwcGVyIGZvciBlbHQsIHdoaWNoIHJlbW92ZXMgdGhlIGVsdCBmcm9tIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWVcbiAgZnVuY3Rpb24gZWx0UCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICB2YXIgZSA9IGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpO1xuICAgIGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgdmFyIHJhbmdlO1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHIuc2V0RW5kKGVuZE5vZGUgfHwgbm9kZSwgZW5kKTtcbiAgICByLnNldFN0YXJ0KG5vZGUsIHN0YXJ0KTtcbiAgICByZXR1cm4gclxuICB9OyB9XG4gIGVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgdHJ5IHsgci5tb3ZlVG9FbGVtZW50VGV4dChub2RlLnBhcmVudE5vZGUpOyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gciB9XG4gICAgci5jb2xsYXBzZSh0cnVlKTtcbiAgICByLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMykgLy8gQW5kcm9pZCBicm93c2VyIGFsd2F5cyByZXR1cm5zIGZhbHNlIHdoZW4gY2hpbGQgaXMgYSB0ZXh0bm9kZVxuICAgICAgeyBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7IH1cbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxuICAgICAgeyByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSB9XG4gICAgZG8ge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSB7IGNoaWxkID0gY2hpbGQuaG9zdDsgfVxuICAgICAgaWYgKGNoaWxkID09IHBhcmVudCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZlRWx0KCkge1xuICAgIC8vIElFIGFuZCBFZGdlIG1heSB0aHJvdyBhbiBcIlVuc3BlY2lmaWVkIEVycm9yXCIgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5cbiAgICAvLyBJRSA8IDEwIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCB3aGlsZSB0aGUgcGFnZSBpcyBsb2FkaW5nIG9yIGluIGFuIGlmcmFtZS5cbiAgICAvLyBJRSA+IDkgYW5kIEVkZ2Ugd2lsbCB0aHJvdyB3aGVuIGFjY2Vzc2VkIGluIGFuIGlmcmFtZSBpZiBkb2N1bWVudC5ib2R5IGlzIHVuYXZhaWxhYmxlLlxuICAgIHZhciBhY3RpdmVFbGVtZW50O1xuICAgIHRyeSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IG51bGw7XG4gICAgfVxuICAgIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgIHsgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50OyB9XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWU7XG4gICAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSB7IG5vZGUuY2xhc3NOYW1lICs9IChjdXJyZW50ID8gXCIgXCIgOiBcIlwiKSArIGNsczsgfVxuICB9XG4gIGZ1bmN0aW9uIGpvaW5DbGFzc2VzKGEsIGIpIHtcbiAgICB2YXIgYXMgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAoYXNbaV0gJiYgIWNsYXNzVGVzdChhc1tpXSkudGVzdChiKSkgeyBiICs9IFwiIFwiICsgYXNbaV07IH0gfVxuICAgIHJldHVybiBiXG4gIH1cblxuICB2YXIgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0KCk7IH07XG4gIGlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9OyB9XG4gIGVsc2UgaWYgKGllKSAvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXG4gICAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKTsgfSBjYXRjaChfZSkge30gfTsgfVxuXG4gIGZ1bmN0aW9uIGJpbmQoZikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlPYmoob2JqLCB0YXJnZXQsIG92ZXJ3cml0ZSkge1xuICAgIGlmICghdGFyZ2V0KSB7IHRhcmdldCA9IHt9OyB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopXG4gICAgICB7IGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKG92ZXJ3cml0ZSAhPT0gZmFsc2UgfHwgIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkpXG4gICAgICAgIHsgdGFyZ2V0W3Byb3BdID0gb2JqW3Byb3BdOyB9IH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbiAgLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbiAgZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXgsIHN0YXJ0VmFsdWUpIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgIGlmIChlbmQgPT0gLTEpIHsgZW5kID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBuID0gc3RhcnRWYWx1ZSB8fCAwOzspIHtcbiAgICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXCJcXHRcIiwgaSk7XG4gICAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXG4gICAgICAgIHsgcmV0dXJuIG4gKyAoZW5kIC0gaSkgfVxuICAgICAgbiArPSBuZXh0VGFiIC0gaTtcbiAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICBpID0gbmV4dFRhYiArIDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB0aGlzLmYgPSBudWxsO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5oYW5kbGVyID0gYmluZCh0aGlzLm9uVGltZW91dCwgdGhpcyk7XG4gIH07XG4gIERlbGF5ZWQucHJvdG90eXBlLm9uVGltZW91dCA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgc2VsZi5pZCA9IDA7XG4gICAgaWYgKHNlbGYudGltZSA8PSArbmV3IERhdGUpIHtcbiAgICAgIHNlbGYuZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHNlbGYuaGFuZGxlciwgc2VsZi50aW1lIC0gK25ldyBEYXRlKTtcbiAgICB9XG4gIH07XG4gIERlbGF5ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChtcywgZikge1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUgKyBtcztcbiAgICBpZiAoIXRoaXMuaWQgfHwgdGltZSA8IHRoaXMudGltZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVyLCBtcyk7XG4gICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoYXJyYXlbaV0gPT0gZWx0KSB7IHJldHVybiBpIH0gfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHBpeGVscyBhZGRlZCB0byBzY3JvbGxlciBhbmQgc2l6ZXIgdG8gaGlkZSBzY3JvbGxiYXJcbiAgdmFyIHNjcm9sbGVyR2FwID0gNTA7XG5cbiAgLy8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxuICAvLyBoYW5kbGluZyB0aGlzJy5cbiAgdmFyIFBhc3MgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5QYXNzXCJ9fTtcblxuICAvLyBSZXVzZWQgb3B0aW9uIG9iamVjdHMgZm9yIHNldFNlbGVjdGlvbiAmIGZyaWVuZHNcbiAgdmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9LCBzZWxfbW91c2UgPSB7b3JpZ2luOiBcIiptb3VzZVwifSwgc2VsX21vdmUgPSB7b3JpZ2luOiBcIittb3ZlXCJ9O1xuXG4gIC8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXG4gIC8vIGEgcGFydGljdWxhciBjb2x1bW4uXG4gIGZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XG4gICAgZm9yICh2YXIgcG9zID0gMCwgY29sID0gMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIHBvcyk7XG4gICAgICBpZiAobmV4dFRhYiA9PSAtMSkgeyBuZXh0VGFiID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgaWYgKG5leHRUYWIgPT0gc3RyaW5nLmxlbmd0aCB8fCBjb2wgKyBza2lwcGVkID49IGdvYWwpXG4gICAgICAgIHsgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpIH1cbiAgICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgY29sICs9IHRhYlNpemUgLSAoY29sICUgdGFiU2l6ZSk7XG4gICAgICBwb3MgPSBuZXh0VGFiICsgMTtcbiAgICAgIGlmIChjb2wgPj0gZ29hbCkgeyByZXR1cm4gcG9zIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3BhY2VTdHJzID0gW1wiXCJdO1xuICBmdW5jdGlvbiBzcGFjZVN0cihuKSB7XG4gICAgd2hpbGUgKHNwYWNlU3Rycy5sZW5ndGggPD0gbilcbiAgICAgIHsgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcIiBcIik7IH1cbiAgICByZXR1cm4gc3BhY2VTdHJzW25dXG4gIH1cblxuICBmdW5jdGlvbiBsc3QoYXJyKSB7IHJldHVybiBhcnJbYXJyLmxlbmd0aC0xXSB9XG5cbiAgZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gZihhcnJheVtpXSwgaSk7IH1cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIHZhbHVlLCBzY29yZSkge1xuICAgIHZhciBwb3MgPSAwLCBwcmlvcml0eSA9IHNjb3JlKHZhbHVlKTtcbiAgICB3aGlsZSAocG9zIDwgYXJyYXkubGVuZ3RoICYmIHNjb3JlKGFycmF5W3Bvc10pIDw9IHByaW9yaXR5KSB7IHBvcysrOyB9XG4gICAgYXJyYXkuc3BsaWNlKHBvcywgMCwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aGluZygpIHt9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XG4gICAgdmFyIGluc3Q7XG4gICAgaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgICAgIGluc3QgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2U7XG4gICAgICBpbnN0ID0gbmV3IG5vdGhpbmcoKTtcbiAgICB9XG4gICAgaWYgKHByb3BzKSB7IGNvcHlPYmoocHJvcHMsIGluc3QpOyB9XG4gICAgcmV0dXJuIGluc3RcbiAgfVxuXG4gIHZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbiAgZnVuY3Rpb24gaXNXb3JkQ2hhckJhc2ljKGNoKSB7XG4gICAgcmV0dXJuIC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmXG4gICAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKVxuICB9XG4gIGZ1bmN0aW9uIGlzV29yZENoYXIoY2gsIGhlbHBlcikge1xuICAgIGlmICghaGVscGVyKSB7IHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpIH1cbiAgICBpZiAoaGVscGVyLnNvdXJjZS5pbmRleE9mKFwiXFxcXHdcIikgPiAtMSAmJiBpc1dvcmRDaGFyQmFzaWMoY2gpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gaGVscGVyLnRlc3QoY2gpXG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIG4gaW4gb2JqKSB7IGlmIChvYmouaGFzT3duUHJvcGVydHkobikgJiYgb2JqW25dKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gRXh0ZW5kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy4gQSBzZXJpZXMgb2YgYSBub24tZXh0ZW5kaW5nIGNoYXIgK1xuICAvLyBhbnkgbnVtYmVyIG9mIGV4dGVuZGluZyBjaGFycyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHVuaXQgYXMgZmFyXG4gIC8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXG4gIC8vIHNpbmNlIHNvbWUgc2NyaXB0cy9mb250cy9icm93c2VycyBhbHNvIHRyZWF0IG90aGVyIGNvbmZpZ3VyYXRpb25zXG4gIC8vIG9mIGNvZGUgcG9pbnRzIGFzIGEgZ3JvdXAuXG4gIHZhciBleHRlbmRpbmdDaGFycyA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjVlXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGUtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA5MDAtXFx1MDkwMlxcdTA5M2NcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU1XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MGEwMVxcdTBhMDJcXHUwYTNjXFx1MGE0MVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwXFx1MGE3MVxcdTBhNzVcXHUwYTgxXFx1MGE4MlxcdTBhYmNcXHUwYWMxLVxcdTBhYzVcXHUwYWM3XFx1MGFjOFxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0XFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOFxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOTAtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzYVxcdTEwM2RcXHUxMDNlXFx1MTA1OFxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExN1xcdTFhMThcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWIwMC1cXHUxYjAzXFx1MWIzNFxcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MFxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4XFx1MWJhOVxcdTFjMmMtXFx1MWMzM1xcdTFjMzZcXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFkYzAtXFx1MWRlNlxcdTFkZmQtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjBkMC1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjZmLVxcdWE2NzJcXHVhNjdjXFx1YTY3ZFxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmNcXHVhYTI5LVxcdWFhMmVcXHVhYTMxXFx1YWEzMlxcdWFhMzVcXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVkYzAwLVxcdWRmZmZcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmY5ZVxcdWZmOWZdLztcbiAgZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApID49IDc2OCAmJiBleHRlbmRpbmdDaGFycy50ZXN0KGNoKSB9XG5cbiAgLy8gUmV0dXJucyBhIG51bWJlciBmcm9tIHRoZSByYW5nZSBbYDBgOyBgc3RyLmxlbmd0aGBdIHVubGVzcyBgcG9zYCBpcyBvdXRzaWRlIHRoYXQgcmFuZ2UuXG4gIGZ1bmN0aW9uIHNraXBFeHRlbmRpbmdDaGFycyhzdHIsIHBvcywgZGlyKSB7XG4gICAgd2hpbGUgKChkaXIgPCAwID8gcG9zID4gMCA6IHBvcyA8IHN0ci5sZW5ndGgpICYmIGlzRXh0ZW5kaW5nQ2hhcihzdHIuY2hhckF0KHBvcykpKSB7IHBvcyArPSBkaXI7IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSByYW5nZSBbYGZyb21gOyBgdG9gXSB0aGF0IHNhdGlzZmllc1xuICAvLyBgcHJlZGAgYW5kIGlzIGNsb3Nlc3QgdG8gYGZyb21gLiBBc3N1bWVzIHRoYXQgYXQgbGVhc3QgYHRvYFxuICAvLyBzYXRpc2ZpZXMgYHByZWRgLiBTdXBwb3J0cyBgZnJvbWAgYmVpbmcgZ3JlYXRlciB0aGFuIGB0b2AuXG4gIGZ1bmN0aW9uIGZpbmRGaXJzdChwcmVkLCBmcm9tLCB0bykge1xuICAgIC8vIEF0IGFueSBwb2ludCB3ZSBhcmUgY2VydGFpbiBgdG9gIHNhdGlzZmllcyBgcHJlZGAsIGRvbid0IGtub3dcbiAgICAvLyB3aGV0aGVyIGBmcm9tYCBkb2VzLlxuICAgIHZhciBkaXIgPSBmcm9tID4gdG8gPyAtMSA6IDE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKGZyb20gPT0gdG8pIHsgcmV0dXJuIGZyb20gfVxuICAgICAgdmFyIG1pZEYgPSAoZnJvbSArIHRvKSAvIDIsIG1pZCA9IGRpciA8IDAgPyBNYXRoLmNlaWwobWlkRikgOiBNYXRoLmZsb29yKG1pZEYpO1xuICAgICAgaWYgKG1pZCA9PSBmcm9tKSB7IHJldHVybiBwcmVkKG1pZCkgPyBmcm9tIDogdG8gfVxuICAgICAgaWYgKHByZWQobWlkKSkgeyB0byA9IG1pZDsgfVxuICAgICAgZWxzZSB7IGZyb20gPSBtaWQgKyBkaXI7IH1cbiAgICB9XG4gIH1cblxuICAvLyBCSURJIEhFTFBFUlNcblxuICBmdW5jdGlvbiBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tLCB0bywgZikge1xuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGYoZnJvbSwgdG8sIFwibHRyXCIsIDApIH1cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XG4gICAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcInJ0bFwiIDogXCJsdHJcIiwgaSk7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgeyBmKGZyb20sIHRvLCBcImx0clwiKTsgfVxuICB9XG5cbiAgdmFyIGJpZGlPdGhlciA9IG51bGw7XG4gIGZ1bmN0aW9uIGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoLCBzdGlja3kpIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgYmlkaU90aGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY3VyID0gb3JkZXJbaV07XG4gICAgICBpZiAoY3VyLmZyb20gPCBjaCAmJiBjdXIudG8gPiBjaCkgeyByZXR1cm4gaSB9XG4gICAgICBpZiAoY3VyLnRvID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ID09IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyLmZyb20gPT0gY2gpIHtcbiAgICAgICAgaWYgKGN1ci5mcm9tICE9IGN1ci50byAmJiBzdGlja3kgIT0gXCJiZWZvcmVcIikgeyBmb3VuZCA9IGk7IH1cbiAgICAgICAgZWxzZSB7IGJpZGlPdGhlciA9IGk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kICE9IG51bGwgPyBmb3VuZCA6IGJpZGlPdGhlclxuICB9XG5cbiAgLy8gQmlkaXJlY3Rpb25hbCBvcmRlcmluZyBhbGdvcml0aG1cbiAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxuICAvLyB0aGF0IHRoaXMgKHBhcnRpYWxseSkgaW1wbGVtZW50cy5cblxuICAvLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XG4gIC8vIEwgKEwpOiAgIExlZnQtdG8tUmlnaHRcbiAgLy8gUiAoUik6ICAgUmlnaHQtdG8tTGVmdFxuICAvLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xuICAvLyAxIChFTik6ICBFdXJvcGVhbiBOdW1iZXJcbiAgLy8gKyAoRVMpOiAgRXVyb3BlYW4gTnVtYmVyIFNlcGFyYXRvclxuICAvLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxuICAvLyBuIChBTik6ICBBcmFiaWMgTnVtYmVyXG4gIC8vICwgKENTKTogIENvbW1vbiBOdW1iZXIgU2VwYXJhdG9yXG4gIC8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcbiAgLy8gYiAoQk4pOiAgQm91bmRhcnkgTmV1dHJhbFxuICAvLyBzIChCKTogICBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gIC8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXG4gIC8vIHcgKFdTKTogIFdoaXRlc3BhY2VcbiAgLy8gTiAoT04pOiAgT3RoZXIgTmV1dHJhbHNcblxuICAvLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxuICAvLyAobGVmdC10by1yaWdodCksIG9yIGFuIGFycmF5IG9mIHNlY3Rpb25zICh7ZnJvbSwgdG8sIGxldmVsfVxuICAvLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cbiAgdmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGZmXG4gICAgdmFyIGxvd1R5cGVzID0gXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlwiO1xuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuICAgIHZhciBhcmFiaWNUeXBlcyA9IFwibm5ubm5uTk5yJSVyLHJOTm1tbW1tbW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbW1tbm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1uTm1tbW1tbXJybW1ObW1tbXJyMTExMTExMTExMVwiO1xuICAgIGZ1bmN0aW9uIGNoYXJUeXBlKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlIDw9IDB4ZjcpIHsgcmV0dXJuIGxvd1R5cGVzLmNoYXJBdChjb2RlKSB9XG4gICAgICBlbHNlIGlmICgweDU5MCA8PSBjb2RlICYmIGNvZGUgPD0gMHg1ZjQpIHsgcmV0dXJuIFwiUlwiIH1cbiAgICAgIGVsc2UgaWYgKDB4NjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZmOSkgeyByZXR1cm4gYXJhYmljVHlwZXMuY2hhckF0KGNvZGUgLSAweDYwMCkgfVxuICAgICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSB7IHJldHVybiBcInJcIiB9XG4gICAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgeyByZXR1cm4gXCJ3XCIgfVxuICAgICAgZWxzZSBpZiAoY29kZSA9PSAweDIwMGMpIHsgcmV0dXJuIFwiYlwiIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gXCJMXCIgfVxuICAgIH1cblxuICAgIHZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuICAgIHZhciBpc05ldXRyYWwgPSAvW3N0d05dLywgaXNTdHJvbmcgPSAvW0xScl0vLCBjb3VudHNBc0xlZnQgPSAvW0xiMW5dLywgY291bnRzQXNOdW0gPSAvWzFuXS87XG5cbiAgICBmdW5jdGlvbiBCaWRpU3BhbihsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gXCJsdHJcIiA/IFwiTFwiIDogXCJSXCI7XG5cbiAgICAgIGlmIChzdHIubGVuZ3RoID09IDAgfHwgZGlyZWN0aW9uID09IFwibHRyXCIgJiYgIWJpZGlSRS50ZXN0KHN0cikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgICAgeyB0eXBlcy5wdXNoKGNoYXJUeXBlKHN0ci5jaGFyQ29kZUF0KGkpKSk7IH1cblxuICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpJDEgPCBsZW47ICsraSQxKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaSQxXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJtXCIpIHsgdHlwZXNbaSQxXSA9IHByZXY7IH1cbiAgICAgICAgZWxzZSB7IHByZXYgPSB0eXBlOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cbiAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgIC8vIG51bWJlci5cbiAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxuICAgICAgZm9yICh2YXIgaSQyID0gMCwgY3VyID0gb3V0ZXJUeXBlOyBpJDIgPCBsZW47ICsraSQyKSB7XG4gICAgICAgIHZhciB0eXBlJDEgPSB0eXBlc1tpJDJdO1xuICAgICAgICBpZiAodHlwZSQxID09IFwiMVwiICYmIGN1ciA9PSBcInJcIikgeyB0eXBlc1tpJDJdID0gXCJuXCI7IH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDEpKSB7IGN1ciA9IHR5cGUkMTsgaWYgKHR5cGUkMSA9PSBcInJcIikgeyB0eXBlc1tpJDJdID0gXCJSXCI7IH0gfVxuICAgICAgfVxuXG4gICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcbiAgICAgIC8vIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vbiBzZXBhcmF0b3IgYmV0d2VlblxuICAgICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgIGZvciAodmFyIGkkMyA9IDEsIHByZXYkMSA9IHR5cGVzWzBdOyBpJDMgPCBsZW4gLSAxOyArK2kkMykge1xuICAgICAgICB2YXIgdHlwZSQyID0gdHlwZXNbaSQzXTtcbiAgICAgICAgaWYgKHR5cGUkMiA9PSBcIitcIiAmJiBwcmV2JDEgPT0gXCIxXCIgJiYgdHlwZXNbaSQzKzFdID09IFwiMVwiKSB7IHR5cGVzW2kkM10gPSBcIjFcIjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlJDIgPT0gXCIsXCIgJiYgcHJldiQxID09IHR5cGVzW2kkMysxXSAmJlxuICAgICAgICAgICAgICAgICAocHJldiQxID09IFwiMVwiIHx8IHByZXYkMSA9PSBcIm5cIikpIHsgdHlwZXNbaSQzXSA9IHByZXYkMTsgfVxuICAgICAgICBwcmV2JDEgPSB0eXBlJDI7XG4gICAgICB9XG5cbiAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgIC8vIE5ldXRyYWwuXG4gICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBsZW47ICsraSQ0KSB7XG4gICAgICAgIHZhciB0eXBlJDMgPSB0eXBlc1tpJDRdO1xuICAgICAgICBpZiAodHlwZSQzID09IFwiLFwiKSB7IHR5cGVzW2kkNF0gPSBcIk5cIjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlJDMgPT0gXCIlXCIpIHtcbiAgICAgICAgICB2YXIgZW5kID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQgPSBpJDQgKyAxOyBlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIiVcIjsgKytlbmQpIHt9XG4gICAgICAgICAgdmFyIHJlcGxhY2UgPSAoaSQ0ICYmIHR5cGVzW2kkNC0xXSA9PSBcIiFcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiMVwiKSA/IFwiMVwiIDogXCJOXCI7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGkkNDsgaiA8IGVuZDsgKytqKSB7IHR5cGVzW2pdID0gcmVwbGFjZTsgfVxuICAgICAgICAgIGkkNCA9IGVuZCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcbiAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICBmb3IgKHZhciBpJDUgPSAwLCBjdXIkMSA9IG91dGVyVHlwZTsgaSQ1IDwgbGVuOyArK2kkNSkge1xuICAgICAgICB2YXIgdHlwZSQ0ID0gdHlwZXNbaSQ1XTtcbiAgICAgICAgaWYgKGN1ciQxID09IFwiTFwiICYmIHR5cGUkNCA9PSBcIjFcIikgeyB0eXBlc1tpJDVdID0gXCJMXCI7IH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDQpKSB7IGN1ciQxID0gdHlwZSQ0OyB9XG4gICAgICB9XG5cbiAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxuICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xuICAgICAgICBpZiAoaXNOZXV0cmFsLnRlc3QodHlwZXNbaSQ2XSkpIHtcbiAgICAgICAgICB2YXIgZW5kJDEgPSAodm9pZCAwKTtcbiAgICAgICAgICBmb3IgKGVuZCQxID0gaSQ2ICsgMTsgZW5kJDEgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsgKytlbmQkMSkge31cbiAgICAgICAgICB2YXIgYmVmb3JlID0gKGkkNiA/IHR5cGVzW2kkNi0xXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIGFmdGVyID0gKGVuZCQxIDwgbGVuID8gdHlwZXNbZW5kJDFdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcbiAgICAgICAgICB2YXIgcmVwbGFjZSQxID0gYmVmb3JlID09IGFmdGVyID8gKGJlZm9yZSA/IFwiTFwiIDogXCJSXCIpIDogb3V0ZXJUeXBlO1xuICAgICAgICAgIGZvciAodmFyIGokMSA9IGkkNjsgaiQxIDwgZW5kJDE7ICsraiQxKSB7IHR5cGVzW2okMV0gPSByZXBsYWNlJDE7IH1cbiAgICAgICAgICBpJDYgPSBlbmQkMSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxuICAgICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxuICAgICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cbiAgICAgIHZhciBvcmRlciA9IFtdLCBtO1xuICAgICAgZm9yICh2YXIgaSQ3ID0gMDsgaSQ3IDwgbGVuOykge1xuICAgICAgICBpZiAoY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSkpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBpJDc7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pOyArK2kkNykge31cbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBzdGFydCwgaSQ3KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGkkNywgYXQgPSBvcmRlci5sZW5ndGgsIGlzUlRMID0gZGlyZWN0aW9uID09IFwicnRsXCIgPyAxIDogMDtcbiAgICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgdHlwZXNbaSQ3XSAhPSBcIkxcIjsgKytpJDcpIHt9XG4gICAgICAgICAgZm9yICh2YXIgaiQyID0gcG9zOyBqJDIgPCBpJDc7KSB7XG4gICAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKSkge1xuICAgICAgICAgICAgICBpZiAocG9zIDwgaiQyKSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaiQyKSk7IGF0ICs9IGlzUlRMOyB9XG4gICAgICAgICAgICAgIHZhciBuc3RhcnQgPSBqJDI7XG4gICAgICAgICAgICAgIGZvciAoKytqJDI7IGokMiA8IGkkNyAmJiBjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pOyArK2okMikge31cbiAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMiwgbnN0YXJ0LCBqJDIpKTtcbiAgICAgICAgICAgICAgYXQgKz0gaXNSVEw7XG4gICAgICAgICAgICAgIHBvcyA9IGokMjtcbiAgICAgICAgICAgIH0gZWxzZSB7ICsraiQyOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPCBpJDcpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpJDcpKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09IFwibHRyXCIpIHtcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL15cXHMrLykpKSB7XG4gICAgICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgIG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDAsIDAsIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxzKyQvKSkpIHtcbiAgICAgICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIGxlbiAtIG1bMF0ubGVuZ3RoLCBsZW4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09IFwicnRsXCIgPyBvcmRlci5yZXZlcnNlKCkgOiBvcmRlclxuICAgIH1cbiAgfSkoKTtcblxuICAvLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXG4gIC8vIGZhbHNlIGZvciBsaW5lcyB0aGF0IGFyZSBmdWxseSBsZWZ0LXRvLXJpZ2h0LCBhbmQgYW4gYXJyYXkgb2ZcbiAgLy8gQmlkaVNwYW4gb2JqZWN0cyBvdGhlcndpc2UuXG4gIGZ1bmN0aW9uIGdldE9yZGVyKGxpbmUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvcmRlciA9IGxpbmUub3JkZXI7XG4gICAgaWYgKG9yZGVyID09IG51bGwpIHsgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCwgZGlyZWN0aW9uKTsgfVxuICAgIHJldHVybiBvcmRlclxuICB9XG5cbiAgLy8gRVZFTlQgSEFORExJTkdcblxuICAvLyBMaWdodHdlaWdodCBldmVudCBmcmFtZXdvcmsuIG9uL29mZiBhbHNvIHdvcmsgb24gRE9NIG5vZGVzLFxuICAvLyByZWdpc3RlcmluZyBuYXRpdmUgRE9NIGhhbmRsZXJzLlxuXG4gIHZhciBub0hhbmRsZXJzID0gW107XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xuICAgIGlmIChlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbWl0dGVyLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbWl0dGVyLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFwID0gZW1pdHRlci5faGFuZGxlcnMgfHwgKGVtaXR0ZXIuX2hhbmRsZXJzID0ge30pO1xuICAgICAgbWFwW3R5cGVdID0gKG1hcFt0eXBlXSB8fCBub0hhbmRsZXJzKS5jb25jYXQoZik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV0gfHwgbm9IYW5kbGVyc1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5kZXRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzLCBhcnIgPSBtYXAgJiYgbWFwW3R5cGVdO1xuICAgICAgaWYgKGFycikge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKGFyciwgZik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgIHsgbWFwW3R5cGVdID0gYXJyLnNsaWNlKDAsIGluZGV4KS5jb25jYXQoYXJyLnNsaWNlKGluZGV4ICsgMSkpOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSk7XG4gICAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7ICsraSkgeyBoYW5kbGVyc1tpXS5hcHBseShudWxsLCBhcmdzKTsgfVxuICB9XG5cbiAgLy8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcbiAgLy8gcmVnaXN0ZXJpbmcgYSAobm9uLURPTSkgaGFuZGxlciBvbiB0aGUgZWRpdG9yIGZvciB0aGUgZXZlbnQgbmFtZSxcbiAgLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxuICBmdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHsgZSA9IHt0eXBlOiBlLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH19OyB9XG4gICAgc2lnbmFsKGNtLCBvdmVycmlkZSB8fCBlLnR5cGUsIGNtLCBlKTtcbiAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZVxuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtcbiAgICBpZiAoIWFycikgeyByZXR1cm4gfVxuICAgIHZhciBzZXQgPSBjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzID0gW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7IGlmIChpbmRleE9mKHNldCwgYXJyW2ldKSA9PSAtMSlcbiAgICAgIHsgc2V0LnB1c2goYXJyW2ldKTsgfSB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gQWRkIG9uIGFuZCBvZmYgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLCB0byBtYWtlXG4gIC8vIHJlZ2lzdGVyaW5nIGV2ZW50cyBvbiBzdWNoIG9iamVjdHMgbW9yZSBjb252ZW5pZW50LlxuICBmdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcbiAgICBjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvbih0aGlzLCB0eXBlLCBmKTt9O1xuICAgIGN0b3IucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvZmYodGhpcywgdHlwZSwgZik7fTtcbiAgfVxuXG4gIC8vIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHN0aWxsIHN1cHBvcnQganVyYXNzaWMgSUUgdmVyc2lvbnMsIHNvbWVcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxuXG4gIGZ1bmN0aW9uIGVfcHJldmVudERlZmF1bHQoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIGVsc2UgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgfVxuICBmdW5jdGlvbiBlX3N0b3BQcm9wYWdhdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH1cbiAgICBlbHNlIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9kZWZhdWx0UHJldmVudGVkKGUpIHtcbiAgICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlXG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wKGUpIHtlX3ByZXZlbnREZWZhdWx0KGUpOyBlX3N0b3BQcm9wYWdhdGlvbihlKTt9XG5cbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnR9XG4gIGZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcbiAgICB2YXIgYiA9IGUud2hpY2g7XG4gICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgaWYgKGUuYnV0dG9uICYgMSkgeyBiID0gMTsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiAyKSB7IGIgPSAzOyB9XG4gICAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDQpIHsgYiA9IDI7IH1cbiAgICB9XG4gICAgaWYgKG1hYyAmJiBlLmN0cmxLZXkgJiYgYiA9PSAxKSB7IGIgPSAzOyB9XG4gICAgcmV0dXJuIGJcbiAgfVxuXG4gIC8vIERldGVjdCBkcmFnLWFuZC1kcm9wXG4gIHZhciBkcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZXJlIGlzICpzb21lKiBraW5kIG9mIGRyYWctYW5kLWRyb3Agc3VwcG9ydCBpbiBJRTYtOCwgYnV0IElcbiAgICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGRpdiA9IGVsdCgnZGl2Jyk7XG4gICAgcmV0dXJuIFwiZHJhZ2dhYmxlXCIgaW4gZGl2IHx8IFwiZHJhZ0Ryb3BcIiBpbiBkaXZcbiAgfSgpO1xuXG4gIHZhciB6d3NwU3VwcG9ydGVkO1xuICBmdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcbiAgICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICB2YXIgdGVzdCA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDBiXCIpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBbdGVzdCwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpXSkpO1xuICAgICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcbiAgICAgICAgeyB6d3NwU3VwcG9ydGVkID0gdGVzdC5vZmZzZXRXaWR0aCA8PSAxICYmIHRlc3Qub2Zmc2V0SGVpZ2h0ID4gMiAmJiAhKGllICYmIGllX3ZlcnNpb24gPCA4KTsgfVxuICAgIH1cbiAgICB2YXIgbm9kZSA9IHp3c3BTdXBwb3J0ZWQgPyBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKSA6XG4gICAgICBlbHQoXCJzcGFuXCIsIFwiXFx1MDBhMFwiLCBudWxsLCBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBcIlwiKTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLy8gRmVhdHVyZS1kZXRlY3QgSUUncyBjcnVtbXkgY2xpZW50IHJlY3QgcmVwb3J0aW5nIGZvciBiaWRpIHRleHRcbiAgdmFyIGJhZEJpZGlSZWN0cztcbiAgZnVuY3Rpb24gaGFzQmFkQmlkaVJlY3RzKG1lYXN1cmUpIHtcbiAgICBpZiAoYmFkQmlkaVJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZEJpZGlSZWN0cyB9XG4gICAgdmFyIHR4dCA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQVxcdTA2MmVBXCIpKTtcbiAgICB2YXIgcjAgPSByYW5nZSh0eHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByMSA9IHJhbmdlKHR4dCwgMSwgMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmVtb3ZlQ2hpbGRyZW4obWVhc3VyZSk7XG4gICAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSB7IHJldHVybiBmYWxzZSB9IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXG4gICAgcmV0dXJuIGJhZEJpZGlSZWN0cyA9IChyMS5yaWdodCAtIHIwLnJpZ2h0IDwgMylcbiAgfVxuXG4gIC8vIFNlZSBpZiBcIlwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cbiAgLy8gYWx0ZXJuYXRpdmUgd2F5IHRvIHNwbGl0IGxpbmVzLlxuICB2YXIgc3BsaXRMaW5lc0F1dG8gPSBcIlxcblxcbmJcIi5zcGxpdCgvXFxuLykubGVuZ3RoICE9IDMgPyBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aDtcbiAgICB3aGlsZSAocG9zIDw9IGwpIHtcbiAgICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICBpZiAobmwgPT0gLTEpIHsgbmwgPSBzdHJpbmcubGVuZ3RoOyB9XG4gICAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcIlxcclwiID8gbmwgLSAxIDogbmwpO1xuICAgICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFwiXFxyXCIpO1xuICAgICAgaWYgKHJ0ICE9IC0xKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKTtcbiAgICAgICAgcG9zICs9IHJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBwb3MgPSBubCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxyXFxuP3xcXG4vKTsgfTtcblxuICB2YXIgaGFzU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IGZ1bmN0aW9uICh0ZSkge1xuICAgIHRyeSB7IHJldHVybiB0ZS5zZWxlY3Rpb25TdGFydCAhPSB0ZS5zZWxlY3Rpb25FbmQgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfSA6IGZ1bmN0aW9uICh0ZSkge1xuICAgIHZhciByYW5nZTtcbiAgICB0cnkge3JhbmdlID0gdGUub3duZXJEb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTt9XG4gICAgY2F0Y2goZSkge31cbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiByYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCByYW5nZSkgIT0gMFxuICB9O1xuXG4gIHZhciBoYXNDb3B5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gZWx0KFwiZGl2XCIpO1xuICAgIGlmIChcIm9uY29weVwiIGluIGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIGUuc2V0QXR0cmlidXRlKFwib25jb3B5XCIsIFwicmV0dXJuO1wiKTtcbiAgICByZXR1cm4gdHlwZW9mIGUub25jb3B5ID09IFwiZnVuY3Rpb25cIlxuICB9KSgpO1xuXG4gIHZhciBiYWRab29tZWRSZWN0cyA9IG51bGw7XG4gIGZ1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpIHtcbiAgICBpZiAoYmFkWm9vbWVkUmVjdHMgIT0gbnVsbCkgeyByZXR1cm4gYmFkWm9vbWVkUmVjdHMgfVxuICAgIHZhciBub2RlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBcInhcIikpO1xuICAgIHZhciBub3JtYWwgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBmcm9tUmFuZ2UgPSByYW5nZShub2RlLCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gYmFkWm9vbWVkUmVjdHMgPSBNYXRoLmFicyhub3JtYWwubGVmdCAtIGZyb21SYW5nZS5sZWZ0KSA+IDFcbiAgfVxuXG4gIC8vIEtub3duIG1vZGVzLCBieSBuYW1lIGFuZCBieSBNSU1FXG4gIHZhciBtb2RlcyA9IHt9LCBtaW1lTW9kZXMgPSB7fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgZnVuY3Rpb24gZGVmaW5lTW9kZShuYW1lLCBtb2RlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgeyBtb2RlLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7IH1cbiAgICBtb2Rlc1tuYW1lXSA9IG1vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVNSU1FKG1pbWUsIHNwZWMpIHtcbiAgICBtaW1lTW9kZXNbbWltZV0gPSBzcGVjO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBNSU1FIHR5cGUsIGEge25hbWUsIC4uLm9wdGlvbnN9IGNvbmZpZyBvYmplY3QsIG9yIGEgbmFtZVxuICAvLyBzdHJpbmcsIHJldHVybiBhIG1vZGUgY29uZmlnIG9iamVjdC5cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZGUoc3BlYykge1xuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjKSkge1xuICAgICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXTtcbiAgICB9IGVsc2UgaWYgKHNwZWMgJiYgdHlwZW9mIHNwZWMubmFtZSA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZm91bmQgPSBtaW1lTW9kZXNbc3BlYy5uYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXCJzdHJpbmdcIikgeyBmb3VuZCA9IHtuYW1lOiBmb3VuZH07IH1cbiAgICAgIHNwZWMgPSBjcmVhdGVPYmooZm91bmQsIHNwZWMpO1xuICAgICAgc3BlYy5uYW1lID0gZm91bmQubmFtZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCt4bWwkLy50ZXN0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi94bWxcIilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCtqc29uJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24vanNvblwiKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIikgeyByZXR1cm4ge25hbWU6IHNwZWN9IH1cbiAgICBlbHNlIHsgcmV0dXJuIHNwZWMgfHwge25hbWU6IFwibnVsbFwifSB9XG4gIH1cblxuICAvLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBhbiBhY3R1YWwgbW9kZSBvYmplY3QuXG4gIGZ1bmN0aW9uIGdldE1vZGUob3B0aW9ucywgc3BlYykge1xuICAgIHNwZWMgPSByZXNvbHZlTW9kZShzcGVjKTtcbiAgICB2YXIgbWZhY3RvcnkgPSBtb2Rlc1tzcGVjLm5hbWVdO1xuICAgIGlmICghbWZhY3RvcnkpIHsgcmV0dXJuIGdldE1vZGUob3B0aW9ucywgXCJ0ZXh0L3BsYWluXCIpIH1cbiAgICB2YXIgbW9kZU9iaiA9IG1mYWN0b3J5KG9wdGlvbnMsIHNwZWMpO1xuICAgIGlmIChtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zW3NwZWMubmFtZV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV4dHMpIHtcbiAgICAgICAgaWYgKCFleHRzLmhhc093blByb3BlcnR5KHByb3ApKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHsgbW9kZU9ialtcIl9cIiArIHByb3BdID0gbW9kZU9ialtwcm9wXTsgfVxuICAgICAgICBtb2RlT2JqW3Byb3BdID0gZXh0c1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kZU9iai5uYW1lID0gc3BlYy5uYW1lO1xuICAgIGlmIChzcGVjLmhlbHBlclR5cGUpIHsgbW9kZU9iai5oZWxwZXJUeXBlID0gc3BlYy5oZWxwZXJUeXBlOyB9XG4gICAgaWYgKHNwZWMubW9kZVByb3BzKSB7IGZvciAodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcylcbiAgICAgIHsgbW9kZU9ialtwcm9wJDFdID0gc3BlYy5tb2RlUHJvcHNbcHJvcCQxXTsgfSB9XG5cbiAgICByZXR1cm4gbW9kZU9ialxuICB9XG5cbiAgLy8gVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggcHJvcGVydGllcyB0byBtb2RlIG9iamVjdHMgZnJvbVxuICAvLyBvdXRzaWRlIHRoZSBhY3R1YWwgbW9kZSBkZWZpbml0aW9uLlxuICB2YXIgbW9kZUV4dGVuc2lvbnMgPSB7fTtcbiAgZnVuY3Rpb24gZXh0ZW5kTW9kZShtb2RlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShtb2RlKSA/IG1vZGVFeHRlbnNpb25zW21vZGVdIDogKG1vZGVFeHRlbnNpb25zW21vZGVdID0ge30pO1xuICAgIGNvcHlPYmoocHJvcGVydGllcywgZXh0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U3RhdGUobW9kZSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHRydWUpIHsgcmV0dXJuIHN0YXRlIH1cbiAgICBpZiAobW9kZS5jb3B5U3RhdGUpIHsgcmV0dXJuIG1vZGUuY29weVN0YXRlKHN0YXRlKSB9XG4gICAgdmFyIG5zdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIG4gaW4gc3RhdGUpIHtcbiAgICAgIHZhciB2YWwgPSBzdGF0ZVtuXTtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgeyB2YWwgPSB2YWwuY29uY2F0KFtdKTsgfVxuICAgICAgbnN0YXRlW25dID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gbnN0YXRlXG4gIH1cblxuICAvLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxuICAvLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxuICBmdW5jdGlvbiBpbm5lck1vZGUobW9kZSwgc3RhdGUpIHtcbiAgICB2YXIgaW5mbztcbiAgICB3aGlsZSAobW9kZS5pbm5lck1vZGUpIHtcbiAgICAgIGluZm8gPSBtb2RlLmlubmVyTW9kZShzdGF0ZSk7XG4gICAgICBpZiAoIWluZm8gfHwgaW5mby5tb2RlID09IG1vZGUpIHsgYnJlYWsgfVxuICAgICAgc3RhdGUgPSBpbmZvLnN0YXRlO1xuICAgICAgbW9kZSA9IGluZm8ubW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm8gfHwge21vZGU6IG1vZGUsIHN0YXRlOiBzdGF0ZX1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0U3RhdGUobW9kZSwgYTEsIGEyKSB7XG4gICAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZVxuICB9XG5cbiAgLy8gU1RSSU5HIFNUUkVBTVxuXG4gIC8vIEZlZCB0byB0aGUgbW9kZSBwYXJzZXJzLCBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIG1ha2VcbiAgLy8gcGFyc2VycyBtb3JlIHN1Y2NpbmN0LlxuXG4gIHZhciBTdHJpbmdTdHJlYW0gPSBmdW5jdGlvbihzdHJpbmcsIHRhYlNpemUsIGxpbmVPcmFjbGUpIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemUgfHwgODtcbiAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMubGluZU9yYWNsZSA9IGxpbmVPcmFjbGU7XG4gIH07XG5cbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lb2wgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc29sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA9PSB0aGlzLmxpbmVTdGFydH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspIH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICB2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgIHZhciBvaztcbiAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpIHsgb2sgPSBjaCA9PSBtYXRjaDsgfVxuICAgIGVsc2UgeyBvayA9IGNoICYmIChtYXRjaC50ZXN0ID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpOyB9XG4gICAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNofVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFdoaWxlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSl7fVxuICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0U3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpIHsgKyt0aGlzLnBvczsgfVxuICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvRW5kID0gZnVuY3Rpb24gKCkge3RoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoO307XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgIGlmIChmb3VuZCA+IC0xKSB7dGhpcy5wb3MgPSBmb3VuZDsgcmV0dXJuIHRydWV9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFja1VwID0gZnVuY3Rpb24gKG4pIHt0aGlzLnBvcyAtPSBuO307XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xuICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSkgLVxuICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFyIGNhc2VkID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7IH07XG4gICAgICB2YXIgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoOyB9XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpe3JldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyl9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmhpZGVGaXJzdENoYXJzID0gZnVuY3Rpb24gKG4sIGlubmVyKSB7XG4gICAgdGhpcy5saW5lU3RhcnQgKz0gbjtcbiAgICB0cnkgeyByZXR1cm4gaW5uZXIoKSB9XG4gICAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG47IH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBvcmFjbGUgPSB0aGlzLmxpbmVPcmFjbGU7XG4gICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUubG9va0FoZWFkKG4pXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmFjbGUgPSB0aGlzLmxpbmVPcmFjbGU7XG4gICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUuYmFzZVRva2VuKHRoaXMucG9zKVxuICB9O1xuXG4gIC8vIEZpbmQgdGhlIGxpbmUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICBmdW5jdGlvbiBnZXRMaW5lKGRvYywgbikge1xuICAgIG4gLT0gZG9jLmZpcnN0O1xuICAgIGlmIChuIDwgMCB8fCBuID49IGRvYy5zaXplKSB7IHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAobiArIGRvYy5maXJzdCkgKyBcIiBpbiB0aGUgZG9jdW1lbnQuXCIpIH1cbiAgICB2YXIgY2h1bmsgPSBkb2M7XG4gICAgd2hpbGUgKCFjaHVuay5saW5lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChuIDwgc3opIHsgY2h1bmsgPSBjaGlsZDsgYnJlYWsgfVxuICAgICAgICBuIC09IHN6O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmsubGluZXNbbl1cbiAgfVxuXG4gIC8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcbiAgLy8gc3RyaW5ncy5cbiAgZnVuY3Rpb24gZ2V0QmV0d2Vlbihkb2MsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lO1xuICAgIGRvYy5pdGVyKHN0YXJ0LmxpbmUsIGVuZC5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciB0ZXh0ID0gbGluZS50ZXh0O1xuICAgICAgaWYgKG4gPT0gZW5kLmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKTsgfVxuICAgICAgaWYgKG4gPT0gc3RhcnQubGluZSkgeyB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7IH1cbiAgICAgIG91dC5wdXNoKHRleHQpO1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRcbiAgfVxuICAvLyBHZXQgdGhlIGxpbmVzIGJldHdlZW4gZnJvbSBhbmQgdG8sIGFzIGFycmF5IG9mIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldExpbmVzKGRvYywgZnJvbSwgdG8pIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZG9jLml0ZXIoZnJvbSwgdG8sIGZ1bmN0aW9uIChsaW5lKSB7IG91dC5wdXNoKGxpbmUudGV4dCk7IH0pOyAvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCBwcm9wYWdhdGluZyB0aGUgaGVpZ2h0IGNoYW5nZVxuICAvLyB1cHdhcmRzIHRvIHBhcmVudCBub2Rlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcbiAgICB2YXIgZGlmZiA9IGhlaWdodCAtIGxpbmUuaGVpZ2h0O1xuICAgIGlmIChkaWZmKSB7IGZvciAodmFyIG4gPSBsaW5lOyBuOyBuID0gbi5wYXJlbnQpIHsgbi5oZWlnaHQgKz0gZGlmZjsgfSB9XG4gIH1cblxuICAvLyBHaXZlbiBhIGxpbmUgb2JqZWN0LCBmaW5kIGl0cyBsaW5lIG51bWJlciBieSB3YWxraW5nIHVwIHRocm91Z2hcbiAgLy8gaXRzIHBhcmVudCBsaW5rcy5cbiAgZnVuY3Rpb24gbGluZU5vKGxpbmUpIHtcbiAgICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGN1ciA9IGxpbmUucGFyZW50LCBubyA9IGluZGV4T2YoY3VyLmxpbmVzLCBsaW5lKTtcbiAgICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGlsZHJlbltpXSA9PSBjdXIpIHsgYnJlYWsgfVxuICAgICAgICBubyArPSBjaHVuay5jaGlsZHJlbltpXS5jaHVua1NpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vICsgY3VyLmZpcnN0XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdXNpbmcgdGhlIGhlaWdodFxuICAvLyBpbmZvcm1hdGlvbiBpbiB0aGUgZG9jdW1lbnQgdHJlZS5cbiAgZnVuY3Rpb24gbGluZUF0SGVpZ2h0KGNodW5rLCBoKSB7XG4gICAgdmFyIG4gPSBjaHVuay5maXJzdDtcbiAgICBvdXRlcjogZG8ge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2h1bmsuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpJDFdLCBjaCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgaWYgKGggPCBjaCkgeyBjaHVuayA9IGNoaWxkOyBjb250aW51ZSBvdXRlciB9XG4gICAgICAgIGggLT0gY2g7XG4gICAgICAgIG4gKz0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gblxuICAgIH0gd2hpbGUgKCFjaHVuay5saW5lcylcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXSwgbGggPSBsaW5lLmhlaWdodDtcbiAgICAgIGlmIChoIDwgbGgpIHsgYnJlYWsgfVxuICAgICAgaCAtPSBsaDtcbiAgICB9XG4gICAgcmV0dXJuIG4gKyBpXG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbmUoZG9jLCBsKSB7cmV0dXJuIGwgPj0gZG9jLmZpcnN0ICYmIGwgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZX1cblxuICBmdW5jdGlvbiBsaW5lTnVtYmVyRm9yKG9wdGlvbnMsIGkpIHtcbiAgICByZXR1cm4gU3RyaW5nKG9wdGlvbnMubGluZU51bWJlckZvcm1hdHRlcihpICsgb3B0aW9ucy5maXJzdExpbmVOdW1iZXIpKVxuICB9XG5cbiAgLy8gQSBQb3MgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBvc2l0aW9uIHdpdGhpbiB0aGUgdGV4dC5cbiAgZnVuY3Rpb24gUG9zKGxpbmUsIGNoLCBzdGlja3kpIHtcbiAgICBpZiAoIHN0aWNreSA9PT0gdm9pZCAwICkgc3RpY2t5ID0gbnVsbDtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSB7IHJldHVybiBuZXcgUG9zKGxpbmUsIGNoLCBzdGlja3kpIH1cbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY2ggPSBjaDtcbiAgICB0aGlzLnN0aWNreSA9IHN0aWNreTtcbiAgfVxuXG4gIC8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcbiAgLy8gbnVtYmVyIHdoZW4gYSBpcyBsZXNzLCBhbmQgYSBwb3NpdGl2ZSBudW1iZXIgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYS5saW5lIC0gYi5saW5lIHx8IGEuY2ggLSBiLmNoIH1cblxuICBmdW5jdGlvbiBlcXVhbEN1cnNvclBvcyhhLCBiKSB7IHJldHVybiBhLnN0aWNreSA9PSBiLnN0aWNreSAmJiBjbXAoYSwgYikgPT0gMCB9XG5cbiAgZnVuY3Rpb24gY29weVBvcyh4KSB7cmV0dXJuIFBvcyh4LmxpbmUsIHguY2gpfVxuICBmdW5jdGlvbiBtYXhQb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGIgOiBhIH1cbiAgZnVuY3Rpb24gbWluUG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYiB9XG5cbiAgLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxuICAvLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKX1cbiAgZnVuY3Rpb24gY2xpcFBvcyhkb2MsIHBvcykge1xuICAgIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCkgeyByZXR1cm4gUG9zKGRvYy5maXJzdCwgMCkgfVxuICAgIHZhciBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xuICAgIGlmIChwb3MubGluZSA+IGxhc3QpIHsgcmV0dXJuIFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpIH1cbiAgICByZXR1cm4gY2xpcFRvTGVuKHBvcywgZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0Lmxlbmd0aClcbiAgfVxuICBmdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XG4gICAgdmFyIGNoID0gcG9zLmNoO1xuICAgIGlmIChjaCA9PSBudWxsIHx8IGNoID4gbGluZWxlbikgeyByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKSB9XG4gICAgZWxzZSBpZiAoY2ggPCAwKSB7IHJldHVybiBQb3MocG9zLmxpbmUsIDApIH1cbiAgICBlbHNlIHsgcmV0dXJuIHBvcyB9XG4gIH1cbiAgZnVuY3Rpb24gY2xpcFBvc0FycmF5KGRvYywgYXJyYXkpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgeyBvdXRbaV0gPSBjbGlwUG9zKGRvYywgYXJyYXlbaV0pOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgdmFyIFNhdmVkQ29udGV4dCA9IGZ1bmN0aW9uKHN0YXRlLCBsb29rQWhlYWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gIH07XG5cbiAgdmFyIENvbnRleHQgPSBmdW5jdGlvbihkb2MsIHN0YXRlLCBsaW5lLCBsb29rQWhlYWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLm1heExvb2tBaGVhZCA9IGxvb2tBaGVhZCB8fCAwO1xuICAgIHRoaXMuYmFzZVRva2VucyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVG9rZW5Qb3MgPSAxO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2tBaGVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHRoaXMubGluZSArIG4pO1xuICAgIGlmIChsaW5lICE9IG51bGwgJiYgbiA+IHRoaXMubWF4TG9va0FoZWFkKSB7IHRoaXMubWF4TG9va0FoZWFkID0gbjsgfVxuICAgIHJldHVybiBsaW5lXG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVRva2VucykgeyByZXR1cm4gbnVsbCB9XG4gICAgd2hpbGUgKHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc10gPD0gbilcbiAgICAgIHsgdGhpcy5iYXNlVG9rZW5Qb3MgKz0gMjsgfVxuICAgIHZhciB0eXBlID0gdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zICsgMV07XG4gICAgcmV0dXJuIHt0eXBlOiB0eXBlICYmIHR5cGUucmVwbGFjZSgvKCB8XilvdmVybGF5IC4qLywgXCJcIiksXG4gICAgICAgICAgICBzaXplOiB0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIC0gbn1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5uZXh0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpbmUrKztcbiAgICBpZiAodGhpcy5tYXhMb29rQWhlYWQgPiAwKSB7IHRoaXMubWF4TG9va0FoZWFkLS07IH1cbiAgfTtcblxuICBDb250ZXh0LmZyb21TYXZlZCA9IGZ1bmN0aW9uIChkb2MsIHNhdmVkLCBsaW5lKSB7XG4gICAgaWYgKHNhdmVkIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0KVxuICAgICAgeyByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkLnN0YXRlKSwgbGluZSwgc2F2ZWQubG9va0FoZWFkKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkKSwgbGluZSkgfVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoY29weSkge1xuICAgIHZhciBzdGF0ZSA9IGNvcHkgIT09IGZhbHNlID8gY29weVN0YXRlKHRoaXMuZG9jLm1vZGUsIHRoaXMuc3RhdGUpIDogdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdGhpcy5tYXhMb29rQWhlYWQgPiAwID8gbmV3IFNhdmVkQ29udGV4dChzdGF0ZSwgdGhpcy5tYXhMb29rQWhlYWQpIDogc3RhdGVcbiAgfTtcblxuXG4gIC8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxuICAvLyAtLSBmb3IgaW52YWxpZGF0aW9uIC0tIGZvbGxvd2VkIGJ5IHBhaXJzIG9mIGVuZCBwb3NpdGlvbnMgYW5kXG4gIC8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxuICAvLyBsaW5lLlxuICBmdW5jdGlvbiBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCBmb3JjZVRvRW5kKSB7XG4gICAgLy8gQSBzdHlsZXMgYXJyYXkgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIGlkZW50aWZ5aW5nIHRoZVxuICAgIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cbiAgICB2YXIgc3QgPSBbY20uc3RhdGUubW9kZUdlbl0sIGxpbmVDbGFzc2VzID0ge307XG4gICAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcbiAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIGNtLmRvYy5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkgeyByZXR1cm4gc3QucHVzaChlbmQsIHN0eWxlKTsgfSxcbiAgICAgICAgICAgIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKTtcbiAgICB2YXIgc3RhdGUgPSBjb250ZXh0LnN0YXRlO1xuXG4gICAgLy8gUnVuIG92ZXJsYXlzLCBhZGp1c3Qgc3R5bGUgYXJyYXkuXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG8gKSB7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBzdDtcbiAgICAgIHZhciBvdmVybGF5ID0gY20uc3RhdGUub3ZlcmxheXNbb10sIGkgPSAxLCBhdCA9IDA7XG4gICAgICBjb250ZXh0LnN0YXRlID0gdHJ1ZTtcbiAgICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUncyBhIHRva2VuIGVuZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoYXQgaSBwb2ludHMgYXQgaXRcbiAgICAgICAgd2hpbGUgKGF0IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIGlfZW5kID0gc3RbaV07XG4gICAgICAgICAgaWYgKGlfZW5kID4gZW5kKVxuICAgICAgICAgICAgeyBzdC5zcGxpY2UoaSwgMSwgZW5kLCBzdFtpKzFdLCBpX2VuZCk7IH1cbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgYXQgPSBNYXRoLm1pbihlbmQsIGlfZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0eWxlKSB7IHJldHVybiB9XG4gICAgICAgIGlmIChvdmVybGF5Lm9wYXF1ZSkge1xuICAgICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFwib3ZlcmxheSBcIiArIHN0eWxlKTtcbiAgICAgICAgICBpID0gc3RhcnQgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSBzdFtzdGFydCsxXTtcbiAgICAgICAgICAgIHN0W3N0YXJ0KzFdID0gKGN1ciA/IGN1ciArIFwiIFwiIDogXCJcIikgKyBcIm92ZXJsYXkgXCIgKyBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGxpbmVDbGFzc2VzKTtcbiAgICAgIGNvbnRleHQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIGNvbnRleHQuYmFzZVRva2VucyA9IG51bGw7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlblBvcyA9IDE7XG4gICAgfTtcblxuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgY20uc3RhdGUub3ZlcmxheXMubGVuZ3RoOyArK28pIGxvb3AoIG8gKTtcblxuICAgIHJldHVybiB7c3R5bGVzOiBzdCwgY2xhc3NlczogbGluZUNsYXNzZXMuYmdDbGFzcyB8fCBsaW5lQ2xhc3Nlcy50ZXh0Q2xhc3MgPyBsaW5lQ2xhc3NlcyA6IG51bGx9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xuICAgIGlmICghbGluZS5zdHlsZXMgfHwgbGluZS5zdHlsZXNbMF0gIT0gY20uc3RhdGUubW9kZUdlbikge1xuICAgICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBsaW5lTm8obGluZSkpO1xuICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggJiYgY29weVN0YXRlKGNtLmRvYy5tb2RlLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0KTtcbiAgICAgIGlmIChyZXNldFN0YXRlKSB7IGNvbnRleHQuc3RhdGUgPSByZXNldFN0YXRlOyB9XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LnNhdmUoIXJlc2V0U3RhdGUpO1xuICAgICAgbGluZS5zdHlsZXMgPSByZXN1bHQuc3R5bGVzO1xuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXM7IH1cbiAgICAgIGVsc2UgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDsgfVxuICAgICAgaWYgKHVwZGF0ZUZyb250aWVyID09PSBjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIpXG4gICAgICAgIHsgY20uZG9jLm1vZGVGcm9udGllciA9IE1hdGgubWF4KGNtLmRvYy5tb2RlRnJvbnRpZXIsICsrY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKTsgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZS5zdHlsZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRCZWZvcmUoY20sIG4sIHByZWNpc2UpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRvYy5tb2RlLnN0YXJ0U3RhdGUpIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgdHJ1ZSwgbikgfVxuICAgIHZhciBzdGFydCA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpO1xuICAgIHZhciBzYXZlZCA9IHN0YXJ0ID4gZG9jLmZpcnN0ICYmIGdldExpbmUoZG9jLCBzdGFydCAtIDEpLnN0YXRlQWZ0ZXI7XG4gICAgdmFyIGNvbnRleHQgPSBzYXZlZCA/IENvbnRleHQuZnJvbVNhdmVkKGRvYywgc2F2ZWQsIHN0YXJ0KSA6IG5ldyBDb250ZXh0KGRvYywgc3RhcnRTdGF0ZShkb2MubW9kZSksIHN0YXJ0KTtcblxuICAgIGRvYy5pdGVyKHN0YXJ0LCBuLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcHJvY2Vzc0xpbmUoY20sIGxpbmUudGV4dCwgY29udGV4dCk7XG4gICAgICB2YXIgcG9zID0gY29udGV4dC5saW5lO1xuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gcG9zID09IG4gLSAxIHx8IHBvcyAlIDUgPT0gMCB8fCBwb3MgPj0gZGlzcGxheS52aWV3RnJvbSAmJiBwb3MgPCBkaXNwbGF5LnZpZXdUbyA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgIGNvbnRleHQubmV4dExpbmUoKTtcbiAgICB9KTtcbiAgICBpZiAocHJlY2lzZSkgeyBkb2MubW9kZUZyb250aWVyID0gY29udGV4dC5saW5lOyB9XG4gICAgcmV0dXJuIGNvbnRleHRcbiAgfVxuXG4gIC8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXG4gIC8vIHVwZGF0ZSBzdGF0ZSwgYnV0IGRvbid0IHNhdmUgYSBzdHlsZSBhcnJheS4gVXNlZCBmb3IgbGluZXMgdGhhdFxuICAvLyBhcmVuJ3QgY3VycmVudGx5IHZpc2libGUuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBjb250ZXh0LCBzdGFydEF0KSB7XG4gICAgdmFyIG1vZGUgPSBjbS5kb2MubW9kZTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUsIGNvbnRleHQpO1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgPSBzdGFydEF0IHx8IDA7XG4gICAgaWYgKHRleHQgPT0gXCJcIikgeyBjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpOyB9XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSkgfVxuICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHsgcmV0dXJuIH1cbiAgICB2YXIgaW5uZXIgPSBpbm5lck1vZGUobW9kZSwgc3RhdGUpO1xuICAgIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gaW5uZXIubW9kZS5ibGFua0xpbmUoaW5uZXIuc3RhdGUpIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgaWYgKGlubmVyKSB7IGlubmVyWzBdID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKS5tb2RlOyB9XG4gICAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpIHsgcmV0dXJuIHN0eWxlIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZSBcIiArIG1vZGUubmFtZSArIFwiIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIilcbiAgfVxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uKHN0cmVhbSwgdHlwZSwgc3RhdGUpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RyZWFtLnN0YXJ0OyB0aGlzLmVuZCA9IHN0cmVhbS5wb3M7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xuICBmdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIG1vZGUgPSBkb2MubW9kZSwgc3R5bGU7XG4gICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLCBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgdG9rZW5zO1xuICAgIGlmIChhc0FycmF5KSB7IHRva2VucyA9IFtdOyB9XG4gICAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgaWYgKGFzQXJyYXkpIHsgdG9rZW5zLnB1c2gobmV3IFRva2VuKHN0cmVhbSwgc3R5bGUsIGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkpKTsgfVxuICAgIH1cbiAgICByZXR1cm4gYXNBcnJheSA/IHRva2VucyA6IG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb250ZXh0LnN0YXRlKVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xuICAgIGlmICh0eXBlKSB7IGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lQ2xhc3MgPSB0eXBlLm1hdGNoKC8oPzpefFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFMrKS8pO1xuICAgICAgaWYgKCFsaW5lQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgbGluZUNsYXNzLmluZGV4KSArIHR5cGUuc2xpY2UobGluZUNsYXNzLmluZGV4ICsgbGluZUNsYXNzWzBdLmxlbmd0aCk7XG4gICAgICB2YXIgcHJvcCA9IGxpbmVDbGFzc1sxXSA/IFwiYmdDbGFzc1wiIDogXCJ0ZXh0Q2xhc3NcIjtcbiAgICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcbiAgICAgICAgeyBvdXRwdXRbcHJvcF0gPSBsaW5lQ2xhc3NbMl07IH1cbiAgICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIgKyBsaW5lQ2xhc3NbMl0gKyBcIig/OiR8XFxcXHMpXCIpKS50ZXN0KG91dHB1dFtwcm9wXSkpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdICs9IFwiIFwiICsgbGluZUNsYXNzWzJdOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHR5cGVcbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxuICBmdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBjb250ZXh0LCBmLCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCkge1xuICAgIHZhciBmbGF0dGVuU3BhbnMgPSBtb2RlLmZsYXR0ZW5TcGFucztcbiAgICBpZiAoZmxhdHRlblNwYW5zID09IG51bGwpIHsgZmxhdHRlblNwYW5zID0gY20ub3B0aW9ucy5mbGF0dGVuU3BhbnM7IH1cbiAgICB2YXIgY3VyU3RhcnQgPSAwLCBjdXJTdHlsZSA9IG51bGw7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgc3R5bGU7XG4gICAgdmFyIGlubmVyID0gY20ub3B0aW9ucy5hZGRNb2RlQ2xhc3MgJiYgW251bGxdO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgY29udGV4dC5zdGF0ZSksIGxpbmVDbGFzc2VzKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIGZsYXR0ZW5TcGFucyA9IGZhbHNlO1xuICAgICAgICBpZiAoZm9yY2VUb0VuZCkgeyBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RyZWFtLnBvcyk7IH1cbiAgICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoO1xuICAgICAgICBzdHlsZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGV4dHJhY3RMaW5lQ2xhc3NlcyhyZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlLCBpbm5lciksIGxpbmVDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbm5lcikge1xuICAgICAgICB2YXIgbU5hbWUgPSBpbm5lclswXS5uYW1lO1xuICAgICAgICBpZiAobU5hbWUpIHsgc3R5bGUgPSBcIm0tXCIgKyAoc3R5bGUgPyBtTmFtZSArIFwiIFwiICsgc3R5bGUgOiBtTmFtZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XG4gICAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xuICAgICAgICAgIGN1clN0YXJ0ID0gTWF0aC5taW4oc3RyZWFtLnN0YXJ0LCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJTdHlsZSA9IHN0eWxlO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xuICAgICAgLy8gV2Via2l0IHNlZW1zIHRvIHJlZnVzZSB0byByZW5kZXIgdGV4dCBub2RlcyBsb25nZXIgdGhhbiA1NzQ0NFxuICAgICAgLy8gY2hhcmFjdGVycywgYW5kIHJldHVybnMgaW5hY2N1cmF0ZSBtZWFzdXJlbWVudHMgaW4gbm9kZXNcbiAgICAgIC8vIHN0YXJ0aW5nIGFyb3VuZCA1MDAwIGNoYXJzLlxuICAgICAgdmFyIHBvcyA9IE1hdGgubWluKHN0cmVhbS5wb3MsIGN1clN0YXJ0ICsgNTAwMCk7XG4gICAgICBmKHBvcywgY3VyU3R5bGUpO1xuICAgICAgY3VyU3RhcnQgPSBwb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZHMgdGhlIGxpbmUgdG8gc3RhcnQgd2l0aCB3aGVuIHN0YXJ0aW5nIGEgcGFyc2UuIFRyaWVzIHRvXG4gIC8vIGZpbmQgYSBsaW5lIHdpdGggYSBzdGF0ZUFmdGVyLCBzbyB0aGF0IGl0IGNhbiBzdGFydCB3aXRoIGFcbiAgLy8gdmFsaWQgc3RhdGUuIElmIHRoYXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIGxpbmUgd2l0aCB0aGVcbiAgLy8gc21hbGxlc3QgaW5kZW50YXRpb24sIHdoaWNoIHRlbmRzIHRvIG5lZWQgdGhlIGxlYXN0IGNvbnRleHQgdG9cbiAgLy8gcGFyc2UgY29ycmVjdGx5LlxuICBmdW5jdGlvbiBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIG1pbmluZGVudCwgbWlubGluZSwgZG9jID0gY20uZG9jO1xuICAgIHZhciBsaW0gPSBwcmVjaXNlID8gLTEgOiBuIC0gKGNtLmRvYy5tb2RlLmlubmVyTW9kZSA/IDEwMDAgOiAxMDApO1xuICAgIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcbiAgICAgIGlmIChzZWFyY2ggPD0gZG9jLmZpcnN0KSB7IHJldHVybiBkb2MuZmlyc3QgfVxuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgc2VhcmNoIC0gMSksIGFmdGVyID0gbGluZS5zdGF0ZUFmdGVyO1xuICAgICAgaWYgKGFmdGVyICYmICghcHJlY2lzZSB8fCBzZWFyY2ggKyAoYWZ0ZXIgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQgPyBhZnRlci5sb29rQWhlYWQgOiAwKSA8PSBkb2MubW9kZUZyb250aWVyKSlcbiAgICAgICAgeyByZXR1cm4gc2VhcmNoIH1cbiAgICAgIHZhciBpbmRlbnRlZCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgY20ub3B0aW9ucy50YWJTaXplKTtcbiAgICAgIGlmIChtaW5saW5lID09IG51bGwgfHwgbWluaW5kZW50ID4gaW5kZW50ZWQpIHtcbiAgICAgICAgbWlubGluZSA9IHNlYXJjaCAtIDE7XG4gICAgICAgIG1pbmluZGVudCA9IGluZGVudGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWlubGluZVxuICB9XG5cbiAgZnVuY3Rpb24gcmV0cmVhdEZyb250aWVyKGRvYywgbikge1xuICAgIGRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1pbihkb2MubW9kZUZyb250aWVyLCBuKTtcbiAgICBpZiAoZG9jLmhpZ2hsaWdodEZyb250aWVyIDwgbiAtIDEwKSB7IHJldHVybiB9XG4gICAgdmFyIHN0YXJ0ID0gZG9jLmZpcnN0O1xuICAgIGZvciAodmFyIGxpbmUgPSBuIC0gMTsgbGluZSA+IHN0YXJ0OyBsaW5lLS0pIHtcbiAgICAgIHZhciBzYXZlZCA9IGdldExpbmUoZG9jLCBsaW5lKS5zdGF0ZUFmdGVyO1xuICAgICAgLy8gY2hhbmdlIGlzIG9uIDNcbiAgICAgIC8vIHN0YXRlIG9uIGxpbmUgMSBsb29rZWQgYWhlYWQgMiAtLSBzbyBzYXcgM1xuICAgICAgLy8gdGVzdCAxICsgMiA8IDMgc2hvdWxkIGNvdmVyIHRoaXNcbiAgICAgIGlmIChzYXZlZCAmJiAoIShzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dCkgfHwgbGluZSArIHNhdmVkLmxvb2tBaGVhZCA8IG4pKSB7XG4gICAgICAgIHN0YXJ0ID0gbGluZSArIDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IE1hdGgubWluKGRvYy5oaWdobGlnaHRGcm9udGllciwgc3RhcnQpO1xuICB9XG5cbiAgLy8gT3B0aW1pemUgc29tZSBjb2RlIHdoZW4gdGhlc2UgZmVhdHVyZXMgYXJlIG5vdCB1c2VkLlxuICB2YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlLCBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKSB7XG4gICAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVDb2xsYXBzZWRTcGFucygpIHtcbiAgICBzYXdDb2xsYXBzZWRTcGFucyA9IHRydWU7XG4gIH1cblxuICAvLyBURVhUTUFSS0VSIFNQQU5TXG5cbiAgZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XG4gICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xuICB9XG5cbiAgLy8gU2VhcmNoIGFuIGFycmF5IG9mIHNwYW5zIGZvciBhIHNwYW4gbWF0Y2hpbmcgdGhlIGdpdmVuIG1hcmtlci5cbiAgZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XG4gICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5tYXJrZXIgPT0gbWFya2VyKSB7IHJldHVybiBzcGFuIH1cbiAgICB9IH1cbiAgfVxuICAvLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXG4gIC8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcbiAgICB2YXIgcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoc3BhbnNbaV0gIT0gc3BhbikgeyAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7IH0gfVxuICAgIHJldHVybiByXG4gIH1cbiAgLy8gQWRkIGEgc3BhbiB0byBhIGxpbmUuXG4gIGZ1bmN0aW9uIGFkZE1hcmtlZFNwYW4obGluZSwgc3Bhbikge1xuICAgIGxpbmUubWFya2VkU3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zID8gbGluZS5tYXJrZWRTcGFucy5jb25jYXQoW3NwYW5dKSA6IFtzcGFuXTtcbiAgICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgdGhlIGFsZ29yaXRobSB0aGF0IGFkanVzdHMgbWFya2VycyBmb3IgYSBjaGFuZ2UgaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cbiAgLy8gY2hhcmFjdGVyIHBvc2l0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcmVtYWluaW5nIGNodW5rcyAob3JcbiAgLy8gdW5kZWZpbmVkIGlmIG5vdGhpbmcgcmVtYWlucykuXG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcbiAgICB2YXIgbnc7XG4gICAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xuICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBzdGFydENoIDogc3Bhbi5mcm9tIDwgc3RhcnRDaCk7XG4gICAgICBpZiAoc3RhcnRzQmVmb3JlIHx8IHNwYW4uZnJvbSA9PSBzdGFydENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8ICFzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xuICAgICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IHN0YXJ0Q2ggOiBzcGFuLnRvID4gc3RhcnRDaClcbiAgICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSk7XG4gICAgICB9XG4gICAgfSB9XG4gICAgcmV0dXJuIG53XG4gIH1cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNBZnRlcihvbGQsIGVuZENoLCBpc0luc2VydCkge1xuICAgIHZhciBudztcbiAgICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKTtcbiAgICAgIGlmIChlbmRzQWZ0ZXIgfHwgc3Bhbi5mcm9tID09IGVuZENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8IHNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBzdGFydHNCZWZvcmUgPSBzcGFuLmZyb20gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZUxlZnQgPyBzcGFuLmZyb20gPD0gZW5kQ2ggOiBzcGFuLmZyb20gPCBlbmRDaClcbiAgICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi50byA9PSBudWxsID8gbnVsbCA6IHNwYW4udG8gLSBlbmRDaCkpO1xuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBud1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XG4gIC8vIGNvdmVyIHRoZSBsaW5lIGluIHdoaWNoIHRoZSBjaGFuZ2UgdG9vayBwbGFjZS4gUmVtb3ZlcyBzcGFuc1xuICAvLyBlbnRpcmVseSB3aXRoaW4gdGhlIGNoYW5nZSwgcmVjb25uZWN0cyBzcGFucyBiZWxvbmdpbmcgdG8gdGhlXG4gIC8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXG4gIC8vIHNwYW5zIHBhcnRpYWxseSB3aXRoaW4gdGhlIGNoYW5nZS4gUmV0dXJucyBhbiBhcnJheSBvZiBzcGFuXG4gIC8vIGFycmF5cyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGxpbmUgaW4gKGFmdGVyKSB0aGUgY2hhbmdlLlxuICBmdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5mdWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgb2xkRmlyc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkubWFya2VkU3BhbnM7XG4gICAgdmFyIG9sZExhc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS50by5saW5lKS5tYXJrZWRTcGFucztcbiAgICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwO1xuICAgIC8vIEdldCB0aGUgc3BhbnMgdGhhdCAnc3RpY2sgb3V0JyBvbiBib3RoIHNpZGVzXG4gICAgdmFyIGZpcnN0ID0gbWFya2VkU3BhbnNCZWZvcmUob2xkRmlyc3QsIHN0YXJ0Q2gsIGlzSW5zZXJ0KTtcbiAgICB2YXIgbGFzdCA9IG1hcmtlZFNwYW5zQWZ0ZXIob2xkTGFzdCwgZW5kQ2gsIGlzSW5zZXJ0KTtcblxuICAgIC8vIE5leHQsIG1lcmdlIHRob3NlIHR3byBlbmRzXG4gICAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRml4IHVwIC50byBwcm9wZXJ0aWVzIG9mIGZpcnN0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gZmlyc3RbaV07XG4gICAgICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7IHNwYW4udG8gPSBzdGFydENoOyB9XG4gICAgICAgICAgZWxzZSBpZiAoc2FtZUxpbmUpIHsgc3Bhbi50byA9IGZvdW5kLnRvID09IG51bGwgPyBudWxsIDogZm91bmQudG8gKyBvZmZzZXQ7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCkge1xuICAgICAgLy8gRml4IHVwIC5mcm9tIGluIGxhc3QgKG9yIG1vdmUgdGhlbSBpbnRvIGZpcnN0IGluIGNhc2Ugb2Ygc2FtZUxpbmUpXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsYXN0Lmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIHNwYW4kMSA9IGxhc3RbaSQxXTtcbiAgICAgICAgaWYgKHNwYW4kMS50byAhPSBudWxsKSB7IHNwYW4kMS50byArPSBvZmZzZXQ7IH1cbiAgICAgICAgaWYgKHNwYW4kMS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQkMSA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4kMS5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQkMSkge1xuICAgICAgICAgICAgc3BhbiQxLmZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4kMS5mcm9tICs9IG9mZnNldDtcbiAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXG4gICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gY2xlYXJFbXB0eVNwYW5zKGZpcnN0KTsgfVxuICAgIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIHsgbGFzdCA9IGNsZWFyRW1wdHlTcGFucyhsYXN0KTsgfVxuXG4gICAgdmFyIG5ld01hcmtlcnMgPSBbZmlyc3RdO1xuICAgIGlmICghc2FtZUxpbmUpIHtcbiAgICAgIC8vIEZpbGwgZ2FwIHdpdGggd2hvbGUtbGluZS1zcGFuc1xuICAgICAgdmFyIGdhcCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDIsIGdhcE1hcmtlcnM7XG4gICAgICBpZiAoZ2FwID4gMCAmJiBmaXJzdClcbiAgICAgICAgeyBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBmaXJzdC5sZW5ndGg7ICsraSQyKVxuICAgICAgICAgIHsgaWYgKGZpcnN0W2kkMl0udG8gPT0gbnVsbClcbiAgICAgICAgICAgIHsgKGdhcE1hcmtlcnMgfHwgKGdhcE1hcmtlcnMgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4oZmlyc3RbaSQyXS5tYXJrZXIsIG51bGwsIG51bGwpKTsgfSB9IH1cbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdhcDsgKytpJDMpXG4gICAgICAgIHsgbmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpOyB9XG4gICAgICBuZXdNYXJrZXJzLnB1c2gobGFzdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXJrZXJzXG4gIH1cblxuICAvLyBSZW1vdmUgc3BhbnMgdGhhdCBhcmUgZW1wdHkgYW5kIGRvbid0IGhhdmUgYSBjbGVhcldoZW5FbXB0eVxuICAvLyBvcHRpb24gb2YgZmFsc2UuXG4gIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgICB7IHNwYW5zLnNwbGljZShpLS0sIDEpOyB9XG4gICAgfVxuICAgIGlmICghc3BhbnMubGVuZ3RoKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gc3BhbnNcbiAgfVxuXG4gIC8vIFVzZWQgdG8gJ2NsaXAnIG91dCByZWFkT25seSByYW5nZXMgd2hlbiBtYWtpbmcgYSBjaGFuZ2UuXG4gIGZ1bmN0aW9uIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgZnJvbSwgdG8pIHtcbiAgICB2YXIgbWFya2VycyA9IG51bGw7XG4gICAgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbWFyayA9IGxpbmUubWFya2VkU3BhbnNbaV0ubWFya2VyO1xuICAgICAgICBpZiAobWFyay5yZWFkT25seSAmJiAoIW1hcmtlcnMgfHwgaW5kZXhPZihtYXJrZXJzLCBtYXJrKSA9PSAtMSkpXG4gICAgICAgICAgeyAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrKTsgfVxuICAgICAgfSB9XG4gICAgfSk7XG4gICAgaWYgKCFtYXJrZXJzKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcGFydHMgPSBbe2Zyb206IGZyb20sIHRvOiB0b31dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG1rID0gbWFya2Vyc1tpXSwgbSA9IG1rLmZpbmQoMCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBwID0gcGFydHNbal07XG4gICAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIG5ld1BhcnRzID0gW2osIDFdLCBkZnJvbSA9IGNtcChwLmZyb20sIG0uZnJvbSksIGR0byA9IGNtcChwLnRvLCBtLnRvKTtcbiAgICAgICAgaWYgKGRmcm9tIDwgMCB8fCAhbWsuaW5jbHVzaXZlTGVmdCAmJiAhZGZyb20pXG4gICAgICAgICAgeyBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBwLmZyb20sIHRvOiBtLmZyb219KTsgfVxuICAgICAgICBpZiAoZHRvID4gMCB8fCAhbWsuaW5jbHVzaXZlUmlnaHQgJiYgIWR0bylcbiAgICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IG0udG8sIHRvOiBwLnRvfSk7IH1cbiAgICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cyk7XG4gICAgICAgIGogKz0gbmV3UGFydHMubGVuZ3RoIC0gMztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzXG4gIH1cblxuICAvLyBDb25uZWN0IG9yIGRpc2Nvbm5lY3Qgc3BhbnMgZnJvbSBhIGxpbmUuXG4gIGZ1bmN0aW9uIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBzcGFuc1tpXS5tYXJrZXIuZGV0YWNoTGluZShsaW5lKTsgfVxuICAgIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHNwYW5zW2ldLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpOyB9XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IHNwYW5zO1xuICB9XG5cbiAgLy8gSGVscGVycyB1c2VkIHdoZW4gY29tcHV0aW5nIHdoaWNoIG92ZXJsYXBwaW5nIGNvbGxhcHNlZCBzcGFuXG4gIC8vIGNvdW50cyBhcyB0aGUgbGFyZ2VyIG9uZS5cbiAgZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDAgfVxuICBmdW5jdGlvbiBleHRyYVJpZ2h0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDAgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGljaCBvZiB0d28gb3ZlcmxhcHBpbmcgY29sbGFwc2VkXG4gIC8vIHNwYW5zIGlzIGxhcmdlciAoYW5kIHRodXMgaW5jbHVkZXMgdGhlIG90aGVyKS4gRmFsbHMgYmFjayB0b1xuICAvLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXG4gIGZ1bmN0aW9uIGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGEsIGIpIHtcbiAgICB2YXIgbGVuRGlmZiA9IGEubGluZXMubGVuZ3RoIC0gYi5saW5lcy5sZW5ndGg7XG4gICAgaWYgKGxlbkRpZmYgIT0gMCkgeyByZXR1cm4gbGVuRGlmZiB9XG4gICAgdmFyIGFQb3MgPSBhLmZpbmQoKSwgYlBvcyA9IGIuZmluZCgpO1xuICAgIHZhciBmcm9tQ21wID0gY21wKGFQb3MuZnJvbSwgYlBvcy5mcm9tKSB8fCBleHRyYUxlZnQoYSkgLSBleHRyYUxlZnQoYik7XG4gICAgaWYgKGZyb21DbXApIHsgcmV0dXJuIC1mcm9tQ21wIH1cbiAgICB2YXIgdG9DbXAgPSBjbXAoYVBvcy50bywgYlBvcy50bykgfHwgZXh0cmFSaWdodChhKSAtIGV4dHJhUmlnaHQoYik7XG4gICAgaWYgKHRvQ21wKSB7IHJldHVybiB0b0NtcCB9XG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkXG4gIH1cblxuICAvLyBGaW5kIG91dCB3aGV0aGVyIGEgbGluZSBlbmRzIG9yIHN0YXJ0cyBpbiBhIGNvbGxhcHNlZCBzcGFuLiBJZlxuICAvLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zLCBmb3VuZDtcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxuICAgICAgICAgICghZm91bmQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoZm91bmQsIHNwLm1hcmtlcikgPCAwKSlcbiAgICAgICAgeyBmb3VuZCA9IHNwLm1hcmtlcjsgfVxuICAgIH0gfVxuICAgIHJldHVybiBmb3VuZFxuICB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgdHJ1ZSkgfVxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBmYWxzZSkgfVxuXG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5Bcm91bmQobGluZSwgY2gpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHNwLmZyb20gPT0gbnVsbCB8fCBzcC5mcm9tIDwgY2gpICYmIChzcC50byA9PSBudWxsIHx8IHNwLnRvID4gY2gpICYmXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKSB7IGZvdW5kID0gc3AubWFya2VyOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcbiAgLy8gb3ZlcmxhcHMgKGNvdmVycyB0aGUgc3RhcnQgb3IgZW5kLCBidXQgbm90IGJvdGgpIG9mIGEgbmV3IHNwYW4uXG4gIC8vIFN1Y2ggb3ZlcmxhcCBpcyBub3QgYWxsb3dlZC5cbiAgZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObywgZnJvbSwgdG8sIG1hcmtlcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVObyk7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xuICAgICAgdmFyIGZyb21DbXAgPSBjbXAoZm91bmQuZnJvbSwgZnJvbSkgfHwgZXh0cmFMZWZ0KHNwLm1hcmtlcikgLSBleHRyYUxlZnQobWFya2VyKTtcbiAgICAgIHZhciB0b0NtcCA9IGNtcChmb3VuZC50bywgdG8pIHx8IGV4dHJhUmlnaHQoc3AubWFya2VyKSAtIGV4dHJhUmlnaHQobWFya2VyKTtcbiAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoZnJvbUNtcCA8PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQudG8sIGZyb20pID49IDAgOiBjbXAoZm91bmQudG8sIGZyb20pID4gMCkgfHxcbiAgICAgICAgICBmcm9tQ21wID49IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC5mcm9tLCB0bykgPD0gMCA6IGNtcChmb3VuZC5mcm9tLCB0bykgPCAwKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBBIHZpc3VhbCBsaW5lIGlzIGEgbGluZSBhcyBkcmF3biBvbiB0aGUgc2NyZWVuLiBGb2xkaW5nLCBmb3JcbiAgLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXG4gIC8vIHZpc3VhbCBsaW5lLiBUaGlzIGZpbmRzIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcbiAgLy8gZ2l2ZW4gbGluZSBpcyBwYXJ0IG9mICh1c3VhbGx5IHRoYXQgaXMgdGhlIGxpbmUgaXRzZWxmKS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XG4gICAgdmFyIG1lcmdlZDtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICBmdW5jdGlvbiB2aXN1YWxMaW5lRW5kKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxuICAvLyBzdGFydGVkIGJ5IHRoZSBhcmd1bWVudCwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBzdWNoIGxpbmVzLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkLCBsaW5lcztcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxuICAgICAgOyhsaW5lcyB8fCAobGluZXMgPSBbXSkpLnB1c2gobGluZSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lc1xuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4gIC8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVObyhkb2MsIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCB2aXMgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmIChsaW5lID09IHZpcykgeyByZXR1cm4gbGluZU4gfVxuICAgIHJldHVybiBsaW5lTm8odmlzKVxuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcbiAgLy8gdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIG1lcmdlZDtcbiAgICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZU5vKGxpbmUpICsgMVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB3aGV0aGVyIGEgbGluZSBpcyBoaWRkZW4uIExpbmVzIGNvdW50IGFzIGhpZGRlbiB3aGVuIHRoZXlcbiAgLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxuICAvLyB0aGV5IGFyZSBlbnRpcmVseSBjb3ZlcmVkIGJ5IGNvbGxhcHNlZCwgbm9uLXdpZGdldCBzcGFuLlxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIHsgY29udGludWUgfVxuICAgICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAoc3AubWFya2VyLndpZGdldE5vZGUpIHsgY29udGludWUgfVxuICAgICAgaWYgKHNwLmZyb20gPT0gMCAmJiBzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCAmJiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB9XG4gIH1cbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XG4gICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgdmFyIGVuZCA9IHNwYW4ubWFya2VyLmZpbmQoMSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKVxuICAgIH1cbiAgICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAhc3AubWFya2VyLndpZGdldE5vZGUgJiYgc3AuZnJvbSA9PSBzcGFuLnRvICYmXG4gICAgICAgICAgKHNwLnRvID09IG51bGwgfHwgc3AudG8gIT0gc3Bhbi5mcm9tKSAmJlxuICAgICAgICAgIChzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCB8fCBzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCkgJiZcbiAgICAgICAgICBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgaGVpZ2h0IGFib3ZlIHRoZSBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiBoZWlnaHRBdExpbmUobGluZU9iaikge1xuICAgIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xuXG4gICAgdmFyIGggPSAwLCBjaHVuayA9IGxpbmVPYmoucGFyZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV07XG4gICAgICBpZiAobGluZSA9PSBsaW5lT2JqKSB7IGJyZWFrIH1cbiAgICAgIGVsc2UgeyBoICs9IGxpbmUuaGVpZ2h0OyB9XG4gICAgfVxuICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcC5jaGlsZHJlbi5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2kkMV07XG4gICAgICAgIGlmIChjdXIgPT0gY2h1bmspIHsgYnJlYWsgfVxuICAgICAgICBlbHNlIHsgaCArPSBjdXIuaGVpZ2h0OyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxuICAvLyBjb2xsYXBzZWQgcmFuZ2VzIChzZWUgbWFya1RleHQpIHRoYXQgbWlnaHQgaGlkZSBwYXJ0cywgYW5kIGpvaW5cbiAgLy8gb3RoZXIgbGluZXMgb250byBpdC5cbiAgZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XG4gICAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHsgcmV0dXJuIDAgfVxuICAgIHZhciBsZW4gPSBsaW5lLnRleHQubGVuZ3RoLCBtZXJnZWQsIGN1ciA9IGxpbmU7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1lcmdlZC5maW5kKDAsIHRydWUpO1xuICAgICAgY3VyID0gZm91bmQuZnJvbS5saW5lO1xuICAgICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcbiAgICB9XG4gICAgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCQxID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBsZW4gLT0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS5mcm9tLmNoO1xuICAgICAgY3VyID0gZm91bmQkMS50by5saW5lO1xuICAgICAgbGVuICs9IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEudG8uY2g7XG4gICAgfVxuICAgIHJldHVybiBsZW5cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIGZpbmRNYXhMaW5lKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgZC5tYXhMaW5lID0gZ2V0TGluZShkb2MsIGRvYy5maXJzdCk7XG4gICAgZC5tYXhMaW5lTGVuZ3RoID0gbGluZUxlbmd0aChkLm1heExpbmUpO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgIGlmIChsZW4gPiBkLm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgZC5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBkLm1heExpbmUgPSBsaW5lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTElORSBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXG4gIC8vIGhpZ2hsaWdodGluZyBpbmZvICh0aGUgc3R5bGVzIGFycmF5KS5cbiAgdmFyIExpbmUgPSBmdW5jdGlvbih0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcbiAgICB0aGlzLmhlaWdodCA9IGVzdGltYXRlSGVpZ2h0ID8gZXN0aW1hdGVIZWlnaHQodGhpcykgOiAxO1xuICB9O1xuXG4gIExpbmUucHJvdG90eXBlLmxpbmVObyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVObyh0aGlzKSB9O1xuICBldmVudE1peGluKExpbmUpO1xuXG4gIC8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XG4gIC8vIGludmFsaWRhdGVzIGNhY2hlZCBpbmZvcm1hdGlvbiBhbmQgdHJpZXMgdG8gcmUtZXN0aW1hdGUgdGhlXG4gIC8vIGxpbmUncyBoZWlnaHQuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgbGluZS50ZXh0ID0gdGV4dDtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XG4gICAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgeyBsaW5lLm9yZGVyID0gbnVsbDsgfVxuICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIG1hcmtlZFNwYW5zKTtcbiAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodChsaW5lKSA6IDE7XG4gICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCk7IH1cbiAgfVxuXG4gIC8vIERldGFjaCBhIGxpbmUgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZSBhbmQgaXRzIG1hcmtlcnMuXG4gIGZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpIHtcbiAgICBsaW5lLnBhcmVudCA9IG51bGw7XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGEgc3R5bGUgYXMgcmV0dXJuZWQgYnkgYSBtb2RlIChlaXRoZXIgbnVsbCwgb3IgYSBzdHJpbmdcbiAgLy8gY29udGFpbmluZyBvbmUgb3IgbW9yZSBzdHlsZXMpIHRvIGEgQ1NTIHN0eWxlLiBUaGlzIGlzIGNhY2hlZCxcbiAgLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXG4gIHZhciBzdHlsZVRvQ2xhc3NDYWNoZSA9IHt9LCBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlID0ge307XG4gIGZ1bmN0aW9uIGludGVycHJldFRva2VuU3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXN0eWxlIHx8IC9eXFxzKiQvLnRlc3Qoc3R5bGUpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY2FjaGUgPSBvcHRpb25zLmFkZE1vZGVDbGFzcyA/IHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgOiBzdHlsZVRvQ2xhc3NDYWNoZTtcbiAgICByZXR1cm4gY2FjaGVbc3R5bGVdIHx8XG4gICAgICAoY2FjaGVbc3R5bGVdID0gc3R5bGUucmVwbGFjZSgvXFxTKy9nLCBcImNtLSQmXCIpKVxuICB9XG5cbiAgLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xuICAvLyB1cCBhICdsaW5lIG1hcCcsIHdoaWNoIHBvaW50cyBhdCB0aGUgRE9NIG5vZGVzIHRoYXQgcmVwcmVzZW50XG4gIC8vIHNwZWNpZmljIHN0cmV0Y2hlcyBvZiB0ZXh0LCBhbmQgaXMgdXNlZCBieSB0aGUgbWVhc3VyaW5nIGNvZGUuXG4gIC8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXG4gIC8vIGluZm9ybWF0aW9uIGFib3V0IGxpbmUtd2lkZSBzdHlsZXMgdGhhdCB3ZXJlIHNldCBieSB0aGUgbW9kZS5cbiAgZnVuY3Rpb24gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxuICAgIC8vIGlzIG5lZWRlZCBvbiBXZWJraXQgdG8gYmUgYWJsZSB0byBnZXQgbGluZS1sZXZlbCBib3VuZGluZ1xuICAgIC8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXG4gICAgdmFyIGNvbnRlbnQgPSBlbHRQKFwic3BhblwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcInBhZGRpbmctcmlnaHQ6IC4xcHhcIiA6IG51bGwpO1xuICAgIHZhciBidWlsZGVyID0ge3ByZTogZWx0UChcInByZVwiLCBbY29udGVudF0sIFwiQ29kZU1pcnJvci1saW5lXCIpLCBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgIGNvbDogMCwgcG9zOiAwLCBjbTogY20sXG4gICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IGNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKX07XG4gICAgbGluZVZpZXcubWVhc3VyZSA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGkgPyBsaW5lVmlldy5yZXN0W2kgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyID0gKHZvaWQgMCk7XG4gICAgICBidWlsZGVyLnBvcyA9IDA7XG4gICAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbjtcbiAgICAgIC8vIE9wdGlvbmFsbHkgd2lyZSBpbiBzb21lIGhhY2tzIGludG8gdGhlIHRva2VuLXJlbmRlcmluZ1xuICAgICAgLy8gYWxnb3JpdGhtLCB0byBkZWFsIHdpdGggYnJvd3NlciBxdWlya3MuXG4gICAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbikpKVxuICAgICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLCBvcmRlcik7IH1cbiAgICAgIGJ1aWxkZXIubWFwID0gW107XG4gICAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSk7XG4gICAgICBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCBhbGxvd0Zyb250aWVyVXBkYXRlKSk7XG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpXG4gICAgICAgICAgeyBidWlsZGVyLmJnQ2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzLCBidWlsZGVyLmJnQ2xhc3MgfHwgXCJcIik7IH1cbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcylcbiAgICAgICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgYXQgbGVhc3QgYSBzaW5nbGUgbm9kZSBpcyBwcmVzZW50LCBmb3IgbWVhc3VyaW5nLlxuICAgICAgaWYgKGJ1aWxkZXIubWFwLmxlbmd0aCA9PSAwKVxuICAgICAgICB7IGJ1aWxkZXIubWFwLnB1c2goMCwgMCwgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHplcm9XaWR0aEVsZW1lbnQoY20uZGlzcGxheS5tZWFzdXJlKSkpOyB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBtYXAgYW5kIGEgY2FjaGUgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5tYXAgPSBidWlsZGVyLm1hcDtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyB8fCAobGluZVZpZXcubWVhc3VyZS5tYXBzID0gW10pKS5wdXNoKGJ1aWxkZXIubWFwKVxuICAgICAgICA7KGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzIHx8IChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2VlIGlzc3VlICMyOTAxXG4gICAgaWYgKHdlYmtpdCkge1xuICAgICAgdmFyIGxhc3QgPSBidWlsZGVyLmNvbnRlbnQubGFzdENoaWxkO1xuICAgICAgaWYgKC9cXGJjbS10YWJcXGIvLnRlc3QobGFzdC5jbGFzc05hbWUpIHx8IChsYXN0LnF1ZXJ5U2VsZWN0b3IgJiYgbGFzdC5xdWVyeVNlbGVjdG9yKFwiLmNtLXRhYlwiKSkpXG4gICAgICAgIHsgYnVpbGRlci5jb250ZW50LmNsYXNzTmFtZSA9IFwiY20tdGFiLXdyYXAtaGFja1wiOyB9XG4gICAgfVxuXG4gICAgc2lnbmFsKGNtLCBcInJlbmRlckxpbmVcIiwgY20sIGxpbmVWaWV3LmxpbmUsIGJ1aWxkZXIucHJlKTtcbiAgICBpZiAoYnVpbGRlci5wcmUuY2xhc3NOYW1lKVxuICAgICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSwgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXCJcIik7IH1cblxuICAgIHJldHVybiBidWlsZGVyXG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCkge1xuICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDIyXCIsIFwiY20taW52YWxpZGNoYXJcIik7XG4gICAgdG9rZW4udGl0bGUgPSBcIlxcXFx1XCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICB0b2tlbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRva2VuLnRpdGxlKTtcbiAgICByZXR1cm4gdG9rZW5cbiAgfVxuXG4gIC8vIEJ1aWxkIHVwIHRoZSBET00gcmVwcmVzZW50YXRpb24gZm9yIGEgc2luZ2xlIHRva2VuLCBhbmQgYWRkIGl0IHRvXG4gIC8vIHRoZSBsaW5lIG1hcC4gVGFrZXMgY2FyZSB0byByZW5kZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIHNlcGFyYXRlbHkuXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW4oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIXRleHQpIHsgcmV0dXJuIH1cbiAgICB2YXIgZGlzcGxheVRleHQgPSBidWlsZGVyLnNwbGl0U3BhY2VzID8gc3BsaXRTcGFjZXModGV4dCwgYnVpbGRlci50cmFpbGluZ1NwYWNlKSA6IHRleHQ7XG4gICAgdmFyIHNwZWNpYWwgPSBidWlsZGVyLmNtLnN0YXRlLnNwZWNpYWxDaGFycywgbXVzdFdyYXAgPSBmYWxzZTtcbiAgICB2YXIgY29udGVudDtcbiAgICBpZiAoIXNwZWNpYWwudGVzdCh0ZXh0KSkge1xuICAgICAgYnVpbGRlci5jb2wgKz0gdGV4dC5sZW5ndGg7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO1xuICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyB0ZXh0Lmxlbmd0aCwgY29udGVudCk7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgbXVzdFdyYXAgPSB0cnVlOyB9XG4gICAgICBidWlsZGVyLnBvcyArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgIHZhciBtID0gc3BlY2lhbC5leGVjKHRleHQpO1xuICAgICAgICB2YXIgc2tpcHBlZCA9IG0gPyBtLmluZGV4IC0gcG9zIDogdGV4dC5sZW5ndGggLSBwb3M7XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0LnNsaWNlKHBvcywgcG9zICsgc2tpcHBlZCkpO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dF0pKTsgfVxuICAgICAgICAgIGVsc2UgeyBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7IH1cbiAgICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNraXBwZWQsIHR4dCk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gc2tpcHBlZDtcbiAgICAgICAgICBidWlsZGVyLnBvcyArPSBza2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbSkgeyBicmVhayB9XG4gICAgICAgIHBvcyArPSBza2lwcGVkICsgMTtcbiAgICAgICAgdmFyIHR4dCQxID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChtWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICB2YXIgdGFiU2l6ZSA9IGJ1aWxkZXIuY20ub3B0aW9ucy50YWJTaXplLCB0YWJXaWR0aCA9IHRhYlNpemUgLSBidWlsZGVyLmNvbCAlIHRhYlNpemU7XG4gICAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcImNtLXRhYlwiKSk7XG4gICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIFwiXFx0XCIpO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHRhYldpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKG1bMF0gPT0gXCJcXHJcIiB8fCBtWzBdID09IFwiXFxuXCIpIHtcbiAgICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBtWzBdID09IFwiXFxyXCIgPyBcIlxcdTI0MGRcIiA6IFwiXFx1MjQyNFwiLCBcImNtLWludmFsaWRjaGFyXCIpKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHh0JDEgPSBidWlsZGVyLmNtLm9wdGlvbnMuc3BlY2lhbENoYXJQbGFjZWhvbGRlcihtWzBdKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dCQxXSkpOyB9XG4gICAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0JDEpOyB9XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCQxKTtcbiAgICAgICAgYnVpbGRlci5wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZGlzcGxheVRleHQuY2hhckNvZGVBdCh0ZXh0Lmxlbmd0aCAtIDEpID09IDMyO1xuICAgIGlmIChzdHlsZSB8fCBzdGFydFN0eWxlIHx8IGVuZFN0eWxlIHx8IG11c3RXcmFwIHx8IGNzcyB8fCBhdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIgZnVsbFN0eWxlID0gc3R5bGUgfHwgXCJcIjtcbiAgICAgIGlmIChzdGFydFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBzdGFydFN0eWxlOyB9XG4gICAgICBpZiAoZW5kU3R5bGUpIHsgZnVsbFN0eWxlICs9IGVuZFN0eWxlOyB9XG4gICAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7IGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpICYmIGF0dHIgIT0gXCJzdHlsZVwiICYmIGF0dHIgIT0gXCJjbGFzc1wiKVxuICAgICAgICAgIHsgdG9rZW4uc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJpYnV0ZXNbYXR0cl0pOyB9IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pXG4gICAgfVxuICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgfVxuXG4gIC8vIENoYW5nZSBzb21lIHNwYWNlcyB0byBOQlNQIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBjb2xsYXBzaW5nXG4gIC8vIHRyYWlsaW5nIHNwYWNlcyBhdCB0aGUgZW5kIG9mIGEgbGluZSB3aGVuIHJlbmRlcmluZyB0ZXh0IChpc3N1ZSAjMTM2MikuXG4gIGZ1bmN0aW9uIHNwbGl0U3BhY2VzKHRleHQsIHRyYWlsaW5nQmVmb3JlKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiAhLyAgLy50ZXN0KHRleHQpKSB7IHJldHVybiB0ZXh0IH1cbiAgICB2YXIgc3BhY2VCZWZvcmUgPSB0cmFpbGluZ0JlZm9yZSwgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgaWYgKGNoID09IFwiIFwiICYmIHNwYWNlQmVmb3JlICYmIChpID09IHRleHQubGVuZ3RoIC0gMSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09IDMyKSlcbiAgICAgICAgeyBjaCA9IFwiXFx1MDBhMFwiOyB9XG4gICAgICByZXN1bHQgKz0gY2g7XG4gICAgICBzcGFjZUJlZm9yZSA9IGNoID09IFwiIFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBub25zZW5zZSBkaW1lbnNpb25zIGJlaW5nIHJlcG9ydGVkIGZvciBzdHJldGNoZXMgb2ZcbiAgLy8gcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICBmdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcIiBjbS1mb3JjZS1ib3JkZXJcIiA6IFwiY20tZm9yY2UtYm9yZGVyXCI7XG4gICAgICB2YXIgc3RhcnQgPSBidWlsZGVyLnBvcywgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxuICAgICAgICB2YXIgcGFydCA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgICAgIGlmIChwYXJ0LnRvID4gc3RhcnQgJiYgcGFydC5mcm9tIDw9IHN0YXJ0KSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50byA+PSBlbmQpIHsgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB9XG4gICAgICAgIGlubmVyKGJ1aWxkZXIsIHRleHQuc2xpY2UoMCwgcGFydC50byAtIHN0YXJ0KSwgc3R5bGUsIHN0YXJ0U3R5bGUsIG51bGwsIGNzcywgYXR0cmlidXRlcyk7XG4gICAgICAgIHN0YXJ0U3R5bGUgPSBudWxsO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHBhcnQudG87XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIHNpemUsIG1hcmtlciwgaWdub3JlV2lkZ2V0KSB7XG4gICAgdmFyIHdpZGdldCA9ICFpZ25vcmVXaWRnZXQgJiYgbWFya2VyLndpZGdldE5vZGU7XG4gICAgaWYgKHdpZGdldCkgeyBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNpemUsIHdpZGdldCk7IH1cbiAgICBpZiAoIWlnbm9yZVdpZGdldCAmJiBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlKSB7XG4gICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgeyB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpOyB9XG4gICAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIsIG1hcmtlci5pZCk7XG4gICAgfVxuICAgIGlmICh3aWRnZXQpIHtcbiAgICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldCk7XG4gICAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQod2lkZ2V0KTtcbiAgICB9XG4gICAgYnVpbGRlci5wb3MgKz0gc2l6ZTtcbiAgICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcbiAgLy8gYW5kIG1hcmtlZCB0ZXh0IGludG8gYWNjb3VudC5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwO1xuICAgIGlmICghc3BhbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHN0eWxlcy5sZW5ndGg7IGkkMSs9MilcbiAgICAgICAgeyBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2kkMV0pLCBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpJDErMV0sIGJ1aWxkZXIuY20ub3B0aW9ucykpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYWxsVGV4dC5sZW5ndGgsIHBvcyA9IDAsIGkgPSAxLCB0ZXh0ID0gXCJcIiwgc3R5bGUsIGNzcztcbiAgICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgY29sbGFwc2VkLCBhdHRyaWJ1dGVzO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChuZXh0Q2hhbmdlID09IHBvcykgeyAvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XG4gICAgICAgIHNwYW5TdHlsZSA9IHNwYW5FbmRTdHlsZSA9IHNwYW5TdGFydFN0eWxlID0gY3NzID0gXCJcIjtcbiAgICAgICAgYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIGNvbGxhcHNlZCA9IG51bGw7IG5leHRDaGFuZ2UgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGZvdW5kQm9va21hcmtzID0gW10sIGVuZFN0eWxlcyA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKG0udHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgc3AuZnJvbSA9PSBwb3MgJiYgbS53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICBmb3VuZEJvb2ttYXJrcy5wdXNoKG0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xuICAgICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgc3AudG8gIT0gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC50bykge1xuICAgICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AudG87XG4gICAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jbGFzc05hbWUpIHsgc3BhblN0eWxlICs9IFwiIFwiICsgbS5jbGFzc05hbWU7IH1cbiAgICAgICAgICAgIGlmIChtLmNzcykgeyBjc3MgPSAoY3NzID8gY3NzICsgXCI7XCIgOiBcIlwiKSArIG0uY3NzOyB9XG4gICAgICAgICAgICBpZiAobS5zdGFydFN0eWxlICYmIHNwLmZyb20gPT0gcG9zKSB7IHNwYW5TdGFydFN0eWxlICs9IFwiIFwiICsgbS5zdGFydFN0eWxlOyB9XG4gICAgICAgICAgICBpZiAobS5lbmRTdHlsZSAmJiBzcC50byA9PSBuZXh0Q2hhbmdlKSB7IChlbmRTdHlsZXMgfHwgKGVuZFN0eWxlcyA9IFtdKSkucHVzaChtLmVuZFN0eWxlLCBzcC50byk7IH1cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHRoZSBvbGQgdGl0bGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL0NvZGVNaXJyb3IvcHVsbC81NjczXG4gICAgICAgICAgICBpZiAobS50aXRsZSkgeyAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSkudGl0bGUgPSBtLnRpdGxlOyB9XG4gICAgICAgICAgICBpZiAobS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gbS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgIHsgKGF0dHJpYnV0ZXMgfHwgKGF0dHJpYnV0ZXMgPSB7fSkpW2F0dHJdID0gbS5hdHRyaWJ1dGVzW2F0dHJdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSlcbiAgICAgICAgICAgICAgeyBjb2xsYXBzZWQgPSBzcDsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHlsZXMpIHsgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZW5kU3R5bGVzLmxlbmd0aDsgaiQxICs9IDIpXG4gICAgICAgICAgeyBpZiAoZW5kU3R5bGVzW2okMSArIDFdID09IG5leHRDaGFuZ2UpIHsgc3BhbkVuZFN0eWxlICs9IFwiIFwiICsgZW5kU3R5bGVzW2okMV07IH0gfSB9XG5cbiAgICAgICAgaWYgKCFjb2xsYXBzZWQgfHwgY29sbGFwc2VkLmZyb20gPT0gcG9zKSB7IGZvciAodmFyIGokMiA9IDA7IGokMiA8IGZvdW5kQm9va21hcmtzLmxlbmd0aDsgKytqJDIpXG4gICAgICAgICAgeyBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3NbaiQyXSk7IH0gfVxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIChjb2xsYXBzZWQuZnJvbSB8fCAwKSA9PSBwb3MpIHtcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZC5tYXJrZXIsIGNvbGxhcHNlZC5mcm9tID09IG51bGwpO1xuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gcG9zKSB7IGNvbGxhcHNlZCA9IGZhbHNlOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPj0gbGVuKSB7IGJyZWFrIH1cblxuICAgICAgdmFyIHVwdG8gPSBNYXRoLm1pbihsZW4sIG5leHRDaGFuZ2UpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICB2YXIgZW5kID0gcG9zICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHZhciB0b2tlblRleHQgPSBlbmQgPiB1cHRvID8gdGV4dC5zbGljZSgwLCB1cHRvIC0gcG9zKSA6IHRleHQ7XG4gICAgICAgICAgICBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIHRva2VuVGV4dCwgc3R5bGUgPyBzdHlsZSArIHNwYW5TdHlsZSA6IHNwYW5TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhblN0YXJ0U3R5bGUsIHBvcyArIHRva2VuVGV4dC5sZW5ndGggPT0gbmV4dENoYW5nZSA/IHNwYW5FbmRTdHlsZSA6IFwiXCIsIGNzcywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPj0gdXB0bykge3RleHQgPSB0ZXh0LnNsaWNlKHVwdG8gLSBwb3MpOyBwb3MgPSB1cHRvOyBicmVha31cbiAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgc3BhblN0YXJ0U3R5bGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpKytdKTtcbiAgICAgICAgc3R5bGUgPSBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpKytdLCBidWlsZGVyLmNtLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHZpc2libGUgKGN1cnJlbnRseSBkcmF3bilcbiAgLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcbiAgLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxuICBmdW5jdGlvbiBMaW5lVmlldyhkb2MsIGxpbmUsIGxpbmVOKSB7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIC8vIENvbnRpbnVpbmcgbGluZXMsIGlmIGFueVxuICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XG4gICAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxuICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVzdCA/IGxpbmVObyhsc3QodGhpcy5yZXN0KSkgLSBsaW5lTiArIDEgOiAxO1xuICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XG4gICAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cbiAgZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XG4gICAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcyk7XG4gICAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xuICAgICAgYXJyYXkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5XG4gIH1cblxuICB2YXIgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3ApIHtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIG9wZXJhdGlvbkdyb3VwLm9wcy5wdXNoKG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aub3duc0dyb3VwID0gb3BlcmF0aW9uR3JvdXAgPSB7XG4gICAgICAgIG9wczogW29wXSxcbiAgICAgICAgZGVsYXllZENhbGxiYWNrczogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCkge1xuICAgIC8vIENhbGxzIGRlbGF5ZWQgY2FsbGJhY2tzIGFuZCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyB1bnRpbCBub1xuICAgIC8vIG5ldyBvbmVzIGFwcGVhclxuICAgIHZhciBjYWxsYmFja3MgPSBncm91cC5kZWxheWVkQ2FsbGJhY2tzLCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBjYWxsYmFja3NbaV0uY2FsbChudWxsKTsgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5vcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdO1xuICAgICAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcbiAgICAgICAgICB7IHdoaWxlIChvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCA8IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMubGVuZ3RoKVxuICAgICAgICAgICAgeyBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW29wLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgb3AuY20pOyB9IH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChpIDwgY2FsbGJhY2tzLmxlbmd0aClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE9wZXJhdGlvbihvcCwgZW5kQ2IpIHtcbiAgICB2YXIgZ3JvdXAgPSBvcC5vd25zR3JvdXA7XG4gICAgaWYgKCFncm91cCkgeyByZXR1cm4gfVxuXG4gICAgdHJ5IHsgZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCk7IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgIG9wZXJhdGlvbkdyb3VwID0gbnVsbDtcbiAgICAgIGVuZENiKGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG5cbiAgLy8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcbiAgLy8gbWlkZGxlIG9mIHNvbWUgd29yaywgYnV0IGRvbid0IHdhbnQgdGhlIGhhbmRsZXIgdG8gc3RhcnQgY2FsbGluZ1xuICAvLyBvdGhlciBtZXRob2RzIG9uIHRoZSBlZGl0b3IsIHdoaWNoIG1pZ2h0IGJlIGluIGFuIGluY29uc2lzdGVudFxuICAvLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cbiAgLy8gc2lnbmFsTGF0ZXIgbG9va3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGhhbmRsZXJzLCBhbmQgc2NoZWR1bGVzXG4gIC8vIHRoZW0gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgbGFzdCBvcGVyYXRpb24gZW5kcywgb3IsIGlmIG5vXG4gIC8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxuICBmdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBhcnIgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKTtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIGxpc3Q7XG4gICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XG4gICAgICBsaXN0ID0gb3BlcmF0aW9uR3JvdXAuZGVsYXllZENhbGxiYWNrcztcbiAgICB9IGVsc2UgaWYgKG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MpIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IFtdO1xuICAgICAgc2V0VGltZW91dChmaXJlT3JwaGFuRGVsYXllZCwgMCk7XG4gICAgfVxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgbGlzdC5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycltpXS5hcHBseShudWxsLCBhcmdzKTsgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgbG9vcCggaSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZU9ycGhhbkRlbGF5ZWQoKSB7XG4gICAgdmFyIGRlbGF5ZWQgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgeyBkZWxheWVkW2ldKCk7IH1cbiAgfVxuXG4gIC8vIFdoZW4gYW4gYXNwZWN0IG9mIGEgbGluZSBjaGFuZ2VzLCBhIHN0cmluZyBpcyBhZGRlZCB0b1xuICAvLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xuICAvLyBET00gc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lVmlldy5jaGFuZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal07XG4gICAgICBpZiAodHlwZSA9PSBcInRleHRcIikgeyB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiZ3V0dGVyXCIpIHsgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImNsYXNzXCIpIHsgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIndpZGdldFwiKSB7IHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7IH1cbiAgICB9XG4gICAgbGluZVZpZXcuY2hhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvLyBMaW5lcyB3aXRoIGd1dHRlciBlbGVtZW50cywgd2lkZ2V0cyBvciBhIGJhY2tncm91bmQgY2xhc3MgbmVlZCB0b1xuICAvLyBiZSB3cmFwcGVkLCBhbmQgaGF2ZSB0aGUgZXh0cmEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIHdyYXBwZXIgZGl2XG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KSB7XG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZVZpZXcudGV4dCkge1xuICAgICAgbGluZVZpZXcubm9kZSA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcbiAgICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpXG4gICAgICAgIHsgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KTsgfVxuICAgICAgbGluZVZpZXcubm9kZS5hcHBlbmRDaGlsZChsaW5lVmlldy50ZXh0KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBsaW5lVmlldy5ub2RlLnN0eWxlLnpJbmRleCA9IDI7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldykge1xuICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcbiAgICBpZiAoY2xzKSB7IGNscyArPSBcIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXCI7IH1cbiAgICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xuICAgICAgaWYgKGNscykgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNsczsgfVxuICAgICAgZWxzZSB7IGxpbmVWaWV3LmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5iYWNrZ3JvdW5kKTsgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGw7IH1cbiAgICB9IGVsc2UgaWYgKGNscykge1xuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kID0gd3JhcC5pbnNlcnRCZWZvcmUoZWx0KFwiZGl2XCIsIG51bGwsIGNscyksIHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobGluZVZpZXcuYmFja2dyb3VuZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcHBlciBhcm91bmQgYnVpbGRMaW5lQ29udGVudCB3aGljaCB3aWxsIHJldXNlIHRoZSBzdHJ1Y3R1cmVcbiAgLy8gaW4gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkIHdoZW4gcG9zc2libGUuXG4gIGZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBleHQubGluZSA9PSBsaW5lVmlldy5saW5lKSB7XG4gICAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgICAgbGluZVZpZXcubWVhc3VyZSA9IGV4dC5tZWFzdXJlO1xuICAgICAgcmV0dXJuIGV4dC5idWlsdFxuICAgIH1cbiAgICByZXR1cm4gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXG4gIH1cblxuICAvLyBSZWRyYXcgdGhlIGxpbmUncyB0ZXh0LiBJbnRlcmFjdHMgd2l0aCB0aGUgYmFja2dyb3VuZCBhbmQgdGV4dFxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcbiAgLy8gY2xhc3Nlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkgeyBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlOyB9XG4gICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBidWlsdC5wcmU7XG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MgIT0gbGluZVZpZXcuYmdDbGFzcyB8fCBidWlsdC50ZXh0Q2xhc3MgIT0gbGluZVZpZXcudGV4dENsYXNzKSB7XG4gICAgICBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzcztcbiAgICAgIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcbiAgICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gY2xzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldykge1xuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKVxuICAgICAgeyBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3M7IH1cbiAgICBlbHNlIGlmIChsaW5lVmlldy5ub2RlICE9IGxpbmVWaWV3LnRleHQpXG4gICAgICB7IGxpbmVWaWV3Lm5vZGUuY2xhc3NOYW1lID0gXCJcIjsgfVxuICAgIHZhciB0ZXh0Q2xhc3MgPSBsaW5lVmlldy50ZXh0Q2xhc3MgPyBsaW5lVmlldy50ZXh0Q2xhc3MgKyBcIiBcIiArIChsaW5lVmlldy5saW5lLnRleHRDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzO1xuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XG4gICAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCkge1xuICAgICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcykge1xuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaW1zLmZpeGVkUG9zIDogLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHhcIikpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgd3JhcC5pbnNlcnRCZWZvcmUobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCwgbGluZVZpZXcudGV4dCk7XG4gICAgfVxuICAgIHZhciBtYXJrZXJzID0gbGluZVZpZXcubGluZS5ndXR0ZXJNYXJrZXJzO1xuICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzIHx8IG1hcmtlcnMpIHtcbiAgICAgIHZhciB3cmFwJDEgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcIiwgKFwibGVmdDogXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHhcIikpO1xuICAgICAgZ3V0dGVyV3JhcC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUoZ3V0dGVyV3JhcCk7XG4gICAgICB3cmFwJDEuaW5zZXJ0QmVmb3JlKGd1dHRlcldyYXAsIGxpbmVWaWV3LnRleHQpO1xuICAgICAgaWYgKGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MpXG4gICAgICAgIHsgZ3V0dGVyV3JhcC5jbGFzc05hbWUgKz0gXCIgXCIgKyBsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzOyB9XG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lTnVtYmVycyAmJiAoIW1hcmtlcnMgfHwgIW1hcmtlcnNbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKSlcbiAgICAgICAgeyBsaW5lVmlldy5saW5lTnVtYmVyID0gZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBlbHQoXCJkaXZcIiwgbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTiksXG4gICAgICAgICAgICAgIFwiQ29kZU1pcnJvci1saW5lbnVtYmVyIENvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFxuICAgICAgICAgICAgICAoXCJsZWZ0OiBcIiArIChkaW1zLmd1dHRlckxlZnRbXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCJdKSArIFwicHg7IHdpZHRoOiBcIiArIChjbS5kaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoKSArIFwicHhcIikpKTsgfVxuICAgICAgaWYgKG1hcmtlcnMpIHsgZm9yICh2YXIgayA9IDA7IGsgPCBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIHZhciBpZCA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3Nba10uY2xhc3NOYW1lLCBmb3VuZCA9IG1hcmtlcnMuaGFzT3duUHJvcGVydHkoaWQpICYmIG1hcmtlcnNbaWRdO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgeyBndXR0ZXJXcmFwLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZm91bmRdLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWVsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGRpbXMuZ3V0dGVyTGVmdFtpZF0pICsgXCJweDsgd2lkdGg6IFwiICsgKGRpbXMuZ3V0dGVyV2lkdGhbaWRdKSArIFwicHhcIikpKTsgfVxuICAgICAgfSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaWYgKGxpbmVWaWV3LmFsaWduYWJsZSkgeyBsaW5lVmlldy5hbGlnbmFibGUgPSBudWxsOyB9XG4gICAgdmFyIGlzV2lkZ2V0ID0gY2xhc3NUZXN0KFwiQ29kZU1pcnJvci1saW5ld2lkZ2V0XCIpO1xuICAgIGZvciAodmFyIG5vZGUgPSBsaW5lVmlldy5ub2RlLmZpcnN0Q2hpbGQsIG5leHQgPSAodm9pZCAwKTsgbm9kZTsgbm9kZSA9IG5leHQpIHtcbiAgICAgIG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgaWYgKGlzV2lkZ2V0LnRlc3Qobm9kZS5jbGFzc05hbWUpKSB7IGxpbmVWaWV3Lm5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7IH1cbiAgICB9XG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgbGluZSdzIERPTSByZXByZXNlbnRhdGlvbiBmcm9tIHNjcmF0Y2hcbiAgZnVuY3Rpb24gYnVpbGRMaW5lRWxlbWVudChjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgdmFyIGJ1aWx0ID0gZ2V0TGluZUNvbnRlbnQoY20sIGxpbmVWaWV3KTtcbiAgICBsaW5lVmlldy50ZXh0ID0gbGluZVZpZXcubm9kZSA9IGJ1aWx0LnByZTtcbiAgICBpZiAoYnVpbHQuYmdDbGFzcykgeyBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzczsgfVxuICAgIGlmIChidWlsdC50ZXh0Q2xhc3MpIHsgbGluZVZpZXcudGV4dENsYXNzID0gYnVpbHQudGV4dENsYXNzOyB9XG5cbiAgICB1cGRhdGVMaW5lQ2xhc3NlcyhjbSwgbGluZVZpZXcpO1xuICAgIHVwZGF0ZUxpbmVHdXR0ZXIoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKTtcbiAgICByZXR1cm4gbGluZVZpZXcubm9kZVxuICB9XG5cbiAgLy8gQSBsaW5lVmlldyBtYXkgY29udGFpbiBtdWx0aXBsZSBsb2dpY2FsIGxpbmVzICh3aGVuIG1lcmdlZCBieVxuICAvLyBjb2xsYXBzZWQgc3BhbnMpLiBUaGUgd2lkZ2V0cyBmb3IgYWxsIG9mIHRoZW0gbmVlZCB0byBiZSBkcmF3bi5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZVdpZGdldHMoY20sIGxpbmVWaWV3LCBkaW1zKSB7XG4gICAgaW5zZXJ0TGluZVdpZGdldHNGb3IoY20sIGxpbmVWaWV3LmxpbmUsIGxpbmVWaWV3LCBkaW1zLCB0cnVlKTtcbiAgICBpZiAobGluZVZpZXcucmVzdCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICB7IGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5yZXN0W2ldLCBsaW5lVmlldywgZGltcywgZmFsc2UpOyB9IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lLCBsaW5lVmlldywgZGltcywgYWxsb3dBYm92ZSkge1xuICAgIGlmICghbGluZS53aWRnZXRzKSB7IHJldHVybiB9XG4gICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIHdzID0gbGluZS53aWRnZXRzOyBpIDwgd3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB3aWRnZXQgPSB3c1tpXSwgbm9kZSA9IGVsdChcImRpdlwiLCBbd2lkZ2V0Lm5vZGVdLCBcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiICsgKHdpZGdldC5jbGFzc05hbWUgPyBcIiBcIiArIHdpZGdldC5jbGFzc05hbWUgOiBcIlwiKSk7XG4gICAgICBpZiAoIXdpZGdldC5oYW5kbGVNb3VzZUV2ZW50cykgeyBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpOyB9XG4gICAgICBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcyk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XG4gICAgICBpZiAoYWxsb3dBYm92ZSAmJiB3aWRnZXQuYWJvdmUpXG4gICAgICAgIHsgd3JhcC5pbnNlcnRCZWZvcmUobm9kZSwgbGluZVZpZXcuZ3V0dGVyIHx8IGxpbmVWaWV3LnRleHQpOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgd3JhcC5hcHBlbmRDaGlsZChub2RlKTsgfVxuICAgICAgc2lnbmFsTGF0ZXIod2lkZ2V0LCBcInJlZHJhd1wiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbkxpbmVXaWRnZXQod2lkZ2V0LCBub2RlLCBsaW5lVmlldywgZGltcykge1xuICAgIGlmICh3aWRnZXQubm9IU2Nyb2xsKSB7XG4gIChsaW5lVmlldy5hbGlnbmFibGUgfHwgKGxpbmVWaWV3LmFsaWduYWJsZSA9IFtdKSkucHVzaChub2RlKTtcbiAgICAgIHZhciB3aWR0aCA9IGRpbXMud3JhcHBlcldpZHRoO1xuICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gZGltcy5maXhlZFBvcyArIFwicHhcIjtcbiAgICAgIGlmICghd2lkZ2V0LmNvdmVyR3V0dGVyKSB7XG4gICAgICAgIHdpZHRoIC09IGRpbXMuZ3V0dGVyVG90YWxXaWR0aDtcbiAgICAgICAgbm9kZS5zdHlsZS5wYWRkaW5nTGVmdCA9IGRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICB9XG4gICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcikge1xuICAgICAgbm9kZS5zdHlsZS56SW5kZXggPSA1O1xuICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGlmICghd2lkZ2V0Lm5vSFNjcm9sbCkgeyBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoICsgXCJweFwiOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2lkZ2V0SGVpZ2h0KHdpZGdldCkge1xuICAgIGlmICh3aWRnZXQuaGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIHdpZGdldC5oZWlnaHQgfVxuICAgIHZhciBjbSA9IHdpZGdldC5kb2MuY207XG4gICAgaWYgKCFjbSkgeyByZXR1cm4gMCB9XG4gICAgaWYgKCFjb250YWlucyhkb2N1bWVudC5ib2R5LCB3aWRnZXQubm9kZSkpIHtcbiAgICAgIHZhciBwYXJlbnRTdHlsZSA9IFwicG9zaXRpb246IHJlbGF0aXZlO1wiO1xuICAgICAgaWYgKHdpZGdldC5jb3Zlckd1dHRlcilcbiAgICAgICAgeyBwYXJlbnRTdHlsZSArPSBcIm1hcmdpbi1sZWZ0OiAtXCIgKyBjbS5kaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGggKyBcInB4O1wiOyB9XG4gICAgICBpZiAod2lkZ2V0Lm5vSFNjcm9sbClcbiAgICAgICAgeyBwYXJlbnRTdHlsZSArPSBcIndpZHRoOiBcIiArIGNtLmRpc3BsYXkud3JhcHBlci5jbGllbnRXaWR0aCArIFwicHg7XCI7IH1cbiAgICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubWVhc3VyZSwgZWx0KFwiZGl2XCIsIFt3aWRnZXQubm9kZV0sIG51bGwsIHBhcmVudFN0eWxlKSk7XG4gICAgfVxuICAgIHJldHVybiB3aWRnZXQuaGVpZ2h0ID0gd2lkZ2V0Lm5vZGUucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHRcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIHdoZW4gdGhlIGdpdmVuIG1vdXNlIGV2ZW50IGhhcHBlbmVkIGluIGEgd2lkZ2V0XG4gIGZ1bmN0aW9uIGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkge1xuICAgIGZvciAodmFyIG4gPSBlX3RhcmdldChlKTsgbiAhPSBkaXNwbGF5LndyYXBwZXI7IG4gPSBuLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmICghbiB8fCAobi5ub2RlVHlwZSA9PSAxICYmIG4uZ2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiKSA9PSBcInRydWVcIikgfHxcbiAgICAgICAgICAobi5wYXJlbnROb2RlID09IGRpc3BsYXkuc2l6ZXIgJiYgbiAhPSBkaXNwbGF5Lm1vdmVyKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gUE9TSVRJT04gTUVBU1VSRU1FTlRcblxuICBmdW5jdGlvbiBwYWRkaW5nVG9wKGRpc3BsYXkpIHtyZXR1cm4gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0VG9wfVxuICBmdW5jdGlvbiBwYWRkaW5nVmVydChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubW92ZXIub2Zmc2V0SGVpZ2h0IC0gZGlzcGxheS5saW5lU3BhY2Uub2Zmc2V0SGVpZ2h0fVxuICBmdW5jdGlvbiBwYWRkaW5nSChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkUGFkZGluZ0gpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggfVxuICAgIHZhciBlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBlbHQoXCJwcmVcIiwgXCJ4XCIsIFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIikpO1xuICAgIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSkgOiBlLmN1cnJlbnRTdHlsZTtcbiAgICB2YXIgZGF0YSA9IHtsZWZ0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nTGVmdCksIHJpZ2h0OiBwYXJzZUludChzdHlsZS5wYWRkaW5nUmlnaHQpfTtcbiAgICBpZiAoIWlzTmFOKGRhdGEubGVmdCkgJiYgIWlzTmFOKGRhdGEucmlnaHQpKSB7IGRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBkYXRhOyB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbEdhcChjbSkgeyByZXR1cm4gc2Nyb2xsZXJHYXAgLSBjbS5kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoIH1cbiAgZnVuY3Rpb24gZGlzcGxheVdpZHRoKGNtKSB7XG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJXaWR0aFxuICB9XG4gIGZ1bmN0aW9uIGRpc3BsYXlIZWlnaHQoY20pIHtcbiAgICByZXR1cm4gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQgLSBzY3JvbGxHYXAoY20pIC0gY20uZGlzcGxheS5iYXJIZWlnaHRcbiAgfVxuXG4gIC8vIEVuc3VyZSB0aGUgbGluZVZpZXcud3JhcHBpbmcuaGVpZ2h0cyBhcnJheSBpcyBwb3B1bGF0ZWQuIFRoaXMgaXNcbiAgLy8gYW4gYXJyYXkgb2YgYm90dG9tIG9mZnNldHMgZm9yIHRoZSBsaW5lcyB0aGF0IG1ha2UgdXAgYSBkcmF3blxuICAvLyBsaW5lLiBXaGVuIGxpbmVXcmFwcGluZyBpcyBvbiwgdGhlcmUgbWlnaHQgYmUgbW9yZSB0aGFuIG9uZVxuICAvLyBoZWlnaHQuXG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBsaW5lVmlldywgcmVjdCkge1xuICAgIHZhciB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgIHZhciBjdXJXaWR0aCA9IHdyYXBwaW5nICYmIGRpc3BsYXlXaWR0aChjbSk7XG4gICAgaWYgKCFsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgfHwgd3JhcHBpbmcgJiYgbGluZVZpZXcubWVhc3VyZS53aWR0aCAhPSBjdXJXaWR0aCkge1xuICAgICAgdmFyIGhlaWdodHMgPSBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBbXTtcbiAgICAgIGlmICh3cmFwcGluZykge1xuICAgICAgICBsaW5lVmlldy5tZWFzdXJlLndpZHRoID0gY3VyV2lkdGg7XG4gICAgICAgIHZhciByZWN0cyA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIHZhciBjdXIgPSByZWN0c1tpXSwgbmV4dCA9IHJlY3RzW2kgKyAxXTtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoY3VyLmJvdHRvbSAtIG5leHQuYm90dG9tKSA+IDIpXG4gICAgICAgICAgICB7IGhlaWdodHMucHVzaCgoY3VyLmJvdHRvbSArIG5leHQudG9wKSAvIDIgLSByZWN0LnRvcCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGVpZ2h0cy5wdXNoKHJlY3QuYm90dG9tIC0gcmVjdC50b3ApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgYSBsaW5lIG1hcCAobWFwcGluZyBjaGFyYWN0ZXIgb2Zmc2V0cyB0byB0ZXh0IG5vZGVzKSBhbmQgYVxuICAvLyBtZWFzdXJlbWVudCBjYWNoZSBmb3IgdGhlIGdpdmVuIGxpbmUgbnVtYmVyLiAoQSBsaW5lIHZpZXcgbWlnaHRcbiAgLy8gY29udGFpbiBtdWx0aXBsZSBsaW5lcyB3aGVuIGNvbGxhcHNlZCByYW5nZXMgYXJlIHByZXNlbnQuKVxuICBmdW5jdGlvbiBtYXBGcm9tTGluZVZpZXcobGluZVZpZXcsIGxpbmUsIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVWaWV3LmxpbmUgPT0gbGluZSlcbiAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZX0gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVZpZXcucmVzdC5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKGxpbmVWaWV3LnJlc3RbaV0gPT0gbGluZSlcbiAgICAgICAgeyByZXR1cm4ge21hcDogbGluZVZpZXcubWVhc3VyZS5tYXBzW2ldLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV19IH0gfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpJDErKylcbiAgICAgIHsgaWYgKGxpbmVObyhsaW5lVmlldy5yZXN0W2kkMV0pID4gbGluZU4pXG4gICAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpJDFdLCBjYWNoZTogbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaSQxXSwgYmVmb3JlOiB0cnVlfSB9IH1cbiAgfVxuXG4gIC8vIFJlbmRlciBhIGxpbmUgaW50byB0aGUgaGlkZGVuIG5vZGUgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkLiBVc2VkXG4gIC8vIHdoZW4gbWVhc3VyZW1lbnQgaXMgbmVlZGVkIGZvciBhIGxpbmUgdGhhdCdzIG5vdCBpbiB0aGUgdmlld3BvcnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZUV4dGVybmFsTWVhc3VyZW1lbnQoY20sIGxpbmUpIHtcbiAgICBsaW5lID0gdmlzdWFsTGluZShsaW5lKTtcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBuZXcgTGluZVZpZXcoY20uZG9jLCBsaW5lLCBsaW5lTik7XG4gICAgdmlldy5saW5lTiA9IGxpbmVOO1xuICAgIHZhciBidWlsdCA9IHZpZXcuYnVpbHQgPSBidWlsZExpbmVDb250ZW50KGNtLCB2aWV3KTtcbiAgICB2aWV3LnRleHQgPSBidWlsdC5wcmU7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoY20uZGlzcGxheS5saW5lTWVhc3VyZSwgYnVpbHQucHJlKTtcbiAgICByZXR1cm4gdmlld1xuICB9XG5cbiAgLy8gR2V0IGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IChpbiBsaW5lLWxvY2FsIGNvb3JkaW5hdGVzKVxuICAvLyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyKGNtLCBsaW5lLCBjaCwgYmlhcykge1xuICAgIHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpLCBjaCwgYmlhcylcbiAgfVxuXG4gIC8vIEZpbmQgYSBsaW5lIHZpZXcgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgZ2l2ZW4gbGluZSBudW1iZXIuXG4gIGZ1bmN0aW9uIGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pIHtcbiAgICBpZiAobGluZU4gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBsaW5lTiA8IGNtLmRpc3BsYXkudmlld1RvKVxuICAgICAgeyByZXR1cm4gY20uZGlzcGxheS52aWV3W2ZpbmRWaWV3SW5kZXgoY20sIGxpbmVOKV0gfVxuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBsaW5lTiA+PSBleHQubGluZU4gJiYgbGluZU4gPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgIHsgcmV0dXJuIGV4dCB9XG4gIH1cblxuICAvLyBNZWFzdXJlbWVudCBjYW4gYmUgc3BsaXQgaW4gdHdvIHN0ZXBzLCB0aGUgc2V0LXVwIHdvcmsgdGhhdFxuICAvLyBhcHBsaWVzIHRvIHRoZSB3aG9sZSBsaW5lLCBhbmQgdGhlIG1lYXN1cmVtZW50IG9mIHRoZSBhY3R1YWxcbiAgLy8gY2hhcmFjdGVyLiBGdW5jdGlvbnMgbGlrZSBjb29yZHNDaGFyLCB0aGF0IG5lZWQgdG8gZG8gYSBsb3Qgb2ZcbiAgLy8gbWVhc3VyZW1lbnRzIGluIGEgcm93LCBjYW4gdGh1cyBlbnN1cmUgdGhhdCB0aGUgc2V0LXVwIHdvcmsgaXNcbiAgLy8gb25seSBkb25lIG9uY2UuXG4gIGZ1bmN0aW9uIHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZSkge1xuICAgIHZhciBsaW5lTiA9IGxpbmVObyhsaW5lKTtcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgIGlmICh2aWV3ICYmICF2aWV3LnRleHQpIHtcbiAgICAgIHZpZXcgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodmlldyAmJiB2aWV3LmNoYW5nZXMpIHtcbiAgICAgIHVwZGF0ZUxpbmVGb3JDaGFuZ2VzKGNtLCB2aWV3LCBsaW5lTiwgZ2V0RGltZW5zaW9ucyhjbSkpO1xuICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZpZXcpXG4gICAgICB7IHZpZXcgPSB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKTsgfVxuXG4gICAgdmFyIGluZm8gPSBtYXBGcm9tTGluZVZpZXcodmlldywgbGluZSwgbGluZU4pO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBsaW5lLCB2aWV3OiB2aWV3LCByZWN0OiBudWxsLFxuICAgICAgbWFwOiBpbmZvLm1hcCwgY2FjaGU6IGluZm8uY2FjaGUsIGJlZm9yZTogaW5mby5iZWZvcmUsXG4gICAgICBoYXNIZWlnaHRzOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIEdpdmVuIGEgcHJlcGFyZWQgbWVhc3VyZW1lbnQgb2JqZWN0LCBtZWFzdXJlcyB0aGUgcG9zaXRpb24gb2YgYW5cbiAgLy8gYWN0dWFsIGNoYXJhY3RlciAob3IgZmV0Y2hlcyBpdCBmcm9tIHRoZSBjYWNoZSkuXG4gIGZ1bmN0aW9uIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkLCBjaCwgYmlhcywgdmFySGVpZ2h0KSB7XG4gICAgaWYgKHByZXBhcmVkLmJlZm9yZSkgeyBjaCA9IC0xOyB9XG4gICAgdmFyIGtleSA9IGNoICsgKGJpYXMgfHwgXCJcIiksIGZvdW5kO1xuICAgIGlmIChwcmVwYXJlZC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBmb3VuZCA9IHByZXBhcmVkLmNhY2hlW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcHJlcGFyZWQucmVjdClcbiAgICAgICAgeyBwcmVwYXJlZC5yZWN0ID0gcHJlcGFyZWQudmlldy50ZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgICBpZiAoIXByZXBhcmVkLmhhc0hlaWdodHMpIHtcbiAgICAgICAgZW5zdXJlTGluZUhlaWdodHMoY20sIHByZXBhcmVkLnZpZXcsIHByZXBhcmVkLnJlY3QpO1xuICAgICAgICBwcmVwYXJlZC5oYXNIZWlnaHRzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvdW5kID0gbWVhc3VyZUNoYXJJbm5lcihjbSwgcHJlcGFyZWQsIGNoLCBiaWFzKTtcbiAgICAgIGlmICghZm91bmQuYm9ndXMpIHsgcHJlcGFyZWQuY2FjaGVba2V5XSA9IGZvdW5kOyB9XG4gICAgfVxuICAgIHJldHVybiB7bGVmdDogZm91bmQubGVmdCwgcmlnaHQ6IGZvdW5kLnJpZ2h0LFxuICAgICAgICAgICAgdG9wOiB2YXJIZWlnaHQgPyBmb3VuZC5ydG9wIDogZm91bmQudG9wLFxuICAgICAgICAgICAgYm90dG9tOiB2YXJIZWlnaHQgPyBmb3VuZC5yYm90dG9tIDogZm91bmQuYm90dG9tfVxuICB9XG5cbiAgdmFyIG51bGxSZWN0ID0ge2xlZnQ6IDAsIHJpZ2h0OiAwLCB0b3A6IDAsIGJvdHRvbTogMH07XG5cbiAgZnVuY3Rpb24gbm9kZUFuZE9mZnNldEluTGluZU1hcChtYXAsIGNoLCBiaWFzKSB7XG4gICAgdmFyIG5vZGUsIHN0YXJ0LCBlbmQsIGNvbGxhcHNlLCBtU3RhcnQsIG1FbmQ7XG4gICAgLy8gRmlyc3QsIHNlYXJjaCB0aGUgbGluZSBtYXAgZm9yIHRoZSB0ZXh0IG5vZGUgY29ycmVzcG9uZGluZyB0byxcbiAgICAvLyBvciBjbG9zZXN0IHRvLCB0aGUgdGFyZ2V0IGNoYXJhY3Rlci5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgbVN0YXJ0ID0gbWFwW2ldO1xuICAgICAgbUVuZCA9IG1hcFtpICsgMV07XG4gICAgICBpZiAoY2ggPCBtU3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSAwOyBlbmQgPSAxO1xuICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xuICAgICAgfSBlbHNlIGlmIChjaCA8IG1FbmQpIHtcbiAgICAgICAgc3RhcnQgPSBjaCAtIG1TdGFydDtcbiAgICAgICAgZW5kID0gc3RhcnQgKyAxO1xuICAgICAgfSBlbHNlIGlmIChpID09IG1hcC5sZW5ndGggLSAzIHx8IGNoID09IG1FbmQgJiYgbWFwW2kgKyAzXSA+IGNoKSB7XG4gICAgICAgIGVuZCA9IG1FbmQgLSBtU3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gZW5kIC0gMTtcbiAgICAgICAgaWYgKGNoID49IG1FbmQpIHsgY29sbGFwc2UgPSBcInJpZ2h0XCI7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUgPSBtYXBbaSArIDJdO1xuICAgICAgICBpZiAobVN0YXJ0ID09IG1FbmQgJiYgYmlhcyA9PSAobm9kZS5pbnNlcnRMZWZ0ID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpKVxuICAgICAgICAgIHsgY29sbGFwc2UgPSBiaWFzOyB9XG4gICAgICAgIGlmIChiaWFzID09IFwibGVmdFwiICYmIHN0YXJ0ID09IDApXG4gICAgICAgICAgeyB3aGlsZSAoaSAmJiBtYXBbaSAtIDJdID09IG1hcFtpIC0gM10gJiYgbWFwW2kgLSAxXS5pbnNlcnRMZWZ0KSB7XG4gICAgICAgICAgICBub2RlID0gbWFwWyhpIC09IDMpICsgMl07XG4gICAgICAgICAgICBjb2xsYXBzZSA9IFwibGVmdFwiO1xuICAgICAgICAgIH0gfVxuICAgICAgICBpZiAoYmlhcyA9PSBcInJpZ2h0XCIgJiYgc3RhcnQgPT0gbUVuZCAtIG1TdGFydClcbiAgICAgICAgICB7IHdoaWxlIChpIDwgbWFwLmxlbmd0aCAtIDMgJiYgbWFwW2kgKyAzXSA9PSBtYXBbaSArIDRdICYmICFtYXBbaSArIDVdLmluc2VydExlZnQpIHtcbiAgICAgICAgICAgIG5vZGUgPSBtYXBbKGkgKz0gMykgKyAyXTtcbiAgICAgICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xuICAgICAgICAgIH0gfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge25vZGU6IG5vZGUsIHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQsIGNvbGxhcHNlOiBjb2xsYXBzZSwgY292ZXJTdGFydDogbVN0YXJ0LCBjb3ZlckVuZDogbUVuZH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVzZWZ1bFJlY3QocmVjdHMsIGJpYXMpIHtcbiAgICB2YXIgcmVjdCA9IG51bGxSZWN0O1xuICAgIGlmIChiaWFzID09IFwibGVmdFwiKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgocmVjdCA9IHJlY3RzW2ldKS5sZWZ0ICE9IHJlY3QucmlnaHQpIHsgYnJlYWsgfVxuICAgIH0gfSBlbHNlIHsgZm9yICh2YXIgaSQxID0gcmVjdHMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICBpZiAoKHJlY3QgPSByZWN0c1tpJDFdKS5sZWZ0ICE9IHJlY3QucmlnaHQpIHsgYnJlYWsgfVxuICAgIH0gfVxuICAgIHJldHVybiByZWN0XG4gIH1cblxuICBmdW5jdGlvbiBtZWFzdXJlQ2hhcklubmVyKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMpIHtcbiAgICB2YXIgcGxhY2UgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKHByZXBhcmVkLm1hcCwgY2gsIGJpYXMpO1xuICAgIHZhciBub2RlID0gcGxhY2Uubm9kZSwgc3RhcnQgPSBwbGFjZS5zdGFydCwgZW5kID0gcGxhY2UuZW5kLCBjb2xsYXBzZSA9IHBsYWNlLmNvbGxhcHNlO1xuXG4gICAgdmFyIHJlY3Q7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykgeyAvLyBJZiBpdCBpcyBhIHRleHQgbm9kZSwgdXNlIGEgcmFuZ2UgdG8gcmV0cmlldmUgdGhlIGNvb3JkaW5hdGVzLlxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgNDsgaSQxKyspIHsgLy8gUmV0cnkgYSBtYXhpbXVtIG9mIDQgdGltZXMgd2hlbiBub25zZW5zZSByZWN0YW5nbGVzIGFyZSByZXR1cm5lZFxuICAgICAgICB3aGlsZSAoc3RhcnQgJiYgaXNFeHRlbmRpbmdDaGFyKHByZXBhcmVkLmxpbmUudGV4dC5jaGFyQXQocGxhY2UuY292ZXJTdGFydCArIHN0YXJ0KSkpIHsgLS1zdGFydDsgfVxuICAgICAgICB3aGlsZSAocGxhY2UuY292ZXJTdGFydCArIGVuZCA8IHBsYWNlLmNvdmVyRW5kICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQpKSkgeyArK2VuZDsgfVxuICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkgJiYgc3RhcnQgPT0gMCAmJiBlbmQgPT0gcGxhY2UuY292ZXJFbmQgLSBwbGFjZS5jb3ZlclN0YXJ0KVxuICAgICAgICAgIHsgcmVjdCA9IG5vZGUucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZWN0ID0gZ2V0VXNlZnVsUmVjdChyYW5nZShub2RlLCBzdGFydCwgZW5kKS5nZXRDbGllbnRSZWN0cygpLCBiaWFzKTsgfVxuICAgICAgICBpZiAocmVjdC5sZWZ0IHx8IHJlY3QucmlnaHQgfHwgc3RhcnQgPT0gMCkgeyBicmVhayB9XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IHN0YXJ0IC0gMTtcbiAgICAgICAgY29sbGFwc2UgPSBcInJpZ2h0XCI7XG4gICAgICB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7IHJlY3QgPSBtYXliZVVwZGF0ZVJlY3RGb3Jab29taW5nKGNtLmRpc3BsYXkubWVhc3VyZSwgcmVjdCk7IH1cbiAgICB9IGVsc2UgeyAvLyBJZiBpdCBpcyBhIHdpZGdldCwgc2ltcGx5IGdldCB0aGUgYm94IGZvciB0aGUgd2hvbGUgd2lkZ2V0LlxuICAgICAgaWYgKHN0YXJ0ID4gMCkgeyBjb2xsYXBzZSA9IGJpYXMgPSBcInJpZ2h0XCI7IH1cbiAgICAgIHZhciByZWN0cztcbiAgICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiAocmVjdHMgPSBub2RlLmdldENsaWVudFJlY3RzKCkpLmxlbmd0aCA+IDEpXG4gICAgICAgIHsgcmVjdCA9IHJlY3RzW2JpYXMgPT0gXCJyaWdodFwiID8gcmVjdHMubGVuZ3RoIC0gMSA6IDBdOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICB9XG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5ICYmICFzdGFydCAmJiAoIXJlY3QgfHwgIXJlY3QubGVmdCAmJiAhcmVjdC5yaWdodCkpIHtcbiAgICAgIHZhciByU3BhbiA9IG5vZGUucGFyZW50Tm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO1xuICAgICAgaWYgKHJTcGFuKVxuICAgICAgICB7IHJlY3QgPSB7bGVmdDogclNwYW4ubGVmdCwgcmlnaHQ6IHJTcGFuLmxlZnQgKyBjaGFyV2lkdGgoY20uZGlzcGxheSksIHRvcDogclNwYW4udG9wLCBib3R0b206IHJTcGFuLmJvdHRvbX07IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZWN0ID0gbnVsbFJlY3Q7IH1cbiAgICB9XG5cbiAgICB2YXIgcnRvcCA9IHJlY3QudG9wIC0gcHJlcGFyZWQucmVjdC50b3AsIHJib3QgPSByZWN0LmJvdHRvbSAtIHByZXBhcmVkLnJlY3QudG9wO1xuICAgIHZhciBtaWQgPSAocnRvcCArIHJib3QpIC8gMjtcbiAgICB2YXIgaGVpZ2h0cyA9IHByZXBhcmVkLnZpZXcubWVhc3VyZS5oZWlnaHRzO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGhlaWdodHMubGVuZ3RoIC0gMTsgaSsrKVxuICAgICAgeyBpZiAobWlkIDwgaGVpZ2h0c1tpXSkgeyBicmVhayB9IH1cbiAgICB2YXIgdG9wID0gaSA/IGhlaWdodHNbaSAtIDFdIDogMCwgYm90ID0gaGVpZ2h0c1tpXTtcbiAgICB2YXIgcmVzdWx0ID0ge2xlZnQ6IChjb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiAoY29sbGFwc2UgPT0gXCJsZWZ0XCIgPyByZWN0LmxlZnQgOiByZWN0LnJpZ2h0KSAtIHByZXBhcmVkLnJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgIHRvcDogdG9wLCBib3R0b206IGJvdH07XG4gICAgaWYgKCFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpIHsgcmVzdWx0LmJvZ3VzID0gdHJ1ZTsgfVxuICAgIGlmICghY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKSB7IHJlc3VsdC5ydG9wID0gcnRvcDsgcmVzdWx0LnJib3R0b20gPSByYm90OyB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBwcm9ibGVtIHdpdGggYm91bmRpbmcgY2xpZW50IHJlY3RzIG9uIHJhbmdlcyBiZWluZ1xuICAvLyByZXR1cm5lZCBpbmNvcnJlY3RseSB3aGVuIHpvb21lZCBvbiBJRTEwIGFuZCBiZWxvdy5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhtZWFzdXJlLCByZWN0KSB7XG4gICAgaWYgKCF3aW5kb3cuc2NyZWVuIHx8IHNjcmVlbi5sb2dpY2FsWERQSSA9PSBudWxsIHx8XG4gICAgICAgIHNjcmVlbi5sb2dpY2FsWERQSSA9PSBzY3JlZW4uZGV2aWNlWERQSSB8fCAhaGFzQmFkWm9vbWVkUmVjdHMobWVhc3VyZSkpXG4gICAgICB7IHJldHVybiByZWN0IH1cbiAgICB2YXIgc2NhbGVYID0gc2NyZWVuLmxvZ2ljYWxYRFBJIC8gc2NyZWVuLmRldmljZVhEUEk7XG4gICAgdmFyIHNjYWxlWSA9IHNjcmVlbi5sb2dpY2FsWURQSSAvIHNjcmVlbi5kZXZpY2VZRFBJO1xuICAgIHJldHVybiB7bGVmdDogcmVjdC5sZWZ0ICogc2NhbGVYLCByaWdodDogcmVjdC5yaWdodCAqIHNjYWxlWCxcbiAgICAgICAgICAgIHRvcDogcmVjdC50b3AgKiBzY2FsZVksIGJvdHRvbTogcmVjdC5ib3R0b20gKiBzY2FsZVl9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlRm9yKGxpbmVWaWV3KSB7XG4gICAgaWYgKGxpbmVWaWV3Lm1lYXN1cmUpIHtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGUgPSB7fTtcbiAgICAgIGxpbmVWaWV3Lm1lYXN1cmUuaGVpZ2h0cyA9IG51bGw7XG4gICAgICBpZiAobGluZVZpZXcucmVzdCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgbGluZVZpZXcubWVhc3VyZS5jYWNoZXNbaV0gPSB7fTsgfSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZShjbSkge1xuICAgIGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlID0gbnVsbDtcbiAgICByZW1vdmVDaGlsZHJlbihjbS5kaXNwbGF5LmxpbmVNZWFzdXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkudmlldy5sZW5ndGg7IGkrKylcbiAgICAgIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihjbS5kaXNwbGF5LnZpZXdbaV0pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhckNhY2hlcyhjbSkge1xuICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pO1xuICAgIGNtLmRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoID0gY20uZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gY20uZGlzcGxheS5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTsgfVxuICAgIGNtLmRpc3BsYXkubGluZU51bUNoYXJzID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxYKCkge1xuICAgIC8vIFdvcmsgYXJvdW5kIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ4OTIwNlxuICAgIC8vIHdoaWNoIGNhdXNlcyBwYWdlX09mZnNldCBhbmQgYm91bmRpbmcgY2xpZW50IHJlY3RzIHRvIHVzZVxuICAgIC8vIGRpZmZlcmVudCByZWZlcmVuY2Ugdmlld3BvcnRzIGFuZCBpbnZhbGlkYXRlIG91ciBjYWxjdWxhdGlvbnMuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkKSB7IHJldHVybiAtKGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkubWFyZ2luTGVmdCkpIH1cbiAgICByZXR1cm4gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsTGVmdFxuICB9XG4gIGZ1bmN0aW9uIHBhZ2VTY3JvbGxZKCkge1xuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCkgeyByZXR1cm4gLShkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkubWFyZ2luVG9wKSkgfVxuICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5KS5zY3JvbGxUb3BcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpZGdldFRvcEhlaWdodChsaW5lT2JqKSB7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgaWYgKGxpbmVPYmoud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVPYmoud2lkZ2V0cy5sZW5ndGg7ICsraSkgeyBpZiAobGluZU9iai53aWRnZXRzW2ldLmFib3ZlKVxuICAgICAgeyBoZWlnaHQgKz0gd2lkZ2V0SGVpZ2h0KGxpbmVPYmoud2lkZ2V0c1tpXSk7IH0gfSB9XG4gICAgcmV0dXJuIGhlaWdodFxuICB9XG5cbiAgLy8gQ29udmVydHMgYSB7dG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0fSBib3ggZnJvbSBsaW5lLWxvY2FsXG4gIC8vIGNvb3JkaW5hdGVzIGludG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS4gQ29udGV4dCBtYXkgYmUgb25lIG9mXG4gIC8vIFwibGluZVwiLCBcImRpdlwiIChkaXNwbGF5LmxpbmVEaXYpLCBcImxvY2FsXCIuL251bGwgKGVkaXRvciksIFwid2luZG93XCIsXG4gIC8vIG9yIFwicGFnZVwiLlxuICBmdW5jdGlvbiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIHJlY3QsIGNvbnRleHQsIGluY2x1ZGVXaWRnZXRzKSB7XG4gICAgaWYgKCFpbmNsdWRlV2lkZ2V0cykge1xuICAgICAgdmFyIGhlaWdodCA9IHdpZGdldFRvcEhlaWdodChsaW5lT2JqKTtcbiAgICAgIHJlY3QudG9wICs9IGhlaWdodDsgcmVjdC5ib3R0b20gKz0gaGVpZ2h0O1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PSBcImxpbmVcIikgeyByZXR1cm4gcmVjdCB9XG4gICAgaWYgKCFjb250ZXh0KSB7IGNvbnRleHQgPSBcImxvY2FsXCI7IH1cbiAgICB2YXIgeU9mZiA9IGhlaWdodEF0TGluZShsaW5lT2JqKTtcbiAgICBpZiAoY29udGV4dCA9PSBcImxvY2FsXCIpIHsgeU9mZiArPSBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpOyB9XG4gICAgZWxzZSB7IHlPZmYgLT0gY20uZGlzcGxheS52aWV3T2Zmc2V0OyB9XG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIgfHwgY29udGV4dCA9PSBcIndpbmRvd1wiKSB7XG4gICAgICB2YXIgbE9mZiA9IGNtLmRpc3BsYXkubGluZVNwYWNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgeU9mZiArPSBsT2ZmLnRvcCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFkoKSk7XG4gICAgICB2YXIgeE9mZiA9IGxPZmYubGVmdCArIChjb250ZXh0ID09IFwid2luZG93XCIgPyAwIDogcGFnZVNjcm9sbFgoKSk7XG4gICAgICByZWN0LmxlZnQgKz0geE9mZjsgcmVjdC5yaWdodCArPSB4T2ZmO1xuICAgIH1cbiAgICByZWN0LnRvcCArPSB5T2ZmOyByZWN0LmJvdHRvbSArPSB5T2ZmO1xuICAgIHJldHVybiByZWN0XG4gIH1cblxuICAvLyBDb3ZlcnRzIGEgYm94IGZyb20gXCJkaXZcIiBjb29yZHMgdG8gYW5vdGhlciBjb29yZGluYXRlIHN5c3RlbS5cbiAgLy8gQ29udGV4dCBtYXkgYmUgXCJ3aW5kb3dcIiwgXCJwYWdlXCIsIFwiZGl2XCIsIG9yIFwibG9jYWxcIi4vbnVsbC5cbiAgZnVuY3Rpb24gZnJvbUNvb3JkU3lzdGVtKGNtLCBjb29yZHMsIGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PSBcImRpdlwiKSB7IHJldHVybiBjb29yZHMgfVxuICAgIHZhciBsZWZ0ID0gY29vcmRzLmxlZnQsIHRvcCA9IGNvb3Jkcy50b3A7XG4gICAgLy8gRmlyc3QgbW92ZSBpbnRvIFwicGFnZVwiIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgaWYgKGNvbnRleHQgPT0gXCJwYWdlXCIpIHtcbiAgICAgIGxlZnQgLT0gcGFnZVNjcm9sbFgoKTtcbiAgICAgIHRvcCAtPSBwYWdlU2Nyb2xsWSgpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PSBcImxvY2FsXCIgfHwgIWNvbnRleHQpIHtcbiAgICAgIHZhciBsb2NhbEJveCA9IGNtLmRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsZWZ0ICs9IGxvY2FsQm94LmxlZnQ7XG4gICAgICB0b3AgKz0gbG9jYWxCb3gudG9wO1xuICAgIH1cblxuICAgIHZhciBsaW5lU3BhY2VCb3ggPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge2xlZnQ6IGxlZnQgLSBsaW5lU3BhY2VCb3gubGVmdCwgdG9wOiB0b3AgLSBsaW5lU3BhY2VCb3gudG9wfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hhckNvb3JkcyhjbSwgcG9zLCBjb250ZXh0LCBsaW5lT2JqLCBiaWFzKSB7XG4gICAgaWYgKCFsaW5lT2JqKSB7IGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpOyB9XG4gICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXIoY20sIGxpbmVPYmosIHBvcy5jaCwgYmlhcyksIGNvbnRleHQpXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm94IGZvciBhIGdpdmVuIGN1cnNvciBwb3NpdGlvbiwgd2hpY2ggbWF5IGhhdmUgYW5cbiAgLy8gJ290aGVyJyBwcm9wZXJ0eSBjb250YWluaW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kYXJ5IGN1cnNvclxuICAvLyBvbiBhIGJpZGkgYm91bmRhcnkuXG4gIC8vIEEgY3Vyc29yIFBvcyhsaW5lLCBjaGFyLCBcImJlZm9yZVwiKSBpcyBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZSBhcyBgY2hhciAtIDFgXG4gIC8vIGFuZCBhZnRlciBgY2hhciAtIDFgIGluIHdyaXRpbmcgb3JkZXIgb2YgYGNoYXIgLSAxYFxuICAvLyBBIGN1cnNvciBQb3MobGluZSwgY2hhciwgXCJhZnRlclwiKSBpcyBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZSBhcyBgY2hhcmBcbiAgLy8gYW5kIGJlZm9yZSBgY2hhcmAgaW4gd3JpdGluZyBvcmRlciBvZiBgY2hhcmBcbiAgLy8gRXhhbXBsZXMgKHVwcGVyLWNhc2UgbGV0dGVycyBhcmUgUlRMLCBsb3dlci1jYXNlIGFyZSBMVFIpOlxuICAvLyAgICAgUG9zKDAsIDEsIC4uLilcbiAgLy8gICAgIGJlZm9yZSAgIGFmdGVyXG4gIC8vIGFiICAgICBhfGIgICAgIGF8YlxuICAvLyBhQiAgICAgYXxCICAgICBhQnxcbiAgLy8gQWIgICAgIHxBYiAgICAgQXxiXG4gIC8vIEFCICAgICBCfEEgICAgIEJ8QVxuICAvLyBFdmVyeSBwb3NpdGlvbiBhZnRlciB0aGUgbGFzdCBjaGFyYWN0ZXIgb24gYSBsaW5lIGlzIGNvbnNpZGVyZWQgdG8gc3RpY2tcbiAgLy8gdG8gdGhlIGxhc3QgY2hhcmFjdGVyIG9uIHRoZSBsaW5lLlxuICBmdW5jdGlvbiBjdXJzb3JDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB2YXJIZWlnaHQpIHtcbiAgICBsaW5lT2JqID0gbGluZU9iaiB8fCBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xuICAgIGlmICghcHJlcGFyZWRNZWFzdXJlKSB7IHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7IH1cbiAgICBmdW5jdGlvbiBnZXQoY2gsIHJpZ2h0KSB7XG4gICAgICB2YXIgbSA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gsIHJpZ2h0ID8gXCJyaWdodFwiIDogXCJsZWZ0XCIsIHZhckhlaWdodCk7XG4gICAgICBpZiAocmlnaHQpIHsgbS5sZWZ0ID0gbS5yaWdodDsgfSBlbHNlIHsgbS5yaWdodCA9IG0ubGVmdDsgfVxuICAgICAgcmV0dXJuIGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbSwgY29udGV4dClcbiAgICB9XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgY20uZG9jLmRpcmVjdGlvbiksIGNoID0gcG9zLmNoLCBzdGlja3kgPSBwb3Muc3RpY2t5O1xuICAgIGlmIChjaCA+PSBsaW5lT2JqLnRleHQubGVuZ3RoKSB7XG4gICAgICBjaCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICBzdGlja3kgPSBcImJlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoY2ggPD0gMCkge1xuICAgICAgY2ggPSAwO1xuICAgICAgc3RpY2t5ID0gXCJhZnRlclwiO1xuICAgIH1cbiAgICBpZiAoIW9yZGVyKSB7IHJldHVybiBnZXQoc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBjaCAtIDEgOiBjaCwgc3RpY2t5ID09IFwiYmVmb3JlXCIpIH1cblxuICAgIGZ1bmN0aW9uIGdldEJpZGkoY2gsIHBhcnRQb3MsIGludmVydCkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltwYXJ0UG9zXSwgcmlnaHQgPSBwYXJ0LmxldmVsID09IDE7XG4gICAgICByZXR1cm4gZ2V0KGludmVydCA/IGNoIC0gMSA6IGNoLCByaWdodCAhPSBpbnZlcnQpXG4gICAgfVxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgY2gsIHN0aWNreSk7XG4gICAgdmFyIG90aGVyID0gYmlkaU90aGVyO1xuICAgIHZhciB2YWwgPSBnZXRCaWRpKGNoLCBwYXJ0UG9zLCBzdGlja3kgPT0gXCJiZWZvcmVcIik7XG4gICAgaWYgKG90aGVyICE9IG51bGwpIHsgdmFsLm90aGVyID0gZ2V0QmlkaShjaCwgb3RoZXIsIHN0aWNreSAhPSBcImJlZm9yZVwiKTsgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIC8vIFVzZWQgdG8gY2hlYXBseSBlc3RpbWF0ZSB0aGUgY29vcmRpbmF0ZXMgZm9yIGEgcG9zaXRpb24uIFVzZWQgZm9yXG4gIC8vIGludGVybWVkaWF0ZSBzY3JvbGwgdXBkYXRlcy5cbiAgZnVuY3Rpb24gZXN0aW1hdGVDb29yZHMoY20sIHBvcykge1xuICAgIHZhciBsZWZ0ID0gMDtcbiAgICBwb3MgPSBjbGlwUG9zKGNtLmRvYywgcG9zKTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGxlZnQgPSBjaGFyV2lkdGgoY20uZGlzcGxheSkgKiBwb3MuY2g7IH1cbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoY20uZG9jLCBwb3MubGluZSk7XG4gICAgdmFyIHRvcCA9IGhlaWdodEF0TGluZShsaW5lT2JqKSArIHBhZGRpbmdUb3AoY20uZGlzcGxheSk7XG4gICAgcmV0dXJuIHtsZWZ0OiBsZWZ0LCByaWdodDogbGVmdCwgdG9wOiB0b3AsIGJvdHRvbTogdG9wICsgbGluZU9iai5oZWlnaHR9XG4gIH1cblxuICAvLyBQb3NpdGlvbnMgcmV0dXJuZWQgYnkgY29vcmRzQ2hhciBjb250YWluIHNvbWUgZXh0cmEgaW5mb3JtYXRpb24uXG4gIC8vIHhSZWwgaXMgdGhlIHJlbGF0aXZlIHggcG9zaXRpb24gb2YgdGhlIGlucHV0IGNvb3JkaW5hdGVzIGNvbXBhcmVkXG4gIC8vIHRvIHRoZSBmb3VuZCBwb3NpdGlvbiAoc28geFJlbCA+IDAgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGFyZSB0b1xuICAvLyB0aGUgcmlnaHQgb2YgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiwgZm9yIGV4YW1wbGUpLiBXaGVuIG91dHNpZGVcbiAgLy8gaXMgdHJ1ZSwgdGhhdCBtZWFucyB0aGUgY29vcmRpbmF0ZXMgbGllIG91dHNpZGUgdGhlIGxpbmUnc1xuICAvLyB2ZXJ0aWNhbCByYW5nZS5cbiAgZnVuY3Rpb24gUG9zV2l0aEluZm8obGluZSwgY2gsIHN0aWNreSwgb3V0c2lkZSwgeFJlbCkge1xuICAgIHZhciBwb3MgPSBQb3MobGluZSwgY2gsIHN0aWNreSk7XG4gICAgcG9zLnhSZWwgPSB4UmVsO1xuICAgIGlmIChvdXRzaWRlKSB7IHBvcy5vdXRzaWRlID0gb3V0c2lkZTsgfVxuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiBjbG9zZXN0IHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgLy8gSW5wdXQgbXVzdCBiZSBsaW5lU3BhY2UtbG9jYWwgKFwiZGl2XCIgY29vcmRpbmF0ZSBzeXN0ZW0pLlxuICBmdW5jdGlvbiBjb29yZHNDaGFyKGNtLCB4LCB5KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICB5ICs9IGNtLmRpc3BsYXkudmlld09mZnNldDtcbiAgICBpZiAoeSA8IDApIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCwgMCwgbnVsbCwgLTEsIC0xKSB9XG4gICAgdmFyIGxpbmVOID0gbGluZUF0SGVpZ2h0KGRvYywgeSksIGxhc3QgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDE7XG4gICAgaWYgKGxpbmVOID4gbGFzdClcbiAgICAgIHsgcmV0dXJuIFBvc1dpdGhJbmZvKGRvYy5maXJzdCArIGRvYy5zaXplIC0gMSwgZ2V0TGluZShkb2MsIGxhc3QpLnRleHQubGVuZ3RoLCBudWxsLCAxLCAxKSB9XG4gICAgaWYgKHggPCAwKSB7IHggPSAwOyB9XG5cbiAgICB2YXIgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTik7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGZvdW5kID0gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTiwgeCwgeSk7XG4gICAgICB2YXIgY29sbGFwc2VkID0gY29sbGFwc2VkU3BhbkFyb3VuZChsaW5lT2JqLCBmb3VuZC5jaCArIChmb3VuZC54UmVsID4gMCB8fCBmb3VuZC5vdXRzaWRlID4gMCA/IDEgOiAwKSk7XG4gICAgICBpZiAoIWNvbGxhcHNlZCkgeyByZXR1cm4gZm91bmQgfVxuICAgICAgdmFyIHJhbmdlRW5kID0gY29sbGFwc2VkLmZpbmQoMSk7XG4gICAgICBpZiAocmFuZ2VFbmQubGluZSA9PSBsaW5lTikgeyByZXR1cm4gcmFuZ2VFbmQgfVxuICAgICAgbGluZU9iaiA9IGdldExpbmUoZG9jLCBsaW5lTiA9IHJhbmdlRW5kLmxpbmUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHkpIHtcbiAgICB5IC09IHdpZGdldFRvcEhlaWdodChsaW5lT2JqKTtcbiAgICB2YXIgZW5kID0gbGluZU9iai50ZXh0Lmxlbmd0aDtcbiAgICB2YXIgYmVnaW4gPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7IHJldHVybiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoIC0gMSkuYm90dG9tIDw9IHk7IH0sIGVuZCwgMCk7XG4gICAgZW5kID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCkudG9wID4geTsgfSwgYmVnaW4sIGVuZCk7XG4gICAgcmV0dXJuIHtiZWdpbjogYmVnaW4sIGVuZDogZW5kfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZExpbmVFeHRlbnRDaGFyKGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldCkge1xuICAgIGlmICghcHJlcGFyZWRNZWFzdXJlKSB7IHByZXBhcmVkTWVhc3VyZSA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7IH1cbiAgICB2YXIgdGFyZ2V0VG9wID0gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldCksIFwibGluZVwiKS50b3A7XG4gICAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHRhcmdldFRvcClcbiAgfVxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gc2lkZSBvZiBhIGJveCBpcyBhZnRlciB0aGUgZ2l2ZW5cbiAgLy8gY29vcmRpbmF0ZXMsIGluIHRvcC10by1ib3R0b20sIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gIGZ1bmN0aW9uIGJveElzQWZ0ZXIoYm94LCB4LCB5LCBsZWZ0KSB7XG4gICAgcmV0dXJuIGJveC5ib3R0b20gPD0geSA/IGZhbHNlIDogYm94LnRvcCA+IHkgPyB0cnVlIDogKGxlZnQgPyBib3gubGVmdCA6IGJveC5yaWdodCkgPiB4XG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNDaGFySW5uZXIoY20sIGxpbmVPYmosIGxpbmVObywgeCwgeSkge1xuICAgIC8vIE1vdmUgeSBpbnRvIGxpbmUtbG9jYWwgY29vcmRpbmF0ZSBzcGFjZVxuICAgIHkgLT0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopO1xuICAgIHZhciBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgIC8vIFdoZW4gZGlyZWN0bHkgY2FsbGluZyBgbWVhc3VyZUNoYXJQcmVwYXJlZGAsIHdlIGhhdmUgdG8gYWRqdXN0XG4gICAgLy8gZm9yIHRoZSB3aWRnZXRzIGF0IHRoaXMgbGluZS5cbiAgICB2YXIgd2lkZ2V0SGVpZ2h0ID0gd2lkZ2V0VG9wSGVpZ2h0KGxpbmVPYmopO1xuICAgIHZhciBiZWdpbiA9IDAsIGVuZCA9IGxpbmVPYmoudGV4dC5sZW5ndGgsIGx0ciA9IHRydWU7XG5cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAvLyBJZiB0aGUgbGluZSBpc24ndCBwbGFpbiBsZWZ0LXRvLXJpZ2h0IHRleHQsIGZpcnN0IGZpZ3VyZSBvdXRcbiAgICAvLyB3aGljaCBiaWRpIHNlY3Rpb24gdGhlIGNvb3JkaW5hdGVzIGZhbGwgaW50by5cbiAgICBpZiAob3JkZXIpIHtcbiAgICAgIHZhciBwYXJ0ID0gKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nID8gY29vcmRzQmlkaVBhcnRXcmFwcGVkIDogY29vcmRzQmlkaVBhcnQpXG4gICAgICAgICAgICAgICAgICAgKGNtLCBsaW5lT2JqLCBsaW5lTm8sIHByZXBhcmVkTWVhc3VyZSwgb3JkZXIsIHgsIHkpO1xuICAgICAgbHRyID0gcGFydC5sZXZlbCAhPSAxO1xuICAgICAgLy8gVGhlIGF3a3dhcmQgLTEgb2Zmc2V0cyBhcmUgbmVlZGVkIGJlY2F1c2UgZmluZEZpcnN0IChjYWxsZWRcbiAgICAgIC8vIG9uIHRoZXNlIGJlbG93KSB3aWxsIHRyZWF0IGl0cyBmaXJzdCBib3VuZCBhcyBpbmNsdXNpdmUsXG4gICAgICAvLyBzZWNvbmQgYXMgZXhjbHVzaXZlLCBidXQgd2Ugd2FudCB0byBhY3R1YWxseSBhZGRyZXNzIHRoZVxuICAgICAgLy8gY2hhcmFjdGVycyBpbiB0aGUgcGFydCdzIHJhbmdlXG4gICAgICBiZWdpbiA9IGx0ciA/IHBhcnQuZnJvbSA6IHBhcnQudG8gLSAxO1xuICAgICAgZW5kID0gbHRyID8gcGFydC50byA6IHBhcnQuZnJvbSAtIDE7XG4gICAgfVxuXG4gICAgLy8gQSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGZpcnN0IGNoYXJhY3RlciB3aG9zZSBib3VuZGluZyBib3hcbiAgICAvLyBzdGFydHMgYWZ0ZXIgdGhlIGNvb3JkaW5hdGVzLiBJZiB3ZSBydW4gYWNyb3NzIGFueSB3aG9zZSBib3ggd3JhcFxuICAgIC8vIHRoZSBjb29yZGluYXRlcywgc3RvcmUgdGhhdC5cbiAgICB2YXIgY2hBcm91bmQgPSBudWxsLCBib3hBcm91bmQgPSBudWxsO1xuICAgIHZhciBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHZhciBib3ggPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoKTtcbiAgICAgIGJveC50b3AgKz0gd2lkZ2V0SGVpZ2h0OyBib3guYm90dG9tICs9IHdpZGdldEhlaWdodDtcbiAgICAgIGlmICghYm94SXNBZnRlcihib3gsIHgsIHksIGZhbHNlKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgaWYgKGJveC50b3AgPD0geSAmJiBib3gubGVmdCA8PSB4KSB7XG4gICAgICAgIGNoQXJvdW5kID0gY2g7XG4gICAgICAgIGJveEFyb3VuZCA9IGJveDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSwgYmVnaW4sIGVuZCk7XG5cbiAgICB2YXIgYmFzZVgsIHN0aWNreSwgb3V0c2lkZSA9IGZhbHNlO1xuICAgIC8vIElmIGEgYm94IGFyb3VuZCB0aGUgY29vcmRpbmF0ZXMgd2FzIGZvdW5kLCB1c2UgdGhhdFxuICAgIGlmIChib3hBcm91bmQpIHtcbiAgICAgIC8vIERpc3Rpbmd1aXNoIGNvb3JkaW5hdGVzIG5lYXJlciB0byB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBib3hcbiAgICAgIHZhciBhdExlZnQgPSB4IC0gYm94QXJvdW5kLmxlZnQgPCBib3hBcm91bmQucmlnaHQgLSB4LCBhdFN0YXJ0ID0gYXRMZWZ0ID09IGx0cjtcbiAgICAgIGNoID0gY2hBcm91bmQgKyAoYXRTdGFydCA/IDAgOiAxKTtcbiAgICAgIHN0aWNreSA9IGF0U3RhcnQgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgYmFzZVggPSBhdExlZnQgPyBib3hBcm91bmQubGVmdCA6IGJveEFyb3VuZC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gKEFkanVzdCBmb3IgZXh0ZW5kZWQgYm91bmQsIGlmIG5lY2Vzc2FyeS4pXG4gICAgICBpZiAoIWx0ciAmJiAoY2ggPT0gZW5kIHx8IGNoID09IGJlZ2luKSkgeyBjaCsrOyB9XG4gICAgICAvLyBUbyBkZXRlcm1pbmUgd2hpY2ggc2lkZSB0byBhc3NvY2lhdGUgd2l0aCwgZ2V0IHRoZSBib3ggdG8gdGhlXG4gICAgICAvLyBsZWZ0IG9mIHRoZSBjaGFyYWN0ZXIgYW5kIGNvbXBhcmUgaXQncyB2ZXJ0aWNhbCBwb3NpdGlvbiB0byB0aGVcbiAgICAgIC8vIGNvb3JkaW5hdGVzXG4gICAgICBzdGlja3kgPSBjaCA9PSAwID8gXCJhZnRlclwiIDogY2ggPT0gbGluZU9iai50ZXh0Lmxlbmd0aCA/IFwiYmVmb3JlXCIgOlxuICAgICAgICAobWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCAtIChsdHIgPyAxIDogMCkpLmJvdHRvbSArIHdpZGdldEhlaWdodCA8PSB5KSA9PSBsdHIgP1xuICAgICAgICBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgLy8gTm93IGdldCBhY2N1cmF0ZSBjb29yZGluYXRlcyBmb3IgdGhpcyBwbGFjZSwgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICAgIC8vIGJhc2UgWCBwb3NpdGlvblxuICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgY2gsIHN0aWNreSksIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpO1xuICAgICAgYmFzZVggPSBjb29yZHMubGVmdDtcbiAgICAgIG91dHNpZGUgPSB5IDwgY29vcmRzLnRvcCA/IC0xIDogeSA+PSBjb29yZHMuYm90dG9tID8gMSA6IDA7XG4gICAgfVxuXG4gICAgY2ggPSBza2lwRXh0ZW5kaW5nQ2hhcnMobGluZU9iai50ZXh0LCBjaCwgMSk7XG4gICAgcmV0dXJuIFBvc1dpdGhJbmZvKGxpbmVObywgY2gsIHN0aWNreSwgb3V0c2lkZSwgeCAtIGJhc2VYKVxuICB9XG5cbiAgZnVuY3Rpb24gY29vcmRzQmlkaVBhcnQoY20sIGxpbmVPYmosIGxpbmVObywgcHJlcGFyZWRNZWFzdXJlLCBvcmRlciwgeCwgeSkge1xuICAgIC8vIEJpZGkgcGFydHMgYXJlIHNvcnRlZCBsZWZ0LXRvLXJpZ2h0LCBhbmQgaW4gYSBub24tbGluZS13cmFwcGluZ1xuICAgIC8vIHNpdHVhdGlvbiwgd2UgY2FuIHRha2UgdGhpcyBvcmRlcmluZyB0byBjb3JyZXNwb25kIHRvIHRoZSB2aXN1YWxcbiAgICAvLyBvcmRlcmluZy4gVGhpcyBmaW5kcyB0aGUgZmlyc3QgcGFydCB3aG9zZSBlbmQgaXMgYWZ0ZXIgdGhlIGdpdmVuXG4gICAgLy8gY29vcmRpbmF0ZXMuXG4gICAgdmFyIGluZGV4ID0gZmluZEZpcnN0KGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW2ldLCBsdHIgPSBwYXJ0LmxldmVsICE9IDE7XG4gICAgICByZXR1cm4gYm94SXNBZnRlcihjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGx0ciA/IHBhcnQudG8gOiBwYXJ0LmZyb20sIGx0ciA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGluZVwiLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUpLCB4LCB5LCB0cnVlKVxuICAgIH0sIDAsIG9yZGVyLmxlbmd0aCAtIDEpO1xuICAgIHZhciBwYXJ0ID0gb3JkZXJbaW5kZXhdO1xuICAgIC8vIElmIHRoaXMgaXNuJ3QgdGhlIGZpcnN0IHBhcnQsIHRoZSBwYXJ0J3Mgc3RhcnQgaXMgYWxzbyBhZnRlclxuICAgIC8vIHRoZSBjb29yZGluYXRlcywgYW5kIHRoZSBjb29yZGluYXRlcyBhcmVuJ3Qgb24gdGhlIHNhbWUgbGluZSBhc1xuICAgIC8vIHRoYXQgc3RhcnQsIG1vdmUgb25lIHBhcnQgYmFjay5cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICB2YXIgbHRyID0gcGFydC5sZXZlbCAhPSAxO1xuICAgICAgdmFyIHN0YXJ0ID0gY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBsdHIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvLCBsdHIgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcbiAgICAgIGlmIChib3hJc0FmdGVyKHN0YXJ0LCB4LCB5LCB0cnVlKSAmJiBzdGFydC50b3AgPiB5KVxuICAgICAgICB7IHBhcnQgPSBvcmRlcltpbmRleCAtIDFdOyB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0XG4gIH1cblxuICBmdW5jdGlvbiBjb29yZHNCaWRpUGFydFdyYXBwZWQoY20sIGxpbmVPYmosIF9saW5lTm8sIHByZXBhcmVkTWVhc3VyZSwgb3JkZXIsIHgsIHkpIHtcbiAgICAvLyBJbiBhIHdyYXBwZWQgbGluZSwgcnRsIHRleHQgb24gd3JhcHBpbmcgYm91bmRhcmllcyBjYW4gZG8gdGhpbmdzXG4gICAgLy8gdGhhdCBkb24ndCBjb3JyZXNwb25kIHRvIHRoZSBvcmRlcmluZyBpbiBvdXIgYG9yZGVyYCBhcnJheSBhdFxuICAgIC8vIGFsbCwgc28gYSBiaW5hcnkgc2VhcmNoIGRvZXNuJ3Qgd29yaywgYW5kIHdlIHdhbnQgdG8gcmV0dXJuIGFcbiAgICAvLyBwYXJ0IHRoYXQgb25seSBzcGFucyBvbmUgbGluZSBzbyB0aGF0IHRoZSBiaW5hcnkgc2VhcmNoIGluXG4gICAgLy8gY29vcmRzQ2hhcklubmVyIGlzIHNhZmUuIEFzIHN1Y2gsIHdlIGZpcnN0IGZpbmQgdGhlIGV4dGVudCBvZiB0aGVcbiAgICAvLyB3cmFwcGVkIGxpbmUsIGFuZCB0aGVuIGRvIGEgZmxhdCBzZWFyY2ggaW4gd2hpY2ggd2UgZGlzY2FyZCBhbnlcbiAgICAvLyBzcGFucyB0aGF0IGFyZW4ndCBvbiB0aGUgbGluZS5cbiAgICB2YXIgcmVmID0gd3JhcHBlZExpbmVFeHRlbnQoY20sIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgeSk7XG4gICAgdmFyIGJlZ2luID0gcmVmLmJlZ2luO1xuICAgIHZhciBlbmQgPSByZWYuZW5kO1xuICAgIGlmICgvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoZW5kIC0gMSkpKSB7IGVuZC0tOyB9XG4gICAgdmFyIHBhcnQgPSBudWxsLCBjbG9zZXN0RGlzdCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBvcmRlcltpXTtcbiAgICAgIGlmIChwLmZyb20gPj0gZW5kIHx8IHAudG8gPD0gYmVnaW4pIHsgY29udGludWUgfVxuICAgICAgdmFyIGx0ciA9IHAubGV2ZWwgIT0gMTtcbiAgICAgIHZhciBlbmRYID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBsdHIgPyBNYXRoLm1pbihlbmQsIHAudG8pIC0gMSA6IE1hdGgubWF4KGJlZ2luLCBwLmZyb20pKS5yaWdodDtcbiAgICAgIC8vIFdlaWdoIGFnYWluc3Qgc3BhbnMgZW5kaW5nIGJlZm9yZSB0aGlzLCBzbyB0aGF0IHRoZXkgYXJlIG9ubHlcbiAgICAgIC8vIHBpY2tlZCBpZiBub3RoaW5nIGVuZHMgYWZ0ZXJcbiAgICAgIHZhciBkaXN0ID0gZW5kWCA8IHggPyB4IC0gZW5kWCArIDFlOSA6IGVuZFggLSB4O1xuICAgICAgaWYgKCFwYXJ0IHx8IGNsb3Nlc3REaXN0ID4gZGlzdCkge1xuICAgICAgICBwYXJ0ID0gcDtcbiAgICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXBhcnQpIHsgcGFydCA9IG9yZGVyW29yZGVyLmxlbmd0aCAtIDFdOyB9XG4gICAgLy8gQ2xpcCB0aGUgcGFydCB0byB0aGUgd3JhcHBlZCBsaW5lLlxuICAgIGlmIChwYXJ0LmZyb20gPCBiZWdpbikgeyBwYXJ0ID0ge2Zyb206IGJlZ2luLCB0bzogcGFydC50bywgbGV2ZWw6IHBhcnQubGV2ZWx9OyB9XG4gICAgaWYgKHBhcnQudG8gPiBlbmQpIHsgcGFydCA9IHtmcm9tOiBwYXJ0LmZyb20sIHRvOiBlbmQsIGxldmVsOiBwYXJ0LmxldmVsfTsgfVxuICAgIHJldHVybiBwYXJ0XG4gIH1cblxuICB2YXIgbWVhc3VyZVRleHQ7XG4gIC8vIENvbXB1dGUgdGhlIGRlZmF1bHQgdGV4dCBoZWlnaHQuXG4gIGZ1bmN0aW9uIHRleHRIZWlnaHQoZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgIT0gbnVsbCkgeyByZXR1cm4gZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0IH1cbiAgICBpZiAobWVhc3VyZVRleHQgPT0gbnVsbCkge1xuICAgICAgbWVhc3VyZVRleHQgPSBlbHQoXCJwcmVcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtcbiAgICAgIC8vIE1lYXN1cmUgYSBidW5jaCBvZiBsaW5lcywgZm9yIGJyb3dzZXJzIHRoYXQgY29tcHV0ZVxuICAgICAgLy8gZnJhY3Rpb25hbCBoZWlnaHRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OTsgKytpKSB7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGVsdChcImJyXCIpKTtcbiAgICAgIH1cbiAgICAgIG1lYXN1cmVUZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwieFwiKSk7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgbWVhc3VyZVRleHQpO1xuICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlVGV4dC5vZmZzZXRIZWlnaHQgLyA1MDtcbiAgICBpZiAoaGVpZ2h0ID4gMykgeyBkaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQgPSBoZWlnaHQ7IH1cbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5Lm1lYXN1cmUpO1xuICAgIHJldHVybiBoZWlnaHQgfHwgMVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgd2lkdGguXG4gIGZ1bmN0aW9uIGNoYXJXaWR0aChkaXNwbGF5KSB7XG4gICAgaWYgKGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkQ2hhcldpZHRoIH1cbiAgICB2YXIgYW5jaG9yID0gZWx0KFwic3BhblwiLCBcInh4eHh4eHh4eHhcIik7XG4gICAgdmFyIHByZSA9IGVsdChcInByZVwiLCBbYW5jaG9yXSwgXCJDb2RlTWlycm9yLWxpbmUtbGlrZVwiKTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIHByZSk7XG4gICAgdmFyIHJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gKHJlY3QucmlnaHQgLSByZWN0LmxlZnQpIC8gMTA7XG4gICAgaWYgKHdpZHRoID4gMikgeyBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IHdpZHRoOyB9XG4gICAgcmV0dXJuIHdpZHRoIHx8IDEwXG4gIH1cblxuICAvLyBEbyBhIGJ1bGstcmVhZCBvZiB0aGUgRE9NIHBvc2l0aW9ucyBhbmQgc2l6ZXMgbmVlZGVkIHRvIGRyYXcgdGhlXG4gIC8vIHZpZXcsIHNvIHRoYXQgd2UgZG9uJ3QgaW50ZXJsZWF2ZSByZWFkaW5nIGFuZCB3cml0aW5nIHRvIHRoZSBET00uXG4gIGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXksIGxlZnQgPSB7fSwgd2lkdGggPSB7fTtcbiAgICB2YXIgZ3V0dGVyTGVmdCA9IGQuZ3V0dGVycy5jbGllbnRMZWZ0O1xuICAgIGZvciAodmFyIG4gPSBkLmd1dHRlcnMuZmlyc3RDaGlsZCwgaSA9IDA7IG47IG4gPSBuLm5leHRTaWJsaW5nLCArK2kpIHtcbiAgICAgIHZhciBpZCA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3NbaV0uY2xhc3NOYW1lO1xuICAgICAgbGVmdFtpZF0gPSBuLm9mZnNldExlZnQgKyBuLmNsaWVudExlZnQgKyBndXR0ZXJMZWZ0O1xuICAgICAgd2lkdGhbaWRdID0gbi5jbGllbnRXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHtmaXhlZFBvczogY29tcGVuc2F0ZUZvckhTY3JvbGwoZCksXG4gICAgICAgICAgICBndXR0ZXJUb3RhbFdpZHRoOiBkLmd1dHRlcnMub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBndXR0ZXJMZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgZ3V0dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgd3JhcHBlcldpZHRoOiBkLndyYXBwZXIuY2xpZW50V2lkdGh9XG4gIH1cblxuICAvLyBDb21wdXRlcyBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsXG4gIC8vIGJ1dCB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdG8gZ2V0IGEgc3ViLXBpeGVsLWFjY3VyYXRlXG4gIC8vIHJlc3VsdC5cbiAgZnVuY3Rpb24gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkge1xuICAgIHJldHVybiBkaXNwbGF5LnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBkaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnRcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGVzdGltYXRlcyB0aGUgaGVpZ2h0IG9mIGEgbGluZSwgdG8gdXNlIGFzXG4gIC8vIGZpcnN0IGFwcHJveGltYXRpb24gdW50aWwgdGhlIGxpbmUgYmVjb21lcyB2aXNpYmxlIChhbmQgaXMgdGh1c1xuICAvLyBwcm9wZXJseSBtZWFzdXJhYmxlKS5cbiAgZnVuY3Rpb24gZXN0aW1hdGVIZWlnaHQoY20pIHtcbiAgICB2YXIgdGggPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgIHZhciBwZXJMaW5lID0gd3JhcHBpbmcgJiYgTWF0aC5tYXgoNSwgY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSAtIDMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihjbS5kb2MsIGxpbmUpKSB7IHJldHVybiAwIH1cblxuICAgICAgdmFyIHdpZGdldHNIZWlnaHQgPSAwO1xuICAgICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZS53aWRnZXRzW2ldLmhlaWdodCkgeyB3aWRnZXRzSGVpZ2h0ICs9IGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQ7IH1cbiAgICAgIH0gfVxuXG4gICAgICBpZiAod3JhcHBpbmcpXG4gICAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyAoTWF0aC5jZWlsKGxpbmUudGV4dC5sZW5ndGggLyBwZXJMaW5lKSB8fCAxKSAqIHRoIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyByZXR1cm4gd2lkZ2V0c0hlaWdodCArIHRoIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZXN0ID0gZXN0aW1hdGVIZWlnaHQoY20pO1xuICAgIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0KGxpbmUpO1xuICAgICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCk7IH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIEdpdmVuIGEgbW91c2UgZXZlbnQsIGZpbmQgdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24uIElmIGxpYmVyYWxcbiAgLy8gaXMgZmFsc2UsIGl0IGNoZWNrcyB3aGV0aGVyIGEgZ3V0dGVyIG9yIHNjcm9sbGJhciB3YXMgY2xpY2tlZCxcbiAgLy8gYW5kIHJldHVybnMgbnVsbCBpZiBpdCB3YXMuIGZvclJlY3QgaXMgdXNlZCBieSByZWN0YW5ndWxhclxuICAvLyBzZWxlY3Rpb25zLCBhbmQgdHJpZXMgdG8gZXN0aW1hdGUgYSBjaGFyYWN0ZXIgcG9zaXRpb24gZXZlbiBmb3JcbiAgLy8gY29vcmRpbmF0ZXMgYmV5b25kIHRoZSByaWdodCBvZiB0aGUgdGV4dC5cbiAgZnVuY3Rpb24gcG9zRnJvbU1vdXNlKGNtLCBlLCBsaWJlcmFsLCBmb3JSZWN0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmICghbGliZXJhbCAmJiBlX3RhcmdldChlKS5nZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiKSA9PSBcInRydWVcIikgeyByZXR1cm4gbnVsbCB9XG5cbiAgICB2YXIgeCwgeSwgc3BhY2UgPSBkaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBGYWlscyB1bnByZWRpY3RhYmx5IG9uIElFWzY3XSB3aGVuIG1vdXNlIGlzIGRyYWdnZWQgYXJvdW5kIHF1aWNrbHkuXG4gICAgdHJ5IHsgeCA9IGUuY2xpZW50WCAtIHNwYWNlLmxlZnQ7IHkgPSBlLmNsaWVudFkgLSBzcGFjZS50b3A7IH1cbiAgICBjYXRjaCAoZSQxKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY29vcmRzID0gY29vcmRzQ2hhcihjbSwgeCwgeSksIGxpbmU7XG4gICAgaWYgKGZvclJlY3QgJiYgY29vcmRzLnhSZWwgPiAwICYmIChsaW5lID0gZ2V0TGluZShjbS5kb2MsIGNvb3Jkcy5saW5lKS50ZXh0KS5sZW5ndGggPT0gY29vcmRzLmNoKSB7XG4gICAgICB2YXIgY29sRGlmZiA9IGNvdW50Q29sdW1uKGxpbmUsIGxpbmUubGVuZ3RoLCBjbS5vcHRpb25zLnRhYlNpemUpIC0gbGluZS5sZW5ndGg7XG4gICAgICBjb29yZHMgPSBQb3MoY29vcmRzLmxpbmUsIE1hdGgubWF4KDAsIE1hdGgucm91bmQoKHggLSBwYWRkaW5nSChjbS5kaXNwbGF5KS5sZWZ0KSAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSkgLSBjb2xEaWZmKSk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZHNcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHZpZXcgZWxlbWVudCBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gbGluZS4gUmV0dXJuIG51bGxcbiAgLy8gd2hlbiB0aGUgbGluZSBpc24ndCB2aXNpYmxlLlxuICBmdW5jdGlvbiBmaW5kVmlld0luZGV4KGNtLCBuKSB7XG4gICAgaWYgKG4gPj0gY20uZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIG51bGwgfVxuICAgIG4gLT0gY20uZGlzcGxheS52aWV3RnJvbTtcbiAgICBpZiAobiA8IDApIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgbiAtPSB2aWV3W2ldLnNpemU7XG4gICAgICBpZiAobiA8IDApIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZXMgdGhlIGRpc3BsYXkudmlldyBkYXRhIHN0cnVjdHVyZSBmb3IgYSBnaXZlbiBjaGFuZ2UgdG8gdGhlXG4gIC8vIGRvY3VtZW50LiBGcm9tIGFuZCB0byBhcmUgaW4gcHJlLWNoYW5nZSBjb29yZGluYXRlcy4gTGVuZGlmZiBpc1xuICAvLyB0aGUgYW1vdW50IG9mIGxpbmVzIGFkZGVkIG9yIHN1YnRyYWN0ZWQgYnkgdGhlIGNoYW5nZS4gVGhpcyBpc1xuICAvLyB1c2VkIGZvciBjaGFuZ2VzIHRoYXQgc3BhbiBtdWx0aXBsZSBsaW5lcywgb3IgY2hhbmdlIHRoZSB3YXlcbiAgLy8gbGluZXMgYXJlIGRpdmlkZWQgaW50byB2aXN1YWwgbGluZXMuIHJlZ0xpbmVDaGFuZ2UgKGJlbG93KVxuICAvLyByZWdpc3RlcnMgc2luZ2xlLWxpbmUgY2hhbmdlcy5cbiAgZnVuY3Rpb24gcmVnQ2hhbmdlKGNtLCBmcm9tLCB0bywgbGVuZGlmZikge1xuICAgIGlmIChmcm9tID09IG51bGwpIHsgZnJvbSA9IGNtLmRvYy5maXJzdDsgfVxuICAgIGlmICh0byA9PSBudWxsKSB7IHRvID0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemU7IH1cbiAgICBpZiAoIWxlbmRpZmYpIHsgbGVuZGlmZiA9IDA7IH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAobGVuZGlmZiAmJiB0byA8IGRpc3BsYXkudmlld1RvICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+IGZyb20pKVxuICAgICAgeyBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gZnJvbTsgfVxuXG4gICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xuXG4gICAgaWYgKGZyb20gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQ2hhbmdlIGFmdGVyXG4gICAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSkgPCBkaXNwbGF5LnZpZXdUbylcbiAgICAgICAgeyByZXNldFZpZXcoY20pOyB9XG4gICAgfSBlbHNlIGlmICh0byA8PSBkaXNwbGF5LnZpZXdGcm9tKSB7IC8vIENoYW5nZSBiZWZvcmVcbiAgICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucyAmJiB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byArIGxlbmRpZmYpID4gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSArPSBsZW5kaWZmO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZnJvbSA8PSBkaXNwbGF5LnZpZXdGcm9tICYmIHRvID49IGRpc3BsYXkudmlld1RvKSB7IC8vIEZ1bGwgb3ZlcmxhcFxuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBUb3Agb3ZlcmxhcFxuICAgICAgdmFyIGN1dCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xuICAgICAgaWYgKGN1dCkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoY3V0LmluZGV4KTtcbiAgICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGN1dC5saW5lTjtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBCb3R0b20gb3ZlcmxhcFxuICAgICAgdmFyIGN1dCQxID0gdmlld0N1dHRpbmdQb2ludChjbSwgZnJvbSwgZnJvbSwgLTEpO1xuICAgICAgaWYgKGN1dCQxKSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXQkMS5pbmRleCk7XG4gICAgICAgIGRpc3BsYXkudmlld1RvID0gY3V0JDEubGluZU47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIEdhcCBpbiB0aGUgbWlkZGxlXG4gICAgICB2YXIgY3V0VG9wID0gdmlld0N1dHRpbmdQb2ludChjbSwgZnJvbSwgZnJvbSwgLTEpO1xuICAgICAgdmFyIGN1dEJvdCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIHRvLCB0byArIGxlbmRpZmYsIDEpO1xuICAgICAgaWYgKGN1dFRvcCAmJiBjdXRCb3QpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKDAsIGN1dFRvcC5pbmRleClcbiAgICAgICAgICAuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLCBjdXRUb3AubGluZU4sIGN1dEJvdC5saW5lTikpXG4gICAgICAgICAgLmNvbmNhdChkaXNwbGF5LnZpZXcuc2xpY2UoY3V0Qm90LmluZGV4KSk7XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBleHQgPSBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCkge1xuICAgICAgaWYgKHRvIDwgZXh0LmxpbmVOKVxuICAgICAgICB7IGV4dC5saW5lTiArPSBsZW5kaWZmOyB9XG4gICAgICBlbHNlIGlmIChmcm9tIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICAgIHsgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIHRvIGEgc2luZ2xlIGxpbmUuIFR5cGUgbXVzdCBiZSBvbmUgb2YgXCJ0ZXh0XCIsXG4gIC8vIFwiZ3V0dGVyXCIsIFwiY2xhc3NcIiwgXCJ3aWRnZXRcIlxuICBmdW5jdGlvbiByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lLCB0eXBlKSB7XG4gICAgY20uY3VyT3Audmlld0NoYW5nZWQgPSB0cnVlO1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgbGluZSA+PSBleHQubGluZU4gJiYgbGluZSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgeyBkaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsOyB9XG5cbiAgICBpZiAobGluZSA8IGRpc3BsYXkudmlld0Zyb20gfHwgbGluZSA+PSBkaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gfVxuICAgIHZhciBsaW5lVmlldyA9IGRpc3BsYXkudmlld1tmaW5kVmlld0luZGV4KGNtLCBsaW5lKV07XG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHZhciBhcnIgPSBsaW5lVmlldy5jaGFuZ2VzIHx8IChsaW5lVmlldy5jaGFuZ2VzID0gW10pO1xuICAgIGlmIChpbmRleE9mKGFyciwgdHlwZSkgPT0gLTEpIHsgYXJyLnB1c2godHlwZSk7IH1cbiAgfVxuXG4gIC8vIENsZWFyIHRoZSB2aWV3LlxuICBmdW5jdGlvbiByZXNldFZpZXcoY20pIHtcbiAgICBjbS5kaXNwbGF5LnZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3VG8gPSBjbS5kb2MuZmlyc3Q7XG4gICAgY20uZGlzcGxheS52aWV3ID0gW107XG4gICAgY20uZGlzcGxheS52aWV3T2Zmc2V0ID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZpZXdDdXR0aW5nUG9pbnQoY20sIG9sZE4sIG5ld04sIGRpcikge1xuICAgIHZhciBpbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIG9sZE4pLCBkaWZmLCB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIGlmICghc2F3Q29sbGFwc2VkU3BhbnMgfHwgbmV3TiA9PSBjbS5kb2MuZmlyc3QgKyBjbS5kb2Muc2l6ZSlcbiAgICAgIHsgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfSB9XG4gICAgdmFyIG4gPSBjbS5kaXNwbGF5LnZpZXdGcm9tO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgIHsgbiArPSB2aWV3W2ldLnNpemU7IH1cbiAgICBpZiAobiAhPSBvbGROKSB7XG4gICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICBpZiAoaW5kZXggPT0gdmlldy5sZW5ndGggLSAxKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgZGlmZiA9IChuICsgdmlld1tpbmRleF0uc2l6ZSkgLSBvbGROO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZiA9IG4gLSBvbGROO1xuICAgICAgfVxuICAgICAgb2xkTiArPSBkaWZmOyBuZXdOICs9IGRpZmY7XG4gICAgfVxuICAgIHdoaWxlICh2aXN1YWxMaW5lTm8oY20uZG9jLCBuZXdOKSAhPSBuZXdOKSB7XG4gICAgICBpZiAoaW5kZXggPT0gKGRpciA8IDAgPyAwIDogdmlldy5sZW5ndGggLSAxKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBuZXdOICs9IGRpciAqIHZpZXdbaW5kZXggLSAoZGlyIDwgMCA/IDEgOiAwKV0uc2l6ZTtcbiAgICAgIGluZGV4ICs9IGRpcjtcbiAgICB9XG4gICAgcmV0dXJuIHtpbmRleDogaW5kZXgsIGxpbmVOOiBuZXdOfVxuICB9XG5cbiAgLy8gRm9yY2UgdGhlIHZpZXcgdG8gY292ZXIgYSBnaXZlbiByYW5nZSwgYWRkaW5nIGVtcHR5IHZpZXcgZWxlbWVudFxuICAvLyBvciBjbGlwcGluZyBvZmYgZXhpc3Rpbmcgb25lcyBhcyBuZWVkZWQuXG4gIGZ1bmN0aW9uIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICh2aWV3Lmxlbmd0aCA9PSAwIHx8IGZyb20gPj0gZGlzcGxheS52aWV3VG8gfHwgdG8gPD0gZGlzcGxheS52aWV3RnJvbSkge1xuICAgICAgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKTtcbiAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBmcm9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA+IGZyb20pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIGRpc3BsYXkudmlld0Zyb20pLmNvbmNhdChkaXNwbGF5LnZpZXcpOyB9XG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdGcm9tIDwgZnJvbSlcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoZmluZFZpZXdJbmRleChjbSwgZnJvbSkpOyB9XG4gICAgICBkaXNwbGF5LnZpZXdGcm9tID0gZnJvbTtcbiAgICAgIGlmIChkaXNwbGF5LnZpZXdUbyA8IHRvKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5jb25jYXQoYnVpbGRWaWV3QXJyYXkoY20sIGRpc3BsYXkudmlld1RvLCB0bykpOyB9XG4gICAgICBlbHNlIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBmaW5kVmlld0luZGV4KGNtLCB0bykpOyB9XG4gICAgfVxuICAgIGRpc3BsYXkudmlld1RvID0gdG87XG4gIH1cblxuICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSB2aWV3IHdob3NlIERPTSByZXByZXNlbnRhdGlvbiBpc1xuICAvLyBvdXQgb2YgZGF0ZSAob3Igbm9uZXhpc3RlbnQpLlxuICBmdW5jdGlvbiBjb3VudERpcnR5VmlldyhjbSkge1xuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3LCBkaXJ0eSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xuICAgICAgaWYgKCFsaW5lVmlldy5oaWRkZW4gJiYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3LmNoYW5nZXMpKSB7ICsrZGlydHk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGRpcnR5XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3Rpb24oY20pIHtcbiAgICBjbS5kaXNwbGF5LmlucHV0LnNob3dTZWxlY3Rpb24oY20uZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdGlvbihjbSwgcHJpbWFyeSkge1xuICAgIGlmICggcHJpbWFyeSA9PT0gdm9pZCAwICkgcHJpbWFyeSA9IHRydWU7XG5cbiAgICB2YXIgZG9jID0gY20uZG9jLCByZXN1bHQgPSB7fTtcbiAgICB2YXIgY3VyRnJhZ21lbnQgPSByZXN1bHQuY3Vyc29ycyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgc2VsRnJhZ21lbnQgPSByZXN1bHQuc2VsZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcmltYXJ5ICYmIGkgPT0gZG9jLnNlbC5wcmltSW5kZXgpIHsgY29udGludWUgfVxuICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2UuZnJvbSgpLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgcmFuZ2UudG8oKS5saW5lIDwgY20uZGlzcGxheS52aWV3RnJvbSkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgY29sbGFwc2VkID0gcmFuZ2UuZW1wdHkoKTtcbiAgICAgIGlmIChjb2xsYXBzZWQgfHwgY20ub3B0aW9ucy5zaG93Q3Vyc29yV2hlblNlbGVjdGluZylcbiAgICAgICAgeyBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCByYW5nZS5oZWFkLCBjdXJGcmFnbWVudCk7IH1cbiAgICAgIGlmICghY29sbGFwc2VkKVxuICAgICAgICB7IGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIHNlbEZyYWdtZW50KTsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBEcmF3cyBhIGN1cnNvciBmb3IgdGhlIGdpdmVuIHJhbmdlXG4gIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIGhlYWQsIG91dHB1dCkge1xuICAgIHZhciBwb3MgPSBjdXJzb3JDb29yZHMoY20sIGhlYWQsIFwiZGl2XCIsIG51bGwsIG51bGwsICFjbS5vcHRpb25zLnNpbmdsZUN1cnNvckhlaWdodFBlckxpbmUpO1xuXG4gICAgdmFyIGN1cnNvciA9IG91dHB1dC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgXCJcXHUwMGEwXCIsIFwiQ29kZU1pcnJvci1jdXJzb3JcIikpO1xuICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyBcInB4XCI7XG4gICAgY3Vyc29yLnN0eWxlLnRvcCA9IHBvcy50b3AgKyBcInB4XCI7XG4gICAgY3Vyc29yLnN0eWxlLmhlaWdodCA9IE1hdGgubWF4KDAsIHBvcy5ib3R0b20gLSBwb3MudG9wKSAqIGNtLm9wdGlvbnMuY3Vyc29ySGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgaWYgKHBvcy5vdGhlcikge1xuICAgICAgLy8gU2Vjb25kYXJ5IGN1cnNvciwgc2hvd24gd2hlbiBvbiBhICdqdW1wJyBpbiBiaS1kaXJlY3Rpb25hbCB0ZXh0XG4gICAgICB2YXIgb3RoZXJDdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx1MDBhMFwiLCBcIkNvZGVNaXJyb3ItY3Vyc29yIENvZGVNaXJyb3Itc2Vjb25kYXJ5Y3Vyc29yXCIpKTtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5vdGhlci5sZWZ0ICsgXCJweFwiO1xuICAgICAgb3RoZXJDdXJzb3Iuc3R5bGUudG9wID0gcG9zLm90aGVyLnRvcCArIFwicHhcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmhlaWdodCA9IChwb3Mub3RoZXIuYm90dG9tIC0gcG9zLm90aGVyLnRvcCkgKiAuODUgKyBcInB4XCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY21wQ29vcmRzKGEsIGIpIHsgcmV0dXJuIGEudG9wIC0gYi50b3AgfHwgYS5sZWZ0IC0gYi5sZWZ0IH1cblxuICAvLyBEcmF3cyB0aGUgZ2l2ZW4gcmFuZ2UgYXMgYSBoaWdobGlnaHRlZCBzZWxlY3Rpb25cbiAgZnVuY3Rpb24gZHJhd1NlbGVjdGlvblJhbmdlKGNtLCByYW5nZSwgb3V0cHV0KSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIHZhciBwYWRkaW5nID0gcGFkZGluZ0goY20uZGlzcGxheSksIGxlZnRTaWRlID0gcGFkZGluZy5sZWZ0O1xuICAgIHZhciByaWdodFNpZGUgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyV2lkdGgsIGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQpIC0gcGFkZGluZy5yaWdodDtcbiAgICB2YXIgZG9jTFRSID0gZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiO1xuXG4gICAgZnVuY3Rpb24gYWRkKGxlZnQsIHRvcCwgd2lkdGgsIGJvdHRvbSkge1xuICAgICAgaWYgKHRvcCA8IDApIHsgdG9wID0gMDsgfVxuICAgICAgdG9wID0gTWF0aC5yb3VuZCh0b3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5yb3VuZChib3R0b20pO1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zZWxlY3RlZFwiLCAoXCJwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IFwiICsgbGVmdCArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgdG9wICsgXCJweDsgd2lkdGg6IFwiICsgKHdpZHRoID09IG51bGwgPyByaWdodFNpZGUgLSBsZWZ0IDogd2lkdGgpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogXCIgKyAoYm90dG9tIC0gdG9wKSArIFwicHhcIikpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkcmF3Rm9yTGluZShsaW5lLCBmcm9tQXJnLCB0b0FyZykge1xuICAgICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZSk7XG4gICAgICB2YXIgbGluZUxlbiA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgICB2YXIgc3RhcnQsIGVuZDtcbiAgICAgIGZ1bmN0aW9uIGNvb3JkcyhjaCwgYmlhcykge1xuICAgICAgICByZXR1cm4gY2hhckNvb3JkcyhjbSwgUG9zKGxpbmUsIGNoKSwgXCJkaXZcIiwgbGluZU9iaiwgYmlhcylcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd3JhcFgocG9zLCBkaXIsIHNpZGUpIHtcbiAgICAgICAgdmFyIGV4dGVudCA9IHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZU9iaiwgbnVsbCwgcG9zKTtcbiAgICAgICAgdmFyIHByb3AgPSAoZGlyID09IFwibHRyXCIpID09IChzaWRlID09IFwiYWZ0ZXJcIikgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcbiAgICAgICAgdmFyIGNoID0gc2lkZSA9PSBcImFmdGVyXCIgPyBleHRlbnQuYmVnaW4gOiBleHRlbnQuZW5kIC0gKC9cXHMvLnRlc3QobGluZU9iai50ZXh0LmNoYXJBdChleHRlbnQuZW5kIC0gMSkpID8gMiA6IDEpO1xuICAgICAgICByZXR1cm4gY29vcmRzKGNoLCBwcm9wKVtwcm9wXVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBkb2MuZGlyZWN0aW9uKTtcbiAgICAgIGl0ZXJhdGVCaWRpU2VjdGlvbnMob3JkZXIsIGZyb21BcmcgfHwgMCwgdG9BcmcgPT0gbnVsbCA/IGxpbmVMZW4gOiB0b0FyZywgZnVuY3Rpb24gKGZyb20sIHRvLCBkaXIsIGkpIHtcbiAgICAgICAgdmFyIGx0ciA9IGRpciA9PSBcImx0clwiO1xuICAgICAgICB2YXIgZnJvbVBvcyA9IGNvb3Jkcyhmcm9tLCBsdHIgPyBcImxlZnRcIiA6IFwicmlnaHRcIik7XG4gICAgICAgIHZhciB0b1BvcyA9IGNvb3Jkcyh0byAtIDEsIGx0ciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKTtcblxuICAgICAgICB2YXIgb3BlblN0YXJ0ID0gZnJvbUFyZyA9PSBudWxsICYmIGZyb20gPT0gMCwgb3BlbkVuZCA9IHRvQXJnID09IG51bGwgJiYgdG8gPT0gbGluZUxlbjtcbiAgICAgICAgdmFyIGZpcnN0ID0gaSA9PSAwLCBsYXN0ID0gIW9yZGVyIHx8IGkgPT0gb3JkZXIubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRvUG9zLnRvcCAtIGZyb21Qb3MudG9wIDw9IDMpIHsgLy8gU2luZ2xlIGxpbmVcbiAgICAgICAgICB2YXIgb3BlbkxlZnQgPSAoZG9jTFRSID8gb3BlblN0YXJ0IDogb3BlbkVuZCkgJiYgZmlyc3Q7XG4gICAgICAgICAgdmFyIG9wZW5SaWdodCA9IChkb2NMVFIgPyBvcGVuRW5kIDogb3BlblN0YXJ0KSAmJiBsYXN0O1xuICAgICAgICAgIHZhciBsZWZ0ID0gb3BlbkxlZnQgPyBsZWZ0U2lkZSA6IChsdHIgPyBmcm9tUG9zIDogdG9Qb3MpLmxlZnQ7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gb3BlblJpZ2h0ID8gcmlnaHRTaWRlIDogKGx0ciA/IHRvUG9zIDogZnJvbVBvcykucmlnaHQ7XG4gICAgICAgICAgYWRkKGxlZnQsIGZyb21Qb3MudG9wLCByaWdodCAtIGxlZnQsIGZyb21Qb3MuYm90dG9tKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gTXVsdGlwbGUgbGluZXNcbiAgICAgICAgICB2YXIgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdExlZnQsIGJvdFJpZ2h0O1xuICAgICAgICAgIGlmIChsdHIpIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSBkb2NMVFIgJiYgb3BlblN0YXJ0ICYmIGZpcnN0ID8gbGVmdFNpZGUgOiBmcm9tUG9zLmxlZnQ7XG4gICAgICAgICAgICB0b3BSaWdodCA9IGRvY0xUUiA/IHJpZ2h0U2lkZSA6IHdyYXBYKGZyb20sIGRpciwgXCJiZWZvcmVcIik7XG4gICAgICAgICAgICBib3RMZWZ0ID0gZG9jTFRSID8gbGVmdFNpZGUgOiB3cmFwWCh0bywgZGlyLCBcImFmdGVyXCIpO1xuICAgICAgICAgICAgYm90UmlnaHQgPSBkb2NMVFIgJiYgb3BlbkVuZCAmJiBsYXN0ID8gcmlnaHRTaWRlIDogdG9Qb3MucmlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcExlZnQgPSAhZG9jTFRSID8gbGVmdFNpZGUgOiB3cmFwWChmcm9tLCBkaXIsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgdG9wUmlnaHQgPSAhZG9jTFRSICYmIG9wZW5TdGFydCAmJiBmaXJzdCA/IHJpZ2h0U2lkZSA6IGZyb21Qb3MucmlnaHQ7XG4gICAgICAgICAgICBib3RMZWZ0ID0gIWRvY0xUUiAmJiBvcGVuRW5kICYmIGxhc3QgPyBsZWZ0U2lkZSA6IHRvUG9zLmxlZnQ7XG4gICAgICAgICAgICBib3RSaWdodCA9ICFkb2NMVFIgPyByaWdodFNpZGUgOiB3cmFwWCh0bywgZGlyLCBcImFmdGVyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGQodG9wTGVmdCwgZnJvbVBvcy50b3AsIHRvcFJpZ2h0IC0gdG9wTGVmdCwgZnJvbVBvcy5ib3R0b20pO1xuICAgICAgICAgIGlmIChmcm9tUG9zLmJvdHRvbSA8IHRvUG9zLnRvcCkgeyBhZGQobGVmdFNpZGUsIGZyb21Qb3MuYm90dG9tLCBudWxsLCB0b1Bvcy50b3ApOyB9XG4gICAgICAgICAgYWRkKGJvdExlZnQsIHRvUG9zLnRvcCwgYm90UmlnaHQgLSBib3RMZWZ0LCB0b1Bvcy5ib3R0b20pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzdGFydCB8fCBjbXBDb29yZHMoZnJvbVBvcywgc3RhcnQpIDwgMCkgeyBzdGFydCA9IGZyb21Qb3M7IH1cbiAgICAgICAgaWYgKGNtcENvb3Jkcyh0b1Bvcywgc3RhcnQpIDwgMCkgeyBzdGFydCA9IHRvUG9zOyB9XG4gICAgICAgIGlmICghZW5kIHx8IGNtcENvb3Jkcyhmcm9tUG9zLCBlbmQpIDwgMCkgeyBlbmQgPSBmcm9tUG9zOyB9XG4gICAgICAgIGlmIChjbXBDb29yZHModG9Qb3MsIGVuZCkgPCAwKSB7IGVuZCA9IHRvUG9zOyB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7c3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZH1cbiAgICB9XG5cbiAgICB2YXIgc0Zyb20gPSByYW5nZS5mcm9tKCksIHNUbyA9IHJhbmdlLnRvKCk7XG4gICAgaWYgKHNGcm9tLmxpbmUgPT0gc1RvLmxpbmUpIHtcbiAgICAgIGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzVG8uY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZnJvbUxpbmUgPSBnZXRMaW5lKGRvYywgc0Zyb20ubGluZSksIHRvTGluZSA9IGdldExpbmUoZG9jLCBzVG8ubGluZSk7XG4gICAgICB2YXIgc2luZ2xlVkxpbmUgPSB2aXN1YWxMaW5lKGZyb21MaW5lKSA9PSB2aXN1YWxMaW5lKHRvTGluZSk7XG4gICAgICB2YXIgbGVmdEVuZCA9IGRyYXdGb3JMaW5lKHNGcm9tLmxpbmUsIHNGcm9tLmNoLCBzaW5nbGVWTGluZSA/IGZyb21MaW5lLnRleHQubGVuZ3RoICsgMSA6IG51bGwpLmVuZDtcbiAgICAgIHZhciByaWdodFN0YXJ0ID0gZHJhd0ZvckxpbmUoc1RvLmxpbmUsIHNpbmdsZVZMaW5lID8gMCA6IG51bGwsIHNUby5jaCkuc3RhcnQ7XG4gICAgICBpZiAoc2luZ2xlVkxpbmUpIHtcbiAgICAgICAgaWYgKGxlZnRFbmQudG9wIDwgcmlnaHRTdGFydC50b3AgLSAyKSB7XG4gICAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCBudWxsLCBsZWZ0RW5kLmJvdHRvbSk7XG4gICAgICAgICAgYWRkKGxlZnRTaWRlLCByaWdodFN0YXJ0LnRvcCwgcmlnaHRTdGFydC5sZWZ0LCByaWdodFN0YXJ0LmJvdHRvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkKGxlZnRFbmQucmlnaHQsIGxlZnRFbmQudG9wLCByaWdodFN0YXJ0LmxlZnQgLSBsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0RW5kLmJvdHRvbSA8IHJpZ2h0U3RhcnQudG9wKVxuICAgICAgICB7IGFkZChsZWZ0U2lkZSwgbGVmdEVuZC5ib3R0b20sIG51bGwsIHJpZ2h0U3RhcnQudG9wKTsgfVxuICAgIH1cblxuICAgIG91dHB1dC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gIH1cblxuICAvLyBDdXJzb3ItYmxpbmtpbmdcbiAgZnVuY3Rpb24gcmVzdGFydEJsaW5rKGNtKSB7XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IHJldHVybiB9XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGNsZWFySW50ZXJ2YWwoZGlzcGxheS5ibGlua2VyKTtcbiAgICB2YXIgb24gPSB0cnVlO1xuICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xuICAgIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA+IDApXG4gICAgICB7IGRpc3BsYXkuYmxpbmtlciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7IG9uQmx1cihjbSk7IH1cbiAgICAgICAgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IChvbiA9ICFvbikgPyBcIlwiIDogXCJoaWRkZW5cIjtcbiAgICAgIH0sIGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlKTsgfVxuICAgIGVsc2UgaWYgKGNtLm9wdGlvbnMuY3Vyc29yQmxpbmtSYXRlIDwgMClcbiAgICAgIHsgZGlzcGxheS5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuc3VyZUZvY3VzKGNtKSB7XG4gICAgaWYgKCFjbS5oYXNGb2N1cygpKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgb25Gb2N1cyhjbSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxheUJsdXJFdmVudChjbSkge1xuICAgIGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XG4gICAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlO1xuICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgb25CbHVyKGNtKTsgfVxuICAgIH0gfSwgMTAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRm9jdXMoY20sIGUpIHtcbiAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dCkgeyBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IGZhbHNlOyB9XG5cbiAgICBpZiAoY20ub3B0aW9ucy5yZWFkT25seSA9PSBcIm5vY3Vyc29yXCIpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgIHNpZ25hbChjbSwgXCJmb2N1c1wiLCBjbSwgZSk7XG4gICAgICBjbS5zdGF0ZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgIGFkZENsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLWZvY3VzZWRcIik7XG4gICAgICAvLyBUaGlzIHRlc3QgcHJldmVudHMgdGhpcyBmcm9tIGZpcmluZyB3aGVuIGEgY29udGV4dFxuICAgICAgLy8gbWVudSBpcyBjbG9zZWQgKHNpbmNlIHRoZSBpbnB1dCByZXNldCB3b3VsZCBraWxsIHRoZVxuICAgICAgLy8gc2VsZWN0LWFsbCBkZXRlY3Rpb24gaGFjaylcbiAgICAgIGlmICghY20uY3VyT3AgJiYgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSAhPSBjbS5kb2Muc2VsKSB7XG4gICAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgaWYgKHdlYmtpdCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgfSAvLyBJc3N1ZSAjMTczMFxuICAgICAgfVxuICAgICAgY20uZGlzcGxheS5pbnB1dC5yZWNlaXZlZEZvY3VzKCk7XG4gICAgfVxuICAgIHJlc3RhcnRCbGluayhjbSk7XG4gIH1cbiAgZnVuY3Rpb24gb25CbHVyKGNtLCBlKSB7XG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7IHJldHVybiB9XG5cbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgc2lnbmFsKGNtLCBcImJsdXJcIiwgY20sIGUpO1xuICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgIH1cbiAgICBjbGVhckludGVydmFsKGNtLmRpc3BsYXkuYmxpbmtlcik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7IH0gfSwgMTUwKTtcbiAgfVxuXG4gIC8vIFJlYWQgdGhlIGFjdHVhbCBoZWlnaHRzIG9mIHRoZSByZW5kZXJlZCBsaW5lcywgYW5kIHVwZGF0ZSB0aGVpclxuICAvLyBzdG9yZWQgaGVpZ2h0cyB0byBtYXRjaC5cbiAgZnVuY3Rpb24gdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHByZXZCb3R0b20gPSBkaXNwbGF5LmxpbmVEaXYub2Zmc2V0VG9wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gZGlzcGxheS52aWV3W2ldLCB3cmFwcGluZyA9IGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgICAgdmFyIGhlaWdodCA9ICh2b2lkIDApLCB3aWR0aCA9IDA7XG4gICAgICBpZiAoY3VyLmhpZGRlbikgeyBjb250aW51ZSB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHtcbiAgICAgICAgdmFyIGJvdCA9IGN1ci5ub2RlLm9mZnNldFRvcCArIGN1ci5ub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gYm90IC0gcHJldkJvdHRvbTtcbiAgICAgICAgcHJldkJvdHRvbSA9IGJvdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBib3ggPSBjdXIubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaGVpZ2h0ID0gYm94LmJvdHRvbSAtIGJveC50b3A7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgbGluZXMgZG9uJ3QgZXh0ZW5kIHBhc3QgdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGVkaXRvciB3aWR0aFxuICAgICAgICBpZiAoIXdyYXBwaW5nICYmIGN1ci50ZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgeyB3aWR0aCA9IGN1ci50ZXh0LmZpcnN0Q2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgLSBib3gubGVmdCAtIDE7IH1cbiAgICAgIH1cbiAgICAgIHZhciBkaWZmID0gY3VyLmxpbmUuaGVpZ2h0IC0gaGVpZ2h0O1xuICAgICAgaWYgKGRpZmYgPiAuMDA1IHx8IGRpZmYgPCAtLjAwNSkge1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGN1ci5saW5lLCBoZWlnaHQpO1xuICAgICAgICB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLmxpbmUpO1xuICAgICAgICBpZiAoY3VyLnJlc3QpIHsgZm9yICh2YXIgaiA9IDA7IGogPCBjdXIucmVzdC5sZW5ndGg7IGorKylcbiAgICAgICAgICB7IHVwZGF0ZVdpZGdldEhlaWdodChjdXIucmVzdFtqXSk7IH0gfVxuICAgICAgfVxuICAgICAgaWYgKHdpZHRoID4gY20uZGlzcGxheS5zaXplcldpZHRoKSB7XG4gICAgICAgIHZhciBjaFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gY2hhcldpZHRoKGNtLmRpc3BsYXkpKTtcbiAgICAgICAgaWYgKGNoV2lkdGggPiBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVMZW5ndGggPSBjaFdpZHRoO1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IGN1ci5saW5lO1xuICAgICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVhZCBhbmQgc3RvcmUgdGhlIGhlaWdodCBvZiBsaW5lIHdpZGdldHMgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAvLyBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiB1cGRhdGVXaWRnZXRIZWlnaHQobGluZSkge1xuICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB3ID0gbGluZS53aWRnZXRzW2ldLCBwYXJlbnQgPSB3Lm5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQpIHsgdy5oZWlnaHQgPSBwYXJlbnQub2Zmc2V0SGVpZ2h0OyB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBsaW5lcyB0aGF0IGFyZSB2aXNpYmxlIGluIGEgZ2l2ZW4gdmlld3BvcnQgKGRlZmF1bHRzXG4gIC8vIHRoZSB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24pLiB2aWV3cG9ydCBtYXkgY29udGFpbiB0b3AsXG4gIC8vIGhlaWdodCwgYW5kIGVuc3VyZSAoc2VlIG9wLnNjcm9sbFRvUG9zKSBwcm9wZXJ0aWVzLlxuICBmdW5jdGlvbiB2aXNpYmxlTGluZXMoZGlzcGxheSwgZG9jLCB2aWV3cG9ydCkge1xuICAgIHZhciB0b3AgPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbCA/IE1hdGgubWF4KDAsIHZpZXdwb3J0LnRvcCkgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICB0b3AgPSBNYXRoLmZsb29yKHRvcCAtIHBhZGRpbmdUb3AoZGlzcGxheSkpO1xuICAgIHZhciBib3R0b20gPSB2aWV3cG9ydCAmJiB2aWV3cG9ydC5ib3R0b20gIT0gbnVsbCA/IHZpZXdwb3J0LmJvdHRvbSA6IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG5cbiAgICB2YXIgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIHRvcCksIHRvID0gbGluZUF0SGVpZ2h0KGRvYywgYm90dG9tKTtcbiAgICAvLyBFbnN1cmUgaXMgYSB7ZnJvbToge2xpbmUsIGNofSwgdG86IHtsaW5lLCBjaH19IG9iamVjdCwgYW5kXG4gICAgLy8gZm9yY2VzIHRob3NlIGxpbmVzIGludG8gdGhlIHZpZXdwb3J0IChpZiBwb3NzaWJsZSkuXG4gICAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LmVuc3VyZSkge1xuICAgICAgdmFyIGVuc3VyZUZyb20gPSB2aWV3cG9ydC5lbnN1cmUuZnJvbS5saW5lLCBlbnN1cmVUbyA9IHZpZXdwb3J0LmVuc3VyZS50by5saW5lO1xuICAgICAgaWYgKGVuc3VyZUZyb20gPCBmcm9tKSB7XG4gICAgICAgIGZyb20gPSBlbnN1cmVGcm9tO1xuICAgICAgICB0byA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlRnJvbSkpICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGgubWluKGVuc3VyZVRvLCBkb2MubGFzdExpbmUoKSkgPj0gdG8pIHtcbiAgICAgICAgZnJvbSA9IGxpbmVBdEhlaWdodChkb2MsIGhlaWdodEF0TGluZShnZXRMaW5lKGRvYywgZW5zdXJlVG8pKSAtIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO1xuICAgICAgICB0byA9IGVuc3VyZVRvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge2Zyb206IGZyb20sIHRvOiBNYXRoLm1heCh0bywgZnJvbSArIDEpfVxuICB9XG5cbiAgLy8gU0NST0xMSU5HIFRISU5HUyBJTlRPIFZJRVdcblxuICAvLyBJZiBhbiBlZGl0b3Igc2l0cyBvbiB0aGUgdG9wIG9yIGJvdHRvbSBvZiB0aGUgd2luZG93LCBwYXJ0aWFsbHlcbiAgLy8gc2Nyb2xsZWQgb3V0IG9mIHZpZXcsIHRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjdXJzb3IgaXMgdmlzaWJsZS5cbiAgZnVuY3Rpb24gbWF5YmVTY3JvbGxXaW5kb3coY20sIHJlY3QpIHtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIFwic2Nyb2xsQ3Vyc29ySW50b1ZpZXdcIikpIHsgcmV0dXJuIH1cblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgYm94ID0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9TY3JvbGwgPSBudWxsO1xuICAgIGlmIChyZWN0LnRvcCArIGJveC50b3AgPCAwKSB7IGRvU2Nyb2xsID0gdHJ1ZTsgfVxuICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tICsgYm94LnRvcCA+ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkpIHsgZG9TY3JvbGwgPSBmYWxzZTsgfVxuICAgIGlmIChkb1Njcm9sbCAhPSBudWxsICYmICFwaGFudG9tKSB7XG4gICAgICB2YXIgc2Nyb2xsTm9kZSA9IGVsdChcImRpdlwiLCBcIlxcdTIwMGJcIiwgbnVsbCwgKFwicG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IFwiICsgKHJlY3QudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0IC0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KSkgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiICsgKHJlY3QuYm90dG9tIC0gcmVjdC50b3AgKyBzY3JvbGxHYXAoY20pICsgZGlzcGxheS5iYXJIZWlnaHQpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogXCIgKyAocmVjdC5sZWZ0KSArIFwicHg7IHdpZHRoOiBcIiArIChNYXRoLm1heCgyLCByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSkgKyBcInB4O1wiKSk7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5hcHBlbmRDaGlsZChzY3JvbGxOb2RlKTtcbiAgICAgIHNjcm9sbE5vZGUuc2Nyb2xsSW50b1ZpZXcoZG9TY3JvbGwpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoc2Nyb2xsTm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2Nyb2xsIGEgZ2l2ZW4gcG9zaXRpb24gaW50byB2aWV3IChpbW1lZGlhdGVseSksIHZlcmlmeWluZyB0aGF0XG4gIC8vIGl0IGFjdHVhbGx5IGJlY2FtZSB2aXNpYmxlIChhcyBsaW5lIGhlaWdodHMgYXJlIGFjY3VyYXRlbHlcbiAgLy8gbWVhc3VyZWQsIHRoZSBwb3NpdGlvbiBvZiBzb21ldGhpbmcgbWF5ICdkcmlmdCcgZHVyaW5nIGRyYXdpbmcpLlxuICBmdW5jdGlvbiBzY3JvbGxQb3NJbnRvVmlldyhjbSwgcG9zLCBlbmQsIG1hcmdpbikge1xuICAgIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSAwOyB9XG4gICAgdmFyIHJlY3Q7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiBwb3MgPT0gZW5kKSB7XG4gICAgICAvLyBTZXQgcG9zIGFuZCBlbmQgdG8gdGhlIGN1cnNvciBwb3NpdGlvbnMgYXJvdW5kIHRoZSBjaGFyYWN0ZXIgcG9zIHN0aWNrcyB0b1xuICAgICAgLy8gSWYgcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiLCB0aGF0IGlzIGFyb3VuZCBwb3MuY2ggLSAxLCBvdGhlcndpc2UgYXJvdW5kIHBvcy5jaFxuICAgICAgLy8gSWYgcG9zID09IFBvcyhfLCAwLCBcImJlZm9yZVwiKSwgcG9zIGFuZCBlbmQgYXJlIHVuY2hhbmdlZFxuICAgICAgcG9zID0gcG9zLmNoID8gUG9zKHBvcy5saW5lLCBwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBwb3MuY2ggLSAxIDogcG9zLmNoLCBcImFmdGVyXCIpIDogcG9zO1xuICAgICAgZW5kID0gcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiID8gUG9zKHBvcy5saW5lLCBwb3MuY2ggKyAxLCBcImJlZm9yZVwiKSA6IHBvcztcbiAgICB9XG4gICAgZm9yICh2YXIgbGltaXQgPSAwOyBsaW1pdCA8IDU7IGxpbWl0KyspIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKGNtLCBwb3MpO1xuICAgICAgdmFyIGVuZENvb3JkcyA9ICFlbmQgfHwgZW5kID09IHBvcyA/IGNvb3JkcyA6IGN1cnNvckNvb3JkcyhjbSwgZW5kKTtcbiAgICAgIHJlY3QgPSB7bGVmdDogTWF0aC5taW4oY29vcmRzLmxlZnQsIGVuZENvb3Jkcy5sZWZ0KSxcbiAgICAgICAgICAgICAgdG9wOiBNYXRoLm1pbihjb29yZHMudG9wLCBlbmRDb29yZHMudG9wKSAtIG1hcmdpbixcbiAgICAgICAgICAgICAgcmlnaHQ6IE1hdGgubWF4KGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgICAgIGJvdHRvbTogTWF0aC5tYXgoY29vcmRzLmJvdHRvbSwgZW5kQ29vcmRzLmJvdHRvbSkgKyBtYXJnaW59O1xuICAgICAgdmFyIHNjcm9sbFBvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCk7XG4gICAgICB2YXIgc3RhcnRUb3AgPSBjbS5kb2Muc2Nyb2xsVG9wLCBzdGFydExlZnQgPSBjbS5kb2Muc2Nyb2xsTGVmdDtcbiAgICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlU2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSBzdGFydFRvcCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHN0YXJ0TGVmdCkgPiAxKSB7IGNoYW5nZWQgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgICBpZiAoIWNoYW5nZWQpIHsgYnJlYWsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdFxuICB9XG5cbiAgLy8gU2Nyb2xsIGEgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLlxuICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhjbSwgcmVjdCkge1xuICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpO1xuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsVG9wICE9IG51bGwpIHsgdXBkYXRlU2Nyb2xsVG9wKGNtLCBzY3JvbGxQb3Muc2Nyb2xsVG9wKTsgfVxuICAgIGlmIChzY3JvbGxQb3Muc2Nyb2xsTGVmdCAhPSBudWxsKSB7IHNldFNjcm9sbExlZnQoY20sIHNjcm9sbFBvcy5zY3JvbGxMZWZ0KTsgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGEgbmV3IHNjcm9sbCBwb3NpdGlvbiBuZWVkZWQgdG8gc2Nyb2xsIHRoZSBnaXZlblxuICAvLyByZWN0YW5nbGUgaW50byB2aWV3LiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHNjcm9sbFRvcCBhbmRcbiAgLy8gc2Nyb2xsTGVmdCBwcm9wZXJ0aWVzLiBXaGVuIHRoZXNlIGFyZSB1bmRlZmluZWQsIHRoZVxuICAvLyB2ZXJ0aWNhbC9ob3Jpem9udGFsIHBvc2l0aW9uIGRvZXMgbm90IG5lZWQgdG8gYmUgYWRqdXN0ZWQuXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwgcmVjdCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc25hcE1hcmdpbiA9IHRleHRIZWlnaHQoY20uZGlzcGxheSk7XG4gICAgaWYgKHJlY3QudG9wIDwgMCkgeyByZWN0LnRvcCA9IDA7IH1cbiAgICB2YXIgc2NyZWVudG9wID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wICE9IG51bGwgPyBjbS5jdXJPcC5zY3JvbGxUb3AgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcDtcbiAgICB2YXIgc2NyZWVuID0gZGlzcGxheUhlaWdodChjbSksIHJlc3VsdCA9IHt9O1xuICAgIGlmIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gc2NyZWVuKSB7IHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBzY3JlZW47IH1cbiAgICB2YXIgZG9jQm90dG9tID0gY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGRpc3BsYXkpO1xuICAgIHZhciBhdFRvcCA9IHJlY3QudG9wIDwgc25hcE1hcmdpbiwgYXRCb3R0b20gPSByZWN0LmJvdHRvbSA+IGRvY0JvdHRvbSAtIHNuYXBNYXJnaW47XG4gICAgaWYgKHJlY3QudG9wIDwgc2NyZWVudG9wKSB7XG4gICAgICByZXN1bHQuc2Nyb2xsVG9wID0gYXRUb3AgPyAwIDogcmVjdC50b3A7XG4gICAgfSBlbHNlIGlmIChyZWN0LmJvdHRvbSA+IHNjcmVlbnRvcCArIHNjcmVlbikge1xuICAgICAgdmFyIG5ld1RvcCA9IE1hdGgubWluKHJlY3QudG9wLCAoYXRCb3R0b20gPyBkb2NCb3R0b20gOiByZWN0LmJvdHRvbSkgLSBzY3JlZW4pO1xuICAgICAgaWYgKG5ld1RvcCAhPSBzY3JlZW50b3ApIHsgcmVzdWx0LnNjcm9sbFRvcCA9IG5ld1RvcDsgfVxuICAgIH1cblxuICAgIHZhciBndXR0ZXJTcGFjZSA9IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyAwIDogZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBzY3JlZW5sZWZ0ID0gY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsTGVmdCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsTGVmdCA6IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAtIGd1dHRlclNwYWNlO1xuICAgIHZhciBzY3JlZW53ID0gZGlzcGxheVdpZHRoKGNtKSAtIGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgdG9vV2lkZSA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQgPiBzY3JlZW53O1xuICAgIGlmICh0b29XaWRlKSB7IHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBzY3JlZW53OyB9XG4gICAgaWYgKHJlY3QubGVmdCA8IDEwKVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IDA7IH1cbiAgICBlbHNlIGlmIChyZWN0LmxlZnQgPCBzY3JlZW5sZWZ0KVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsIHJlY3QubGVmdCArIGd1dHRlclNwYWNlIC0gKHRvb1dpZGUgPyAwIDogMTApKTsgfVxuICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBzY3JlZW53ICsgc2NyZWVubGVmdCAtIDMpXG4gICAgICB7IHJlc3VsdC5zY3JvbGxMZWZ0ID0gcmVjdC5yaWdodCArICh0b29XaWRlID8gMCA6IDEwKSAtIHNjcmVlbnc7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBTdG9yZSBhIHJlbGF0aXZlIGFkanVzdG1lbnQgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICAvLyBvcGVyYXRpb24gKHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgb3BlcmF0aW9uIGZpbmlzaGVzKS5cbiAgZnVuY3Rpb24gYWRkVG9TY3JvbGxUb3AoY20sIHRvcCkge1xuICAgIGlmICh0b3AgPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9wID0gKGNtLmN1ck9wLnNjcm9sbFRvcCA9PSBudWxsID8gY20uZG9jLnNjcm9sbFRvcCA6IGNtLmN1ck9wLnNjcm9sbFRvcCkgKyB0b3A7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgdGhhdCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb24gdGhlIGN1cnJlbnQgY3Vyc29yIGlzXG4gIC8vIHNob3duLlxuICBmdW5jdGlvbiBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKSB7XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICB2YXIgY3VyID0gY20uZ2V0Q3Vyc29yKCk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSB7ZnJvbTogY3VyLCB0bzogY3VyLCBtYXJnaW46IGNtLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2lufTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvQ29vcmRzKGNtLCB4LCB5KSB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHsgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTsgfVxuICAgIGlmICh4ICE9IG51bGwpIHsgY20uY3VyT3Auc2Nyb2xsTGVmdCA9IHg7IH1cbiAgICBpZiAoeSAhPSBudWxsKSB7IGNtLmN1ck9wLnNjcm9sbFRvcCA9IHk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvUmFuZ2UoY20sIHJhbmdlKSB7XG4gICAgcmVzb2x2ZVNjcm9sbFRvUG9zKGNtKTtcbiAgICBjbS5jdXJPcC5zY3JvbGxUb1BvcyA9IHJhbmdlO1xuICB9XG5cbiAgLy8gV2hlbiBhbiBvcGVyYXRpb24gaGFzIGl0cyBzY3JvbGxUb1BvcyBwcm9wZXJ0eSBzZXQsIGFuZCBhbm90aGVyXG4gIC8vIHNjcm9sbCBhY3Rpb24gaXMgYXBwbGllZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLCB0aGlzXG4gIC8vICdzaW11bGF0ZXMnIHNjcm9sbGluZyB0aGF0IHBvc2l0aW9uIGludG8gdmlldyBpbiBhIGNoZWFwIHdheSwgc29cbiAgLy8gdGhhdCB0aGUgZWZmZWN0IG9mIGludGVybWVkaWF0ZSBzY3JvbGwgY29tbWFuZHMgaXMgbm90IGlnbm9yZWQuXG4gIGZ1bmN0aW9uIHJlc29sdmVTY3JvbGxUb1BvcyhjbSkge1xuICAgIHZhciByYW5nZSA9IGNtLmN1ck9wLnNjcm9sbFRvUG9zO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSBudWxsO1xuICAgICAgdmFyIGZyb20gPSBlc3RpbWF0ZUNvb3JkcyhjbSwgcmFuZ2UuZnJvbSksIHRvID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLnRvKTtcbiAgICAgIHNjcm9sbFRvQ29vcmRzUmFuZ2UoY20sIGZyb20sIHRvLCByYW5nZS5tYXJnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvQ29vcmRzUmFuZ2UoY20sIGZyb20sIHRvLCBtYXJnaW4pIHtcbiAgICB2YXIgc1BvcyA9IGNhbGN1bGF0ZVNjcm9sbFBvcyhjbSwge1xuICAgICAgbGVmdDogTWF0aC5taW4oZnJvbS5sZWZ0LCB0by5sZWZ0KSxcbiAgICAgIHRvcDogTWF0aC5taW4oZnJvbS50b3AsIHRvLnRvcCkgLSBtYXJnaW4sXG4gICAgICByaWdodDogTWF0aC5tYXgoZnJvbS5yaWdodCwgdG8ucmlnaHQpLFxuICAgICAgYm90dG9tOiBNYXRoLm1heChmcm9tLmJvdHRvbSwgdG8uYm90dG9tKSArIG1hcmdpblxuICAgIH0pO1xuICAgIHNjcm9sbFRvQ29vcmRzKGNtLCBzUG9zLnNjcm9sbExlZnQsIHNQb3Muc2Nyb2xsVG9wKTtcbiAgfVxuXG4gIC8vIFN5bmMgdGhlIHNjcm9sbGFibGUgYXJlYSBhbmQgc2Nyb2xsYmFycywgZW5zdXJlIHRoZSB2aWV3cG9ydFxuICAvLyBjb3ZlcnMgdGhlIHZpc2libGUgYXJlYS5cbiAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsVG9wKGNtLCB2YWwpIHtcbiAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbFRvcCAtIHZhbCkgPCAyKSB7IHJldHVybiB9XG4gICAgaWYgKCFnZWNrbykgeyB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB7dG9wOiB2YWx9KTsgfVxuICAgIHNldFNjcm9sbFRvcChjbSwgdmFsLCB0cnVlKTtcbiAgICBpZiAoZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSk7IH1cbiAgICBzdGFydFdvcmtlcihjbSwgMTAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbFRvcChjbSwgdmFsLCBmb3JjZVNjcm9sbCkge1xuICAgIHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0IC0gY20uZGlzcGxheS5zY3JvbGxlci5jbGllbnRIZWlnaHQsIHZhbCkpO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9PSB2YWwgJiYgIWZvcmNlU2Nyb2xsKSB7IHJldHVybiB9XG4gICAgY20uZG9jLnNjcm9sbFRvcCA9IHZhbDtcbiAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsVG9wKHZhbCk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICE9IHZhbCkgeyBjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHZhbDsgfVxuICB9XG5cbiAgLy8gU3luYyBzY3JvbGxlciBhbmQgc2Nyb2xsYmFyLCBlbnN1cmUgdGhlIGd1dHRlciBlbGVtZW50cyBhcmVcbiAgLy8gYWxpZ25lZC5cbiAgZnVuY3Rpb24gc2V0U2Nyb2xsTGVmdChjbSwgdmFsLCBpc1Njcm9sbGVyLCBmb3JjZVNjcm9sbCkge1xuICAgIHZhbCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZhbCwgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxXaWR0aCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgpKTtcbiAgICBpZiAoKGlzU2Nyb2xsZXIgPyB2YWwgPT0gY20uZG9jLnNjcm9sbExlZnQgOiBNYXRoLmFicyhjbS5kb2Muc2Nyb2xsTGVmdCAtIHZhbCkgPCAyKSAmJiAhZm9yY2VTY3JvbGwpIHsgcmV0dXJuIH1cbiAgICBjbS5kb2Muc2Nyb2xsTGVmdCA9IHZhbDtcbiAgICBhbGlnbkhvcml6b250YWxseShjbSk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ID0gdmFsOyB9XG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbExlZnQodmFsKTtcbiAgfVxuXG4gIC8vIFNDUk9MTEJBUlNcblxuICAvLyBQcmVwYXJlIERPTSByZWFkcyBuZWVkZWQgdG8gdXBkYXRlIHRoZSBzY3JvbGxiYXJzLiBEb25lIGluIG9uZVxuICAvLyBzaG90IHRvIG1pbmltaXplIHVwZGF0ZS9tZWFzdXJlIHJvdW5kdHJpcHMuXG4gIGZ1bmN0aW9uIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBndXR0ZXJXID0gZC5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIHZhciBkb2NIID0gTWF0aC5yb3VuZChjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkpO1xuICAgIHJldHVybiB7XG4gICAgICBjbGllbnRIZWlnaHQ6IGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LFxuICAgICAgdmlld0hlaWdodDogZC53cmFwcGVyLmNsaWVudEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBkLnNjcm9sbGVyLnNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aDogZC5zY3JvbGxlci5jbGllbnRXaWR0aCxcbiAgICAgIHZpZXdXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRoLFxuICAgICAgYmFyTGVmdDogY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGd1dHRlclcgOiAwLFxuICAgICAgZG9jSGVpZ2h0OiBkb2NILFxuICAgICAgc2Nyb2xsSGVpZ2h0OiBkb2NIICsgc2Nyb2xsR2FwKGNtKSArIGQuYmFySGVpZ2h0LFxuICAgICAgbmF0aXZlQmFyV2lkdGg6IGQubmF0aXZlQmFyV2lkdGgsXG4gICAgICBndXR0ZXJXaWR0aDogZ3V0dGVyV1xuICAgIH1cbiAgfVxuXG4gIHZhciBOYXRpdmVTY3JvbGxiYXJzID0gZnVuY3Rpb24ocGxhY2UsIHNjcm9sbCwgY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgdmFyIHZlcnQgPSB0aGlzLnZlcnQgPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcIm1pbi13aWR0aDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLXZzY3JvbGxiYXJcIik7XG4gICAgdmFyIGhvcml6ID0gdGhpcy5ob3JpeiA9IGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwiaGVpZ2h0OiAxMDAlOyBtaW4taGVpZ2h0OiAxcHhcIildLCBcIkNvZGVNaXJyb3ItaHNjcm9sbGJhclwiKTtcbiAgICB2ZXJ0LnRhYkluZGV4ID0gaG9yaXoudGFiSW5kZXggPSAtMTtcbiAgICBwbGFjZSh2ZXJ0KTsgcGxhY2UoaG9yaXopO1xuXG4gICAgb24odmVydCwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHZlcnQuY2xpZW50SGVpZ2h0KSB7IHNjcm9sbCh2ZXJ0LnNjcm9sbFRvcCwgXCJ2ZXJ0aWNhbFwiKTsgfVxuICAgIH0pO1xuICAgIG9uKGhvcml6LCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaG9yaXouY2xpZW50V2lkdGgpIHsgc2Nyb2xsKGhvcml6LnNjcm9sbExlZnQsIFwiaG9yaXpvbnRhbFwiKTsgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5jaGVja2VkWmVyb1dpZHRoID0gZmFsc2U7XG4gICAgLy8gTmVlZCB0byBzZXQgYSBtaW5pbXVtIHdpZHRoIHRvIHNlZSB0aGUgc2Nyb2xsYmFyIG9uIElFNyAoYnV0IG11c3Qgbm90IHNldCBpdCBvbiBJRTgpLlxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyB0aGlzLmhvcml6LnN0eWxlLm1pbkhlaWdodCA9IHRoaXMudmVydC5zdHlsZS5taW5XaWR0aCA9IFwiMThweFwiOyB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICB2YXIgbmVlZHNIID0gbWVhc3VyZS5zY3JvbGxXaWR0aCA+IG1lYXN1cmUuY2xpZW50V2lkdGggKyAxO1xuICAgIHZhciBuZWVkc1YgPSBtZWFzdXJlLnNjcm9sbEhlaWdodCA+IG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgMTtcbiAgICB2YXIgc1dpZHRoID0gbWVhc3VyZS5uYXRpdmVCYXJXaWR0aDtcblxuICAgIGlmIChuZWVkc1YpIHtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy52ZXJ0LnN0eWxlLmJvdHRvbSA9IG5lZWRzSCA/IHNXaWR0aCArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgdmFyIHRvdGFsSGVpZ2h0ID0gbWVhc3VyZS52aWV3SGVpZ2h0IC0gKG5lZWRzSCA/IHNXaWR0aCA6IDApO1xuICAgICAgLy8gQSBidWcgaW4gSUU4IGNhbiBjYXVzZSB0aGlzIHZhbHVlIHRvIGJlIG5lZ2F0aXZlLCBzbyBndWFyZCBpdC5cbiAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9XG4gICAgICAgIE1hdGgubWF4KDAsIG1lYXN1cmUuc2Nyb2xsSGVpZ2h0IC0gbWVhc3VyZS5jbGllbnRIZWlnaHQgKyB0b3RhbEhlaWdodCkgKyBcInB4XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIHRoaXMudmVydC5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0gpIHtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUucmlnaHQgPSBuZWVkc1YgPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHRoaXMuaG9yaXouc3R5bGUubGVmdCA9IG1lYXN1cmUuYmFyTGVmdCArIFwicHhcIjtcbiAgICAgIHZhciB0b3RhbFdpZHRoID0gbWVhc3VyZS52aWV3V2lkdGggLSBtZWFzdXJlLmJhckxlZnQgLSAobmVlZHNWID8gc1dpZHRoIDogMCk7XG4gICAgICB0aGlzLmhvcml6LmZpcnN0Q2hpbGQuc3R5bGUud2lkdGggPVxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbFdpZHRoIC0gbWVhc3VyZS5jbGllbnRXaWR0aCArIHRvdGFsV2lkdGgpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID0gXCIwXCI7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNoZWNrZWRaZXJvV2lkdGggJiYgbWVhc3VyZS5jbGllbnRIZWlnaHQgPiAwKSB7XG4gICAgICBpZiAoc1dpZHRoID09IDApIHsgdGhpcy56ZXJvV2lkdGhIYWNrKCk7IH1cbiAgICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtyaWdodDogbmVlZHNWID8gc1dpZHRoIDogMCwgYm90dG9tOiBuZWVkc0ggPyBzV2lkdGggOiAwfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgaWYgKHRoaXMuaG9yaXouc2Nyb2xsTGVmdCAhPSBwb3MpIHsgdGhpcy5ob3Jpei5zY3JvbGxMZWZ0ID0gcG9zOyB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZUhvcml6KSB7IHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMuaG9yaXosIHRoaXMuZGlzYWJsZUhvcml6LCBcImhvcml6XCIpOyB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHBvcykge1xuICAgIGlmICh0aGlzLnZlcnQuc2Nyb2xsVG9wICE9IHBvcykgeyB0aGlzLnZlcnQuc2Nyb2xsVG9wID0gcG9zOyB9XG4gICAgaWYgKHRoaXMuZGlzYWJsZVZlcnQpIHsgdGhpcy5lbmFibGVaZXJvV2lkdGhCYXIodGhpcy52ZXJ0LCB0aGlzLmRpc2FibGVWZXJ0LCBcInZlcnRcIik7IH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS56ZXJvV2lkdGhIYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB3ID0gbWFjICYmICFtYWNfZ2VNb3VudGFpbkxpb24gPyBcIjEycHhcIiA6IFwiMThweFwiO1xuICAgIHRoaXMuaG9yaXouc3R5bGUuaGVpZ2h0ID0gdGhpcy52ZXJ0LnN0eWxlLndpZHRoID0gdztcbiAgICB0aGlzLmhvcml6LnN0eWxlLnBvaW50ZXJFdmVudHMgPSB0aGlzLnZlcnQuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIHRoaXMuZGlzYWJsZUhvcml6ID0gbmV3IERlbGF5ZWQ7XG4gICAgdGhpcy5kaXNhYmxlVmVydCA9IG5ldyBEZWxheWVkO1xuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmVuYWJsZVplcm9XaWR0aEJhciA9IGZ1bmN0aW9uIChiYXIsIGRlbGF5LCB0eXBlKSB7XG4gICAgYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICBmdW5jdGlvbiBtYXliZURpc2FibGUoKSB7XG4gICAgICAvLyBUbyBmaW5kIG91dCB3aGV0aGVyIHRoZSBzY3JvbGxiYXIgaXMgc3RpbGwgdmlzaWJsZSwgd2VcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGVsZW1lbnQgdW5kZXIgdGhlIHBpeGVsIGluIHRoZSBib3R0b21cbiAgICAgIC8vIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2Nyb2xsYmFyIGJveCBpcyB0aGUgc2Nyb2xsYmFyIGJveFxuICAgICAgLy8gaXRzZWxmICh3aGVuIHRoZSBiYXIgaXMgc3RpbGwgdmlzaWJsZSkgb3IgaXRzIGZpbGxlciBjaGlsZFxuICAgICAgLy8gKHdoZW4gdGhlIGJhciBpcyBoaWRkZW4pLiBJZiBpdCBpcyBzdGlsbCB2aXNpYmxlLCB3ZSBrZWVwXG4gICAgICAvLyBpdCBlbmFibGVkLCBpZiBpdCdzIGhpZGRlbiwgd2UgZGlzYWJsZSBwb2ludGVyIGV2ZW50cy5cbiAgICAgIHZhciBib3ggPSBiYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgZWx0ID0gdHlwZSA9PSBcInZlcnRcIiA/IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoYm94LnJpZ2h0IC0gMSwgKGJveC50b3AgKyBib3guYm90dG9tKSAvIDIpXG4gICAgICAgICAgOiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KChib3gucmlnaHQgKyBib3gubGVmdCkgLyAyLCBib3guYm90dG9tIC0gMSk7XG4gICAgICBpZiAoZWx0ICE9IGJhcikgeyBiYXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiOyB9XG4gICAgICBlbHNlIHsgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7IH1cbiAgICB9XG4gICAgZGVsYXkuc2V0KDEwMDAsIG1heWJlRGlzYWJsZSk7XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuaG9yaXoucGFyZW50Tm9kZTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5ob3Jpeik7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMudmVydCk7XG4gIH07XG5cbiAgdmFyIE51bGxTY3JvbGxiYXJzID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHtib3R0b206IDAsIHJpZ2h0OiAwfSB9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHt9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnMoY20sIG1lYXN1cmUpIHtcbiAgICBpZiAoIW1lYXN1cmUpIHsgbWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTsgfVxuICAgIHZhciBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aCwgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcbiAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAmJiBzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggfHwgc3RhcnRIZWlnaHQgIT0gY20uZGlzcGxheS5iYXJIZWlnaHQ7IGkrKykge1xuICAgICAgaWYgKHN0YXJ0V2lkdGggIT0gY20uZGlzcGxheS5iYXJXaWR0aCAmJiBjbS5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgeyB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7IH1cbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pKTtcbiAgICAgIHN0YXJ0V2lkdGggPSBjbS5kaXNwbGF5LmJhcldpZHRoOyBzdGFydEhlaWdodCA9IGNtLmRpc3BsYXkuYmFySGVpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlLXN5bmNocm9uaXplIHRoZSBmYWtlIHNjcm9sbGJhcnMgd2l0aCB0aGUgYWN0dWFsIHNpemUgb2YgdGhlXG4gIC8vIGNvbnRlbnQuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbGJhcnNJbm5lcihjbSwgbWVhc3VyZSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICB2YXIgc2l6ZXMgPSBkLnNjcm9sbGJhcnMudXBkYXRlKG1lYXN1cmUpO1xuXG4gICAgZC5zaXplci5zdHlsZS5wYWRkaW5nUmlnaHQgPSAoZC5iYXJXaWR0aCA9IHNpemVzLnJpZ2h0KSArIFwicHhcIjtcbiAgICBkLnNpemVyLnN0eWxlLnBhZGRpbmdCb3R0b20gPSAoZC5iYXJIZWlnaHQgPSBzaXplcy5ib3R0b20pICsgXCJweFwiO1xuICAgIGQuaGVpZ2h0Rm9yY2VyLnN0eWxlLmJvcmRlckJvdHRvbSA9IHNpemVzLmJvdHRvbSArIFwicHggc29saWQgdHJhbnNwYXJlbnRcIjtcblxuICAgIGlmIChzaXplcy5yaWdodCAmJiBzaXplcy5ib3R0b20pIHtcbiAgICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS53aWR0aCA9IHNpemVzLnJpZ2h0ICsgXCJweFwiO1xuICAgIH0gZWxzZSB7IGQuc2Nyb2xsYmFyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG4gICAgaWYgKHNpemVzLmJvdHRvbSAmJiBjbS5vcHRpb25zLmNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyICYmIGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIpIHtcbiAgICAgIGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5oZWlnaHQgPSBzaXplcy5ib3R0b20gKyBcInB4XCI7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS53aWR0aCA9IG1lYXN1cmUuZ3V0dGVyV2lkdGggKyBcInB4XCI7XG4gICAgfSBlbHNlIHsgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuZGlzcGxheSA9IFwiXCI7IH1cbiAgfVxuXG4gIHZhciBzY3JvbGxiYXJNb2RlbCA9IHtcIm5hdGl2ZVwiOiBOYXRpdmVTY3JvbGxiYXJzLCBcIm51bGxcIjogTnVsbFNjcm9sbGJhcnN9O1xuXG4gIGZ1bmN0aW9uIGluaXRTY3JvbGxiYXJzKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycykge1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLmNsZWFyKCk7XG4gICAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgICB7IHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpOyB9XG4gICAgfVxuXG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzID0gbmV3IHNjcm9sbGJhck1vZGVsW2NtLm9wdGlvbnMuc2Nyb2xsYmFyU3R5bGVdKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBjbS5kaXNwbGF5LndyYXBwZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGNtLmRpc3BsYXkuc2Nyb2xsYmFyRmlsbGVyKTtcbiAgICAgIC8vIFByZXZlbnQgY2xpY2tzIGluIHRoZSBzY3JvbGxiYXJzIGZyb20ga2lsbGluZyBmb2N1c1xuICAgICAgb24obm9kZSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMCk7IH1cbiAgICAgIH0pO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgfSwgZnVuY3Rpb24gKHBvcywgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT0gXCJob3Jpem9udGFsXCIpIHsgc2V0U2Nyb2xsTGVmdChjbSwgcG9zKTsgfVxuICAgICAgZWxzZSB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgcG9zKTsgfVxuICAgIH0sIGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKVxuICAgICAgeyBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcyk7IH1cbiAgfVxuXG4gIC8vIE9wZXJhdGlvbnMgYXJlIHVzZWQgdG8gd3JhcCBhIHNlcmllcyBvZiBjaGFuZ2VzIHRvIHRoZSBlZGl0b3JcbiAgLy8gc3RhdGUgaW4gc3VjaCBhIHdheSB0aGF0IGVhY2ggY2hhbmdlIHdvbid0IGhhdmUgdG8gdXBkYXRlIHRoZVxuICAvLyBjdXJzb3IgYW5kIGRpc3BsYXkgKHdoaWNoIHdvdWxkIGJlIGF3a3dhcmQsIHNsb3csIGFuZFxuICAvLyBlcnJvci1wcm9uZSkuIEluc3RlYWQsIGRpc3BsYXkgdXBkYXRlcyBhcmUgYmF0Y2hlZCBhbmQgdGhlbiBhbGxcbiAgLy8gY29tYmluZWQgYW5kIGV4ZWN1dGVkIGF0IG9uY2UuXG5cbiAgdmFyIG5leHRPcElkID0gMDtcbiAgLy8gU3RhcnQgYSBuZXcgb3BlcmF0aW9uLlxuICBmdW5jdGlvbiBzdGFydE9wZXJhdGlvbihjbSkge1xuICAgIGNtLmN1ck9wID0ge1xuICAgICAgY206IGNtLFxuICAgICAgdmlld0NoYW5nZWQ6IGZhbHNlLCAgICAgIC8vIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBsaW5lcyBtaWdodCBuZWVkIHRvIGJlIHJlZHJhd25cbiAgICAgIHN0YXJ0SGVpZ2h0OiBjbS5kb2MuaGVpZ2h0LCAvLyBVc2VkIHRvIGRldGVjdCBuZWVkIHRvIHVwZGF0ZSBzY3JvbGxiYXJcbiAgICAgIGZvcmNlVXBkYXRlOiBmYWxzZSwgICAgICAvLyBVc2VkIHRvIGZvcmNlIGEgcmVkcmF3XG4gICAgICB1cGRhdGVJbnB1dDogMCwgICAgICAgLy8gV2hldGhlciB0byByZXNldCB0aGUgaW5wdXQgdGV4dGFyZWFcbiAgICAgIHR5cGluZzogZmFsc2UsICAgICAgICAgICAvLyBXaGV0aGVyIHRoaXMgcmVzZXQgc2hvdWxkIGJlIGNhcmVmdWwgdG8gbGVhdmUgZXhpc3RpbmcgdGV4dCAoZm9yIGNvbXBvc2l0aW5nKVxuICAgICAgY2hhbmdlT2JqczogbnVsbCwgICAgICAgIC8vIEFjY3VtdWxhdGVkIGNoYW5nZXMsIGZvciBmaXJpbmcgY2hhbmdlIGV2ZW50c1xuICAgICAgY3Vyc29yQWN0aXZpdHlIYW5kbGVyczogbnVsbCwgLy8gU2V0IG9mIGhhbmRsZXJzIHRvIGZpcmUgY3Vyc29yQWN0aXZpdHkgb25cbiAgICAgIGN1cnNvckFjdGl2aXR5Q2FsbGVkOiAwLCAvLyBUcmFja3Mgd2hpY2ggY3Vyc29yQWN0aXZpdHkgaGFuZGxlcnMgaGF2ZSBiZWVuIGNhbGxlZCBhbHJlYWR5XG4gICAgICBzZWxlY3Rpb25DaGFuZ2VkOiBmYWxzZSwgLy8gV2hldGhlciB0aGUgc2VsZWN0aW9uIG5lZWRzIHRvIGJlIHJlZHJhd25cbiAgICAgIHVwZGF0ZU1heExpbmU6IGZhbHNlLCAgICAvLyBTZXQgd2hlbiB0aGUgd2lkZXN0IGxpbmUgbmVlZHMgdG8gYmUgZGV0ZXJtaW5lZCBhbmV3XG4gICAgICBzY3JvbGxMZWZ0OiBudWxsLCBzY3JvbGxUb3A6IG51bGwsIC8vIEludGVybWVkaWF0ZSBzY3JvbGwgcG9zaXRpb24sIG5vdCBwdXNoZWQgdG8gRE9NIHlldFxuICAgICAgc2Nyb2xsVG9Qb3M6IG51bGwsICAgICAgIC8vIFVzZWQgdG8gc2Nyb2xsIHRvIGEgc3BlY2lmaWMgcG9zaXRpb25cbiAgICAgIGZvY3VzOiBmYWxzZSxcbiAgICAgIGlkOiArK25leHRPcElkICAgICAgICAgICAvLyBVbmlxdWUgSURcbiAgICB9O1xuICAgIHB1c2hPcGVyYXRpb24oY20uY3VyT3ApO1xuICB9XG5cbiAgLy8gRmluaXNoIGFuIG9wZXJhdGlvbiwgdXBkYXRpbmcgdGhlIGRpc3BsYXkgYW5kIHNpZ25hbGxpbmcgZGVsYXllZCBldmVudHNcbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uKGNtKSB7XG4gICAgdmFyIG9wID0gY20uY3VyT3A7XG4gICAgaWYgKG9wKSB7IGZpbmlzaE9wZXJhdGlvbihvcCwgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm9wcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBncm91cC5vcHNbaV0uY20uY3VyT3AgPSBudWxsOyB9XG4gICAgICBlbmRPcGVyYXRpb25zKGdyb3VwKTtcbiAgICB9KTsgfVxuICB9XG5cbiAgLy8gVGhlIERPTSB1cGRhdGVzIGRvbmUgd2hlbiBhbiBvcGVyYXRpb24gZmluaXNoZXMgYXJlIGJhdGNoZWQgc29cbiAgLy8gdGhhdCB0aGUgbWluaW11bSBudW1iZXIgb2YgcmVsYXlvdXRzIGFyZSByZXF1aXJlZC5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9ucyhncm91cCkge1xuICAgIHZhciBvcHMgPSBncm91cC5vcHM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9SMShvcHNbaV0pOyB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb3BzLmxlbmd0aDsgaSQxKyspIC8vIFdyaXRlIERPTSAobWF5YmUpXG4gICAgICB7IGVuZE9wZXJhdGlvbl9XMShvcHNbaSQxXSk7IH1cbiAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBvcHMubGVuZ3RoOyBpJDIrKykgLy8gUmVhZCBET01cbiAgICAgIHsgZW5kT3BlcmF0aW9uX1IyKG9wc1tpJDJdKTsgfVxuICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG9wcy5sZW5ndGg7IGkkMysrKSAvLyBXcml0ZSBET00gKG1heWJlKVxuICAgICAgeyBlbmRPcGVyYXRpb25fVzIob3BzW2kkM10pOyB9XG4gICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgb3BzLmxlbmd0aDsgaSQ0KyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9maW5pc2gob3BzW2kkNF0pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fUjEob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgbWF5YmVDbGlwU2Nyb2xsYmFycyhjbSk7XG4gICAgaWYgKG9wLnVwZGF0ZU1heExpbmUpIHsgZmluZE1heExpbmUoY20pOyB9XG5cbiAgICBvcC5tdXN0VXBkYXRlID0gb3Audmlld0NoYW5nZWQgfHwgb3AuZm9yY2VVcGRhdGUgfHwgb3Auc2Nyb2xsVG9wICE9IG51bGwgfHxcbiAgICAgIG9wLnNjcm9sbFRvUG9zICYmIChvcC5zY3JvbGxUb1Bvcy5mcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgb3Auc2Nyb2xsVG9Qb3MudG8ubGluZSA+PSBkaXNwbGF5LnZpZXdUbykgfHxcbiAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmc7XG4gICAgb3AudXBkYXRlID0gb3AubXVzdFVwZGF0ZSAmJlxuICAgICAgbmV3IERpc3BsYXlVcGRhdGUoY20sIG9wLm11c3RVcGRhdGUgJiYge3RvcDogb3Auc2Nyb2xsVG9wLCBlbnN1cmU6IG9wLnNjcm9sbFRvUG9zfSwgb3AuZm9yY2VVcGRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1cxKG9wKSB7XG4gICAgb3AudXBkYXRlZERpc3BsYXkgPSBvcC5tdXN0VXBkYXRlICYmIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChvcC5jbSwgb3AudXBkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9SMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAob3AudXBkYXRlZERpc3BsYXkpIHsgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pOyB9XG5cbiAgICBvcC5iYXJNZWFzdXJlID0gbWVhc3VyZUZvclNjcm9sbGJhcnMoY20pO1xuXG4gICAgLy8gSWYgdGhlIG1heCBsaW5lIGNoYW5nZWQgc2luY2UgaXQgd2FzIGxhc3QgbWVhc3VyZWQsIG1lYXN1cmUgaXQsXG4gICAgLy8gYW5kIGVuc3VyZSB0aGUgZG9jdW1lbnQncyB3aWR0aCBtYXRjaGVzIGl0LlxuICAgIC8vIHVwZGF0ZURpc3BsYXlfVzIgd2lsbCB1c2UgdGhlc2UgcHJvcGVydGllcyB0byBkbyB0aGUgYWN0dWFsIHJlc2l6aW5nXG4gICAgaWYgKGRpc3BsYXkubWF4TGluZUNoYW5nZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBvcC5hZGp1c3RXaWR0aFRvID0gbWVhc3VyZUNoYXIoY20sIGRpc3BsYXkubWF4TGluZSwgZGlzcGxheS5tYXhMaW5lLnRleHQubGVuZ3RoKS5sZWZ0ICsgMztcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCA9IG9wLmFkanVzdFdpZHRoVG87XG4gICAgICBvcC5iYXJNZWFzdXJlLnNjcm9sbFdpZHRoID1cbiAgICAgICAgTWF0aC5tYXgoZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyArIHNjcm9sbEdhcChjbSkgKyBjbS5kaXNwbGF5LmJhcldpZHRoKTtcbiAgICAgIG9wLm1heFNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCBkaXNwbGF5LnNpemVyLm9mZnNldExlZnQgKyBvcC5hZGp1c3RXaWR0aFRvIC0gZGlzcGxheVdpZHRoKGNtKSk7XG4gICAgfVxuXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnNlbGVjdGlvbkNoYW5nZWQpXG4gICAgICB7IG9wLnByZXBhcmVkU2VsZWN0aW9uID0gZGlzcGxheS5pbnB1dC5wcmVwYXJlU2VsZWN0aW9uKCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMihvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtO1xuXG4gICAgaWYgKG9wLmFkanVzdFdpZHRoVG8gIT0gbnVsbCkge1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IG9wLmFkanVzdFdpZHRoVG8gKyBcInB4XCI7XG4gICAgICBpZiAob3AubWF4U2Nyb2xsTGVmdCA8IGNtLmRvYy5zY3JvbGxMZWZ0KVxuICAgICAgICB7IHNldFNjcm9sbExlZnQoY20sIE1hdGgubWluKGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgb3AubWF4U2Nyb2xsTGVmdCksIHRydWUpOyB9XG4gICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHRha2VGb2N1cyA9IG9wLmZvY3VzICYmIG9wLmZvY3VzID09IGFjdGl2ZUVsdCgpO1xuICAgIGlmIChvcC5wcmVwYXJlZFNlbGVjdGlvbilcbiAgICAgIHsgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKG9wLnByZXBhcmVkU2VsZWN0aW9uLCB0YWtlRm9jdXMpOyB9XG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5IHx8IG9wLnN0YXJ0SGVpZ2h0ICE9IGNtLmRvYy5oZWlnaHQpXG4gICAgICB7IHVwZGF0ZVNjcm9sbGJhcnMoY20sIG9wLmJhck1lYXN1cmUpOyB9XG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KVxuICAgICAgeyBzZXREb2N1bWVudEhlaWdodChjbSwgb3AuYmFyTWVhc3VyZSk7IH1cblxuICAgIGlmIChvcC5zZWxlY3Rpb25DaGFuZ2VkKSB7IHJlc3RhcnRCbGluayhjbSk7IH1cblxuICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkICYmIG9wLnVwZGF0ZUlucHV0KVxuICAgICAgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KG9wLnR5cGluZyk7IH1cbiAgICBpZiAodGFrZUZvY3VzKSB7IGVuc3VyZUZvY3VzKG9wLmNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX2ZpbmlzaChvcCkge1xuICAgIHZhciBjbSA9IG9wLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuXG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHBvc3RVcGRhdGVEaXNwbGF5KGNtLCBvcC51cGRhdGUpOyB9XG5cbiAgICAvLyBBYm9ydCBtb3VzZSB3aGVlbCBkZWx0YSBtZWFzdXJlbWVudCwgd2hlbiBzY3JvbGxpbmcgZXhwbGljaXRseVxuICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYICE9IG51bGwgJiYgKG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8IG9wLnNjcm9sbExlZnQgIT0gbnVsbCB8fCBvcC5zY3JvbGxUb1BvcykpXG4gICAgICB7IGRpc3BsYXkud2hlZWxTdGFydFggPSBkaXNwbGF5LndoZWVsU3RhcnRZID0gbnVsbDsgfVxuXG4gICAgLy8gUHJvcGFnYXRlIHRoZSBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIGFjdHVhbCBET00gc2Nyb2xsZXJcbiAgICBpZiAob3Auc2Nyb2xsVG9wICE9IG51bGwpIHsgc2V0U2Nyb2xsVG9wKGNtLCBvcC5zY3JvbGxUb3AsIG9wLmZvcmNlU2Nyb2xsKTsgfVxuXG4gICAgaWYgKG9wLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBvcC5zY3JvbGxMZWZ0LCB0cnVlLCB0cnVlKTsgfVxuICAgIC8vIElmIHdlIG5lZWQgdG8gc2Nyb2xsIGEgc3BlY2lmaWMgcG9zaXRpb24gaW50byB2aWV3LCBkbyBzby5cbiAgICBpZiAob3Auc2Nyb2xsVG9Qb3MpIHtcbiAgICAgIHZhciByZWN0ID0gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy5mcm9tKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIG9wLnNjcm9sbFRvUG9zLnRvKSwgb3Auc2Nyb2xsVG9Qb3MubWFyZ2luKTtcbiAgICAgIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KTtcbiAgICB9XG5cbiAgICAvLyBGaXJlIGV2ZW50cyBmb3IgbWFya2VycyB0aGF0IGFyZSBoaWRkZW4vdW5pZGRlbiBieSBlZGl0aW5nIG9yXG4gICAgLy8gdW5kb2luZ1xuICAgIHZhciBoaWRkZW4gPSBvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHVuaGlkZGVuID0gb3AubWF5YmVVbmhpZGRlbk1hcmtlcnM7XG4gICAgaWYgKGhpZGRlbikgeyBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbi5sZW5ndGg7ICsraSlcbiAgICAgIHsgaWYgKCFoaWRkZW5baV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbChoaWRkZW5baV0sIFwiaGlkZVwiKTsgfSB9IH1cbiAgICBpZiAodW5oaWRkZW4pIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdW5oaWRkZW4ubGVuZ3RoOyArK2kkMSlcbiAgICAgIHsgaWYgKHVuaGlkZGVuW2kkMV0ubGluZXMubGVuZ3RoKSB7IHNpZ25hbCh1bmhpZGRlbltpJDFdLCBcInVuaGlkZVwiKTsgfSB9IH1cblxuICAgIGlmIChkaXNwbGF5LndyYXBwZXIub2Zmc2V0SGVpZ2h0KVxuICAgICAgeyBkb2Muc2Nyb2xsVG9wID0gY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7IH1cblxuICAgIC8vIEZpcmUgY2hhbmdlIGV2ZW50cywgYW5kIGRlbGF5ZWQgZXZlbnQgaGFuZGxlcnNcbiAgICBpZiAob3AuY2hhbmdlT2JqcylcbiAgICAgIHsgc2lnbmFsKGNtLCBcImNoYW5nZXNcIiwgY20sIG9wLmNoYW5nZU9ianMpOyB9XG4gICAgaWYgKG9wLnVwZGF0ZSlcbiAgICAgIHsgb3AudXBkYXRlLmZpbmlzaCgpOyB9XG4gIH1cblxuICAvLyBSdW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvblxuICBmdW5jdGlvbiBydW5Jbk9wKGNtLCBmKSB7XG4gICAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmKCkgfVxuICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICB0cnkgeyByZXR1cm4gZigpIH1cbiAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICB9XG4gIC8vIFdyYXBzIGEgZnVuY3Rpb24gaW4gYW4gb3BlcmF0aW9uLiBSZXR1cm5zIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICBmdW5jdGlvbiBvcGVyYXRpb24oY20sIGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoY20uY3VyT3ApIHsgcmV0dXJuIGYuYXBwbHkoY20sIGFyZ3VtZW50cykgfVxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkoY20sIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cbiAgICB9XG4gIH1cbiAgLy8gVXNlZCB0byBhZGQgbWV0aG9kcyB0byBlZGl0b3IgYW5kIGRvYyBpbnN0YW5jZXMsIHdyYXBwaW5nIHRoZW0gaW5cbiAgLy8gb3BlcmF0aW9ucy5cbiAgZnVuY3Rpb24gbWV0aG9kT3AoZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgc3RhcnRPcGVyYXRpb24odGhpcyk7XG4gICAgICB0cnkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24odGhpcyk7IH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZG9jTWV0aG9kT3AoZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjbSA9IHRoaXMuY207XG4gICAgICBpZiAoIWNtIHx8IGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgc3RhcnRPcGVyYXRpb24oY20pO1xuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEhJR0hMSUdIVCBXT1JLRVJcblxuICBmdW5jdGlvbiBzdGFydFdvcmtlcihjbSwgdGltZSkge1xuICAgIGlmIChjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPCBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgIHsgY20uc3RhdGUuaGlnaGxpZ2h0LnNldCh0aW1lLCBiaW5kKGhpZ2hsaWdodFdvcmtlciwgY20pKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0V29ya2VyKGNtKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBpZiAoZG9jLmhpZ2hsaWdodEZyb250aWVyID49IGNtLmRpc3BsYXkudmlld1RvKSB7IHJldHVybiB9XG4gICAgdmFyIGVuZCA9ICtuZXcgRGF0ZSArIGNtLm9wdGlvbnMud29ya1RpbWU7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIpO1xuICAgIHZhciBjaGFuZ2VkTGluZXMgPSBbXTtcblxuICAgIGRvYy5pdGVyKGNvbnRleHQubGluZSwgTWF0aC5taW4oZG9jLmZpcnN0ICsgZG9jLnNpemUsIGNtLmRpc3BsYXkudmlld1RvICsgNTAwKSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChjb250ZXh0LmxpbmUgPj0gY20uZGlzcGxheS52aWV3RnJvbSkgeyAvLyBWaXNpYmxlXG4gICAgICAgIHZhciBvbGRTdHlsZXMgPSBsaW5lLnN0eWxlcztcbiAgICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggPyBjb3B5U3RhdGUoZG9jLm1vZGUsIGNvbnRleHQuc3RhdGUpIDogbnVsbDtcbiAgICAgICAgdmFyIGhpZ2hsaWdodGVkID0gaGlnaGxpZ2h0TGluZShjbSwgbGluZSwgY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIGlmIChyZXNldFN0YXRlKSB7IGNvbnRleHQuc3RhdGUgPSByZXNldFN0YXRlOyB9XG4gICAgICAgIGxpbmUuc3R5bGVzID0gaGlnaGxpZ2h0ZWQuc3R5bGVzO1xuICAgICAgICB2YXIgb2xkQ2xzID0gbGluZS5zdHlsZUNsYXNzZXMsIG5ld0NscyA9IGhpZ2hsaWdodGVkLmNsYXNzZXM7XG4gICAgICAgIGlmIChuZXdDbHMpIHsgbGluZS5zdHlsZUNsYXNzZXMgPSBuZXdDbHM7IH1cbiAgICAgICAgZWxzZSBpZiAob2xkQ2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDsgfVxuICAgICAgICB2YXIgaXNjaGFuZ2UgPSAhb2xkU3R5bGVzIHx8IG9sZFN0eWxlcy5sZW5ndGggIT0gbGluZS5zdHlsZXMubGVuZ3RoIHx8XG4gICAgICAgICAgb2xkQ2xzICE9IG5ld0NscyAmJiAoIW9sZENscyB8fCAhbmV3Q2xzIHx8IG9sZENscy5iZ0NsYXNzICE9IG5ld0Nscy5iZ0NsYXNzIHx8IG9sZENscy50ZXh0Q2xhc3MgIT0gbmV3Q2xzLnRleHRDbGFzcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyAhaXNjaGFuZ2UgJiYgaSA8IG9sZFN0eWxlcy5sZW5ndGg7ICsraSkgeyBpc2NoYW5nZSA9IG9sZFN0eWxlc1tpXSAhPSBsaW5lLnN0eWxlc1tpXTsgfVxuICAgICAgICBpZiAoaXNjaGFuZ2UpIHsgY2hhbmdlZExpbmVzLnB1c2goY29udGV4dC5saW5lKTsgfVxuICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgY29udGV4dC5uZXh0TGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxpbmUudGV4dC5sZW5ndGggPD0gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGgpXG4gICAgICAgICAgeyBwcm9jZXNzTGluZShjbSwgbGluZS50ZXh0LCBjb250ZXh0KTsgfVxuICAgICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LmxpbmUgJSA1ID09IDAgPyBjb250ZXh0LnNhdmUoKSA6IG51bGw7XG4gICAgICAgIGNvbnRleHQubmV4dExpbmUoKTtcbiAgICAgIH1cbiAgICAgIGlmICgrbmV3IERhdGUgPiBlbmQpIHtcbiAgICAgICAgc3RhcnRXb3JrZXIoY20sIGNtLm9wdGlvbnMud29ya0RlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBjb250ZXh0LmxpbmU7XG4gICAgZG9jLm1vZGVGcm9udGllciA9IE1hdGgubWF4KGRvYy5tb2RlRnJvbnRpZXIsIGNvbnRleHQubGluZSk7XG4gICAgaWYgKGNoYW5nZWRMaW5lcy5sZW5ndGgpIHsgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VkTGluZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgY2hhbmdlZExpbmVzW2ldLCBcInRleHRcIik7IH1cbiAgICB9KTsgfVxuICB9XG5cbiAgLy8gRElTUExBWSBEUkFXSU5HXG5cbiAgdmFyIERpc3BsYXlVcGRhdGUgPSBmdW5jdGlvbihjbSwgdmlld3BvcnQsIGZvcmNlKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuXG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIC8vIFN0b3JlIHNvbWUgdmFsdWVzIHRoYXQgd2UnbGwgbmVlZCBsYXRlciAoYnV0IGRvbid0IHdhbnQgdG8gZm9yY2UgYSByZWxheW91dCBmb3IpXG4gICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgIHRoaXMuZWRpdG9ySXNIaWRkZW4gPSAhZGlzcGxheS53cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgIHRoaXMud3JhcHBlckhlaWdodCA9IGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgdGhpcy53cmFwcGVyV2lkdGggPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGg7XG4gICAgdGhpcy5vbGREaXNwbGF5V2lkdGggPSBkaXNwbGF5V2lkdGgoY20pO1xuICAgIHRoaXMuZm9yY2UgPSBmb3JjZTtcbiAgICB0aGlzLmRpbXMgPSBnZXREaW1lbnNpb25zKGNtKTtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICB9O1xuXG4gIERpc3BsYXlVcGRhdGUucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gICAgaWYgKGhhc0hhbmRsZXIoZW1pdHRlciwgdHlwZSkpXG4gICAgICB7IHRoaXMuZXZlbnRzLnB1c2goYXJndW1lbnRzKTsgfVxuICB9O1xuICBEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHsgc2lnbmFsLmFwcGx5KG51bGwsIHRoaXMuZXZlbnRzW2ldKTsgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKCFkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkICYmIGRpc3BsYXkuc2Nyb2xsZXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgIGRpc3BsYXkubmF0aXZlQmFyV2lkdGggPSBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoIC0gZGlzcGxheS5zY3JvbGxlci5jbGllbnRXaWR0aDtcbiAgICAgIGRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLmhlaWdodCA9IHNjcm9sbEdhcChjbSkgKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNpemVyLnN0eWxlLm1hcmdpbkJvdHRvbSA9IC1kaXNwbGF5Lm5hdGl2ZUJhcldpZHRoICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zaXplci5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gc2Nyb2xsR2FwKGNtKSArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2Nyb2xsYmFyc0NsaXBwZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvblNuYXBzaG90KGNtKSB7XG4gICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBhY3RpdmUgPSBhY3RpdmVFbHQoKTtcbiAgICBpZiAoIWFjdGl2ZSB8fCAhY29udGFpbnMoY20uZGlzcGxheS5saW5lRGl2LCBhY3RpdmUpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcmVzdWx0ID0ge2FjdGl2ZUVsdDogYWN0aXZlfTtcbiAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmIChzZWwuYW5jaG9yTm9kZSAmJiBzZWwuZXh0ZW5kICYmIGNvbnRhaW5zKGNtLmRpc3BsYXkubGluZURpdiwgc2VsLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIHJlc3VsdC5hbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7XG4gICAgICAgIHJlc3VsdC5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICByZXN1bHQuZm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTtcbiAgICAgICAgcmVzdWx0LmZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHNuYXBzaG90KSB7XG4gICAgaWYgKCFzbmFwc2hvdCB8fCAhc25hcHNob3QuYWN0aXZlRWx0IHx8IHNuYXBzaG90LmFjdGl2ZUVsdCA9PSBhY3RpdmVFbHQoKSkgeyByZXR1cm4gfVxuICAgIHNuYXBzaG90LmFjdGl2ZUVsdC5mb2N1cygpO1xuICAgIGlmICghL14oSU5QVVR8VEVYVEFSRUEpJC8udGVzdChzbmFwc2hvdC5hY3RpdmVFbHQubm9kZU5hbWUpICYmXG4gICAgICAgIHNuYXBzaG90LmFuY2hvck5vZGUgJiYgY29udGFpbnMoZG9jdW1lbnQuYm9keSwgc25hcHNob3QuYW5jaG9yTm9kZSkgJiYgY29udGFpbnMoZG9jdW1lbnQuYm9keSwgc25hcHNob3QuZm9jdXNOb2RlKSkge1xuICAgICAgdmFyIHNlbCA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSwgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2V0RW5kKHNuYXBzaG90LmFuY2hvck5vZGUsIHNuYXBzaG90LmFuY2hvck9mZnNldCk7XG4gICAgICByYW5nZS5jb2xsYXBzZShmYWxzZSk7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICBzZWwuYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsLmV4dGVuZChzbmFwc2hvdC5mb2N1c05vZGUsIHNuYXBzaG90LmZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICAvLyBEb2VzIHRoZSBhY3R1YWwgdXBkYXRpbmcgb2YgdGhlIGxpbmUgZGlzcGxheS4gQmFpbHMgb3V0XG4gIC8vIChyZXR1cm5pbmcgZmFsc2UpIHdoZW4gdGhlcmUgaXMgbm90aGluZyB0byBiZSBkb25lIGFuZCBmb3JjZWQgaXNcbiAgLy8gZmFsc2UuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG5cbiAgICBpZiAodXBkYXRlLmVkaXRvcklzSGlkZGVuKSB7XG4gICAgICByZXNldFZpZXcoY20pO1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgdGhlIHZpc2libGUgYXJlYSBpcyBhbHJlYWR5IHJlbmRlcmVkIGFuZCBub3RoaW5nIGNoYW5nZWQuXG4gICAgaWYgKCF1cGRhdGUuZm9yY2UgJiZcbiAgICAgICAgdXBkYXRlLnZpc2libGUuZnJvbSA+PSBkaXNwbGF5LnZpZXdGcm9tICYmIHVwZGF0ZS52aXNpYmxlLnRvIDw9IGRpc3BsYXkudmlld1RvICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykgJiZcbiAgICAgICAgZGlzcGxheS5yZW5kZXJlZFZpZXcgPT0gZGlzcGxheS52aWV3ICYmIGNvdW50RGlydHlWaWV3KGNtKSA9PSAwKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSkge1xuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIHVwZGF0ZS5kaW1zID0gZ2V0RGltZW5zaW9ucyhjbSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBhIHN1aXRhYmxlIG5ldyB2aWV3cG9ydCAoZnJvbSAmIHRvKVxuICAgIHZhciBlbmQgPSBkb2MuZmlyc3QgKyBkb2Muc2l6ZTtcbiAgICB2YXIgZnJvbSA9IE1hdGgubWF4KHVwZGF0ZS52aXNpYmxlLmZyb20gLSBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luLCBkb2MuZmlyc3QpO1xuICAgIHZhciB0byA9IE1hdGgubWluKGVuZCwgdXBkYXRlLnZpc2libGUudG8gKyBjbS5vcHRpb25zLnZpZXdwb3J0TWFyZ2luKTtcbiAgICBpZiAoZGlzcGxheS52aWV3RnJvbSA8IGZyb20gJiYgZnJvbSAtIGRpc3BsYXkudmlld0Zyb20gPCAyMCkgeyBmcm9tID0gTWF0aC5tYXgoZG9jLmZpcnN0LCBkaXNwbGF5LnZpZXdGcm9tKTsgfVxuICAgIGlmIChkaXNwbGF5LnZpZXdUbyA+IHRvICYmIGRpc3BsYXkudmlld1RvIC0gdG8gPCAyMCkgeyB0byA9IE1hdGgubWluKGVuZCwgZGlzcGxheS52aWV3VG8pOyB9XG4gICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zKSB7XG4gICAgICBmcm9tID0gdmlzdWFsTGluZU5vKGNtLmRvYywgZnJvbSk7XG4gICAgICB0byA9IHZpc3VhbExpbmVFbmRObyhjbS5kb2MsIHRvKTtcbiAgICB9XG5cbiAgICB2YXIgZGlmZmVyZW50ID0gZnJvbSAhPSBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvICE9IGRpc3BsYXkudmlld1RvIHx8XG4gICAgICBkaXNwbGF5Lmxhc3RXcmFwSGVpZ2h0ICE9IHVwZGF0ZS53cmFwcGVySGVpZ2h0IHx8IGRpc3BsYXkubGFzdFdyYXBXaWR0aCAhPSB1cGRhdGUud3JhcHBlcldpZHRoO1xuICAgIGFkanVzdFZpZXcoY20sIGZyb20sIHRvKTtcblxuICAgIGRpc3BsYXkudmlld09mZnNldCA9IGhlaWdodEF0TGluZShnZXRMaW5lKGNtLmRvYywgZGlzcGxheS52aWV3RnJvbSkpO1xuICAgIC8vIFBvc2l0aW9uIHRoZSBtb3ZlciBkaXYgdG8gYWxpZ24gd2l0aCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICBjbS5kaXNwbGF5Lm1vdmVyLnN0eWxlLnRvcCA9IGRpc3BsYXkudmlld09mZnNldCArIFwicHhcIjtcblxuICAgIHZhciB0b1VwZGF0ZSA9IGNvdW50RGlydHlWaWV3KGNtKTtcbiAgICBpZiAoIWRpZmZlcmVudCAmJiB0b1VwZGF0ZSA9PSAwICYmICF1cGRhdGUuZm9yY2UgJiYgZGlzcGxheS5yZW5kZXJlZFZpZXcgPT0gZGlzcGxheS52aWV3ICYmXG4gICAgICAgIChkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID09IG51bGwgfHwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA+PSBkaXNwbGF5LnZpZXdUbykpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICAvLyBGb3IgYmlnIGNoYW5nZXMsIHdlIGhpZGUgdGhlIGVuY2xvc2luZyBlbGVtZW50IGR1cmluZyB0aGVcbiAgICAvLyB1cGRhdGUsIHNpbmNlIHRoYXQgc3BlZWRzIHVwIHRoZSBvcGVyYXRpb25zIG9uIG1vc3QgYnJvd3NlcnMuXG4gICAgdmFyIHNlbFNuYXBzaG90ID0gc2VsZWN0aW9uU25hcHNob3QoY20pO1xuICAgIGlmICh0b1VwZGF0ZSA+IDQpIHsgZGlzcGxheS5saW5lRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjsgfVxuICAgIHBhdGNoRGlzcGxheShjbSwgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycywgdXBkYXRlLmRpbXMpO1xuICAgIGlmICh0b1VwZGF0ZSA+IDQpIHsgZGlzcGxheS5saW5lRGl2LnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG4gICAgZGlzcGxheS5yZW5kZXJlZFZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgLy8gVGhlcmUgbWlnaHQgaGF2ZSBiZWVuIGEgd2lkZ2V0IHdpdGggYSBmb2N1c2VkIGVsZW1lbnQgdGhhdCBnb3RcbiAgICAvLyBoaWRkZW4gb3IgdXBkYXRlZCwgaWYgc28gcmUtZm9jdXMgaXQuXG4gICAgcmVzdG9yZVNlbGVjdGlvbihzZWxTbmFwc2hvdCk7XG5cbiAgICAvLyBQcmV2ZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycyBmcm9tIGludGVyZmVyaW5nIHdpdGggdGhlIHNjcm9sbFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuc2VsZWN0aW9uRGl2KTtcbiAgICBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUuaGVpZ2h0ID0gZGlzcGxheS5zaXplci5zdHlsZS5taW5IZWlnaHQgPSAwO1xuXG4gICAgaWYgKGRpZmZlcmVudCkge1xuICAgICAgZGlzcGxheS5sYXN0V3JhcEhlaWdodCA9IHVwZGF0ZS53cmFwcGVySGVpZ2h0O1xuICAgICAgZGlzcGxheS5sYXN0V3JhcFdpZHRoID0gdXBkYXRlLndyYXBwZXJXaWR0aDtcbiAgICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuICAgIH1cblxuICAgIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPSBudWxsO1xuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpIHtcbiAgICB2YXIgdmlld3BvcnQgPSB1cGRhdGUudmlld3BvcnQ7XG5cbiAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICBpZiAoIWZpcnN0IHx8ICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyB8fCB1cGRhdGUub2xkRGlzcGxheVdpZHRoID09IGRpc3BsYXlXaWR0aChjbSkpIHtcbiAgICAgICAgLy8gQ2xpcCBmb3JjZWQgdmlld3BvcnQgdG8gYWN0dWFsIHNjcm9sbGFibGUgYXJlYS5cbiAgICAgICAgaWYgKHZpZXdwb3J0ICYmIHZpZXdwb3J0LnRvcCAhPSBudWxsKVxuICAgICAgICAgIHsgdmlld3BvcnQgPSB7dG9wOiBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0ICsgcGFkZGluZ1ZlcnQoY20uZGlzcGxheSkgLSBkaXNwbGF5SGVpZ2h0KGNtKSwgdmlld3BvcnQudG9wKX07IH1cbiAgICAgICAgLy8gVXBkYXRlZCBsaW5lIGhlaWdodHMgbWlnaHQgcmVzdWx0IGluIHRoZSBkcmF3biBhcmVhIG5vdFxuICAgICAgICAvLyBhY3R1YWxseSBjb3ZlcmluZyB0aGUgdmlld3BvcnQuIEtlZXAgbG9vcGluZyB1bnRpbCBpdCBkb2VzLlxuICAgICAgICB1cGRhdGUudmlzaWJsZSA9IHZpc2libGVMaW5lcyhjbS5kaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICAgICAgaWYgKHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgICAgICB7IGJyZWFrIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QpIHtcbiAgICAgICAgdXBkYXRlLnZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSkgeyBicmVhayB9XG4gICAgICB1cGRhdGVIZWlnaHRzSW5WaWV3cG9ydChjbSk7XG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNlbGVjdGlvbihjbSk7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHVwZGF0ZS5mb3JjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHVwZGF0ZS5zaWduYWwoY20sIFwidXBkYXRlXCIsIGNtKTtcbiAgICBpZiAoY20uZGlzcGxheS52aWV3RnJvbSAhPSBjbS5kaXNwbGF5LnJlcG9ydGVkVmlld0Zyb20gfHwgY20uZGlzcGxheS52aWV3VG8gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbykge1xuICAgICAgdXBkYXRlLnNpZ25hbChjbSwgXCJ2aWV3cG9ydENoYW5nZVwiLCBjbSwgY20uZGlzcGxheS52aWV3RnJvbSwgY20uZGlzcGxheS52aWV3VG8pO1xuICAgICAgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tID0gY20uZGlzcGxheS52aWV3RnJvbTsgY20uZGlzcGxheS5yZXBvcnRlZFZpZXdUbyA9IGNtLmRpc3BsYXkudmlld1RvO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHZpZXdwb3J0KSB7XG4gICAgdmFyIHVwZGF0ZSA9IG5ldyBEaXNwbGF5VXBkYXRlKGNtLCB2aWV3cG9ydCk7XG4gICAgaWYgKHVwZGF0ZURpc3BsYXlJZk5lZWRlZChjbSwgdXBkYXRlKSkge1xuICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgcG9zdFVwZGF0ZURpc3BsYXkoY20sIHVwZGF0ZSk7XG4gICAgICB2YXIgYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNlbGVjdGlvbihjbSk7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHNldERvY3VtZW50SGVpZ2h0KGNtLCBiYXJNZWFzdXJlKTtcbiAgICAgIHVwZGF0ZS5maW5pc2goKTtcbiAgICB9XG4gIH1cblxuICAvLyBTeW5jIHRoZSBhY3R1YWwgZGlzcGxheSBET00gc3RydWN0dXJlIHdpdGggZGlzcGxheS52aWV3LCByZW1vdmluZ1xuICAvLyBub2RlcyBmb3IgbGluZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHZpZXcsIGFuZCBjcmVhdGluZyB0aGUgb25lc1xuICAvLyB0aGF0IGFyZSBub3QgdGhlcmUgeWV0LCBhbmQgdXBkYXRpbmcgdGhlIG9uZXMgdGhhdCBhcmUgb3V0IG9mXG4gIC8vIGRhdGUuXG4gIGZ1bmN0aW9uIHBhdGNoRGlzcGxheShjbSwgdXBkYXRlTnVtYmVyc0Zyb20sIGRpbXMpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGxpbmVOdW1iZXJzID0gY20ub3B0aW9ucy5saW5lTnVtYmVycztcbiAgICB2YXIgY29udGFpbmVyID0gZGlzcGxheS5saW5lRGl2LCBjdXIgPSBjb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgIGZ1bmN0aW9uIHJtKG5vZGUpIHtcbiAgICAgIHZhciBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIC8vIFdvcmtzIGFyb3VuZCBhIHRocm93LXNjcm9sbCBidWcgaW4gT1MgWCBXZWJraXRcbiAgICAgIGlmICh3ZWJraXQgJiYgbWFjICYmIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID09IG5vZGUpXG4gICAgICAgIHsgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7IH1cbiAgICAgIHJldHVybiBuZXh0XG4gICAgfVxuXG4gICAgdmFyIHZpZXcgPSBkaXNwbGF5LnZpZXcsIGxpbmVOID0gZGlzcGxheS52aWV3RnJvbTtcbiAgICAvLyBMb29wIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoZSB2aWV3LCBzeW5jaW5nIGN1ciAodGhlIERPTSBub2Rlc1xuICAgIC8vIGluIGRpc3BsYXkubGluZURpdikgd2l0aCB0aGUgdmlldyBhcyB3ZSBnby5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IHZpZXdbaV07XG4gICAgICBpZiAobGluZVZpZXcuaGlkZGVuKSA7IGVsc2UgaWYgKCFsaW5lVmlldy5ub2RlIHx8IGxpbmVWaWV3Lm5vZGUucGFyZW50Tm9kZSAhPSBjb250YWluZXIpIHsgLy8gTm90IGRyYXduIHlldFxuICAgICAgICB2YXIgbm9kZSA9IGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUobm9kZSwgY3VyKTtcbiAgICAgIH0gZWxzZSB7IC8vIEFscmVhZHkgZHJhd25cbiAgICAgICAgd2hpbGUgKGN1ciAhPSBsaW5lVmlldy5ub2RlKSB7IGN1ciA9IHJtKGN1cik7IH1cbiAgICAgICAgdmFyIHVwZGF0ZU51bWJlciA9IGxpbmVOdW1iZXJzICYmIHVwZGF0ZU51bWJlcnNGcm9tICE9IG51bGwgJiZcbiAgICAgICAgICB1cGRhdGVOdW1iZXJzRnJvbSA8PSBsaW5lTiAmJiBsaW5lVmlldy5saW5lTnVtYmVyO1xuICAgICAgICBpZiAobGluZVZpZXcuY2hhbmdlcykge1xuICAgICAgICAgIGlmIChpbmRleE9mKGxpbmVWaWV3LmNoYW5nZXMsIFwiZ3V0dGVyXCIpID4gLTEpIHsgdXBkYXRlTnVtYmVyID0gZmFsc2U7IH1cbiAgICAgICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlTnVtYmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4obGluZVZpZXcubGluZU51bWJlcik7XG4gICAgICAgICAgbGluZVZpZXcubGluZU51bWJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lTnVtYmVyRm9yKGNtLm9wdGlvbnMsIGxpbmVOKSkpO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGxpbmVWaWV3Lm5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBsaW5lTiArPSBsaW5lVmlldy5zaXplO1xuICAgIH1cbiAgICB3aGlsZSAoY3VyKSB7IGN1ciA9IHJtKGN1cik7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUd1dHRlclNwYWNlKGRpc3BsYXkpIHtcbiAgICB2YXIgd2lkdGggPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5MZWZ0ID0gd2lkdGggKyBcInB4XCI7XG4gICAgLy8gU2VuZCBhbiBldmVudCB0byBjb25zdW1lcnMgcmVzcG9uZGluZyB0byBjaGFuZ2VzIGluIGd1dHRlciB3aWR0aC5cbiAgICBzaWduYWxMYXRlcihkaXNwbGF5LCBcImd1dHRlckNoYW5nZWRcIiwgZGlzcGxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREb2N1bWVudEhlaWdodChjbSwgbWVhc3VyZSkge1xuICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XG4gICAgY20uZGlzcGxheS5oZWlnaHRGb3JjZXIuc3R5bGUudG9wID0gbWVhc3VyZS5kb2NIZWlnaHQgKyBcInB4XCI7XG4gICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IChtZWFzdXJlLmRvY0hlaWdodCArIGNtLmRpc3BsYXkuYmFySGVpZ2h0ICsgc2Nyb2xsR2FwKGNtKSkgKyBcInB4XCI7XG4gIH1cblxuICAvLyBSZS1hbGlnbiBsaW5lIG51bWJlcnMgYW5kIGd1dHRlciBtYXJrcyB0byBjb21wZW5zYXRlIGZvclxuICAvLyBob3Jpem9udGFsIHNjcm9sbGluZy5cbiAgZnVuY3Rpb24gYWxpZ25Ib3Jpem9udGFsbHkoY20pIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHZpZXcgPSBkaXNwbGF5LnZpZXc7XG4gICAgaWYgKCFkaXNwbGF5LmFsaWduV2lkZ2V0cyAmJiAoIWRpc3BsYXkuZ3V0dGVycy5maXJzdENoaWxkIHx8ICFjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSkgeyByZXR1cm4gfVxuICAgIHZhciBjb21wID0gY29tcGVuc2F0ZUZvckhTY3JvbGwoZGlzcGxheSkgLSBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgKyBjbS5kb2Muc2Nyb2xsTGVmdDtcbiAgICB2YXIgZ3V0dGVyVyA9IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aCwgbGVmdCA9IGNvbXAgKyBcInB4XCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7IGlmICghdmlld1tpXS5oaWRkZW4pIHtcbiAgICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XG4gICAgICAgIGlmICh2aWV3W2ldLmd1dHRlcilcbiAgICAgICAgICB7IHZpZXdbaV0uZ3V0dGVyLnN0eWxlLmxlZnQgPSBsZWZ0OyB9XG4gICAgICAgIGlmICh2aWV3W2ldLmd1dHRlckJhY2tncm91bmQpXG4gICAgICAgICAgeyB2aWV3W2ldLmd1dHRlckJhY2tncm91bmQuc3R5bGUubGVmdCA9IGxlZnQ7IH1cbiAgICAgIH1cbiAgICAgIHZhciBhbGlnbiA9IHZpZXdbaV0uYWxpZ25hYmxlO1xuICAgICAgaWYgKGFsaWduKSB7IGZvciAodmFyIGogPSAwOyBqIDwgYWxpZ24ubGVuZ3RoOyBqKyspXG4gICAgICAgIHsgYWxpZ25bal0uc3R5bGUubGVmdCA9IGxlZnQ7IH0gfVxuICAgIH0gfVxuICAgIGlmIChjbS5vcHRpb25zLmZpeGVkR3V0dGVyKVxuICAgICAgeyBkaXNwbGF5Lmd1dHRlcnMuc3R5bGUubGVmdCA9IChjb21wICsgZ3V0dGVyVykgKyBcInB4XCI7IH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciBpcyBzdGlsbCB0aGUgcmlnaHRcbiAgLy8gc2l6ZSBmb3IgdGhlIGN1cnJlbnQgZG9jdW1lbnQgc2l6ZS4gUmV0dXJucyB0cnVlIHdoZW4gYW4gdXBkYXRlXG4gIC8vIGlzIG5lZWRlZC5cbiAgZnVuY3Rpb24gbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgoY20pIHtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZU51bWJlcnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgZG9jID0gY20uZG9jLCBsYXN0ID0gbGluZU51bWJlckZvcihjbS5vcHRpb25zLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAobGFzdC5sZW5ndGggIT0gZGlzcGxheS5saW5lTnVtQ2hhcnMpIHtcbiAgICAgIHZhciB0ZXN0ID0gZGlzcGxheS5tZWFzdXJlLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBbZWx0KFwiZGl2XCIsIGxhc3QpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIikpO1xuICAgICAgdmFyIGlubmVyVyA9IHRlc3QuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aCwgcGFkZGluZyA9IHRlc3Qub2Zmc2V0V2lkdGggLSBpbm5lclc7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBcIlwiO1xuICAgICAgZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA9IE1hdGgubWF4KGlubmVyVywgZGlzcGxheS5saW5lR3V0dGVyLm9mZnNldFdpZHRoIC0gcGFkZGluZykgKyAxO1xuICAgICAgZGlzcGxheS5saW5lTnVtV2lkdGggPSBkaXNwbGF5LmxpbmVOdW1Jbm5lcldpZHRoICsgcGFkZGluZztcbiAgICAgIGRpc3BsYXkubGluZU51bUNoYXJzID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCA/IGxhc3QubGVuZ3RoIDogLTE7XG4gICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIuc3R5bGUud2lkdGggPSBkaXNwbGF5LmxpbmVOdW1XaWR0aCArIFwicHhcIjtcbiAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKGNtLmRpc3BsYXkpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmdW5jdGlvbiBnZXRHdXR0ZXJzKGd1dHRlcnMsIGxpbmVOdW1iZXJzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBzYXdMaW5lTnVtYmVycyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3V0dGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBndXR0ZXJzW2ldLCBzdHlsZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT0gXCJzdHJpbmdcIikgeyBzdHlsZSA9IG5hbWUuc3R5bGU7IG5hbWUgPSBuYW1lLmNsYXNzTmFtZTsgfVxuICAgICAgaWYgKG5hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgaWYgKCFsaW5lTnVtYmVycykgeyBjb250aW51ZSB9XG4gICAgICAgIGVsc2UgeyBzYXdMaW5lTnVtYmVycyA9IHRydWU7IH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHtjbGFzc05hbWU6IG5hbWUsIHN0eWxlOiBzdHlsZX0pO1xuICAgIH1cbiAgICBpZiAobGluZU51bWJlcnMgJiYgIXNhd0xpbmVOdW1iZXJzKSB7IHJlc3VsdC5wdXNoKHtjbGFzc05hbWU6IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiLCBzdHlsZTogbnVsbH0pOyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gUmVidWlsZCB0aGUgZ3V0dGVyIGVsZW1lbnRzLCBlbnN1cmUgdGhlIG1hcmdpbiB0byB0aGUgbGVmdCBvZiB0aGVcbiAgLy8gY29kZSBtYXRjaGVzIHRoZWlyIHdpZHRoLlxuICBmdW5jdGlvbiByZW5kZXJHdXR0ZXJzKGRpc3BsYXkpIHtcbiAgICB2YXIgZ3V0dGVycyA9IGRpc3BsYXkuZ3V0dGVycywgc3BlY3MgPSBkaXNwbGF5Lmd1dHRlclNwZWNzO1xuICAgIHJlbW92ZUNoaWxkcmVuKGd1dHRlcnMpO1xuICAgIGRpc3BsYXkubGluZUd1dHRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGVjcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHJlZiA9IHNwZWNzW2ldO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgICB2YXIgZ0VsdCA9IGd1dHRlcnMuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXIgXCIgKyBjbGFzc05hbWUpKTtcbiAgICAgIGlmIChzdHlsZSkgeyBnRWx0LnN0eWxlLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgICAgaWYgKGNsYXNzTmFtZSA9PSBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIikge1xuICAgICAgICBkaXNwbGF5LmxpbmVHdXR0ZXIgPSBnRWx0O1xuICAgICAgICBnRWx0LnN0eWxlLndpZHRoID0gKGRpc3BsYXkubGluZU51bVdpZHRoIHx8IDEpICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBndXR0ZXJzLnN0eWxlLmRpc3BsYXkgPSBzcGVjcy5sZW5ndGggPyBcIlwiIDogXCJub25lXCI7XG4gICAgdXBkYXRlR3V0dGVyU3BhY2UoZGlzcGxheSk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJzKGNtKSB7XG4gICAgcmVuZGVyR3V0dGVycyhjbS5kaXNwbGF5KTtcbiAgICByZWdDaGFuZ2UoY20pO1xuICAgIGFsaWduSG9yaXpvbnRhbGx5KGNtKTtcbiAgfVxuXG4gIC8vIFRoZSBkaXNwbGF5IGhhbmRsZXMgdGhlIERPTSBpbnRlZ3JhdGlvbiwgYm90aCBmb3IgaW5wdXQgcmVhZGluZ1xuICAvLyBhbmQgY29udGVudCBkcmF3aW5nLiBJdCBob2xkcyByZWZlcmVuY2VzIHRvIERPTSBub2RlcyBhbmRcbiAgLy8gZGlzcGxheS1yZWxhdGVkIHN0YXRlLlxuXG4gIGZ1bmN0aW9uIERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZCA9IHRoaXM7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gICAgLy8gQ292ZXJzIGJvdHRvbS1yaWdodCBzcXVhcmUgd2hlbiBib3RoIHNjcm9sbGJhcnMgYXJlIHByZXNlbnQuXG4gICAgZC5zY3JvbGxiYXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLXNjcm9sbGJhci1maWxsZXJcIik7XG4gICAgZC5zY3JvbGxiYXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIC8vIENvdmVycyBib3R0b20gb2YgZ3V0dGVyIHdoZW4gY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIgaXMgb25cbiAgICAvLyBhbmQgaCBzY3JvbGxiYXIgaXMgcHJlc2VudC5cbiAgICBkLmd1dHRlckZpbGxlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLWZpbGxlclwiKTtcbiAgICBkLmd1dHRlckZpbGxlci5zZXRBdHRyaWJ1dGUoXCJjbS1ub3QtY29udGVudFwiLCBcInRydWVcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBhY3R1YWwgY29kZSwgcG9zaXRpb25lZCB0byBjb3ZlciB0aGUgdmlld3BvcnQuXG4gICAgZC5saW5lRGl2ID0gZWx0UChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY29kZVwiKTtcbiAgICAvLyBFbGVtZW50cyBhcmUgYWRkZWQgdG8gdGhlc2UgdG8gcmVwcmVzZW50IHNlbGVjdGlvbiBhbmQgY3Vyc29ycy5cbiAgICBkLnNlbGVjdGlvbkRpdiA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgei1pbmRleDogMVwiKTtcbiAgICBkLmN1cnNvckRpdiA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29yc1wiKTtcbiAgICAvLyBBIHZpc2liaWxpdHk6IGhpZGRlbiBlbGVtZW50IHVzZWQgdG8gZmluZCB0aGUgc2l6ZSBvZiB0aGluZ3MuXG4gICAgZC5tZWFzdXJlID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1tZWFzdXJlXCIpO1xuICAgIC8vIFdoZW4gbGluZXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQgYXJlIG1lYXN1cmVkLCB0aGV5IGFyZSBkcmF3biBpbiB0aGlzLlxuICAgIGQubGluZU1lYXN1cmUgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLW1lYXN1cmVcIik7XG4gICAgLy8gV3JhcHMgZXZlcnl0aGluZyB0aGF0IG5lZWRzIHRvIGV4aXN0IGluc2lkZSB0aGUgdmVydGljYWxseS1wYWRkZWQgY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICBkLmxpbmVTcGFjZSA9IGVsdFAoXCJkaXZcIiwgW2QubWVhc3VyZSwgZC5saW5lTWVhc3VyZSwgZC5zZWxlY3Rpb25EaXYsIGQuY3Vyc29yRGl2LCBkLmxpbmVEaXZdLFxuICAgICAgICAgICAgICAgICAgICAgIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlOyBvdXRsaW5lOiBub25lXCIpO1xuICAgIHZhciBsaW5lcyA9IGVsdFAoXCJkaXZcIiwgW2QubGluZVNwYWNlXSwgXCJDb2RlTWlycm9yLWxpbmVzXCIpO1xuICAgIC8vIE1vdmVkIGFyb3VuZCBpdHMgcGFyZW50IHRvIGNvdmVyIHZpc2libGUgdmlldy5cbiAgICBkLm1vdmVyID0gZWx0KFwiZGl2XCIsIFtsaW5lc10sIG51bGwsIFwicG9zaXRpb246IHJlbGF0aXZlXCIpO1xuICAgIC8vIFNldCB0byB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudCwgYWxsb3dpbmcgc2Nyb2xsaW5nLlxuICAgIGQuc2l6ZXIgPSBlbHQoXCJkaXZcIiwgW2QubW92ZXJdLCBcIkNvZGVNaXJyb3Itc2l6ZXJcIik7XG4gICAgZC5zaXplcldpZHRoID0gbnVsbDtcbiAgICAvLyBCZWhhdmlvciBvZiBlbHRzIHdpdGggb3ZlcmZsb3c6IGF1dG8gYW5kIHBhZGRpbmcgaXNcbiAgICAvLyBpbmNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoZVxuICAgIC8vIHNjcm9sbGFibGUgYXJlYSBpcyBiaWcgZW5vdWdoLlxuICAgIGQuaGVpZ2h0Rm9yY2VyID0gZWx0KFwiZGl2XCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IFwiICsgc2Nyb2xsZXJHYXAgKyBcInB4OyB3aWR0aDogMXB4O1wiKTtcbiAgICAvLyBXaWxsIGNvbnRhaW4gdGhlIGd1dHRlcnMsIGlmIGFueS5cbiAgICBkLmd1dHRlcnMgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlcnNcIik7XG4gICAgZC5saW5lR3V0dGVyID0gbnVsbDtcbiAgICAvLyBBY3R1YWwgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIGQuc2Nyb2xsZXIgPSBlbHQoXCJkaXZcIiwgW2Quc2l6ZXIsIGQuaGVpZ2h0Rm9yY2VyLCBkLmd1dHRlcnNdLCBcIkNvZGVNaXJyb3Itc2Nyb2xsXCIpO1xuICAgIGQuc2Nyb2xsZXIuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgXCItMVwiKTtcbiAgICAvLyBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgZWRpdG9yIGxpdmVzLlxuICAgIGQud3JhcHBlciA9IGVsdChcImRpdlwiLCBbZC5zY3JvbGxiYXJGaWxsZXIsIGQuZ3V0dGVyRmlsbGVyLCBkLnNjcm9sbGVyXSwgXCJDb2RlTWlycm9yXCIpO1xuXG4gICAgLy8gV29yayBhcm91bmQgSUU3IHotaW5kZXggYnVnIChub3QgcGVyZmVjdCwgaGVuY2UgSUU3IG5vdCByZWFsbHkgYmVpbmcgc3VwcG9ydGVkKVxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBkLmd1dHRlcnMuc3R5bGUuekluZGV4ID0gLTE7IGQuc2Nyb2xsZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gMDsgfVxuICAgIGlmICghd2Via2l0ICYmICEoZ2Vja28gJiYgbW9iaWxlKSkgeyBkLnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH1cblxuICAgIGlmIChwbGFjZSkge1xuICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKSB7IHBsYWNlLmFwcGVuZENoaWxkKGQud3JhcHBlcik7IH1cbiAgICAgIGVsc2UgeyBwbGFjZShkLndyYXBwZXIpOyB9XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCByZW5kZXJlZCByYW5nZSAobWF5IGJlIGJpZ2dlciB0aGFuIHRoZSB2aWV3IHdpbmRvdykuXG4gICAgZC52aWV3RnJvbSA9IGQudmlld1RvID0gZG9jLmZpcnN0O1xuICAgIGQucmVwb3J0ZWRWaWV3RnJvbSA9IGQucmVwb3J0ZWRWaWV3VG8gPSBkb2MuZmlyc3Q7XG4gICAgLy8gSW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVkIGxpbmVzLlxuICAgIGQudmlldyA9IFtdO1xuICAgIGQucmVuZGVyZWRWaWV3ID0gbnVsbDtcbiAgICAvLyBIb2xkcyBpbmZvIGFib3V0IGEgc2luZ2xlIHJlbmRlcmVkIGxpbmUgd2hlbiBpdCB3YXMgcmVuZGVyZWRcbiAgICAvLyBmb3IgbWVhc3VyZW1lbnQsIHdoaWxlIG5vdCBpbiB2aWV3LlxuICAgIGQuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7XG4gICAgLy8gRW1wdHkgc3BhY2UgKGluIHBpeGVscykgYWJvdmUgdGhlIHZpZXdcbiAgICBkLnZpZXdPZmZzZXQgPSAwO1xuICAgIGQubGFzdFdyYXBIZWlnaHQgPSBkLmxhc3RXcmFwV2lkdGggPSAwO1xuICAgIGQudXBkYXRlTGluZU51bWJlcnMgPSBudWxsO1xuXG4gICAgZC5uYXRpdmVCYXJXaWR0aCA9IGQuYmFySGVpZ2h0ID0gZC5iYXJXaWR0aCA9IDA7XG4gICAgZC5zY3JvbGxiYXJzQ2xpcHBlZCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCB0byBvbmx5IHJlc2l6ZSB0aGUgbGluZSBudW1iZXIgZ3V0dGVyIHdoZW4gbmVjZXNzYXJ5ICh3aGVuXG4gICAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBjcm9zc2VzIGEgYm91bmRhcnkgdGhhdCBtYWtlcyBpdHMgd2lkdGggY2hhbmdlKVxuICAgIGQubGluZU51bVdpZHRoID0gZC5saW5lTnVtSW5uZXJXaWR0aCA9IGQubGluZU51bUNoYXJzID0gbnVsbDtcbiAgICAvLyBTZXQgdG8gdHJ1ZSB3aGVuIGEgbm9uLWhvcml6b250YWwtc2Nyb2xsaW5nIGxpbmUgd2lkZ2V0IGlzXG4gICAgLy8gYWRkZWQuIEFzIGFuIG9wdGltaXphdGlvbiwgbGluZSB3aWRnZXQgYWxpZ25pbmcgaXMgc2tpcHBlZCB3aGVuXG4gICAgLy8gdGhpcyBpcyBmYWxzZS5cbiAgICBkLmFsaWduV2lkZ2V0cyA9IGZhbHNlO1xuXG4gICAgZC5jYWNoZWRDaGFyV2lkdGggPSBkLmNhY2hlZFRleHRIZWlnaHQgPSBkLmNhY2hlZFBhZGRpbmdIID0gbnVsbDtcblxuICAgIC8vIFRyYWNrcyB0aGUgbWF4aW11bSBsaW5lIGxlbmd0aCBzbyB0aGF0IHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxuICAgIC8vIGNhbiBiZSBrZXB0IHN0YXRpYyB3aGVuIHNjcm9sbGluZy5cbiAgICBkLm1heExpbmUgPSBudWxsO1xuICAgIGQubWF4TGluZUxlbmd0aCA9IDA7XG4gICAgZC5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCBmb3IgbWVhc3VyaW5nIHdoZWVsIHNjcm9sbGluZyBncmFudWxhcml0eVxuICAgIGQud2hlZWxEWCA9IGQud2hlZWxEWSA9IGQud2hlZWxTdGFydFggPSBkLndoZWVsU3RhcnRZID0gbnVsbDtcblxuICAgIC8vIFRydWUgd2hlbiBzaGlmdCBpcyBoZWxkIGRvd24uXG4gICAgZC5zaGlmdCA9IGZhbHNlO1xuXG4gICAgLy8gVXNlZCB0byB0cmFjayB3aGV0aGVyIGFueXRoaW5nIGhhcHBlbmVkIHNpbmNlIHRoZSBjb250ZXh0IG1lbnVcbiAgICAvLyB3YXMgb3BlbmVkLlxuICAgIGQuc2VsRm9yQ29udGV4dE1lbnUgPSBudWxsO1xuXG4gICAgZC5hY3RpdmVUb3VjaCA9IG51bGw7XG5cbiAgICBkLmd1dHRlclNwZWNzID0gZ2V0R3V0dGVycyhvcHRpb25zLmd1dHRlcnMsIG9wdGlvbnMubGluZU51bWJlcnMpO1xuICAgIHJlbmRlckd1dHRlcnMoZCk7XG5cbiAgICBpbnB1dC5pbml0KGQpO1xuICB9XG5cbiAgLy8gU2luY2UgdGhlIGRlbHRhIHZhbHVlcyByZXBvcnRlZCBvbiBtb3VzZSB3aGVlbCBldmVudHMgYXJlXG4gIC8vIHVuc3RhbmRhcmRpemVkIGJldHdlZW4gYnJvd3NlcnMgYW5kIGV2ZW4gYnJvd3NlciB2ZXJzaW9ucywgYW5kXG4gIC8vIGdlbmVyYWxseSBob3JyaWJseSB1bnByZWRpY3RhYmxlLCB0aGlzIGNvZGUgc3RhcnRzIGJ5IG1lYXN1cmluZ1xuICAvLyB0aGUgc2Nyb2xsIGVmZmVjdCB0aGF0IHRoZSBmaXJzdCBmZXcgbW91c2Ugd2hlZWwgZXZlbnRzIGhhdmUsXG4gIC8vIGFuZCwgZnJvbSB0aGF0LCBkZXRlY3RzIHRoZSB3YXkgaXQgY2FuIGNvbnZlcnQgZGVsdGFzIHRvIHBpeGVsXG4gIC8vIG9mZnNldHMgYWZ0ZXJ3YXJkcy5cbiAgLy9cbiAgLy8gVGhlIHJlYXNvbiB3ZSB3YW50IHRvIGtub3cgdGhlIGFtb3VudCBhIHdoZWVsIGV2ZW50IHdpbGwgc2Nyb2xsXG4gIC8vIGlzIHRoYXQgaXQgZ2l2ZXMgdXMgYSBjaGFuY2UgdG8gdXBkYXRlIHRoZSBkaXNwbGF5IGJlZm9yZSB0aGVcbiAgLy8gYWN0dWFsIHNjcm9sbGluZyBoYXBwZW5zLCByZWR1Y2luZyBmbGlja2VyaW5nLlxuXG4gIHZhciB3aGVlbFNhbXBsZXMgPSAwLCB3aGVlbFBpeGVsc1BlclVuaXQgPSBudWxsO1xuICAvLyBGaWxsIGluIGEgYnJvd3Nlci1kZXRlY3RlZCBzdGFydGluZyB2YWx1ZSBvbiBicm93c2VycyB3aGVyZSB3ZVxuICAvLyBrbm93IG9uZS4gVGhlc2UgZG9uJ3QgaGF2ZSB0byBiZSBhY2N1cmF0ZSAtLSB0aGUgcmVzdWx0IG9mIHRoZW1cbiAgLy8gYmVpbmcgd3Jvbmcgd291bGQganVzdCBiZSBhIHNsaWdodCBmbGlja2VyIG9uIHRoZSBmaXJzdCB3aGVlbFxuICAvLyBzY3JvbGwgKGlmIGl0IGlzIGxhcmdlIGVub3VnaCkuXG4gIGlmIChpZSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjUzOyB9XG4gIGVsc2UgaWYgKGdlY2tvKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IDE1OyB9XG4gIGVsc2UgaWYgKGNocm9tZSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtLjc7IH1cbiAgZWxzZSBpZiAoc2FmYXJpKSB7IHdoZWVsUGl4ZWxzUGVyVW5pdCA9IC0xLzM7IH1cblxuICBmdW5jdGlvbiB3aGVlbEV2ZW50RGVsdGEoZSkge1xuICAgIHZhciBkeCA9IGUud2hlZWxEZWx0YVgsIGR5ID0gZS53aGVlbERlbHRhWTtcbiAgICBpZiAoZHggPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5IT1JJWk9OVEFMX0FYSVMpIHsgZHggPSBlLmRldGFpbDsgfVxuICAgIGlmIChkeSA9PSBudWxsICYmIGUuZGV0YWlsICYmIGUuYXhpcyA9PSBlLlZFUlRJQ0FMX0FYSVMpIHsgZHkgPSBlLmRldGFpbDsgfVxuICAgIGVsc2UgaWYgKGR5ID09IG51bGwpIHsgZHkgPSBlLndoZWVsRGVsdGE7IH1cbiAgICByZXR1cm4ge3g6IGR4LCB5OiBkeX1cbiAgfVxuICBmdW5jdGlvbiB3aGVlbEV2ZW50UGl4ZWxzKGUpIHtcbiAgICB2YXIgZGVsdGEgPSB3aGVlbEV2ZW50RGVsdGEoZSk7XG4gICAgZGVsdGEueCAqPSB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgZGVsdGEueSAqPSB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgcmV0dXJuIGRlbHRhXG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbFdoZWVsKGNtLCBlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpLCBkeCA9IGRlbHRhLngsIGR5ID0gZGVsdGEueTtcblxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2Nyb2xsID0gZGlzcGxheS5zY3JvbGxlcjtcbiAgICAvLyBRdWl0IGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzY3JvbGwgaGVyZVxuICAgIHZhciBjYW5TY3JvbGxYID0gc2Nyb2xsLnNjcm9sbFdpZHRoID4gc2Nyb2xsLmNsaWVudFdpZHRoO1xuICAgIHZhciBjYW5TY3JvbGxZID0gc2Nyb2xsLnNjcm9sbEhlaWdodCA+IHNjcm9sbC5jbGllbnRIZWlnaHQ7XG4gICAgaWYgKCEoZHggJiYgY2FuU2Nyb2xsWCB8fCBkeSAmJiBjYW5TY3JvbGxZKSkgeyByZXR1cm4gfVxuXG4gICAgLy8gV2Via2l0IGJyb3dzZXJzIG9uIE9TIFggYWJvcnQgbW9tZW50dW0gc2Nyb2xscyB3aGVuIHRoZSB0YXJnZXRcbiAgICAvLyBvZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgc2Nyb2xsYWJsZSBlbGVtZW50LlxuICAgIC8vIFRoaXMgaGFjayAoc2VlIHJlbGF0ZWQgY29kZSBpbiBwYXRjaERpc3BsYXkpIG1ha2VzIHN1cmUgdGhlXG4gICAgLy8gZWxlbWVudCBpcyBrZXB0IGFyb3VuZC5cbiAgICBpZiAoZHkgJiYgbWFjICYmIHdlYmtpdCkge1xuICAgICAgb3V0ZXI6IGZvciAodmFyIGN1ciA9IGUudGFyZ2V0LCB2aWV3ID0gZGlzcGxheS52aWV3OyBjdXIgIT0gc2Nyb2xsOyBjdXIgPSBjdXIucGFyZW50Tm9kZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodmlld1tpXS5ub2RlID09IGN1cikge1xuICAgICAgICAgICAgY20uZGlzcGxheS5jdXJyZW50V2hlZWxUYXJnZXQgPSBjdXI7XG4gICAgICAgICAgICBicmVhayBvdXRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9uIHNvbWUgYnJvd3NlcnMsIGhvcml6b250YWwgc2Nyb2xsaW5nIHdpbGwgY2F1c2UgcmVkcmF3cyB0b1xuICAgIC8vIGhhcHBlbiBiZWZvcmUgdGhlIGd1dHRlciBoYXMgYmVlbiByZWFsaWduZWQsIGNhdXNpbmcgaXQgdG9cbiAgICAvLyB3cmlnZ2xlIGFyb3VuZCBpbiBhIG1vc3QgdW5zZWVtbHkgd2F5LiBXaGVuIHdlIGhhdmUgYW5cbiAgICAvLyBlc3RpbWF0ZWQgcGl4ZWxzL2RlbHRhIHZhbHVlLCB3ZSBqdXN0IGhhbmRsZSBob3Jpem9udGFsXG4gICAgLy8gc2Nyb2xsaW5nIGVudGlyZWx5IGhlcmUuIEl0J2xsIGJlIHNsaWdodGx5IG9mZiBmcm9tIG5hdGl2ZSwgYnV0XG4gICAgLy8gYmV0dGVyIHRoYW4gZ2xpdGNoaW5nIG91dC5cbiAgICBpZiAoZHggJiYgIWdlY2tvICYmICFwcmVzdG8gJiYgd2hlZWxQaXhlbHNQZXJVbml0ICE9IG51bGwpIHtcbiAgICAgIGlmIChkeSAmJiBjYW5TY3JvbGxZKVxuICAgICAgICB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgTWF0aC5tYXgoMCwgc2Nyb2xsLnNjcm9sbFRvcCArIGR5ICogd2hlZWxQaXhlbHNQZXJVbml0KSk7IH1cbiAgICAgIHNldFNjcm9sbExlZnQoY20sIE1hdGgubWF4KDAsIHNjcm9sbC5zY3JvbGxMZWZ0ICsgZHggKiB3aGVlbFBpeGVsc1BlclVuaXQpKTtcbiAgICAgIC8vIE9ubHkgcHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBpZiB2ZXJ0aWNhbCBzY3JvbGxpbmcgaXNcbiAgICAgIC8vIGFjdHVhbGx5IHBvc3NpYmxlLiBPdGhlcndpc2UsIGl0IGNhdXNlcyB2ZXJ0aWNhbCBzY3JvbGxcbiAgICAgIC8vIGppdHRlciBvbiBPU1ggdHJhY2twYWRzIHdoZW4gZGVsdGFYIGlzIHNtYWxsIGFuZCBkZWx0YVlcbiAgICAgIC8vIGlzIGxhcmdlIChpc3N1ZSAjMzU3OSlcbiAgICAgIGlmICghZHkgfHwgKGR5ICYmIGNhblNjcm9sbFkpKVxuICAgICAgICB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICAgIGRpc3BsYXkud2hlZWxTdGFydFggPSBudWxsOyAvLyBBYm9ydCBtZWFzdXJlbWVudCwgaWYgaW4gcHJvZ3Jlc3NcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vICdQcm9qZWN0JyB0aGUgdmlzaWJsZSB2aWV3cG9ydCB0byBjb3ZlciB0aGUgYXJlYSB0aGF0IGlzIGJlaW5nXG4gICAgLy8gc2Nyb2xsZWQgaW50byB2aWV3IChpZiB3ZSBrbm93IGVub3VnaCB0byBlc3RpbWF0ZSBpdCkuXG4gICAgaWYgKGR5ICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcGl4ZWxzID0gZHkgKiB3aGVlbFBpeGVsc1BlclVuaXQ7XG4gICAgICB2YXIgdG9wID0gY20uZG9jLnNjcm9sbFRvcCwgYm90ID0gdG9wICsgZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChwaXhlbHMgPCAwKSB7IHRvcCA9IE1hdGgubWF4KDAsIHRvcCArIHBpeGVscyAtIDUwKTsgfVxuICAgICAgZWxzZSB7IGJvdCA9IE1hdGgubWluKGNtLmRvYy5oZWlnaHQsIGJvdCArIHBpeGVscyArIDUwKTsgfVxuICAgICAgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdG9wLCBib3R0b206IGJvdH0pO1xuICAgIH1cblxuICAgIGlmICh3aGVlbFNhbXBsZXMgPCAyMCkge1xuICAgICAgaWYgKGRpc3BsYXkud2hlZWxTdGFydFggPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gc2Nyb2xsLnNjcm9sbExlZnQ7IGRpc3BsYXkud2hlZWxTdGFydFkgPSBzY3JvbGwuc2Nyb2xsVG9wO1xuICAgICAgICBkaXNwbGF5LndoZWVsRFggPSBkeDsgZGlzcGxheS53aGVlbERZID0gZHk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICAgICAgICB2YXIgbW92ZWRYID0gc2Nyb2xsLnNjcm9sbExlZnQgLSBkaXNwbGF5LndoZWVsU3RhcnRYO1xuICAgICAgICAgIHZhciBtb3ZlZFkgPSBzY3JvbGwuc2Nyb2xsVG9wIC0gZGlzcGxheS53aGVlbFN0YXJ0WTtcbiAgICAgICAgICB2YXIgc2FtcGxlID0gKG1vdmVkWSAmJiBkaXNwbGF5LndoZWVsRFkgJiYgbW92ZWRZIC8gZGlzcGxheS53aGVlbERZKSB8fFxuICAgICAgICAgICAgKG1vdmVkWCAmJiBkaXNwbGF5LndoZWVsRFggJiYgbW92ZWRYIC8gZGlzcGxheS53aGVlbERYKTtcbiAgICAgICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGw7XG4gICAgICAgICAgaWYgKCFzYW1wbGUpIHsgcmV0dXJuIH1cbiAgICAgICAgICB3aGVlbFBpeGVsc1BlclVuaXQgPSAod2hlZWxQaXhlbHNQZXJVbml0ICogd2hlZWxTYW1wbGVzICsgc2FtcGxlKSAvICh3aGVlbFNhbXBsZXMgKyAxKTtcbiAgICAgICAgICArK3doZWVsU2FtcGxlcztcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXkud2hlZWxEWCArPSBkeDsgZGlzcGxheS53aGVlbERZICs9IGR5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlbGVjdGlvbiBvYmplY3RzIGFyZSBpbW11dGFibGUuIEEgbmV3IG9uZSBpcyBjcmVhdGVkIGV2ZXJ5IHRpbWVcbiAgLy8gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBBIHNlbGVjdGlvbiBpcyBvbmUgb3IgbW9yZSBub24tb3ZlcmxhcHBpbmdcbiAgLy8gKGFuZCBub24tdG91Y2hpbmcpIHJhbmdlcywgc29ydGVkLCBhbmQgYW4gaW50ZWdlciB0aGF0IGluZGljYXRlc1xuICAvLyB3aGljaCBvbmUgaXMgdGhlIHByaW1hcnkgc2VsZWN0aW9uICh0aGUgb25lIHRoYXQncyBzY3JvbGxlZCBpbnRvXG4gIC8vIHZpZXcsIHRoYXQgZ2V0Q3Vyc29yIHJldHVybnMsIGV0YykuXG4gIHZhciBTZWxlY3Rpb24gPSBmdW5jdGlvbihyYW5nZXMsIHByaW1JbmRleCkge1xuICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgIHRoaXMucHJpbUluZGV4ID0gcHJpbUluZGV4O1xuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUucHJpbWFyeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMucHJpbUluZGV4XSB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgaWYgKG90aGVyID09IHRoaXMpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChvdGhlci5wcmltSW5kZXggIT0gdGhpcy5wcmltSW5kZXggfHwgb3RoZXIucmFuZ2VzLmxlbmd0aCAhPSB0aGlzLnJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVyZSA9IHRoaXMucmFuZ2VzW2ldLCB0aGVyZSA9IG90aGVyLnJhbmdlc1tpXTtcbiAgICAgIGlmICghZXF1YWxDdXJzb3JQb3MoaGVyZS5hbmNob3IsIHRoZXJlLmFuY2hvcikgfHwgIWVxdWFsQ3Vyc29yUG9zKGhlcmUuaGVhZCwgdGhlcmUuaGVhZCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY29weVBvcyh0aGlzLnJhbmdlc1tpXS5hbmNob3IpLCBjb3B5UG9zKHRoaXMucmFuZ2VzW2ldLmhlYWQpKTsgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgdGhpcy5wcmltSW5kZXgpXG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5zb21ldGhpbmdTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAoIXRoaXMucmFuZ2VzW2ldLmVtcHR5KCkpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChwb3MsIGVuZCkge1xuICAgIGlmICghZW5kKSB7IGVuZCA9IHBvczsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMucmFuZ2VzW2ldO1xuICAgICAgaWYgKGNtcChlbmQsIHJhbmdlLmZyb20oKSkgPj0gMCAmJiBjbXAocG9zLCByYW5nZS50bygpKSA8PSAwKVxuICAgICAgICB7IHJldHVybiBpIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH07XG5cbiAgdmFyIFJhbmdlID0gZnVuY3Rpb24oYW5jaG9yLCBoZWFkKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7IHRoaXMuaGVhZCA9IGhlYWQ7XG4gIH07XG5cbiAgUmFuZ2UucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5Qb3ModGhpcy5hbmNob3IsIHRoaXMuaGVhZCkgfTtcbiAgUmFuZ2UucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4UG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpIH07XG4gIFJhbmdlLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGVhZC5saW5lID09IHRoaXMuYW5jaG9yLmxpbmUgJiYgdGhpcy5oZWFkLmNoID09IHRoaXMuYW5jaG9yLmNoIH07XG5cbiAgLy8gVGFrZSBhbiB1bnNvcnRlZCwgcG90ZW50aWFsbHkgb3ZlcmxhcHBpbmcgc2V0IG9mIHJhbmdlcywgYW5kXG4gIC8vIGJ1aWxkIGEgc2VsZWN0aW9uIG91dCBvZiBpdC4gJ0NvbnN1bWVzJyByYW5nZXMgYXJyYXkgKG1vZGlmeWluZ1xuICAvLyBpdCkuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVNlbGVjdGlvbihjbSwgcmFuZ2VzLCBwcmltSW5kZXgpIHtcbiAgICB2YXIgbWF5VG91Y2ggPSBjbSAmJiBjbS5vcHRpb25zLnNlbGVjdGlvbnNNYXlUb3VjaDtcbiAgICB2YXIgcHJpbSA9IHJhbmdlc1twcmltSW5kZXhdO1xuICAgIHJhbmdlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBjbXAoYS5mcm9tKCksIGIuZnJvbSgpKTsgfSk7XG4gICAgcHJpbUluZGV4ID0gaW5kZXhPZihyYW5nZXMsIHByaW0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyID0gcmFuZ2VzW2ldLCBwcmV2ID0gcmFuZ2VzW2kgLSAxXTtcbiAgICAgIHZhciBkaWZmID0gY21wKHByZXYudG8oKSwgY3VyLmZyb20oKSk7XG4gICAgICBpZiAobWF5VG91Y2ggJiYgIWN1ci5lbXB0eSgpID8gZGlmZiA+IDAgOiBkaWZmID49IDApIHtcbiAgICAgICAgdmFyIGZyb20gPSBtaW5Qb3MocHJldi5mcm9tKCksIGN1ci5mcm9tKCkpLCB0byA9IG1heFBvcyhwcmV2LnRvKCksIGN1ci50bygpKTtcbiAgICAgICAgdmFyIGludiA9IHByZXYuZW1wdHkoKSA/IGN1ci5mcm9tKCkgPT0gY3VyLmhlYWQgOiBwcmV2LmZyb20oKSA9PSBwcmV2LmhlYWQ7XG4gICAgICAgIGlmIChpIDw9IHByaW1JbmRleCkgeyAtLXByaW1JbmRleDsgfVxuICAgICAgICByYW5nZXMuc3BsaWNlKC0taSwgMiwgbmV3IFJhbmdlKGludiA/IHRvIDogZnJvbSwgaW52ID8gZnJvbSA6IHRvKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlcywgcHJpbUluZGV4KVxuICB9XG5cbiAgZnVuY3Rpb24gc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCkge1xuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKFtuZXcgUmFuZ2UoYW5jaG9yLCBoZWFkIHx8IGFuY2hvcildLCAwKVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGVuZCBvZiBhIGNoYW5nZSAoaXRzICd0bycgcHJvcGVydHlcbiAgLy8gcmVmZXJzIHRvIHRoZSBwcmUtY2hhbmdlIGVuZCkuXG4gIGZ1bmN0aW9uIGNoYW5nZUVuZChjaGFuZ2UpIHtcbiAgICBpZiAoIWNoYW5nZS50ZXh0KSB7IHJldHVybiBjaGFuZ2UudG8gfVxuICAgIHJldHVybiBQb3MoY2hhbmdlLmZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICBsc3QoY2hhbmdlLnRleHQpLmxlbmd0aCArIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSA/IGNoYW5nZS5mcm9tLmNoIDogMCkpXG4gIH1cblxuICAvLyBBZGp1c3QgYSBwb3NpdGlvbiB0byByZWZlciB0byB0aGUgcG9zdC1jaGFuZ2UgcG9zaXRpb24gb2YgdGhlXG4gIC8vIHNhbWUgdGV4dCwgb3IgdGhlIGVuZCBvZiB0aGUgY2hhbmdlIGlmIHRoZSBjaGFuZ2UgY292ZXJzIGl0LlxuICBmdW5jdGlvbiBhZGp1c3RGb3JDaGFuZ2UocG9zLCBjaGFuZ2UpIHtcbiAgICBpZiAoY21wKHBvcywgY2hhbmdlLmZyb20pIDwgMCkgeyByZXR1cm4gcG9zIH1cbiAgICBpZiAoY21wKHBvcywgY2hhbmdlLnRvKSA8PSAwKSB7IHJldHVybiBjaGFuZ2VFbmQoY2hhbmdlKSB9XG5cbiAgICB2YXIgbGluZSA9IHBvcy5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkgLSAxLCBjaCA9IHBvcy5jaDtcbiAgICBpZiAocG9zLmxpbmUgPT0gY2hhbmdlLnRvLmxpbmUpIHsgY2ggKz0gY2hhbmdlRW5kKGNoYW5nZSkuY2ggLSBjaGFuZ2UudG8uY2g7IH1cbiAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgb3V0LnB1c2gobmV3IFJhbmdlKGFkanVzdEZvckNoYW5nZShyYW5nZS5hbmNob3IsIGNoYW5nZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgYWRqdXN0Rm9yQ2hhbmdlKHJhbmdlLmhlYWQsIGNoYW5nZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRQb3MocG9zLCBvbGQsIG53KSB7XG4gICAgaWYgKHBvcy5saW5lID09IG9sZC5saW5lKVxuICAgICAgeyByZXR1cm4gUG9zKG53LmxpbmUsIHBvcy5jaCAtIG9sZC5jaCArIG53LmNoKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gUG9zKG53LmxpbmUgKyAocG9zLmxpbmUgLSBvbGQubGluZSksIHBvcy5jaCkgfVxuICB9XG5cbiAgLy8gVXNlZCBieSByZXBsYWNlU2VsZWN0aW9ucyB0byBhbGxvdyBtb3ZpbmcgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgLy8gc3RhcnQgb3IgYXJvdW5kIHRoZSByZXBsYWNlZCB0ZXN0LiBIaW50IG1heSBiZSBcInN0YXJ0XCIgb3IgXCJhcm91bmRcIi5cbiAgZnVuY3Rpb24gY29tcHV0ZVJlcGxhY2VkU2VsKGRvYywgY2hhbmdlcywgaGludCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICB2YXIgb2xkUHJldiA9IFBvcyhkb2MuZmlyc3QsIDApLCBuZXdQcmV2ID0gb2xkUHJldjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xuICAgICAgdmFyIGZyb20gPSBvZmZzZXRQb3MoY2hhbmdlLmZyb20sIG9sZFByZXYsIG5ld1ByZXYpO1xuICAgICAgdmFyIHRvID0gb2Zmc2V0UG9zKGNoYW5nZUVuZChjaGFuZ2UpLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgIG9sZFByZXYgPSBjaGFuZ2UudG87XG4gICAgICBuZXdQcmV2ID0gdG87XG4gICAgICBpZiAoaGludCA9PSBcImFyb3VuZFwiKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldLCBpbnYgPSBjbXAocmFuZ2UuaGVhZCwgcmFuZ2UuYW5jaG9yKSA8IDA7XG4gICAgICAgIG91dFtpXSA9IG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoZnJvbSwgZnJvbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKG91dCwgZG9jLnNlbC5wcmltSW5kZXgpXG4gIH1cblxuICAvLyBVc2VkIHRvIGdldCB0aGUgZWRpdG9yIGludG8gYSBjb25zaXN0ZW50IHN0YXRlIGFnYWluIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG5cbiAgZnVuY3Rpb24gbG9hZE1vZGUoY20pIHtcbiAgICBjbS5kb2MubW9kZSA9IGdldE1vZGUoY20ub3B0aW9ucywgY20uZG9jLm1vZGVPcHRpb24pO1xuICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0TW9kZVN0YXRlKGNtKSB7XG4gICAgY20uZG9jLml0ZXIoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxuICAgICAgaWYgKGxpbmUuc3R5bGVzKSB7IGxpbmUuc3R5bGVzID0gbnVsbDsgfVxuICAgIH0pO1xuICAgIGNtLmRvYy5tb2RlRnJvbnRpZXIgPSBjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIgPSBjbS5kb2MuZmlyc3Q7XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gICAgY20uc3RhdGUubW9kZUdlbisrO1xuICAgIGlmIChjbS5jdXJPcCkgeyByZWdDaGFuZ2UoY20pOyB9XG4gIH1cblxuICAvLyBET0NVTUVOVCBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIEJ5IGRlZmF1bHQsIHVwZGF0ZXMgdGhhdCBzdGFydCBhbmQgZW5kIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gIC8vIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgaW4gb3JkZXIgdG8gbWFrZSB0aGUgYXNzb2NpYXRpb24gb2YgbGluZVxuICAvLyB3aWRnZXRzIGFuZCBtYXJrZXIgZWxlbWVudHMgd2l0aCB0aGUgdGV4dCBiZWhhdmUgbW9yZSBpbnR1aXRpdmUuXG4gIGZ1bmN0aW9uIGlzV2hvbGVMaW5lVXBkYXRlKGRvYywgY2hhbmdlKSB7XG4gICAgcmV0dXJuIGNoYW5nZS5mcm9tLmNoID09IDAgJiYgY2hhbmdlLnRvLmNoID09IDAgJiYgbHN0KGNoYW5nZS50ZXh0KSA9PSBcIlwiICYmXG4gICAgICAoIWRvYy5jbSB8fCBkb2MuY20ub3B0aW9ucy53aG9sZUxpbmVVcGRhdGVCZWZvcmUpXG4gIH1cblxuICAvLyBQZXJmb3JtIGEgY2hhbmdlIG9uIHRoZSBkb2N1bWVudCBkYXRhIHN0cnVjdHVyZS5cbiAgZnVuY3Rpb24gdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICBmdW5jdGlvbiBzcGFuc0ZvcihuKSB7cmV0dXJuIG1hcmtlZFNwYW5zID8gbWFya2VkU3BhbnNbbl0gOiBudWxsfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShsaW5lLCB0ZXh0LCBzcGFucykge1xuICAgICAgdXBkYXRlTGluZShsaW5lLCB0ZXh0LCBzcGFucywgZXN0aW1hdGVIZWlnaHQpO1xuICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJjaGFuZ2VcIiwgbGluZSwgY2hhbmdlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZXNGb3Ioc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpXG4gICAgICAgIHsgcmVzdWx0LnB1c2gobmV3IExpbmUodGV4dFtpXSwgc3BhbnNGb3IoaSksIGVzdGltYXRlSGVpZ2h0KSk7IH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bywgdGV4dCA9IGNoYW5nZS50ZXh0O1xuICAgIHZhciBmaXJzdExpbmUgPSBnZXRMaW5lKGRvYywgZnJvbS5saW5lKSwgbGFzdExpbmUgPSBnZXRMaW5lKGRvYywgdG8ubGluZSk7XG4gICAgdmFyIGxhc3RUZXh0ID0gbHN0KHRleHQpLCBsYXN0U3BhbnMgPSBzcGFuc0Zvcih0ZXh0Lmxlbmd0aCAtIDEpLCBubGluZXMgPSB0by5saW5lIC0gZnJvbS5saW5lO1xuXG4gICAgLy8gQWRqdXN0IHRoZSBsaW5lIHN0cnVjdHVyZVxuICAgIGlmIChjaGFuZ2UuZnVsbCkge1xuICAgICAgZG9jLmluc2VydCgwLCBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCkpO1xuICAgICAgZG9jLnJlbW92ZSh0ZXh0Lmxlbmd0aCwgZG9jLnNpemUgLSB0ZXh0Lmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3aG9sZS1saW5lIHJlcGxhY2UuIFRyZWF0ZWQgc3BlY2lhbGx5IHRvIG1ha2VcbiAgICAgIC8vIHN1cmUgbGluZSBvYmplY3RzIG1vdmUgdGhlIHdheSB0aGV5IGFyZSBzdXBwb3NlZCB0by5cbiAgICAgIHZhciBhZGRlZCA9IGxpbmVzRm9yKDAsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RMaW5lLnRleHQsIGxhc3RTcGFucyk7XG4gICAgICBpZiAobmxpbmVzKSB7IGRvYy5yZW1vdmUoZnJvbS5saW5lLCBubGluZXMpOyB9XG4gICAgICBpZiAoYWRkZWQubGVuZ3RoKSB7IGRvYy5pbnNlcnQoZnJvbS5saW5lLCBhZGRlZCk7IH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0TGluZSA9PSBsYXN0TGluZSkge1xuICAgICAgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyBsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhZGRlZCQxID0gbGluZXNGb3IoMSwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgYWRkZWQkMS5wdXNoKG5ldyBMaW5lKGxhc3RUZXh0ICsgZmlyc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMsIGVzdGltYXRlSGVpZ2h0KSk7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIHNwYW5zRm9yKDApKTtcbiAgICAgIGRvYy5yZW1vdmUoZnJvbS5saW5lICsgMSwgbmxpbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlKGZpcnN0TGluZSwgZmlyc3RMaW5lLnRleHQuc2xpY2UoMCwgZnJvbS5jaCkgKyB0ZXh0WzBdLCBzcGFuc0ZvcigwKSk7XG4gICAgICB1cGRhdGUobGFzdExpbmUsIGxhc3RUZXh0ICsgbGFzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICB2YXIgYWRkZWQkMiA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAobmxpbmVzID4gMSkgeyBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyAtIDEpOyB9XG4gICAgICBkb2MuaW5zZXJ0KGZyb20ubGluZSArIDEsIGFkZGVkJDIpO1xuICAgIH1cblxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjaGFuZ2VcIiwgZG9jLCBjaGFuZ2UpO1xuICB9XG5cbiAgLy8gQ2FsbCBmIGZvciBhbGwgbGlua2VkIGRvY3VtZW50cy5cbiAgZnVuY3Rpb24gbGlua2VkRG9jcyhkb2MsIGYsIHNoYXJlZEhpc3RPbmx5KSB7XG4gICAgZnVuY3Rpb24gcHJvcGFnYXRlKGRvYywgc2tpcCwgc2hhcmVkSGlzdCkge1xuICAgICAgaWYgKGRvYy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2MubGlua2VkLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZWwgPSBkb2MubGlua2VkW2ldO1xuICAgICAgICBpZiAocmVsLmRvYyA9PSBza2lwKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIHNoYXJlZCA9IHNoYXJlZEhpc3QgJiYgcmVsLnNoYXJlZEhpc3Q7XG4gICAgICAgIGlmIChzaGFyZWRIaXN0T25seSAmJiAhc2hhcmVkKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgZihyZWwuZG9jLCBzaGFyZWQpO1xuICAgICAgICBwcm9wYWdhdGUocmVsLmRvYywgZG9jLCBzaGFyZWQpO1xuICAgICAgfSB9XG4gICAgfVxuICAgIHByb3BhZ2F0ZShkb2MsIG51bGwsIHRydWUpO1xuICB9XG5cbiAgLy8gQXR0YWNoIGEgZG9jdW1lbnQgdG8gYW4gZWRpdG9yLlxuICBmdW5jdGlvbiBhdHRhY2hEb2MoY20sIGRvYykge1xuICAgIGlmIChkb2MuY20pIHsgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBkb2N1bWVudCBpcyBhbHJlYWR5IGluIHVzZS5cIikgfVxuICAgIGNtLmRvYyA9IGRvYztcbiAgICBkb2MuY20gPSBjbTtcbiAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcbiAgICBsb2FkTW9kZShjbSk7XG4gICAgc2V0RGlyZWN0aW9uQ2xhc3MoY20pO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZmluZE1heExpbmUoY20pOyB9XG4gICAgY20ub3B0aW9ucy5tb2RlID0gZG9jLm1vZGVPcHRpb247XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERpcmVjdGlvbkNsYXNzKGNtKSB7XG4gIChjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIgPyBhZGRDbGFzcyA6IHJtQ2xhc3MpKGNtLmRpc3BsYXkubGluZURpdiwgXCJDb2RlTWlycm9yLXJ0bFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpcmVjdGlvbkNoYW5nZWQoY20pIHtcbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXREaXJlY3Rpb25DbGFzcyhjbSk7XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gSGlzdG9yeShwcmV2KSB7XG4gICAgLy8gQXJyYXlzIG9mIGNoYW5nZSBldmVudHMgYW5kIHNlbGVjdGlvbnMuIERvaW5nIHNvbWV0aGluZyBhZGRzIGFuXG4gICAgLy8gZXZlbnQgdG8gZG9uZSBhbmQgY2xlYXJzIHVuZG8uIFVuZG9pbmcgbW92ZXMgZXZlbnRzIGZyb20gZG9uZVxuICAgIC8vIHRvIHVuZG9uZSwgcmVkb2luZyBtb3ZlcyB0aGVtIGluIHRoZSBvdGhlciBkaXJlY3Rpb24uXG4gICAgdGhpcy5kb25lID0gW107IHRoaXMudW5kb25lID0gW107XG4gICAgdGhpcy51bmRvRGVwdGggPSBwcmV2ID8gcHJldi51bmRvRGVwdGggOiBJbmZpbml0eTtcbiAgICAvLyBVc2VkIHRvIHRyYWNrIHdoZW4gY2hhbmdlcyBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGUgdW5kb1xuICAgIC8vIGV2ZW50XG4gICAgdGhpcy5sYXN0TW9kVGltZSA9IHRoaXMubGFzdFNlbFRpbWUgPSAwO1xuICAgIHRoaXMubGFzdE9wID0gdGhpcy5sYXN0U2VsT3AgPSBudWxsO1xuICAgIHRoaXMubGFzdE9yaWdpbiA9IHRoaXMubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgLy8gVXNlZCBieSB0aGUgaXNDbGVhbigpIG1ldGhvZFxuICAgIHRoaXMuZ2VuZXJhdGlvbiA9IHRoaXMubWF4R2VuZXJhdGlvbiA9IHByZXYgPyBwcmV2Lm1heEdlbmVyYXRpb24gOiAxO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgaGlzdG9yeSBjaGFuZ2UgZXZlbnQgZnJvbSBhbiB1cGRhdGVEb2Mtc3R5bGUgY2hhbmdlXG4gIC8vIG9iamVjdC5cbiAgZnVuY3Rpb24gaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgaGlzdENoYW5nZSA9IHtmcm9tOiBjb3B5UG9zKGNoYW5nZS5mcm9tKSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpLCB0ZXh0OiBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byl9O1xuICAgIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBoaXN0Q2hhbmdlLCBjaGFuZ2UuZnJvbS5saW5lLCBjaGFuZ2UudG8ubGluZSArIDEpO1xuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTsgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGhpc3RDaGFuZ2VcbiAgfVxuXG4gIC8vIFBvcCBhbGwgc2VsZWN0aW9uIGV2ZW50cyBvZmYgdGhlIGVuZCBvZiBhIGhpc3RvcnkgYXJyYXkuIFN0b3AgYXRcbiAgLy8gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGFycmF5KSB7XG4gICAgd2hpbGUgKGFycmF5Lmxlbmd0aCkge1xuICAgICAgdmFyIGxhc3QgPSBsc3QoYXJyYXkpO1xuICAgICAgaWYgKGxhc3QucmFuZ2VzKSB7IGFycmF5LnBvcCgpOyB9XG4gICAgICBlbHNlIHsgYnJlYWsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHRvcCBjaGFuZ2UgZXZlbnQgaW4gdGhlIGhpc3RvcnkuIFBvcCBvZmYgc2VsZWN0aW9uXG4gIC8vIGV2ZW50cyB0aGF0IGFyZSBpbiB0aGUgd2F5LlxuICBmdW5jdGlvbiBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIGNsZWFyU2VsZWN0aW9uRXZlbnRzKGhpc3QuZG9uZSk7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9IGVsc2UgaWYgKGhpc3QuZG9uZS5sZW5ndGggJiYgIWxzdChoaXN0LmRvbmUpLnJhbmdlcykge1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoID4gMSAmJiAhaGlzdC5kb25lW2hpc3QuZG9uZS5sZW5ndGggLSAyXS5yYW5nZXMpIHtcbiAgICAgIGhpc3QuZG9uZS5wb3AoKTtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGEgY2hhbmdlIGluIHRoZSBoaXN0b3J5LiBNZXJnZXMgY2hhbmdlcyB0aGF0IGFyZSB3aXRoaW5cbiAgLy8gYSBzaW5nbGUgb3BlcmF0aW9uLCBvciBhcmUgY2xvc2UgdG9nZXRoZXIgd2l0aCBhbiBvcmlnaW4gdGhhdFxuICAvLyBhbGxvd3MgbWVyZ2luZyAoc3RhcnRpbmcgd2l0aCBcIitcIikgaW50byBhIHNpbmdsZSBldmVudC5cbiAgZnVuY3Rpb24gYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgb3BJZCkge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3Rvcnk7XG4gICAgaGlzdC51bmRvbmUubGVuZ3RoID0gMDtcbiAgICB2YXIgdGltZSA9ICtuZXcgRGF0ZSwgY3VyO1xuICAgIHZhciBsYXN0O1xuXG4gICAgaWYgKChoaXN0Lmxhc3RPcCA9PSBvcElkIHx8XG4gICAgICAgICBoaXN0Lmxhc3RPcmlnaW4gPT0gY2hhbmdlLm9yaWdpbiAmJiBjaGFuZ2Uub3JpZ2luICYmXG4gICAgICAgICAoKGNoYW5nZS5vcmlnaW4uY2hhckF0KDApID09IFwiK1wiICYmIGhpc3QubGFzdE1vZFRpbWUgPiB0aW1lIC0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKSkgfHxcbiAgICAgICAgICBjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcIipcIikpICYmXG4gICAgICAgIChjdXIgPSBsYXN0Q2hhbmdlRXZlbnQoaGlzdCwgaGlzdC5sYXN0T3AgPT0gb3BJZCkpKSB7XG4gICAgICAvLyBNZXJnZSB0aGlzIGNoYW5nZSBpbnRvIHRoZSBsYXN0IGV2ZW50XG4gICAgICBsYXN0ID0gbHN0KGN1ci5jaGFuZ2VzKTtcbiAgICAgIGlmIChjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCAmJiBjbXAoY2hhbmdlLmZyb20sIGxhc3QudG8pID09IDApIHtcbiAgICAgICAgLy8gT3B0aW1pemVkIGNhc2UgZm9yIHNpbXBsZSBpbnNlcnRpb24gLS0gZG9uJ3Qgd2FudCB0byBhZGRcbiAgICAgICAgLy8gbmV3IGNoYW5nZXNldHMgZm9yIGV2ZXJ5IGNoYXJhY3RlciB0eXBlZFxuICAgICAgICBsYXN0LnRvID0gY2hhbmdlRW5kKGNoYW5nZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQgbmV3IHN1Yi1ldmVudFxuICAgICAgICBjdXIuY2hhbmdlcy5wdXNoKGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbiBub3QgYmUgbWVyZ2VkLCBzdGFydCBhIG5ldyBldmVudC5cbiAgICAgIHZhciBiZWZvcmUgPSBsc3QoaGlzdC5kb25lKTtcbiAgICAgIGlmICghYmVmb3JlIHx8ICFiZWZvcmUucmFuZ2VzKVxuICAgICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZG9jLnNlbCwgaGlzdC5kb25lKTsgfVxuICAgICAgY3VyID0ge2NoYW5nZXM6IFtoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSldLFxuICAgICAgICAgICAgIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn07XG4gICAgICBoaXN0LmRvbmUucHVzaChjdXIpO1xuICAgICAgd2hpbGUgKGhpc3QuZG9uZS5sZW5ndGggPiBoaXN0LnVuZG9EZXB0aCkge1xuICAgICAgICBoaXN0LmRvbmUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFoaXN0LmRvbmVbMF0ucmFuZ2VzKSB7IGhpc3QuZG9uZS5zaGlmdCgpOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGhpc3QuZG9uZS5wdXNoKHNlbEFmdGVyKTtcbiAgICBoaXN0LmdlbmVyYXRpb24gPSArK2hpc3QubWF4R2VuZXJhdGlvbjtcbiAgICBoaXN0Lmxhc3RNb2RUaW1lID0gaGlzdC5sYXN0U2VsVGltZSA9IHRpbWU7XG4gICAgaGlzdC5sYXN0T3AgPSBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgaGlzdC5sYXN0T3JpZ2luID0gaGlzdC5sYXN0U2VsT3JpZ2luID0gY2hhbmdlLm9yaWdpbjtcblxuICAgIGlmICghbGFzdCkgeyBzaWduYWwoZG9jLCBcImhpc3RvcnlBZGRlZFwiKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZChkb2MsIG9yaWdpbiwgcHJldiwgc2VsKSB7XG4gICAgdmFyIGNoID0gb3JpZ2luLmNoYXJBdCgwKTtcbiAgICByZXR1cm4gY2ggPT0gXCIqXCIgfHxcbiAgICAgIGNoID09IFwiK1wiICYmXG4gICAgICBwcmV2LnJhbmdlcy5sZW5ndGggPT0gc2VsLnJhbmdlcy5sZW5ndGggJiZcbiAgICAgIHByZXYuc29tZXRoaW5nU2VsZWN0ZWQoKSA9PSBzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSAmJlxuICAgICAgbmV3IERhdGUgLSBkb2MuaGlzdG9yeS5sYXN0U2VsVGltZSA8PSAoZG9jLmNtID8gZG9jLmNtLm9wdGlvbnMuaGlzdG9yeUV2ZW50RGVsYXkgOiA1MDApXG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbmV2ZXIgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLCBzZXRzIHRoZSBuZXcgc2VsZWN0aW9uIGFzXG4gIC8vIHRoZSBwZW5kaW5nIHNlbGVjdGlvbiBpbiB0aGUgaGlzdG9yeSwgYW5kIHB1c2hlcyB0aGUgb2xkIHBlbmRpbmdcbiAgLy8gc2VsZWN0aW9uIGludG8gdGhlICdkb25lJyBhcnJheSB3aGVuIGl0IHdhcyBzaWduaWZpY2FudGx5XG4gIC8vIGRpZmZlcmVudCAoaW4gbnVtYmVyIG9mIHNlbGVjdGVkIHJhbmdlcywgZW1wdGluZXNzLCBvciB0aW1lKS5cbiAgZnVuY3Rpb24gYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgc2VsLCBvcElkLCBvcHRpb25zKSB7XG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgb3JpZ2luID0gb3B0aW9ucyAmJiBvcHRpb25zLm9yaWdpbjtcblxuICAgIC8vIEEgbmV3IGV2ZW50IGlzIHN0YXJ0ZWQgd2hlbiB0aGUgcHJldmlvdXMgb3JpZ2luIGRvZXMgbm90IG1hdGNoXG4gICAgLy8gdGhlIGN1cnJlbnQsIG9yIHRoZSBvcmlnaW5zIGRvbid0IGFsbG93IG1hdGNoaW5nLiBPcmlnaW5zXG4gICAgLy8gc3RhcnRpbmcgd2l0aCAqIGFyZSBhbHdheXMgbWVyZ2VkLCB0aG9zZSBzdGFydGluZyB3aXRoICsgYXJlXG4gICAgLy8gbWVyZ2VkIHdoZW4gc2ltaWxhciBhbmQgY2xvc2UgdG9nZXRoZXIgaW4gdGltZS5cbiAgICBpZiAob3BJZCA9PSBoaXN0Lmxhc3RTZWxPcCB8fFxuICAgICAgICAob3JpZ2luICYmIGhpc3QubGFzdFNlbE9yaWdpbiA9PSBvcmlnaW4gJiZcbiAgICAgICAgIChoaXN0Lmxhc3RNb2RUaW1lID09IGhpc3QubGFzdFNlbFRpbWUgJiYgaGlzdC5sYXN0T3JpZ2luID09IG9yaWdpbiB8fFxuICAgICAgICAgIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIGxzdChoaXN0LmRvbmUpLCBzZWwpKSkpXG4gICAgICB7IGhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMV0gPSBzZWw7IH1cbiAgICBlbHNlXG4gICAgICB7IHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBoaXN0LmRvbmUpOyB9XG5cbiAgICBoaXN0Lmxhc3RTZWxUaW1lID0gK25ldyBEYXRlO1xuICAgIGhpc3QubGFzdFNlbE9yaWdpbiA9IG9yaWdpbjtcbiAgICBoaXN0Lmxhc3RTZWxPcCA9IG9wSWQ7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jbGVhclJlZG8gIT09IGZhbHNlKVxuICAgICAgeyBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LnVuZG9uZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsLCBkZXN0KSB7XG4gICAgdmFyIHRvcCA9IGxzdChkZXN0KTtcbiAgICBpZiAoISh0b3AgJiYgdG9wLnJhbmdlcyAmJiB0b3AuZXF1YWxzKHNlbCkpKVxuICAgICAgeyBkZXN0LnB1c2goc2VsKTsgfVxuICB9XG5cbiAgLy8gVXNlZCB0byBzdG9yZSBtYXJrZWQgc3BhbiBpbmZvcm1hdGlvbiBpbiB0aGUgaGlzdG9yeS5cbiAgZnVuY3Rpb24gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGNoYW5nZSwgZnJvbSwgdG8pIHtcbiAgICB2YXIgZXhpc3RpbmcgPSBjaGFuZ2VbXCJzcGFuc19cIiArIGRvYy5pZF0sIG4gPSAwO1xuICAgIGRvYy5pdGVyKE1hdGgubWF4KGRvYy5maXJzdCwgZnJvbSksIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCB0byksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS5tYXJrZWRTcGFucylcbiAgICAgICAgeyAoZXhpc3RpbmcgfHwgKGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdID0ge30pKVtuXSA9IGxpbmUubWFya2VkU3BhbnM7IH1cbiAgICAgICsrbjtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdoZW4gdW4vcmUtZG9pbmcgcmVzdG9yZXMgdGV4dCBjb250YWluaW5nIG1hcmtlZCBzcGFucywgdGhvc2VcbiAgLy8gdGhhdCBoYXZlIGJlZW4gZXhwbGljaXRseSBjbGVhcmVkIHNob3VsZCBub3QgYmUgcmVzdG9yZWQuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsZWFyZWRTcGFucyhzcGFucykge1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHNwYW5zW2ldLm1hcmtlci5leHBsaWNpdGx5Q2xlYXJlZCkgeyBpZiAoIW91dCkgeyBvdXQgPSBzcGFucy5zbGljZSgwLCBpKTsgfSB9XG4gICAgICBlbHNlIGlmIChvdXQpIHsgb3V0LnB1c2goc3BhbnNbaV0pOyB9XG4gICAgfVxuICAgIHJldHVybiAhb3V0ID8gc3BhbnMgOiBvdXQubGVuZ3RoID8gb3V0IDogbnVsbFxuICB9XG5cbiAgLy8gUmV0cmlldmUgYW5kIGZpbHRlciB0aGUgb2xkIG1hcmtlZCBzcGFucyBzdG9yZWQgaW4gYSBjaGFuZ2UgZXZlbnQuXG4gIGZ1bmN0aW9uIGdldE9sZFNwYW5zKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGZvdW5kID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdO1xuICAgIGlmICghZm91bmQpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBudyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlLnRleHQubGVuZ3RoOyArK2kpXG4gICAgICB7IG53LnB1c2gocmVtb3ZlQ2xlYXJlZFNwYW5zKGZvdW5kW2ldKSk7IH1cbiAgICByZXR1cm4gbndcbiAgfVxuXG4gIC8vIFVzZWQgZm9yIHVuL3JlLWRvaW5nIGNoYW5nZXMgZnJvbSB0aGUgaGlzdG9yeS4gQ29tYmluZXMgdGhlXG4gIC8vIHJlc3VsdCBvZiBjb21wdXRpbmcgdGhlIGV4aXN0aW5nIHNwYW5zIHdpdGggdGhlIHNldCBvZiBzcGFucyB0aGF0XG4gIC8vIGV4aXN0ZWQgaW4gdGhlIGhpc3RvcnkgKHNvIHRoYXQgZGVsZXRpbmcgYXJvdW5kIGEgc3BhbiBhbmQgdGhlblxuICAvLyB1bmRvaW5nIGJyaW5ncyBiYWNrIHRoZSBzcGFuKS5cbiAgZnVuY3Rpb24gbWVyZ2VPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvbGQgPSBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSk7XG4gICAgdmFyIHN0cmV0Y2hlZCA9IHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpO1xuICAgIGlmICghb2xkKSB7IHJldHVybiBzdHJldGNoZWQgfVxuICAgIGlmICghc3RyZXRjaGVkKSB7IHJldHVybiBvbGQgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBvbGRDdXIgPSBvbGRbaV0sIHN0cmV0Y2hDdXIgPSBzdHJldGNoZWRbaV07XG4gICAgICBpZiAob2xkQ3VyICYmIHN0cmV0Y2hDdXIpIHtcbiAgICAgICAgc3BhbnM6IGZvciAodmFyIGogPSAwOyBqIDwgc3RyZXRjaEN1ci5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHZhciBzcGFuID0gc3RyZXRjaEN1cltqXTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG9sZEN1ci5sZW5ndGg7ICsraylcbiAgICAgICAgICAgIHsgaWYgKG9sZEN1cltrXS5tYXJrZXIgPT0gc3Bhbi5tYXJrZXIpIHsgY29udGludWUgc3BhbnMgfSB9XG4gICAgICAgICAgb2xkQ3VyLnB1c2goc3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyZXRjaEN1cikge1xuICAgICAgICBvbGRbaV0gPSBzdHJldGNoQ3VyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkXG4gIH1cblxuICAvLyBVc2VkIGJvdGggdG8gcHJvdmlkZSBhIEpTT04tc2FmZSBvYmplY3QgaW4gLmdldEhpc3RvcnksIGFuZCwgd2hlblxuICAvLyBkZXRhY2hpbmcgYSBkb2N1bWVudCwgdG8gc3BsaXQgdGhlIGhpc3RvcnkgaW4gdHdvXG4gIGZ1bmN0aW9uIGNvcHlIaXN0b3J5QXJyYXkoZXZlbnRzLCBuZXdHcm91cCwgaW5zdGFudGlhdGVTZWwpIHtcbiAgICB2YXIgY29weSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIGNvcHkucHVzaChpbnN0YW50aWF0ZVNlbCA/IFNlbGVjdGlvbi5wcm90b3R5cGUuZGVlcENvcHkuY2FsbChldmVudCkgOiBldmVudCk7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlcyA9IGV2ZW50LmNoYW5nZXMsIG5ld0NoYW5nZXMgPSBbXTtcbiAgICAgIGNvcHkucHVzaCh7Y2hhbmdlczogbmV3Q2hhbmdlc30pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFuZ2VzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzW2pdLCBtID0gKHZvaWQgMCk7XG4gICAgICAgIG5ld0NoYW5nZXMucHVzaCh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2UudG8sIHRleHQ6IGNoYW5nZS50ZXh0fSk7XG4gICAgICAgIGlmIChuZXdHcm91cCkgeyBmb3IgKHZhciBwcm9wIGluIGNoYW5nZSkgeyBpZiAobSA9IHByb3AubWF0Y2goL15zcGFuc18oXFxkKykkLykpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihuZXdHcm91cCwgTnVtYmVyKG1bMV0pKSA+IC0xKSB7XG4gICAgICAgICAgICBsc3QobmV3Q2hhbmdlcylbcHJvcF0gPSBjaGFuZ2VbcHJvcF07XG4gICAgICAgICAgICBkZWxldGUgY2hhbmdlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfVxuXG4gIC8vIFRoZSAnc2Nyb2xsJyBwYXJhbWV0ZXIgZ2l2ZW4gdG8gbWFueSBvZiB0aGVzZSBpbmRpY2F0ZWQgd2hldGhlclxuICAvLyB0aGUgbmV3IGN1cnNvciBwb3NpdGlvbiBzaG91bGQgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGFmdGVyXG4gIC8vIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLlxuXG4gIC8vIElmIHNoaWZ0IGlzIGhlbGQgb3IgdGhlIGV4dGVuZCBmbGFnIGlzIHNldCwgZXh0ZW5kcyBhIHJhbmdlIHRvXG4gIC8vIGluY2x1ZGUgYSBnaXZlbiBwb3NpdGlvbiAoYW5kIG9wdGlvbmFsbHkgYSBzZWNvbmQgcG9zaXRpb24pLlxuICAvLyBPdGhlcndpc2UsIHNpbXBseSByZXR1cm5zIHRoZSByYW5nZSBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMuXG4gIC8vIFVzZWQgZm9yIGN1cnNvciBtb3Rpb24gYW5kIHN1Y2guXG4gIGZ1bmN0aW9uIGV4dGVuZFJhbmdlKHJhbmdlLCBoZWFkLCBvdGhlciwgZXh0ZW5kKSB7XG4gICAgaWYgKGV4dGVuZCkge1xuICAgICAgdmFyIGFuY2hvciA9IHJhbmdlLmFuY2hvcjtcbiAgICAgIGlmIChvdGhlcikge1xuICAgICAgICB2YXIgcG9zQmVmb3JlID0gY21wKGhlYWQsIGFuY2hvcikgPCAwO1xuICAgICAgICBpZiAocG9zQmVmb3JlICE9IChjbXAob3RoZXIsIGFuY2hvcikgPCAwKSkge1xuICAgICAgICAgIGFuY2hvciA9IGhlYWQ7XG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc0JlZm9yZSAhPSAoY21wKGhlYWQsIG90aGVyKSA8IDApKSB7XG4gICAgICAgICAgaGVhZCA9IG90aGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKGFuY2hvciwgaGVhZClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShvdGhlciB8fCBoZWFkLCBoZWFkKVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4dGVuZCB0aGUgcHJpbWFyeSBzZWxlY3Rpb24gcmFuZ2UsIGRpc2NhcmQgdGhlIHJlc3QuXG4gIGZ1bmN0aW9uIGV4dGVuZFNlbGVjdGlvbihkb2MsIGhlYWQsIG90aGVyLCBvcHRpb25zLCBleHRlbmQpIHtcbiAgICBpZiAoZXh0ZW5kID09IG51bGwpIHsgZXh0ZW5kID0gZG9jLmNtICYmIChkb2MuY20uZGlzcGxheS5zaGlmdCB8fCBkb2MuZXh0ZW5kKTsgfVxuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW2V4dGVuZFJhbmdlKGRvYy5zZWwucHJpbWFyeSgpLCBoZWFkLCBvdGhlciwgZXh0ZW5kKV0sIDApLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEV4dGVuZCBhbGwgc2VsZWN0aW9ucyAocG9zIGlzIGFuIGFycmF5IG9mIHNlbGVjdGlvbnMgd2l0aCBsZW5ndGhcbiAgLy8gZXF1YWwgdGhlIG51bWJlciBvZiBzZWxlY3Rpb25zKVxuICBmdW5jdGlvbiBleHRlbmRTZWxlY3Rpb25zKGRvYywgaGVhZHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgb3V0W2ldID0gZXh0ZW5kUmFuZ2UoZG9jLnNlbC5yYW5nZXNbaV0sIGhlYWRzW2ldLCBudWxsLCBleHRlbmQpOyB9XG4gICAgdmFyIG5ld1NlbCA9IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICAgIHNldFNlbGVjdGlvbihkb2MsIG5ld1NlbCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBVcGRhdGVzIGEgc2luZ2xlIHJhbmdlIGluIHRoZSBzZWxlY3Rpb24uXG4gIGZ1bmN0aW9uIHJlcGxhY2VPbmVTZWxlY3Rpb24oZG9jLCBpLCByYW5nZSwgb3B0aW9ucykge1xuICAgIHZhciByYW5nZXMgPSBkb2Muc2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICByYW5nZXNbaV0gPSByYW5nZTtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCByYW5nZXMsIGRvYy5zZWwucHJpbUluZGV4KSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgc2VsZWN0aW9uIHRvIGEgc2luZ2xlIHJhbmdlLlxuICBmdW5jdGlvbiBzZXRTaW1wbGVTZWxlY3Rpb24oZG9jLCBhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBHaXZlIGJlZm9yZVNlbGVjdGlvbkNoYW5nZSBoYW5kbGVycyBhIGNoYW5nZSB0byBpbmZsdWVuY2UgYVxuICAvLyBzZWxlY3Rpb24gdXBkYXRlLlxuICBmdW5jdGlvbiBmaWx0ZXJTZWxlY3Rpb25DaGFuZ2UoZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgcmFuZ2VzOiBzZWwucmFuZ2VzLFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyB0aGlzLnJhbmdlc1tpXSA9IG5ldyBSYW5nZShjbGlwUG9zKGRvYywgcmFuZ2VzW2ldLmFuY2hvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5oZWFkKSk7IH1cbiAgICAgIH0sXG4gICAgICBvcmlnaW46IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW5cbiAgICB9O1xuICAgIHNpZ25hbChkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYywgb2JqKTtcbiAgICBpZiAoZG9jLmNtKSB7IHNpZ25hbChkb2MuY20sIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIsIGRvYy5jbSwgb2JqKTsgfVxuICAgIGlmIChvYmoucmFuZ2VzICE9IHNlbC5yYW5nZXMpIHsgcmV0dXJuIG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG9iai5yYW5nZXMsIG9iai5yYW5nZXMubGVuZ3RoIC0gMSkgfVxuICAgIGVsc2UgeyByZXR1cm4gc2VsIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvbmUgPSBkb2MuaGlzdG9yeS5kb25lLCBsYXN0ID0gbHN0KGRvbmUpO1xuICAgIGlmIChsYXN0ICYmIGxhc3QucmFuZ2VzKSB7XG4gICAgICBkb25lW2RvbmUubGVuZ3RoIC0gMV0gPSBzZWw7XG4gICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCBhIG5ldyBzZWxlY3Rpb24uXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbihkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucyk7XG4gICAgYWRkU2VsZWN0aW9uVG9IaXN0b3J5KGRvYywgZG9jLnNlbCwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiKSlcbiAgICAgIHsgc2VsID0gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKTsgfVxuXG4gICAgdmFyIGJpYXMgPSBvcHRpb25zICYmIG9wdGlvbnMuYmlhcyB8fFxuICAgICAgKGNtcChzZWwucHJpbWFyeSgpLmhlYWQsIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQpIDwgMCA/IC0xIDogMSk7XG4gICAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIHRydWUpKTtcblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy5zY3JvbGwgPT09IGZhbHNlKSAmJiBkb2MuY20gJiYgZG9jLmNtLmdldE9wdGlvbihcInJlYWRPbmx5XCIpICE9IFwibm9jdXJzb3JcIilcbiAgICAgIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZShkb2MuY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNlbCkge1xuICAgIGlmIChzZWwuZXF1YWxzKGRvYy5zZWwpKSB7IHJldHVybiB9XG5cbiAgICBkb2Muc2VsID0gc2VsO1xuXG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMTtcbiAgICAgIGRvYy5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNpZ25hbEN1cnNvckFjdGl2aXR5KGRvYy5jbSk7XG4gICAgfVxuICAgIHNpZ25hbExhdGVyKGRvYywgXCJjdXJzb3JBY3Rpdml0eVwiLCBkb2MpO1xuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgdGhlIHNlbGVjdGlvbiBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gbWFya2VkIHJhbmdlcy5cbiAgZnVuY3Rpb24gcmVDaGVja1NlbGVjdGlvbihkb2MpIHtcbiAgICBzZXRTZWxlY3Rpb25Jbm5lcihkb2MsIHNraXBBdG9taWNJblNlbGVjdGlvbihkb2MsIGRvYy5zZWwsIG51bGwsIGZhbHNlKSk7XG4gIH1cblxuICAvLyBSZXR1cm4gYSBzZWxlY3Rpb24gdGhhdCBkb2VzIG5vdCBwYXJ0aWFsbHkgc2VsZWN0IGFueSBhdG9taWNcbiAgLy8gcmFuZ2VzLlxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBzZWwsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIG91dDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICB2YXIgb2xkID0gc2VsLnJhbmdlcy5sZW5ndGggPT0gZG9jLnNlbC5yYW5nZXMubGVuZ3RoICYmIGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG5ld0FuY2hvciA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5hbmNob3IsIG9sZCAmJiBvbGQuYW5jaG9yLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICB2YXIgbmV3SGVhZCA9IHNraXBBdG9taWMoZG9jLCByYW5nZS5oZWFkLCBvbGQgJiYgb2xkLmhlYWQsIGJpYXMsIG1heUNsZWFyKTtcbiAgICAgIGlmIChvdXQgfHwgbmV3QW5jaG9yICE9IHJhbmdlLmFuY2hvciB8fCBuZXdIZWFkICE9IHJhbmdlLmhlYWQpIHtcbiAgICAgICAgaWYgKCFvdXQpIHsgb3V0ID0gc2VsLnJhbmdlcy5zbGljZSgwLCBpKTsgfVxuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UobmV3QW5jaG9yLCBuZXdIZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dCA/IG5vcm1hbGl6ZVNlbGVjdGlvbihkb2MuY20sIG91dCwgc2VsLnByaW1JbmRleCkgOiBzZWxcbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCBkaXIsIG1heUNsZWFyKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gbGluZS5tYXJrZWRTcGFuc1tpXSwgbSA9IHNwLm1hcmtlcjtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBwcmV2ZW50IHRoZSBjdXJzb3IgYmVpbmcgcGxhY2VkIHRvIHRoZSBsZWZ0L3JpZ2h0IG9mIGFuIGF0b21pYyBtYXJrZXJcbiAgICAgIC8vIEhpc3RvcmljYWxseSB0aGlzIHdhcyBkZXRlcm1pbmVkIHVzaW5nIHRoZSBpbmNsdXNpdmVMZWZ0L1JpZ2h0IG9wdGlvbiwgYnV0IHRoZSBuZXcgd2F5IHRvIGNvbnRyb2wgaXRcbiAgICAgIC8vIGlzIHdpdGggc2VsZWN0TGVmdC9SaWdodFxuICAgICAgdmFyIHByZXZlbnRDdXJzb3JMZWZ0ID0gKFwic2VsZWN0TGVmdFwiIGluIG0pID8gIW0uc2VsZWN0TGVmdCA6IG0uaW5jbHVzaXZlTGVmdDtcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yUmlnaHQgPSAoXCJzZWxlY3RSaWdodFwiIGluIG0pID8gIW0uc2VsZWN0UmlnaHQgOiBtLmluY2x1c2l2ZVJpZ2h0O1xuXG4gICAgICBpZiAoKHNwLmZyb20gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvckxlZnQgPyBzcC5mcm9tIDw9IHBvcy5jaCA6IHNwLmZyb20gPCBwb3MuY2gpKSAmJlxuICAgICAgICAgIChzcC50byA9PSBudWxsIHx8IChwcmV2ZW50Q3Vyc29yUmlnaHQgPyBzcC50byA+PSBwb3MuY2ggOiBzcC50byA+IHBvcy5jaCkpKSB7XG4gICAgICAgIGlmIChtYXlDbGVhcikge1xuICAgICAgICAgIHNpZ25hbChtLCBcImJlZm9yZUN1cnNvckVudGVyXCIpO1xuICAgICAgICAgIGlmIChtLmV4cGxpY2l0bHlDbGVhcmVkKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmUubWFya2VkU3BhbnMpIHsgYnJlYWsgfVxuICAgICAgICAgICAgZWxzZSB7LS1pOyBjb250aW51ZX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtLmF0b21pYykgeyBjb250aW51ZSB9XG5cbiAgICAgICAgaWYgKG9sZFBvcykge1xuICAgICAgICAgIHZhciBuZWFyID0gbS5maW5kKGRpciA8IDAgPyAxIDogLTEpLCBkaWZmID0gKHZvaWQgMCk7XG4gICAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yUmlnaHQgOiBwcmV2ZW50Q3Vyc29yTGVmdClcbiAgICAgICAgICAgIHsgbmVhciA9IG1vdmVQb3MoZG9jLCBuZWFyLCAtZGlyLCBuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICAgIGlmIChuZWFyICYmIG5lYXIubGluZSA9PSBwb3MubGluZSAmJiAoZGlmZiA9IGNtcChuZWFyLCBvbGRQb3MpKSAmJiAoZGlyIDwgMCA/IGRpZmYgPCAwIDogZGlmZiA+IDApKVxuICAgICAgICAgICAgeyByZXR1cm4gc2tpcEF0b21pY0lubmVyKGRvYywgbmVhciwgcG9zLCBkaXIsIG1heUNsZWFyKSB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmFyID0gbS5maW5kKGRpciA8IDAgPyAtMSA6IDEpO1xuICAgICAgICBpZiAoZGlyIDwgMCA/IHByZXZlbnRDdXJzb3JMZWZ0IDogcHJldmVudEN1cnNvclJpZ2h0KVxuICAgICAgICAgIHsgZmFyID0gbW92ZVBvcyhkb2MsIGZhciwgZGlyLCBmYXIubGluZSA9PSBwb3MubGluZSA/IGxpbmUgOiBudWxsKTsgfVxuICAgICAgICByZXR1cm4gZmFyID8gc2tpcEF0b21pY0lubmVyKGRvYywgZmFyLCBwb3MsIGRpciwgbWF5Q2xlYXIpIDogbnVsbFxuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBwb3NcbiAgfVxuXG4gIC8vIEVuc3VyZSBhIGdpdmVuIHBvc2l0aW9uIGlzIG5vdCBpbnNpZGUgYW4gYXRvbWljIHJhbmdlLlxuICBmdW5jdGlvbiBza2lwQXRvbWljKGRvYywgcG9zLCBvbGRQb3MsIGJpYXMsIG1heUNsZWFyKSB7XG4gICAgdmFyIGRpciA9IGJpYXMgfHwgMTtcbiAgICB2YXIgZm91bmQgPSBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCB0cnVlKSkgfHxcbiAgICAgICAgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIC1kaXIsIG1heUNsZWFyKSB8fFxuICAgICAgICAoIW1heUNsZWFyICYmIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCB0cnVlKSk7XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgZG9jLmNhbnRFZGl0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBQb3MoZG9jLmZpcnN0LCAwKVxuICAgIH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVQb3MoZG9jLCBwb3MsIGRpciwgbGluZSkge1xuICAgIGlmIChkaXIgPCAwICYmIHBvcy5jaCA9PSAwKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPiBkb2MuZmlyc3QpIHsgcmV0dXJuIGNsaXBQb3MoZG9jLCBQb3MocG9zLmxpbmUgLSAxKSkgfVxuICAgICAgZWxzZSB7IHJldHVybiBudWxsIH1cbiAgICB9IGVsc2UgaWYgKGRpciA+IDAgJiYgcG9zLmNoID09IChsaW5lIHx8IGdldExpbmUoZG9jLCBwb3MubGluZSkpLnRleHQubGVuZ3RoKSB7XG4gICAgICBpZiAocG9zLmxpbmUgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpIHsgcmV0dXJuIFBvcyhwb3MubGluZSArIDEsIDApIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUG9zKHBvcy5saW5lLCBwb3MuY2ggKyBkaXIpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0QWxsKGNtKSB7XG4gICAgY20uc2V0U2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCksIFBvcyhjbS5sYXN0TGluZSgpKSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9XG5cbiAgLy8gVVBEQVRJTkdcblxuICAvLyBBbGxvdyBcImJlZm9yZUNoYW5nZVwiIGV2ZW50IGhhbmRsZXJzIHRvIGluZmx1ZW5jZSBhIGNoYW5nZVxuICBmdW5jdGlvbiBmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIHVwZGF0ZSkge1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjYW5jZWxlZDogZmFsc2UsXG4gICAgICBmcm9tOiBjaGFuZ2UuZnJvbSxcbiAgICAgIHRvOiBjaGFuZ2UudG8sXG4gICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpbixcbiAgICAgIGNhbmNlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gb2JqLmNhbmNlbGVkID0gdHJ1ZTsgfVxuICAgIH07XG4gICAgaWYgKHVwZGF0ZSkgeyBvYmoudXBkYXRlID0gZnVuY3Rpb24gKGZyb20sIHRvLCB0ZXh0LCBvcmlnaW4pIHtcbiAgICAgIGlmIChmcm9tKSB7IG9iai5mcm9tID0gY2xpcFBvcyhkb2MsIGZyb20pOyB9XG4gICAgICBpZiAodG8pIHsgb2JqLnRvID0gY2xpcFBvcyhkb2MsIHRvKTsgfVxuICAgICAgaWYgKHRleHQpIHsgb2JqLnRleHQgPSB0ZXh0OyB9XG4gICAgICBpZiAob3JpZ2luICE9PSB1bmRlZmluZWQpIHsgb2JqLm9yaWdpbiA9IG9yaWdpbjsgfVxuICAgIH07IH1cbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiLCBkb2MuY20sIG9iaik7IH1cblxuICAgIGlmIChvYmouY2FuY2VsZWQpIHtcbiAgICAgIGlmIChkb2MuY20pIHsgZG9jLmNtLmN1ck9wLnVwZGF0ZUlucHV0ID0gMjsgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBvYmouZnJvbSwgdG86IG9iai50bywgdGV4dDogb2JqLnRleHQsIG9yaWdpbjogb2JqLm9yaWdpbn1cbiAgfVxuXG4gIC8vIEFwcGx5IGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQsIGFuZCBhZGQgaXQgdG8gdGhlIGRvY3VtZW50J3NcbiAgLy8gaGlzdG9yeSwgYW5kIHByb3BhZ2F0aW5nIGl0IHRvIGFsbCBsaW5rZWQgZG9jdW1lbnRzLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlKGRvYywgY2hhbmdlLCBpZ25vcmVSZWFkT25seSkge1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGlmICghZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlKShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIH1cbiAgICAgIGlmIChkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cykgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIGlmIChoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKSkge1xuICAgICAgY2hhbmdlID0gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB0cnVlKTtcbiAgICAgIGlmICghY2hhbmdlKSB7IHJldHVybiB9XG4gICAgfVxuXG4gICAgLy8gUG9zc2libHkgc3BsaXQgb3Igc3VwcHJlc3MgdGhlIHVwZGF0ZSBiYXNlZCBvbiB0aGUgcHJlc2VuY2VcbiAgICAvLyBvZiByZWFkLW9ubHkgc3BhbnMgaW4gaXRzIHJhbmdlLlxuICAgIHZhciBzcGxpdCA9IHNhd1JlYWRPbmx5U3BhbnMgJiYgIWlnbm9yZVJlYWRPbmx5ICYmIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBmb3IgKHZhciBpID0gc3BsaXQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgIHsgbWFrZUNoYW5nZUlubmVyKGRvYywge2Zyb206IHNwbGl0W2ldLmZyb20sIHRvOiBzcGxpdFtpXS50bywgdGV4dDogaSA/IFtcIlwiXSA6IGNoYW5nZS50ZXh0LCBvcmlnaW46IGNoYW5nZS5vcmlnaW59KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VJbm5lcihkb2MsIGNoYW5nZSkge1xuICAgIGlmIChjaGFuZ2UudGV4dC5sZW5ndGggPT0gMSAmJiBjaGFuZ2UudGV4dFswXSA9PSBcIlwiICYmIGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwKSB7IHJldHVybiB9XG4gICAgdmFyIHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBkb2MuY20gPyBkb2MuY20uY3VyT3AuaWQgOiBOYU4pO1xuXG4gICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICByZWJhc2VIaXN0KGRvYy5oaXN0b3J5LCBjaGFuZ2UpO1xuICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgfVxuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgbnVsbCwgc3RyZXRjaFNwYW5zT3ZlckNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gUmV2ZXJ0IGEgY2hhbmdlIHN0b3JlZCBpbiBhIGRvY3VtZW50J3MgaGlzdG9yeS5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZUZyb21IaXN0b3J5KGRvYywgdHlwZSwgYWxsb3dTZWxlY3Rpb25Pbmx5KSB7XG4gICAgdmFyIHN1cHByZXNzID0gZG9jLmNtICYmIGRvYy5jbS5zdGF0ZS5zdXBwcmVzc0VkaXRzO1xuICAgIGlmIChzdXBwcmVzcyAmJiAhYWxsb3dTZWxlY3Rpb25Pbmx5KSB7IHJldHVybiB9XG5cbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5LCBldmVudCwgc2VsQWZ0ZXIgPSBkb2Muc2VsO1xuICAgIHZhciBzb3VyY2UgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC5kb25lIDogaGlzdC51bmRvbmUsIGRlc3QgPSB0eXBlID09IFwidW5kb1wiID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmU7XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhIHVzZWFibGUgZXZlbnQgKHNvIHRoYXQgY3RybC16IHdvbid0XG4gICAgLy8gbmVlZGxlc3NseSBjbGVhciBzZWxlY3Rpb24gZXZlbnRzKVxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgZXZlbnQgPSBzb3VyY2VbaV07XG4gICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ID8gZXZlbnQucmFuZ2VzICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkgOiAhZXZlbnQucmFuZ2VzKVxuICAgICAgICB7IGJyZWFrIH1cbiAgICB9XG4gICAgaWYgKGkgPT0gc291cmNlLmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IG51bGw7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBldmVudCA9IHNvdXJjZS5wb3AoKTtcbiAgICAgIGlmIChldmVudC5yYW5nZXMpIHtcbiAgICAgICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShldmVudCwgZGVzdCk7XG4gICAgICAgIGlmIChhbGxvd1NlbGVjdGlvbk9ubHkgJiYgIWV2ZW50LmVxdWFscyhkb2Muc2VsKSkge1xuICAgICAgICAgIHNldFNlbGVjdGlvbihkb2MsIGV2ZW50LCB7Y2xlYXJSZWRvOiBmYWxzZX0pO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNlbEFmdGVyID0gZXZlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHN1cHByZXNzKSB7XG4gICAgICAgIHNvdXJjZS5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2UgeyBicmVhayB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdXAgYSByZXZlcnNlIGNoYW5nZSBvYmplY3QgdG8gYWRkIHRvIHRoZSBvcHBvc2l0ZSBoaXN0b3J5XG4gICAgLy8gc3RhY2sgKHJlZG8gd2hlbiB1bmRvaW5nLCBhbmQgdmljZSB2ZXJzYSkuXG4gICAgdmFyIGFudGlDaGFuZ2VzID0gW107XG4gICAgcHVzaFNlbGVjdGlvblRvSGlzdG9yeShzZWxBZnRlciwgZGVzdCk7XG4gICAgZGVzdC5wdXNoKHtjaGFuZ2VzOiBhbnRpQ2hhbmdlcywgZ2VuZXJhdGlvbjogaGlzdC5nZW5lcmF0aW9ufSk7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gZXZlbnQuZ2VuZXJhdGlvbiB8fCArK2hpc3QubWF4R2VuZXJhdGlvbjtcblxuICAgIHZhciBmaWx0ZXIgPSBoYXNIYW5kbGVyKGRvYywgXCJiZWZvcmVDaGFuZ2VcIikgfHwgZG9jLmNtICYmIGhhc0hhbmRsZXIoZG9jLmNtLCBcImJlZm9yZUNoYW5nZVwiKTtcblxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgdmFyIGNoYW5nZSA9IGV2ZW50LmNoYW5nZXNbaV07XG4gICAgICBjaGFuZ2Uub3JpZ2luID0gdHlwZTtcbiAgICAgIGlmIChmaWx0ZXIgJiYgIWZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgZmFsc2UpKSB7XG4gICAgICAgIHNvdXJjZS5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4ge31cbiAgICAgIH1cblxuICAgICAgYW50aUNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuXG4gICAgICB2YXIgYWZ0ZXIgPSBpID8gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKSA6IGxzdChzb3VyY2UpO1xuICAgICAgbWFrZUNoYW5nZVNpbmdsZURvYyhkb2MsIGNoYW5nZSwgYWZ0ZXIsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIGlmICghaSAmJiBkb2MuY20pIHsgZG9jLmNtLnNjcm9sbEludG9WaWV3KHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IGNoYW5nZUVuZChjaGFuZ2UpfSk7IH1cbiAgICAgIHZhciByZWJhc2VkID0gW107XG5cbiAgICAgIC8vIFByb3BhZ2F0ZSB0byB0aGUgbGlua2VkIGRvY3VtZW50c1xuICAgICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MsIHNoYXJlZEhpc3QpIHtcbiAgICAgICAgaWYgKCFzaGFyZWRIaXN0ICYmIGluZGV4T2YocmViYXNlZCwgZG9jLmhpc3RvcnkpID09IC0xKSB7XG4gICAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgICByZWJhc2VkLnB1c2goZG9jLmhpc3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmb3IgKHZhciBpJDEgPSBldmVudC5jaGFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyAtLWkkMSkge1xuICAgICAgdmFyIHJldHVybmVkID0gbG9vcCggaSQxICk7XG5cbiAgICAgIGlmICggcmV0dXJuZWQgKSByZXR1cm4gcmV0dXJuZWQudjtcbiAgICB9XG4gIH1cblxuICAvLyBTdWItdmlld3MgbmVlZCB0aGVpciBsaW5lIG51bWJlcnMgc2hpZnRlZCB3aGVuIHRleHQgaXMgYWRkZWRcbiAgLy8gYWJvdmUgb3IgYmVsb3cgdGhlbSBpbiB0aGUgcGFyZW50IGRvY3VtZW50LlxuICBmdW5jdGlvbiBzaGlmdERvYyhkb2MsIGRpc3RhbmNlKSB7XG4gICAgaWYgKGRpc3RhbmNlID09IDApIHsgcmV0dXJuIH1cbiAgICBkb2MuZmlyc3QgKz0gZGlzdGFuY2U7XG4gICAgZG9jLnNlbCA9IG5ldyBTZWxlY3Rpb24obWFwKGRvYy5zZWwucmFuZ2VzLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIG5ldyBSYW5nZShcbiAgICAgIFBvcyhyYW5nZS5hbmNob3IubGluZSArIGRpc3RhbmNlLCByYW5nZS5hbmNob3IuY2gpLFxuICAgICAgUG9zKHJhbmdlLmhlYWQubGluZSArIGRpc3RhbmNlLCByYW5nZS5oZWFkLmNoKVxuICAgICk7IH0pLCBkb2Muc2VsLnByaW1JbmRleCk7XG4gICAgaWYgKGRvYy5jbSkge1xuICAgICAgcmVnQ2hhbmdlKGRvYy5jbSwgZG9jLmZpcnN0LCBkb2MuZmlyc3QgLSBkaXN0YW5jZSwgZGlzdGFuY2UpO1xuICAgICAgZm9yICh2YXIgZCA9IGRvYy5jbS5kaXNwbGF5LCBsID0gZC52aWV3RnJvbTsgbCA8IGQudmlld1RvOyBsKyspXG4gICAgICAgIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIGwsIFwiZ3V0dGVyXCIpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9yZSBsb3dlci1sZXZlbCBjaGFuZ2UgZnVuY3Rpb24sIGhhbmRsaW5nIG9ubHkgYSBzaW5nbGUgZG9jdW1lbnRcbiAgLy8gKG5vdCBsaW5rZWQgb25lcykuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzcGFucykge1xuICAgIGlmIChkb2MuY20gJiYgIWRvYy5jbS5jdXJPcClcbiAgICAgIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1ha2VDaGFuZ2VTaW5nbGVEb2MpKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIH1cblxuICAgIGlmIChjaGFuZ2UudG8ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgc2hpZnREb2MoZG9jLCBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGNoYW5nZS50by5saW5lIC0gY2hhbmdlLmZyb20ubGluZSkpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIH1cblxuICAgIC8vIENsaXAgdGhlIGNoYW5nZSB0byB0aGUgc2l6ZSBvZiB0aGlzIGRvY1xuICAgIGlmIChjaGFuZ2UuZnJvbS5saW5lIDwgZG9jLmZpcnN0KSB7XG4gICAgICB2YXIgc2hpZnQgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAxIC0gKGRvYy5maXJzdCAtIGNoYW5nZS5mcm9tLmxpbmUpO1xuICAgICAgc2hpZnREb2MoZG9jLCBzaGlmdCk7XG4gICAgICBjaGFuZ2UgPSB7ZnJvbTogUG9zKGRvYy5maXJzdCwgMCksIHRvOiBQb3MoY2hhbmdlLnRvLmxpbmUgKyBzaGlmdCwgY2hhbmdlLnRvLmNoKSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbbHN0KGNoYW5nZS50ZXh0KV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuICAgIHZhciBsYXN0ID0gZG9jLmxhc3RMaW5lKCk7XG4gICAgaWYgKGNoYW5nZS50by5saW5lID4gbGFzdCkge1xuICAgICAgY2hhbmdlID0ge2Zyb206IGNoYW5nZS5mcm9tLCB0bzogUG9zKGxhc3QsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2NoYW5nZS50ZXh0WzBdXSwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufTtcbiAgICB9XG5cbiAgICBjaGFuZ2UucmVtb3ZlZCA9IGdldEJldHdlZW4oZG9jLCBjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKTtcblxuICAgIGlmICghc2VsQWZ0ZXIpIHsgc2VsQWZ0ZXIgPSBjb21wdXRlU2VsQWZ0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpOyB9XG4gICAgaWYgKGRvYy5jbSkgeyBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoZG9jLmNtLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIGVsc2UgeyB1cGRhdGVEb2MoZG9jLCBjaGFuZ2UsIHNwYW5zKTsgfVxuICAgIHNldFNlbGVjdGlvbk5vVW5kbyhkb2MsIHNlbEFmdGVyLCBzZWxfZG9udFNjcm9sbCk7XG5cbiAgICBpZiAoZG9jLmNhbnRFZGl0ICYmIHNraXBBdG9taWMoZG9jLCBQb3MoZG9jLmZpcnN0TGluZSgpLCAwKSkpXG4gICAgICB7IGRvYy5jYW50RWRpdCA9IGZhbHNlOyB9XG4gIH1cblxuICAvLyBIYW5kbGUgdGhlIGludGVyYWN0aW9uIG9mIGEgY2hhbmdlIHRvIGEgZG9jdW1lbnQgd2l0aCB0aGUgZWRpdG9yXG4gIC8vIHRoYXQgdGhpcyBkb2N1bWVudCBpcyBwYXJ0IG9mLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jSW5FZGl0b3IoY20sIGNoYW5nZSwgc3BhbnMpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZnJvbSA9IGNoYW5nZS5mcm9tLCB0byA9IGNoYW5nZS50bztcblxuICAgIHZhciByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZSwgY2hlY2tXaWR0aFN0YXJ0ID0gZnJvbS5saW5lO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGNoZWNrV2lkdGhTdGFydCA9IGxpbmVObyh2aXN1YWxMaW5lKGdldExpbmUoZG9jLCBmcm9tLmxpbmUpKSk7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAobGluZSA9PSBkaXNwbGF5Lm1heExpbmUpIHtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkb2Muc2VsLmNvbnRhaW5zKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID4gLTEpXG4gICAgICB7IHNpZ25hbEN1cnNvckFjdGl2aXR5KGNtKTsgfVxuXG4gICAgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucywgZXN0aW1hdGVIZWlnaHQoY20pKTtcblxuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGRvYy5pdGVyKGNoZWNrV2lkdGhTdGFydCwgZnJvbS5saW5lICsgY2hhbmdlLnRleHQubGVuZ3RoLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgaWYgKGxlbiA+IGRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZSA9IGxpbmU7XG4gICAgICAgICAgZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIHJlY29tcHV0ZU1heExlbmd0aCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNvbXB1dGVNYXhMZW5ndGgpIHsgY20uY3VyT3AudXBkYXRlTWF4TGluZSA9IHRydWU7IH1cbiAgICB9XG5cbiAgICByZXRyZWF0RnJvbnRpZXIoZG9jLCBmcm9tLmxpbmUpO1xuICAgIHN0YXJ0V29ya2VyKGNtLCA0MDApO1xuXG4gICAgdmFyIGxlbmRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8ubGluZSAtIGZyb20ubGluZSkgLSAxO1xuICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlc2UgbGluZXMgY2hhbmdlZCwgZm9yIHVwZGF0aW5nIHRoZSBkaXNwbGF5XG4gICAgaWYgKGNoYW5nZS5mdWxsKVxuICAgICAgeyByZWdDaGFuZ2UoY20pOyB9XG4gICAgZWxzZSBpZiAoZnJvbS5saW5lID09IHRvLmxpbmUgJiYgY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgIWlzV2hvbGVMaW5lVXBkYXRlKGNtLmRvYywgY2hhbmdlKSlcbiAgICAgIHsgcmVnTGluZUNoYW5nZShjbSwgZnJvbS5saW5lLCBcInRleHRcIik7IH1cbiAgICBlbHNlXG4gICAgICB7IHJlZ0NoYW5nZShjbSwgZnJvbS5saW5lLCB0by5saW5lICsgMSwgbGVuZGlmZik7IH1cblxuICAgIHZhciBjaGFuZ2VzSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlc1wiKSwgY2hhbmdlSGFuZGxlciA9IGhhc0hhbmRsZXIoY20sIFwiY2hhbmdlXCIpO1xuICAgIGlmIChjaGFuZ2VIYW5kbGVyIHx8IGNoYW5nZXNIYW5kbGVyKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICBmcm9tOiBmcm9tLCB0bzogdG8sXG4gICAgICAgIHRleHQ6IGNoYW5nZS50ZXh0LFxuICAgICAgICByZW1vdmVkOiBjaGFuZ2UucmVtb3ZlZCxcbiAgICAgICAgb3JpZ2luOiBjaGFuZ2Uub3JpZ2luXG4gICAgICB9O1xuICAgICAgaWYgKGNoYW5nZUhhbmRsZXIpIHsgc2lnbmFsTGF0ZXIoY20sIFwiY2hhbmdlXCIsIGNtLCBvYmopOyB9XG4gICAgICBpZiAoY2hhbmdlc0hhbmRsZXIpIHsgKGNtLmN1ck9wLmNoYW5nZU9ianMgfHwgKGNtLmN1ck9wLmNoYW5nZU9ianMgPSBbXSkpLnB1c2gob2JqKTsgfVxuICAgIH1cbiAgICBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSYW5nZShkb2MsIGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICB2YXIgYXNzaWduO1xuXG4gICAgaWYgKCF0bykgeyB0byA9IGZyb207IH1cbiAgICBpZiAoY21wKHRvLCBmcm9tKSA8IDApIHsgKGFzc2lnbiA9IFt0bywgZnJvbV0sIGZyb20gPSBhc3NpZ25bMF0sIHRvID0gYXNzaWduWzFdKTsgfVxuICAgIGlmICh0eXBlb2YgY29kZSA9PSBcInN0cmluZ1wiKSB7IGNvZGUgPSBkb2Muc3BsaXRMaW5lcyhjb2RlKTsgfVxuICAgIG1ha2VDaGFuZ2UoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBjb2RlLCBvcmlnaW46IG9yaWdpbn0pO1xuICB9XG5cbiAgLy8gUmViYXNpbmcvcmVzZXR0aW5nIGhpc3RvcnkgdG8gZGVhbCB3aXRoIGV4dGVybmFsbHktc291cmNlZCBjaGFuZ2VzXG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdFNlbFNpbmdsZShwb3MsIGZyb20sIHRvLCBkaWZmKSB7XG4gICAgaWYgKHRvIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lICs9IGRpZmY7XG4gICAgfSBlbHNlIGlmIChmcm9tIDwgcG9zLmxpbmUpIHtcbiAgICAgIHBvcy5saW5lID0gZnJvbTtcbiAgICAgIHBvcy5jaCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLy8gVHJpZXMgdG8gcmViYXNlIGFuIGFycmF5IG9mIGhpc3RvcnkgZXZlbnRzIGdpdmVuIGEgY2hhbmdlIGluIHRoZVxuICAvLyBkb2N1bWVudC4gSWYgdGhlIGNoYW5nZSB0b3VjaGVzIHRoZSBzYW1lIGxpbmVzIGFzIHRoZSBldmVudCwgdGhlXG4gIC8vIGV2ZW50LCBhbmQgZXZlcnl0aGluZyAnYmVoaW5kJyBpdCwgaXMgZGlzY2FyZGVkLiBJZiB0aGUgY2hhbmdlIGlzXG4gIC8vIGJlZm9yZSB0aGUgZXZlbnQsIHRoZSBldmVudCdzIHBvc2l0aW9ucyBhcmUgdXBkYXRlZC4gVXNlcyBhXG4gIC8vIGNvcHktb24td3JpdGUgc2NoZW1lIGZvciB0aGUgcG9zaXRpb25zLCB0byBhdm9pZCBoYXZpbmcgdG9cbiAgLy8gcmVhbGxvY2F0ZSB0aGVtIGFsbCBvbiBldmVyeSByZWJhc2UsIGJ1dCBhbHNvIGF2b2lkIHByb2JsZW1zIHdpdGhcbiAgLy8gc2hhcmVkIHBvc2l0aW9uIG9iamVjdHMgYmVpbmcgdW5zYWZlbHkgdXBkYXRlZC5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdEFycmF5KGFycmF5LCBmcm9tLCB0bywgZGlmZikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzdWIgPSBhcnJheVtpXSwgb2sgPSB0cnVlO1xuICAgICAgaWYgKHN1Yi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuY29waWVkKSB7IHN1YiA9IGFycmF5W2ldID0gc3ViLmRlZXBDb3B5KCk7IHN1Yi5jb3BpZWQgPSB0cnVlOyB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3ViLnJhbmdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHJlYmFzZUhpc3RTZWxTaW5nbGUoc3ViLnJhbmdlc1tqXS5hbmNob3IsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uaGVhZCwgZnJvbSwgdG8sIGRpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBzdWIuY2hhbmdlcy5sZW5ndGg7ICsraiQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBzdWIuY2hhbmdlc1tqJDFdO1xuICAgICAgICBpZiAodG8gPCBjdXIuZnJvbS5saW5lKSB7XG4gICAgICAgICAgY3VyLmZyb20gPSBQb3MoY3VyLmZyb20ubGluZSArIGRpZmYsIGN1ci5mcm9tLmNoKTtcbiAgICAgICAgICBjdXIudG8gPSBQb3MoY3VyLnRvLmxpbmUgKyBkaWZmLCBjdXIudG8uY2gpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb20gPD0gY3VyLnRvLmxpbmUpIHtcbiAgICAgICAgICBvayA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb2spIHtcbiAgICAgICAgYXJyYXkuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgaSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmViYXNlSGlzdChoaXN0LCBjaGFuZ2UpIHtcbiAgICB2YXIgZnJvbSA9IGNoYW5nZS5mcm9tLmxpbmUsIHRvID0gY2hhbmdlLnRvLmxpbmUsIGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAodG8gLSBmcm9tKSAtIDE7XG4gICAgcmViYXNlSGlzdEFycmF5KGhpc3QuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LnVuZG9uZSwgZnJvbSwgdG8sIGRpZmYpO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBmb3IgYXBwbHlpbmcgYSBjaGFuZ2UgdG8gYSBsaW5lIGJ5IGhhbmRsZSBvciBudW1iZXIsXG4gIC8vIHJldHVybmluZyB0aGUgbnVtYmVyIGFuZCBvcHRpb25hbGx5IHJlZ2lzdGVyaW5nIHRoZSBsaW5lIGFzXG4gIC8vIGNoYW5nZWQuXG4gIGZ1bmN0aW9uIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIGNoYW5nZVR5cGUsIG9wKSB7XG4gICAgdmFyIG5vID0gaGFuZGxlLCBsaW5lID0gaGFuZGxlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUoZG9jLCBjbGlwTGluZShkb2MsIGhhbmRsZSkpOyB9XG4gICAgZWxzZSB7IG5vID0gbGluZU5vKGhhbmRsZSk7IH1cbiAgICBpZiAobm8gPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKG9wKGxpbmUsIG5vKSAmJiBkb2MuY20pIHsgcmVnTGluZUNoYW5nZShkb2MuY20sIG5vLCBjaGFuZ2VUeXBlKTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICAvLyBUaGUgZG9jdW1lbnQgaXMgcmVwcmVzZW50ZWQgYXMgYSBCVHJlZSBjb25zaXN0aW5nIG9mIGxlYXZlcywgd2l0aFxuICAvLyBjaHVuayBvZiBsaW5lcyBpbiB0aGVtLCBhbmQgYnJhbmNoZXMsIHdpdGggdXAgdG8gdGVuIGxlYXZlcyBvclxuICAvLyBvdGhlciBicmFuY2ggbm9kZXMgYmVsb3cgdGhlbS4gVGhlIHRvcCBub2RlIGlzIGFsd2F5cyBhIGJyYW5jaFxuICAvLyBub2RlLCBhbmQgaXMgdGhlIGRvY3VtZW50IG9iamVjdCBpdHNlbGYgKG1lYW5pbmcgaXQgaGFzXG4gIC8vIGFkZGl0aW9uYWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcykuXG4gIC8vXG4gIC8vIEFsbCBub2RlcyBoYXZlIHBhcmVudCBsaW5rcy4gVGhlIHRyZWUgaXMgdXNlZCBib3RoIHRvIGdvIGZyb21cbiAgLy8gbGluZSBudW1iZXJzIHRvIGxpbmUgb2JqZWN0cywgYW5kIHRvIGdvIGZyb20gb2JqZWN0cyB0byBudW1iZXJzLlxuICAvLyBJdCBhbHNvIGluZGV4ZXMgYnkgaGVpZ2h0LCBhbmQgaXMgdXNlZCB0byBjb252ZXJ0IGJldHdlZW4gaGVpZ2h0XG4gIC8vIGFuZCBsaW5lIG9iamVjdCwgYW5kIHRvIGZpbmQgdGhlIHRvdGFsIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQuXG4gIC8vXG4gIC8vIFNlZSBhbHNvIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy9jb2RlbWlycm9yLWxpbmUtdHJlZS5odG1sXG5cbiAgZnVuY3Rpb24gTGVhZkNodW5rKGxpbmVzKSB7XG4gICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgaGVpZ2h0ICs9IGxpbmVzW2ldLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBMZWFmQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmVzLmxlbmd0aCB9LFxuXG4gICAgLy8gUmVtb3ZlIHRoZSBuIGxpbmVzIGF0IG9mZnNldCAnYXQnLlxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgZm9yICh2YXIgaSA9IGF0LCBlID0gYXQgKyBuOyBpIDwgZTsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1tpXTtcbiAgICAgICAgdGhpcy5oZWlnaHQgLT0gbGluZS5oZWlnaHQ7XG4gICAgICAgIGNsZWFuVXBMaW5lKGxpbmUpO1xuICAgICAgICBzaWduYWxMYXRlcihsaW5lLCBcImRlbGV0ZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGluZXMuc3BsaWNlKGF0LCBuKTtcbiAgICB9LFxuXG4gICAgLy8gSGVscGVyIHVzZWQgdG8gY29sbGFwc2UgYSBzbWFsbCBicmFuY2ggaW50byBhIHNpbmdsZSBsZWFmLlxuICAgIGNvbGxhcHNlOiBmdW5jdGlvbihsaW5lcykge1xuICAgICAgbGluZXMucHVzaC5hcHBseShsaW5lcywgdGhpcy5saW5lcyk7XG4gICAgfSxcblxuICAgIC8vIEluc2VydCB0aGUgZ2l2ZW4gYXJyYXkgb2YgbGluZXMgYXQgb2Zmc2V0ICdhdCcsIGNvdW50IHRoZW0gYXNcbiAgICAvLyBoYXZpbmcgdGhlIGdpdmVuIGhlaWdodC5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgIHRoaXMubGluZXMgPSB0aGlzLmxpbmVzLnNsaWNlKDAsIGF0KS5jb25jYXQobGluZXMpLmNvbmNhdCh0aGlzLmxpbmVzLnNsaWNlKGF0KSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGxpbmVzW2ldLnBhcmVudCA9IHRoaXM7IH1cbiAgICB9LFxuXG4gICAgLy8gVXNlZCB0byBpdGVyYXRlIG92ZXIgYSBwYXJ0IG9mIHRoZSB0cmVlLlxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGUgPSBhdCArIG47IGF0IDwgZTsgKythdClcbiAgICAgICAgeyBpZiAob3AodGhpcy5saW5lc1thdF0pKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCcmFuY2hDaHVuayhjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB2YXIgc2l6ZSA9IDAsIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNoID0gY2hpbGRyZW5baV07XG4gICAgICBzaXplICs9IGNoLmNodW5rU2l6ZSgpOyBoZWlnaHQgKz0gY2guaGVpZ2h0O1xuICAgICAgY2gucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBCcmFuY2hDaHVuay5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtTaXplOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc2l6ZSB9LFxuXG4gICAgcmVtb3ZlSW5uZXI6IGZ1bmN0aW9uKGF0LCBuKSB7XG4gICAgICB0aGlzLnNpemUgLT0gbjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciBybSA9IE1hdGgubWluKG4sIHN6IC0gYXQpLCBvbGRIZWlnaHQgPSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgY2hpbGQucmVtb3ZlSW5uZXIoYXQsIHJtKTtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBvbGRIZWlnaHQgLSBjaGlsZC5oZWlnaHQ7XG4gICAgICAgICAgaWYgKHN6ID09IHJtKSB7IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGktLSwgMSk7IGNoaWxkLnBhcmVudCA9IG51bGw7IH1cbiAgICAgICAgICBpZiAoKG4gLT0gcm0pID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSByZXN1bHQgaXMgc21hbGxlciB0aGFuIDI1IGxpbmVzLCBlbnN1cmUgdGhhdCBpdCBpcyBhXG4gICAgICAvLyBzaW5nbGUgbGVhZiBub2RlLlxuICAgICAgaWYgKHRoaXMuc2l6ZSAtIG4gPCAyNSAmJlxuICAgICAgICAgICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDEgfHwgISh0aGlzLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgTGVhZkNodW5rKSkpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gW107XG4gICAgICAgIHRoaXMuY29sbGFwc2UobGluZXMpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW25ldyBMZWFmQ2h1bmsobGluZXMpXTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblswXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkgeyB0aGlzLmNoaWxkcmVuW2ldLmNvbGxhcHNlKGxpbmVzKTsgfVxuICAgIH0sXG5cbiAgICBpbnNlcnRJbm5lcjogZnVuY3Rpb24oYXQsIGxpbmVzLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuc2l6ZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDw9IHN6KSB7XG4gICAgICAgICAgY2hpbGQuaW5zZXJ0SW5uZXIoYXQsIGxpbmVzLCBoZWlnaHQpO1xuICAgICAgICAgIGlmIChjaGlsZC5saW5lcyAmJiBjaGlsZC5saW5lcy5sZW5ndGggPiA1MCkge1xuICAgICAgICAgICAgLy8gVG8gYXZvaWQgbWVtb3J5IHRocmFzaGluZyB3aGVuIGNoaWxkLmxpbmVzIGlzIGh1Z2UgKGUuZy4gZmlyc3QgdmlldyBvZiBhIGxhcmdlIGZpbGUpLCBpdCdzIG5ldmVyIHNwbGljZWQuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCBzbWFsbCBzbGljZXMgYXJlIHRha2VuLiBUaGV5J3JlIHRha2VuIGluIG9yZGVyIGJlY2F1c2Ugc2VxdWVudGlhbCBtZW1vcnkgYWNjZXNzZXMgYXJlIGZhc3Rlc3QuXG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gY2hpbGQubGluZXMubGVuZ3RoICUgMjUgKyAyNTtcbiAgICAgICAgICAgIGZvciAodmFyIHBvcyA9IHJlbWFpbmluZzsgcG9zIDwgY2hpbGQubGluZXMubGVuZ3RoOykge1xuICAgICAgICAgICAgICB2YXIgbGVhZiA9IG5ldyBMZWFmQ2h1bmsoY2hpbGQubGluZXMuc2xpY2UocG9zLCBwb3MgKz0gMjUpKTtcbiAgICAgICAgICAgICAgY2hpbGQuaGVpZ2h0IC09IGxlYWYuaGVpZ2h0O1xuICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZSgrK2ksIDAsIGxlYWYpO1xuICAgICAgICAgICAgICBsZWFmLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5saW5lcyA9IGNoaWxkLmxpbmVzLnNsaWNlKDAsIHJlbWFpbmluZyk7XG4gICAgICAgICAgICB0aGlzLm1heWJlU3BpbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBhdCAtPSBzejtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2hlbiBhIG5vZGUgaGFzIGdyb3duLCBjaGVjayB3aGV0aGVyIGl0IHNob3VsZCBiZSBzcGxpdC5cbiAgICBtYXliZVNwaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxMCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHNwaWxsZWQgPSBtZS5jaGlsZHJlbi5zcGxpY2UobWUuY2hpbGRyZW4ubGVuZ3RoIC0gNSwgNSk7XG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV3IEJyYW5jaENodW5rKHNwaWxsZWQpO1xuICAgICAgICBpZiAoIW1lLnBhcmVudCkgeyAvLyBCZWNvbWUgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgdmFyIGNvcHkgPSBuZXcgQnJhbmNoQ2h1bmsobWUuY2hpbGRyZW4pO1xuICAgICAgICAgIGNvcHkucGFyZW50ID0gbWU7XG4gICAgICAgICAgbWUuY2hpbGRyZW4gPSBbY29weSwgc2libGluZ107XG4gICAgICAgICAgbWUgPSBjb3B5O1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWUuc2l6ZSAtPSBzaWJsaW5nLnNpemU7XG4gICAgICAgICAgbWUuaGVpZ2h0IC09IHNpYmxpbmcuaGVpZ2h0O1xuICAgICAgICAgIHZhciBteUluZGV4ID0gaW5kZXhPZihtZS5wYXJlbnQuY2hpbGRyZW4sIG1lKTtcbiAgICAgICAgICBtZS5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG15SW5kZXggKyAxLCAwLCBzaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG1lLnBhcmVudDtcbiAgICAgIH0gd2hpbGUgKG1lLmNoaWxkcmVuLmxlbmd0aCA+IDEwKVxuICAgICAgbWUucGFyZW50Lm1heWJlU3BpbGwoKTtcbiAgICB9LFxuXG4gICAgaXRlck46IGZ1bmN0aW9uKGF0LCBuLCBvcCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8IHN6KSB7XG4gICAgICAgICAgdmFyIHVzZWQgPSBNYXRoLm1pbihuLCBzeiAtIGF0KTtcbiAgICAgICAgICBpZiAoY2hpbGQuaXRlck4oYXQsIHVzZWQsIG9wKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgICAgaWYgKChuIC09IHVzZWQpID09IDApIHsgYnJlYWsgfVxuICAgICAgICAgIGF0ID0gMDtcbiAgICAgICAgfSBlbHNlIHsgYXQgLT0gc3o7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTGluZSB3aWRnZXRzIGFyZSBibG9jayBlbGVtZW50cyBkaXNwbGF5ZWQgYWJvdmUgb3IgYmVsb3cgYSBsaW5lLlxuXG4gIHZhciBMaW5lV2lkZ2V0ID0gZnVuY3Rpb24oZG9jLCBub2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHsgZm9yICh2YXIgb3B0IGluIG9wdGlvbnMpIHsgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgdGhpc1tvcHRdID0gb3B0aW9uc1tvcHRdOyB9IH0gfVxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdzID0gdGhpcy5saW5lLndpZGdldHMsIGxpbmUgPSB0aGlzLmxpbmUsIG5vID0gbGluZU5vKGxpbmUpO1xuICAgIGlmIChubyA9PSBudWxsIHx8ICF3cykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3MubGVuZ3RoOyArK2kpIHsgaWYgKHdzW2ldID09IHRoaXMpIHsgd3Muc3BsaWNlKGktLSwgMSk7IH0gfVxuICAgIGlmICghd3MubGVuZ3RoKSB7IGxpbmUud2lkZ2V0cyA9IG51bGw7IH1cbiAgICB2YXIgaGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHRoaXMpO1xuICAgIHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgTWF0aC5tYXgoMCwgbGluZS5oZWlnaHQgLSBoZWlnaHQpKTtcbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgLWhlaWdodCk7XG4gICAgICAgIHJlZ0xpbmVDaGFuZ2UoY20sIG5vLCBcIndpZGdldFwiKTtcbiAgICAgIH0pO1xuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENsZWFyZWRcIiwgY20sIHRoaXMsIG5vKTtcbiAgICB9XG4gIH07XG5cbiAgTGluZVdpZGdldC5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9sZEggPSB0aGlzLmhlaWdodCwgY20gPSB0aGlzLmRvYy5jbSwgbGluZSA9IHRoaXMubGluZTtcbiAgICB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdmFyIGRpZmYgPSB3aWRnZXRIZWlnaHQodGhpcykgLSBvbGRIO1xuICAgIGlmICghZGlmZikgeyByZXR1cm4gfVxuICAgIGlmICghbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZGlmZik7IH1cbiAgICBpZiAoY20pIHtcbiAgICAgIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldENoYW5nZWRcIiwgY20sIHRoaXMkMSwgbGluZU5vKGxpbmUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihMaW5lV2lkZ2V0KTtcblxuICBmdW5jdGlvbiBhZGp1c3RTY3JvbGxXaGVuQWJvdmVWaXNpYmxlKGNtLCBsaW5lLCBkaWZmKSB7XG4gICAgaWYgKGhlaWdodEF0TGluZShsaW5lKSA8ICgoY20uY3VyT3AgJiYgY20uY3VyT3Auc2Nyb2xsVG9wKSB8fCBjbS5kb2Muc2Nyb2xsVG9wKSlcbiAgICAgIHsgYWRkVG9TY3JvbGxUb3AoY20sIGRpZmYpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRMaW5lV2lkZ2V0KGRvYywgaGFuZGxlLCBub2RlLCBvcHRpb25zKSB7XG4gICAgdmFyIHdpZGdldCA9IG5ldyBMaW5lV2lkZ2V0KGRvYywgbm9kZSwgb3B0aW9ucyk7XG4gICAgdmFyIGNtID0gZG9jLmNtO1xuICAgIGlmIChjbSAmJiB3aWRnZXQubm9IU2Nyb2xsKSB7IGNtLmRpc3BsYXkuYWxpZ25XaWRnZXRzID0gdHJ1ZTsgfVxuICAgIGNoYW5nZUxpbmUoZG9jLCBoYW5kbGUsIFwid2lkZ2V0XCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgd2lkZ2V0cyA9IGxpbmUud2lkZ2V0cyB8fCAobGluZS53aWRnZXRzID0gW10pO1xuICAgICAgaWYgKHdpZGdldC5pbnNlcnRBdCA9PSBudWxsKSB7IHdpZGdldHMucHVzaCh3aWRnZXQpOyB9XG4gICAgICBlbHNlIHsgd2lkZ2V0cy5zcGxpY2UoTWF0aC5taW4od2lkZ2V0cy5sZW5ndGgsIE1hdGgubWF4KDAsIHdpZGdldC5pbnNlcnRBdCkpLCAwLCB3aWRnZXQpOyB9XG4gICAgICB3aWRnZXQubGluZSA9IGxpbmU7XG4gICAgICBpZiAoY20gJiYgIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7XG4gICAgICAgIHZhciBhYm92ZVZpc2libGUgPSBoZWlnaHRBdExpbmUobGluZSkgPCBkb2Muc2Nyb2xsVG9wO1xuICAgICAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgd2lkZ2V0SGVpZ2h0KHdpZGdldCkpO1xuICAgICAgICBpZiAoYWJvdmVWaXNpYmxlKSB7IGFkZFRvU2Nyb2xsVG9wKGNtLCB3aWRnZXQuaGVpZ2h0KTsgfVxuICAgICAgICBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChjbSkgeyBzaWduYWxMYXRlcihjbSwgXCJsaW5lV2lkZ2V0QWRkZWRcIiwgY20sIHdpZGdldCwgdHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiID8gaGFuZGxlIDogbGluZU5vKGhhbmRsZSkpOyB9XG4gICAgcmV0dXJuIHdpZGdldFxuICB9XG5cbiAgLy8gVEVYVE1BUktFUlNcblxuICAvLyBDcmVhdGVkIHdpdGggbWFya1RleHQgYW5kIHNldEJvb2ttYXJrIG1ldGhvZHMuIEEgVGV4dE1hcmtlciBpcyBhXG4gIC8vIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFyIG9yIGZpbmQgYSBtYXJrZWQgcG9zaXRpb24gaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBMaW5lIG9iamVjdHMgaG9sZCBhcnJheXMgKG1hcmtlZFNwYW5zKSBjb250YWluaW5nXG4gIC8vIHtmcm9tLCB0bywgbWFya2VyfSBvYmplY3QgcG9pbnRpbmcgdG8gc3VjaCBtYXJrZXIgb2JqZWN0cywgYW5kXG4gIC8vIGluZGljYXRpbmcgdGhhdCBzdWNoIGEgbWFya2VyIGlzIHByZXNlbnQgb24gdGhhdCBsaW5lLiBNdWx0aXBsZVxuICAvLyBsaW5lcyBtYXkgcG9pbnQgdG8gdGhlIHNhbWUgbWFya2VyIHdoZW4gaXQgc3BhbnMgYWNyb3NzIGxpbmVzLlxuICAvLyBUaGUgc3BhbnMgd2lsbCBoYXZlIG51bGwgZm9yIHRoZWlyIGZyb20vdG8gcHJvcGVydGllcyB3aGVuIHRoZVxuICAvLyBtYXJrZXIgY29udGludWVzIGJleW9uZCB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lLiBNYXJrZXJzIGhhdmVcbiAgLy8gbGlua3MgYmFjayB0byB0aGUgbGluZXMgdGhleSBjdXJyZW50bHkgdG91Y2guXG5cbiAgLy8gQ29sbGFwc2VkIG1hcmtlcnMgaGF2ZSB1bmlxdWUgaWRzLCBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG9yZGVyXG4gIC8vIHRoZW0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgdW5pcXVlbHkgZGV0ZXJtaW5pbmcgYW4gb3V0ZXIgbWFya2VyXG4gIC8vIHdoZW4gdGhleSBvdmVybGFwICh0aGV5IG1heSBuZXN0LCBidXQgbm90IHBhcnRpYWxseSBvdmVybGFwKS5cbiAgdmFyIG5leHRNYXJrZXJJZCA9IDA7XG5cbiAgdmFyIFRleHRNYXJrZXIgPSBmdW5jdGlvbihkb2MsIHR5cGUpIHtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLmlkID0gKytuZXh0TWFya2VySWQ7XG4gIH07XG5cbiAgLy8gQ2xlYXIgdGhlIG1hcmtlci5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB2YXIgY20gPSB0aGlzLmRvYy5jbSwgd2l0aE9wID0gY20gJiYgIWNtLmN1ck9wO1xuICAgIGlmICh3aXRoT3ApIHsgc3RhcnRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKGhhc0hhbmRsZXIodGhpcywgXCJjbGVhclwiKSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKCk7XG4gICAgICBpZiAoZm91bmQpIHsgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiLCBmb3VuZC5mcm9tLCBmb3VuZC50byk7IH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IG51bGwsIG1heCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoY20gJiYgIXRoaXMuY29sbGFwc2VkKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGxpbmVObyhsaW5lKSwgXCJ0ZXh0XCIpOyB9XG4gICAgICBlbHNlIGlmIChjbSkge1xuICAgICAgICBpZiAoc3Bhbi50byAhPSBudWxsKSB7IG1heCA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHsgbWluID0gbGluZU5vKGxpbmUpOyB9XG4gICAgICB9XG4gICAgICBsaW5lLm1hcmtlZFNwYW5zID0gcmVtb3ZlTWFya2VkU3BhbihsaW5lLm1hcmtlZFNwYW5zLCBzcGFuKTtcbiAgICAgIGlmIChzcGFuLmZyb20gPT0gbnVsbCAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhbGluZUlzSGlkZGVuKHRoaXMuZG9jLCBsaW5lKSAmJiBjbSlcbiAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIHRleHRIZWlnaHQoY20uZGlzcGxheSkpOyB9XG4gICAgfVxuICAgIGlmIChjbSAmJiB0aGlzLmNvbGxhcHNlZCAmJiAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZSh0aGlzLmxpbmVzW2kkMV0pLCBsZW4gPSBsaW5lTGVuZ3RoKHZpc3VhbCk7XG4gICAgICBpZiAobGVuID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZSA9IHZpc3VhbDtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IH1cblxuICAgIGlmIChtaW4gIT0gbnVsbCAmJiBjbSAmJiB0aGlzLmNvbGxhcHNlZCkgeyByZWdDaGFuZ2UoY20sIG1pbiwgbWF4ICsgMSk7IH1cbiAgICB0aGlzLmxpbmVzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXRvbWljICYmIHRoaXMuZG9jLmNhbnRFZGl0KSB7XG4gICAgICB0aGlzLmRvYy5jYW50RWRpdCA9IGZhbHNlO1xuICAgICAgaWYgKGNtKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgIH1cbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQ2xlYXJlZFwiLCBjbSwgdGhpcywgbWluLCBtYXgpOyB9XG4gICAgaWYgKHdpdGhPcCkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7IHRoaXMucGFyZW50LmNsZWFyKCk7IH1cbiAgfTtcblxuICAvLyBGaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgbWFya2VyIGluIHRoZSBkb2N1bWVudC4gUmV0dXJucyBhIHtmcm9tLFxuICAvLyB0b30gb2JqZWN0IGJ5IGRlZmF1bHQuIFNpZGUgY2FuIGJlIHBhc3NlZCB0byBnZXQgYSBzcGVjaWZpYyBzaWRlXG4gIC8vIC0tIDAgKGJvdGgpLCAtMSAobGVmdCksIG9yIDEgKHJpZ2h0KS4gV2hlbiBsaW5lT2JqIGlzIHRydWUsIHRoZVxuICAvLyBQb3Mgb2JqZWN0cyByZXR1cm5lZCBjb250YWluIGEgbGluZSBvYmplY3QsIHJhdGhlciB0aGFuIGEgbGluZVxuICAvLyBudW1iZXIgKHVzZWQgdG8gcHJldmVudCBsb29raW5nIHVwIHRoZSBzYW1lIGxpbmUgdHdpY2UpLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICBpZiAoc2lkZSA9PSBudWxsICYmIHRoaXMudHlwZSA9PSBcImJvb2ttYXJrXCIpIHsgc2lkZSA9IDE7IH1cbiAgICB2YXIgZnJvbSwgdG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICB2YXIgc3BhbiA9IGdldE1hcmtlZFNwYW5Gb3IobGluZS5tYXJrZWRTcGFucywgdGhpcyk7XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi5mcm9tKTtcbiAgICAgICAgaWYgKHNpZGUgPT0gLTEpIHsgcmV0dXJuIGZyb20gfVxuICAgICAgfVxuICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkge1xuICAgICAgICB0byA9IFBvcyhsaW5lT2JqID8gbGluZSA6IGxpbmVObyhsaW5lKSwgc3Bhbi50byk7XG4gICAgICAgIGlmIChzaWRlID09IDEpIHsgcmV0dXJuIHRvIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyb20gJiYge2Zyb206IGZyb20sIHRvOiB0b31cbiAgfTtcblxuICAvLyBTaWduYWxzIHRoYXQgdGhlIG1hcmtlcidzIHdpZGdldCBjaGFuZ2VkLCBhbmQgc3Vycm91bmRpbmcgbGF5b3V0XG4gIC8vIHNob3VsZCBiZSByZWNvbXB1dGVkLlxuICBUZXh0TWFya2VyLnByb3RvdHlwZS5jaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9zID0gdGhpcy5maW5kKC0xLCB0cnVlKSwgd2lkZ2V0ID0gdGhpcywgY20gPSB0aGlzLmRvYy5jbTtcbiAgICBpZiAoIXBvcyB8fCAhY20pIHsgcmV0dXJuIH1cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGluZSA9IHBvcy5saW5lLCBsaW5lTiA9IGxpbmVObyhwb3MubGluZSk7XG4gICAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgbGluZU4pO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcih2aWV3KTtcbiAgICAgICAgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlO1xuICAgICAgaWYgKCFsaW5lSXNIaWRkZW4od2lkZ2V0LmRvYywgbGluZSkgJiYgd2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB3aWRnZXQuaGVpZ2h0O1xuICAgICAgICB3aWRnZXQuaGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdmFyIGRIZWlnaHQgPSB3aWRnZXRIZWlnaHQod2lkZ2V0KSAtIG9sZEhlaWdodDtcbiAgICAgICAgaWYgKGRIZWlnaHQpXG4gICAgICAgICAgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGxpbmUuaGVpZ2h0ICsgZEhlaWdodCk7IH1cbiAgICAgIH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNoYW5nZWRcIiwgY20sIHRoaXMkMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuYXR0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3A7XG4gICAgICBpZiAoIW9wLm1heWJlSGlkZGVuTWFya2VycyB8fCBpbmRleE9mKG9wLm1heWJlSGlkZGVuTWFya2VycywgdGhpcykgPT0gLTEpXG4gICAgICAgIHsgKG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyA9IFtdKSkucHVzaCh0aGlzKTsgfVxuICAgIH1cbiAgICB0aGlzLmxpbmVzLnB1c2gobGluZSk7XG4gIH07XG5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZGV0YWNoTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgdGhpcy5saW5lcy5zcGxpY2UoaW5kZXhPZih0aGlzLmxpbmVzLCBsaW5lKSwgMSk7XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCAmJiB0aGlzLmRvYy5jbSkge1xuICAgICAgdmFyIG9wID0gdGhpcy5kb2MuY20uY3VyT3BcbiAgICAgIDsob3AubWF5YmVIaWRkZW5NYXJrZXJzIHx8IChvcC5tYXliZUhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7XG4gICAgfVxuICB9O1xuICBldmVudE1peGluKFRleHRNYXJrZXIpO1xuXG4gIC8vIENyZWF0ZSBhIG1hcmtlciwgd2lyZSBpdCB1cCB0byB0aGUgcmlnaHQgbGluZXMsIGFuZFxuICBmdW5jdGlvbiBtYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgLy8gU2hhcmVkIG1hcmtlcnMgKGFjcm9zcyBsaW5rZWQgZG9jdW1lbnRzKSBhcmUgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgLy8gKG1hcmtUZXh0U2hhcmVkIHdpbGwgY2FsbCBvdXQgdG8gdGhpcyBhZ2Fpbiwgb25jZSBwZXJcbiAgICAvLyBkb2N1bWVudCkuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFyZWQpIHsgcmV0dXJuIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIH1cbiAgICAvLyBFbnN1cmUgd2UgYXJlIGluIGFuIG9wZXJhdGlvbi5cbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApIHsgcmV0dXJuIG9wZXJhdGlvbihkb2MuY20sIG1hcmtUZXh0KShkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG5cbiAgICB2YXIgbWFya2VyID0gbmV3IFRleHRNYXJrZXIoZG9jLCB0eXBlKSwgZGlmZiA9IGNtcChmcm9tLCB0byk7XG4gICAgaWYgKG9wdGlvbnMpIHsgY29weU9iaihvcHRpb25zLCBtYXJrZXIsIGZhbHNlKTsgfVxuICAgIC8vIERvbid0IGNvbm5lY3QgZW1wdHkgbWFya2VycyB1bmxlc3MgY2xlYXJXaGVuRW1wdHkgaXMgZmFsc2VcbiAgICBpZiAoZGlmZiA+IDAgfHwgZGlmZiA9PSAwICYmIG1hcmtlci5jbGVhcldoZW5FbXB0eSAhPT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBtYXJrZXIgfVxuICAgIGlmIChtYXJrZXIucmVwbGFjZWRXaXRoKSB7XG4gICAgICAvLyBTaG93aW5nIHVwIGFzIGEgd2lkZ2V0IGltcGxpZXMgY29sbGFwc2VkICh3aWRnZXQgcmVwbGFjZXMgdGV4dClcbiAgICAgIG1hcmtlci5jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgbWFya2VyLndpZGdldE5vZGUgPSBlbHRQKFwic3BhblwiLCBbbWFya2VyLnJlcGxhY2VkV2l0aF0sIFwiQ29kZU1pcnJvci13aWRnZXRcIik7XG4gICAgICBpZiAoIW9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHMpIHsgbWFya2VyLndpZGdldE5vZGUuc2V0QXR0cmlidXRlKFwiY20taWdub3JlLWV2ZW50c1wiLCBcInRydWVcIik7IH1cbiAgICAgIGlmIChvcHRpb25zLmluc2VydExlZnQpIHsgbWFya2VyLndpZGdldE5vZGUuaW5zZXJ0TGVmdCA9IHRydWU7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIGlmIChjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgZnJvbS5saW5lLCBmcm9tLCB0bywgbWFya2VyKSB8fFxuICAgICAgICAgIGZyb20ubGluZSAhPSB0by5saW5lICYmIGNvbmZsaWN0aW5nQ29sbGFwc2VkUmFuZ2UoZG9jLCB0by5saW5lLCBmcm9tLCB0bywgbWFya2VyKSlcbiAgICAgICAgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbnNlcnRpbmcgY29sbGFwc2VkIG1hcmtlciBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgYW4gZXhpc3Rpbmcgb25lXCIpIH1cbiAgICAgIHNlZUNvbGxhcHNlZFNwYW5zKCk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlci5hZGRUb0hpc3RvcnkpXG4gICAgICB7IGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIHtmcm9tOiBmcm9tLCB0bzogdG8sIG9yaWdpbjogXCJtYXJrVGV4dFwifSwgZG9jLnNlbCwgTmFOKTsgfVxuXG4gICAgdmFyIGN1ckxpbmUgPSBmcm9tLmxpbmUsIGNtID0gZG9jLmNtLCB1cGRhdGVNYXhMaW5lO1xuICAgIGRvYy5pdGVyKGN1ckxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGNtICYmIG1hcmtlci5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nICYmIHZpc3VhbExpbmUobGluZSkgPT0gY20uZGlzcGxheS5tYXhMaW5lKVxuICAgICAgICB7IHVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZCAmJiBjdXJMaW5lICE9IGZyb20ubGluZSkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIDApOyB9XG4gICAgICBhZGRNYXJrZWRTcGFuKGxpbmUsIG5ldyBNYXJrZWRTcGFuKG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSBmcm9tLmxpbmUgPyBmcm9tLmNoIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9PSB0by5saW5lID8gdG8uY2ggOiBudWxsKSk7XG4gICAgICArK2N1ckxpbmU7XG4gICAgfSk7XG4gICAgLy8gbGluZUlzSGlkZGVuIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIG9mIHRoZSBzcGFucywgc28gbmVlZHMgYSBzZWNvbmQgcGFzc1xuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7IGRvYy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZUlzSGlkZGVuKGRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgIH0pOyB9XG5cbiAgICBpZiAobWFya2VyLmNsZWFyT25FbnRlcikgeyBvbihtYXJrZXIsIFwiYmVmb3JlQ3Vyc29yRW50ZXJcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFya2VyLmNsZWFyKCk7IH0pOyB9XG5cbiAgICBpZiAobWFya2VyLnJlYWRPbmx5KSB7XG4gICAgICBzZWVSZWFkT25seVNwYW5zKCk7XG4gICAgICBpZiAoZG9jLmhpc3RvcnkuZG9uZS5sZW5ndGggfHwgZG9jLmhpc3RvcnkudW5kb25lLmxlbmd0aClcbiAgICAgICAgeyBkb2MuY2xlYXJIaXN0b3J5KCk7IH1cbiAgICB9XG4gICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpIHtcbiAgICAgIG1hcmtlci5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICAgICAgbWFya2VyLmF0b21pYyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjbSkge1xuICAgICAgLy8gU3luYyBlZGl0b3Igc3RhdGVcbiAgICAgIGlmICh1cGRhdGVNYXhMaW5lKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgICBpZiAobWFya2VyLmNvbGxhcHNlZClcbiAgICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEpOyB9XG4gICAgICBlbHNlIGlmIChtYXJrZXIuY2xhc3NOYW1lIHx8IG1hcmtlci5zdGFydFN0eWxlIHx8IG1hcmtlci5lbmRTdHlsZSB8fCBtYXJrZXIuY3NzIHx8XG4gICAgICAgICAgICAgICBtYXJrZXIuYXR0cmlidXRlcyB8fCBtYXJrZXIudGl0bGUpXG4gICAgICAgIHsgZm9yICh2YXIgaSA9IGZyb20ubGluZTsgaSA8PSB0by5saW5lOyBpKyspIHsgcmVnTGluZUNoYW5nZShjbSwgaSwgXCJ0ZXh0XCIpOyB9IH1cbiAgICAgIGlmIChtYXJrZXIuYXRvbWljKSB7IHJlQ2hlY2tTZWxlY3Rpb24oY20uZG9jKTsgfVxuICAgICAgc2lnbmFsTGF0ZXIoY20sIFwibWFya2VyQWRkZWRcIiwgY20sIG1hcmtlcik7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJcbiAgfVxuXG4gIC8vIFNIQVJFRCBURVhUTUFSS0VSU1xuXG4gIC8vIEEgc2hhcmVkIG1hcmtlciBzcGFucyBtdWx0aXBsZSBsaW5rZWQgZG9jdW1lbnRzLiBJdCBpc1xuICAvLyBpbXBsZW1lbnRlZCBhcyBhIG1ldGEtbWFya2VyLW9iamVjdCBjb250cm9sbGluZyBtdWx0aXBsZSBub3JtYWxcbiAgLy8gbWFya2Vycy5cbiAgdmFyIFNoYXJlZFRleHRNYXJrZXIgPSBmdW5jdGlvbihtYXJrZXJzLCBwcmltYXJ5KSB7XG4gICAgdGhpcy5tYXJrZXJzID0gbWFya2VycztcbiAgICB0aGlzLnByaW1hcnkgPSBwcmltYXJ5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgbWFya2Vyc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gIH07XG5cbiAgU2hhcmVkVGV4dE1hcmtlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZXhwbGljaXRseUNsZWFyZWQpIHsgcmV0dXJuIH1cbiAgICB0aGlzLmV4cGxpY2l0bHlDbGVhcmVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7ICsraSlcbiAgICAgIHsgdGhpcy5tYXJrZXJzW2ldLmNsZWFyKCk7IH1cbiAgICBzaWduYWxMYXRlcih0aGlzLCBcImNsZWFyXCIpO1xuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoc2lkZSwgbGluZU9iaikge1xuICAgIHJldHVybiB0aGlzLnByaW1hcnkuZmluZChzaWRlLCBsaW5lT2JqKVxuICB9O1xuICBldmVudE1peGluKFNoYXJlZFRleHRNYXJrZXIpO1xuXG4gIGZ1bmN0aW9uIG1hcmtUZXh0U2hhcmVkKGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpIHtcbiAgICBvcHRpb25zID0gY29weU9iaihvcHRpb25zKTtcbiAgICBvcHRpb25zLnNoYXJlZCA9IGZhbHNlO1xuICAgIHZhciBtYXJrZXJzID0gW21hcmtUZXh0KGRvYywgZnJvbSwgdG8sIG9wdGlvbnMsIHR5cGUpXSwgcHJpbWFyeSA9IG1hcmtlcnNbMF07XG4gICAgdmFyIHdpZGdldCA9IG9wdGlvbnMud2lkZ2V0Tm9kZTtcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykge1xuICAgICAgaWYgKHdpZGdldCkgeyBvcHRpb25zLndpZGdldE5vZGUgPSB3aWRnZXQuY2xvbmVOb2RlKHRydWUpOyB9XG4gICAgICBtYXJrZXJzLnB1c2gobWFya1RleHQoZG9jLCBjbGlwUG9zKGRvYywgZnJvbSksIGNsaXBQb3MoZG9jLCB0byksIG9wdGlvbnMsIHR5cGUpKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgeyBpZiAoZG9jLmxpbmtlZFtpXS5pc1BhcmVudCkgeyByZXR1cm4gfSB9XG4gICAgICBwcmltYXJ5ID0gbHN0KG1hcmtlcnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgU2hhcmVkVGV4dE1hcmtlcihtYXJrZXJzLCBwcmltYXJ5KVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNoYXJlZE1hcmtlcnMoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5maW5kTWFya3MoUG9zKGRvYy5maXJzdCwgMCksIGRvYy5jbGlwUG9zKFBvcyhkb2MubGFzdExpbmUoKSkpLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5wYXJlbnQ7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U2hhcmVkTWFya2Vycyhkb2MsIG1hcmtlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBwb3MgPSBtYXJrZXIuZmluZCgpO1xuICAgICAgdmFyIG1Gcm9tID0gZG9jLmNsaXBQb3MocG9zLmZyb20pLCBtVG8gPSBkb2MuY2xpcFBvcyhwb3MudG8pO1xuICAgICAgaWYgKGNtcChtRnJvbSwgbVRvKSkge1xuICAgICAgICB2YXIgc3ViTWFyayA9IG1hcmtUZXh0KGRvYywgbUZyb20sIG1UbywgbWFya2VyLnByaW1hcnksIG1hcmtlci5wcmltYXJ5LnR5cGUpO1xuICAgICAgICBtYXJrZXIubWFya2Vycy5wdXNoKHN1Yk1hcmspO1xuICAgICAgICBzdWJNYXJrLnBhcmVudCA9IG1hcmtlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hTaGFyZWRNYXJrZXJzKG1hcmtlcnMpIHtcbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2ldLCBsaW5rZWQgPSBbbWFya2VyLnByaW1hcnkuZG9jXTtcbiAgICAgIGxpbmtlZERvY3MobWFya2VyLnByaW1hcnkuZG9jLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gbGlua2VkLnB1c2goZCk7IH0pO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXJrZXIubWFya2Vycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgc3ViTWFya2VyID0gbWFya2VyLm1hcmtlcnNbal07XG4gICAgICAgIGlmIChpbmRleE9mKGxpbmtlZCwgc3ViTWFya2VyLmRvYykgPT0gLTEpIHtcbiAgICAgICAgICBzdWJNYXJrZXIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBtYXJrZXIubWFya2Vycy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyBpKyspIGxvb3AoIGkgKTtcbiAgfVxuXG4gIHZhciBuZXh0RG9jSWQgPSAwO1xuICB2YXIgRG9jID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRG9jKSkgeyByZXR1cm4gbmV3IERvYyh0ZXh0LCBtb2RlLCBmaXJzdExpbmUsIGxpbmVTZXAsIGRpcmVjdGlvbikgfVxuICAgIGlmIChmaXJzdExpbmUgPT0gbnVsbCkgeyBmaXJzdExpbmUgPSAwOyB9XG5cbiAgICBCcmFuY2hDaHVuay5jYWxsKHRoaXMsIFtuZXcgTGVhZkNodW5rKFtuZXcgTGluZShcIlwiLCBudWxsKV0pXSk7XG4gICAgdGhpcy5maXJzdCA9IGZpcnN0TGluZTtcbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsTGVmdCA9IDA7XG4gICAgdGhpcy5jYW50RWRpdCA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gMTtcbiAgICB0aGlzLm1vZGVGcm9udGllciA9IHRoaXMuaGlnaGxpZ2h0RnJvbnRpZXIgPSBmaXJzdExpbmU7XG4gICAgdmFyIHN0YXJ0ID0gUG9zKGZpcnN0TGluZSwgMCk7XG4gICAgdGhpcy5zZWwgPSBzaW1wbGVTZWxlY3Rpb24oc3RhcnQpO1xuICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KG51bGwpO1xuICAgIHRoaXMuaWQgPSArK25leHREb2NJZDtcbiAgICB0aGlzLm1vZGVPcHRpb24gPSBtb2RlO1xuICAgIHRoaXMubGluZVNlcCA9IGxpbmVTZXA7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSAoZGlyZWN0aW9uID09IFwicnRsXCIpID8gXCJydGxcIiA6IFwibHRyXCI7XG4gICAgdGhpcy5leHRlbmQgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGV4dCA9PSBcInN0cmluZ1wiKSB7IHRleHQgPSB0aGlzLnNwbGl0TGluZXModGV4dCk7IH1cbiAgICB1cGRhdGVEb2ModGhpcywge2Zyb206IHN0YXJ0LCB0bzogc3RhcnQsIHRleHQ6IHRleHR9KTtcbiAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KSwgc2VsX2RvbnRTY3JvbGwpO1xuICB9O1xuXG4gIERvYy5wcm90b3R5cGUgPSBjcmVhdGVPYmooQnJhbmNoQ2h1bmsucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IERvYyxcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGRvY3VtZW50LiBTdXBwb3J0cyB0d28gZm9ybXMgLS0gd2l0aCBvbmx5IG9uZVxuICAgIC8vIGFyZ3VtZW50LCBpdCBjYWxscyB0aGF0IGZvciBlYWNoIGxpbmUgaW4gdGhlIGRvY3VtZW50LiBXaXRoXG4gICAgLy8gdGhyZWUsIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIHJhbmdlIGdpdmVuIGJ5IHRoZSBmaXJzdCB0d28gKHdpdGhcbiAgICAvLyB0aGUgc2Vjb25kIGJlaW5nIG5vbi1pbmNsdXNpdmUpLlxuICAgIGl0ZXI6IGZ1bmN0aW9uKGZyb20sIHRvLCBvcCkge1xuICAgICAgaWYgKG9wKSB7IHRoaXMuaXRlck4oZnJvbSAtIHRoaXMuZmlyc3QsIHRvIC0gZnJvbSwgb3ApOyB9XG4gICAgICBlbHNlIHsgdGhpcy5pdGVyTih0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplLCBmcm9tKTsgfVxuICAgIH0sXG5cbiAgICAvLyBOb24tcHVibGljIGludGVyZmFjZSBmb3IgYWRkaW5nIGFuZCByZW1vdmluZyBsaW5lcy5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGF0LCBsaW5lcykge1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7IGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7IH1cbiAgICAgIHRoaXMuaW5zZXJ0SW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oYXQsIG4pIHsgdGhpcy5yZW1vdmVJbm5lcihhdCAtIHRoaXMuZmlyc3QsIG4pOyB9LFxuXG4gICAgLy8gRnJvbSBoZXJlLCB0aGUgbWV0aG9kcyBhcmUgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS4gTW9zdFxuICAgIC8vIGFyZSBhbHNvIGF2YWlsYWJsZSBmcm9tIENvZGVNaXJyb3IgKGVkaXRvcikgaW5zdGFuY2VzLlxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldExpbmVzKHRoaXMsIHRoaXMuZmlyc3QsIHRoaXMuZmlyc3QgKyB0aGlzLnNpemUpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxuICAgIH0sXG4gICAgc2V0VmFsdWU6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgIHZhciB0b3AgPSBQb3ModGhpcy5maXJzdCwgMCksIGxhc3QgPSB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMTtcbiAgICAgIG1ha2VDaGFuZ2UodGhpcywge2Zyb206IHRvcCwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKHRoaXMsIGxhc3QpLnRleHQubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlKSwgb3JpZ2luOiBcInNldFZhbHVlXCIsIGZ1bGw6IHRydWV9LCB0cnVlKTtcbiAgICAgIGlmICh0aGlzLmNtKSB7IHNjcm9sbFRvQ29vcmRzKHRoaXMuY20sIDAsIDApOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgc2ltcGxlU2VsZWN0aW9uKHRvcCksIHNlbF9kb250U2Nyb2xsKTtcbiAgICB9KSxcbiAgICByZXBsYWNlUmFuZ2U6IGZ1bmN0aW9uKGNvZGUsIGZyb20sIHRvLCBvcmlnaW4pIHtcbiAgICAgIGZyb20gPSBjbGlwUG9zKHRoaXMsIGZyb20pO1xuICAgICAgdG8gPSB0byA/IGNsaXBQb3ModGhpcywgdG8pIDogZnJvbTtcbiAgICAgIHJlcGxhY2VSYW5nZSh0aGlzLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiBmdW5jdGlvbihmcm9tLCB0bywgbGluZVNlcCkge1xuICAgICAgdmFyIGxpbmVzID0gZ2V0QmV0d2Vlbih0aGlzLCBjbGlwUG9zKHRoaXMsIGZyb20pLCBjbGlwUG9zKHRoaXMsIHRvKSk7XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIHJldHVybiBsaW5lcy5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpXG4gICAgfSxcblxuICAgIGdldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHt2YXIgbCA9IHRoaXMuZ2V0TGluZUhhbmRsZShsaW5lKTsgcmV0dXJuIGwgJiYgbC50ZXh0fSxcblxuICAgIGdldExpbmVIYW5kbGU6IGZ1bmN0aW9uKGxpbmUpIHtpZiAoaXNMaW5lKHRoaXMsIGxpbmUpKSB7IHJldHVybiBnZXRMaW5lKHRoaXMsIGxpbmUpIH19LFxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKGxpbmUpIHtyZXR1cm4gbGluZU5vKGxpbmUpfSxcblxuICAgIGdldExpbmVIYW5kbGVWaXN1YWxTdGFydDogZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHsgbGluZSA9IGdldExpbmUodGhpcywgbGluZSk7IH1cbiAgICAgIHJldHVybiB2aXN1YWxMaW5lKGxpbmUpXG4gICAgfSxcblxuICAgIGxpbmVDb3VudDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2l6ZX0sXG4gICAgZmlyc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdH0sXG4gICAgbGFzdExpbmU6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmZpcnN0ICsgdGhpcy5zaXplIC0gMX0sXG5cbiAgICBjbGlwUG9zOiBmdW5jdGlvbihwb3MpIHtyZXR1cm4gY2xpcFBvcyh0aGlzLCBwb3MpfSxcblxuICAgIGdldEN1cnNvcjogZnVuY3Rpb24oc3RhcnQpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuc2VsLnByaW1hcnkoKSwgcG9zO1xuICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQgPT0gXCJoZWFkXCIpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgZWxzZSBpZiAoc3RhcnQgPT0gXCJhbmNob3JcIikgeyBwb3MgPSByYW5nZS5hbmNob3I7IH1cbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiZW5kXCIgfHwgc3RhcnQgPT0gXCJ0b1wiIHx8IHN0YXJ0ID09PSBmYWxzZSkgeyBwb3MgPSByYW5nZS50bygpOyB9XG4gICAgICBlbHNlIHsgcG9zID0gcmFuZ2UuZnJvbSgpOyB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSxcbiAgICBsaXN0U2VsZWN0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNlbC5yYW5nZXMgfSxcbiAgICBzb21ldGhpbmdTZWxlY3RlZDogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCl9LFxuXG4gICAgc2V0Q3Vyc29yOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBjaCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgdHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIiA/IFBvcyhsaW5lLCBjaCB8fCAwKSA6IGxpbmUpLCBudWxsLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBzZXRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGFuY2hvciwgaGVhZCwgb3B0aW9ucykge1xuICAgICAgc2V0U2ltcGxlU2VsZWN0aW9uKHRoaXMsIGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvciksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGhlYWQpLCBvdGhlciAmJiBjbGlwUG9zKHRoaXMsIG90aGVyKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGVhZHMsIG9wdGlvbnMpIHtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgZXh0ZW5kU2VsZWN0aW9uc0J5OiBkb2NNZXRob2RPcChmdW5jdGlvbihmLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaGVhZHMgPSBtYXAodGhpcy5zZWwucmFuZ2VzLCBmKTtcbiAgICAgIGV4dGVuZFNlbGVjdGlvbnModGhpcywgY2xpcFBvc0FycmF5KHRoaXMsIGhlYWRzKSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uczogZG9jTWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2VzLCBwcmltYXJ5LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXJhbmdlcy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IG91dFtpXSA9IG5ldyBSYW5nZShjbGlwUG9zKHRoaXMsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uaGVhZCB8fCByYW5nZXNbaV0uYW5jaG9yKSk7IH1cbiAgICAgIGlmIChwcmltYXJ5ID09IG51bGwpIHsgcHJpbWFyeSA9IE1hdGgubWluKHJhbmdlcy5sZW5ndGggLSAxLCB0aGlzLnNlbC5wcmltSW5kZXgpOyB9XG4gICAgICBzZXRTZWxlY3Rpb24odGhpcywgbm9ybWFsaXplU2VsZWN0aW9uKHRoaXMuY20sIG91dCwgcHJpbWFyeSksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGFkZFNlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGNsaXBQb3ModGhpcywgYW5jaG9yKSwgY2xpcFBvcyh0aGlzLCBoZWFkIHx8IGFuY2hvcikpKTtcbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24odGhpcy5jbSwgcmFuZ2VzLCByYW5nZXMubGVuZ3RoIC0gMSksIG9wdGlvbnMpO1xuICAgIH0pLFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzLCBsaW5lcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgbGluZXMgPSBsaW5lcyA/IGxpbmVzLmNvbmNhdChzZWwpIDogc2VsO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICBlbHNlIHsgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSkgfVxuICAgIH0sXG4gICAgZ2V0U2VsZWN0aW9uczogZnVuY3Rpb24obGluZVNlcCkge1xuICAgICAgdmFyIHBhcnRzID0gW10sIHJhbmdlcyA9IHRoaXMuc2VsLnJhbmdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWwgPSBnZXRCZXR3ZWVuKHRoaXMsIHJhbmdlc1tpXS5mcm9tKCksIHJhbmdlc1tpXS50bygpKTtcbiAgICAgICAgaWYgKGxpbmVTZXAgIT09IGZhbHNlKSB7IHNlbCA9IHNlbC5qb2luKGxpbmVTZXAgfHwgdGhpcy5saW5lU2VwYXJhdG9yKCkpOyB9XG4gICAgICAgIHBhcnRzW2ldID0gc2VsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzXG4gICAgfSxcbiAgICByZXBsYWNlU2VsZWN0aW9uOiBmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgZHVwID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBkdXBbaV0gPSBjb2RlOyB9XG4gICAgICB0aGlzLnJlcGxhY2VTZWxlY3Rpb25zKGR1cCwgY29sbGFwc2UsIG9yaWdpbiB8fCBcIitpbnB1dFwiKTtcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb25zOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlLCBjb2xsYXBzZSwgb3JpZ2luKSB7XG4gICAgICB2YXIgY2hhbmdlcyA9IFtdLCBzZWwgPSB0aGlzLnNlbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgICBjaGFuZ2VzW2ldID0ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCksIHRleHQ6IHRoaXMuc3BsaXRMaW5lcyhjb2RlW2ldKSwgb3JpZ2luOiBvcmlnaW59O1xuICAgICAgfVxuICAgICAgdmFyIG5ld1NlbCA9IGNvbGxhcHNlICYmIGNvbGxhcHNlICE9IFwiZW5kXCIgJiYgY29tcHV0ZVJlcGxhY2VkU2VsKHRoaXMsIGNoYW5nZXMsIGNvbGxhcHNlKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKVxuICAgICAgICB7IG1ha2VDaGFuZ2UodGhpcywgY2hhbmdlc1tpJDFdKTsgfVxuICAgICAgaWYgKG5ld1NlbCkgeyBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeSh0aGlzLCBuZXdTZWwpOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLmNtKSB7IGVuc3VyZUN1cnNvclZpc2libGUodGhpcy5jbSk7IH1cbiAgICB9KSxcbiAgICB1bmRvOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIpO30pLFxuICAgIHJlZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIik7fSksXG4gICAgdW5kb1NlbGVjdGlvbjogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwidW5kb1wiLCB0cnVlKTt9KSxcbiAgICByZWRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJyZWRvXCIsIHRydWUpO30pLFxuXG4gICAgc2V0RXh0ZW5kaW5nOiBmdW5jdGlvbih2YWwpIHt0aGlzLmV4dGVuZCA9IHZhbDt9LFxuICAgIGdldEV4dGVuZGluZzogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZXh0ZW5kfSxcblxuICAgIGhpc3RvcnlTaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5LCBkb25lID0gMCwgdW5kb25lID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlzdC5kb25lLmxlbmd0aDsgaSsrKSB7IGlmICghaGlzdC5kb25lW2ldLnJhbmdlcykgeyArK2RvbmU7IH0gfVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGlzdC51bmRvbmUubGVuZ3RoOyBpJDErKykgeyBpZiAoIWhpc3QudW5kb25lW2kkMV0ucmFuZ2VzKSB7ICsrdW5kb25lOyB9IH1cbiAgICAgIHJldHVybiB7dW5kbzogZG9uZSwgcmVkbzogdW5kb25lfVxuICAgIH0sXG4gICAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzLmhpc3RvcnkpO1xuICAgICAgbGlua2VkRG9jcyh0aGlzLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBkb2MuaGlzdG9yeSA9IHRoaXMkMS5oaXN0b3J5OyB9LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgbWFya0NsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY2xlYW5HZW5lcmF0aW9uID0gdGhpcy5jaGFuZ2VHZW5lcmF0aW9uKHRydWUpO1xuICAgIH0sXG4gICAgY2hhbmdlR2VuZXJhdGlvbjogZnVuY3Rpb24oZm9yY2VTcGxpdCkge1xuICAgICAgaWYgKGZvcmNlU3BsaXQpXG4gICAgICAgIHsgdGhpcy5oaXN0b3J5Lmxhc3RPcCA9IHRoaXMuaGlzdG9yeS5sYXN0U2VsT3AgPSB0aGlzLmhpc3RvcnkubGFzdE9yaWdpbiA9IG51bGw7IH1cbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvblxuICAgIH0sXG4gICAgaXNDbGVhbjogZnVuY3Rpb24gKGdlbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZW5lcmF0aW9uID09IChnZW4gfHwgdGhpcy5jbGVhbkdlbmVyYXRpb24pXG4gICAgfSxcblxuICAgIGdldEhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtkb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS5kb25lKSxcbiAgICAgICAgICAgICAgdW5kb25lOiBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUpfVxuICAgIH0sXG4gICAgc2V0SGlzdG9yeTogZnVuY3Rpb24oaGlzdERhdGEpIHtcbiAgICAgIHZhciBoaXN0ID0gdGhpcy5oaXN0b3J5ID0gbmV3IEhpc3RvcnkodGhpcy5oaXN0b3J5KTtcbiAgICAgIGhpc3QuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XG4gICAgICBoaXN0LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEudW5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gbGluZS5ndXR0ZXJNYXJrZXJzIHx8IChsaW5lLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmd1dHRlck1hcmtlcnMgJiYgbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSkge1xuICAgICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcImd1dHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGxpbmUuZ3V0dGVyTWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksXG5cbiAgICBsaW5lSW5mbzogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoIWlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIG4gPSBsaW5lO1xuICAgICAgICBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChuID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c31cbiAgICB9LFxuXG4gICAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIHsgbGluZVtwcm9wXSA9IGNsczsgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc1Rlc3QoY2xzKS50ZXN0KGxpbmVbcHJvcF0pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgeyBsaW5lW3Byb3BdICs9IFwiIFwiICsgY2xzOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFwidGV4dFwiID8gXCJ0ZXh0Q2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiYmFja2dyb3VuZFwiID8gXCJiZ0NsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF07XG4gICAgICAgIGlmICghY3VyKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgaWYgKGNscyA9PSBudWxsKSB7IGxpbmVbcHJvcF0gPSBudWxsOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSk7XG4gICAgICAgICAgaWYgKCFmb3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIHZhciBlbmQgPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcIlwiIDogXCIgXCIpICsgY3VyLnNsaWNlKGVuZCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGFkZExpbmVXaWRnZXQ6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVXaWRnZXQ6IGZ1bmN0aW9uKHdpZGdldCkgeyB3aWRnZXQuY2xlYXIoKTsgfSxcblxuICAgIG1hcmtUZXh0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcInJhbmdlXCIpXG4gICAgfSxcbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24ocG9zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVhbE9wdHMgPSB7cmVwbGFjZWRXaXRoOiBvcHRpb25zICYmIChvcHRpb25zLm5vZGVUeXBlID09IG51bGwgPyBvcHRpb25zLndpZGdldCA6IG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyV2hlbkVtcHR5OiBmYWxzZSwgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnRzOiBvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHN9O1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXCJib29rbWFya1wiKVxuICAgIH0sXG4gICAgZmluZE1hcmtzQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiZcbiAgICAgICAgICAgIChzcGFuLnRvID09IG51bGwgfHwgc3Bhbi50byA+PSBwb3MuY2gpKVxuICAgICAgICAgIHsgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgIH0gfVxuICAgICAgcmV0dXJuIG1hcmtlcnNcbiAgICB9LFxuICAgIGZpbmRNYXJrczogZnVuY3Rpb24oZnJvbSwgdG8sIGZpbHRlcikge1xuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0byk7XG4gICAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vID0gZnJvbS5saW5lO1xuICAgICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gPT0gbnVsbCAmJiBsaW5lTm8gIT0gZnJvbS5saW5lIHx8XG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tICE9IG51bGwgJiYgbGluZU5vID09IHRvLmxpbmUgJiYgc3Bhbi5mcm9tID49IHRvLmNoKSAmJlxuICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcbiAgICAgICAgICAgIHsgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpOyB9XG4gICAgICAgIH0gfVxuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kXG4gICAgfSxcbiAgICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcHMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKHNwc1tpXS5mcm9tICE9IG51bGwpIHsgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpOyB9IH0gfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG5cbiAgICBwb3NGcm9tSW5kZXg6IGZ1bmN0aW9uKG9mZikge1xuICAgICAgdmFyIGNoLCBsaW5lTm8gPSB0aGlzLmZpcnN0LCBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzeiA9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlIH1cbiAgICAgICAgb2ZmIC09IHN6O1xuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKVxuICAgIH0sXG4gICAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3Jkcyk7XG4gICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XG4gICAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxuICAgICAgdmFyIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uIChsaW5lKSB7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxuICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XG4gICAgICB2YXIgZG9jID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgZG9jLnNlbCA9IHRoaXMuc2VsO1xuICAgICAgZG9jLmV4dGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKGNvcHlIaXN0b3J5KSB7XG4gICAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGg7XG4gICAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuXG4gICAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT0gbnVsbCAmJiBvcHRpb25zLmZyb20gPiBmcm9tKSB7IGZyb20gPSBvcHRpb25zLmZyb207IH1cbiAgICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB7IHRvID0gb3B0aW9ucy50bzsgfVxuICAgICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7IGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeVxuICAgICAgOyB9KHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcbiAgICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XTtcbiAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgIHJldHVybiBjb3B5XG4gICAgfSxcbiAgICB1bmxpbmtEb2M6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSB7IG90aGVyID0gb3RoZXIuZG9jOyB9XG4gICAgICBpZiAodGhpcy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua2VkW2ldO1xuICAgICAgICBpZiAobGluay5kb2MgIT0gb3RoZXIpIHsgY29udGludWUgfVxuICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG90aGVyLnVubGlua0RvYyh0aGlzKTtcbiAgICAgICAgZGV0YWNoU2hhcmVkTWFya2VycyhmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IH1cbiAgICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cbiAgICAgIGlmIChvdGhlci5oaXN0b3J5ID09IHRoaXMuaGlzdG9yeSkge1xuICAgICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xuICAgICAgICBsaW5rZWREb2NzKG90aGVyLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBzcGxpdElkcy5wdXNoKGRvYy5pZCk7IH0sIHRydWUpO1xuICAgICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKTt9LFxuXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZX0sXG4gICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5jbX0sXG5cbiAgICBzcGxpdExpbmVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVTZXApIHsgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApIH1cbiAgICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpXG4gICAgfSxcbiAgICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcIlxcblwiIH0sXG5cbiAgICBzZXREaXJlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIGlmIChkaXIgIT0gXCJydGxcIikgeyBkaXIgPSBcImx0clwiOyB9XG4gICAgICBpZiAoZGlyID09IHRoaXMuZGlyZWN0aW9uKSB7IHJldHVybiB9XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gbGluZS5vcmRlciA9IG51bGw7IH0pO1xuICAgICAgaWYgKHRoaXMuY20pIHsgZGlyZWN0aW9uQ2hhbmdlZCh0aGlzLmNtKTsgfVxuICAgIH0pXG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBhbGlhcy5cbiAgRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlcjtcblxuICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgc3RyYW5nZSBJRSBiZWhhdmlvciB3aGVyZSBpdCdsbCBzb21ldGltZXNcbiAgLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcbiAgdmFyIGxhc3REcm9wID0gMDtcblxuICBmdW5jdGlvbiBvbkRyb3AoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgY2xlYXJEcmFnQ3Vyc29yKGNtKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXG4gICAgICB7IHJldHVybiB9XG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICBpZiAoaWUpIHsgbGFzdERyb3AgPSArbmV3IERhdGU7IH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoIXBvcyB8fCBjbS5pc1JlYWRPbmx5KCkpIHsgcmV0dXJuIH1cbiAgICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xuICAgICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDA7XG4gICAgICB2YXIgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgrK3JlYWQgPT0gbikge1xuICAgICAgICAgIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY20uZG9jLnNwbGl0TGluZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAhPSBudWxsOyB9KS5qb2luKGNtLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInBhc3RlXCJ9O1xuICAgICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihjbGlwUG9zKGNtLmRvYywgcG9zKSwgY2xpcFBvcyhjbS5kb2MsIGNoYW5nZUVuZChjaGFuZ2UpKSkpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVhZFRleHRGcm9tRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgICAgIGlmIChjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyAmJlxuICAgICAgICAgICAgaW5kZXhPZihjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcywgZmlsZS50eXBlKSA9PSAtMSkge1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7IH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRbaV0gPSBjb250ZW50O1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHsgcmVhZFRleHRGcm9tRmlsZShmaWxlc1tpXSwgaSk7IH1cbiAgICB9IGVsc2UgeyAvLyBOb3JtYWwgZHJvcFxuICAgICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cbiAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID4gLTEpIHtcbiAgICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0KGUpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGVkaXRvciBpcyByZS1mb2N1c2VkXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRleHQkMSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCQxKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KVxuICAgICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7IH1cbiAgICAgICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBwb3MpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2VsZWN0ZWQubGVuZ3RoOyArK2kkMSlcbiAgICAgICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwgc2VsZWN0ZWRbaSQxXS5hbmNob3IsIHNlbGVjdGVkW2kkMV0uaGVhZCwgXCJkcmFnXCIpOyB9IH1cbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHRleHQkMSwgXCJhcm91bmRcIiwgXCJwYXN0ZVwiKTtcbiAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoKGUkMSl7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLCBlKSB7XG4gICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XG5cbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCBjbS5nZXRTZWxlY3Rpb24oKSk7XG4gICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcblxuICAgIC8vIFVzZSBkdW1teSBpbWFnZSBpbnN0ZWFkIG9mIGRlZmF1bHQgYnJvd3NlcnMgaW1hZ2UuXG4gICAgLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxuICAgIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xuICAgICAgdmFyIGltZyA9IGVsdChcImltZ1wiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtcbiAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XG4gICAgICBpZiAocHJlc3RvKSB7XG4gICAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxO1xuICAgICAgICBjbS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgLy8gRm9yY2UgYSByZWxheW91dCwgb3IgT3BlcmEgd29uJ3QgdXNlIG91ciBpbWFnZSBmb3Igc29tZSBvYnNjdXJlIHJlYXNvblxuICAgICAgICBpbWcuX3RvcCA9IGltZy5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgIGlmIChwcmVzdG8pIHsgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ092ZXIoY20sIGUpIHtcbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICBpZiAoIXBvcykgeyByZXR1cm4gfVxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHBvcywgZnJhZyk7XG4gICAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29ycyBDb2RlTWlycm9yLWRyYWdjdXJzb3JzXCIpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgY20uZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGZyYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yKTtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlc2UgbXVzdCBiZSBoYW5kbGVkIGNhcmVmdWxseSwgYmVjYXVzZSBuYWl2ZWx5IHJlZ2lzdGVyaW5nIGFcbiAgLy8gaGFuZGxlciBmb3IgZWFjaCBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgZWRpdG9ycyB0byBuZXZlciBiZVxuICAvLyBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICBmdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKSB7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7IHJldHVybiB9XG4gICAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiQ29kZU1pcnJvclwiKSwgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnlDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xuICAgICAgaWYgKGNtKSB7IGVkaXRvcnMucHVzaChjbSk7IH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoKSB7IGVkaXRvcnNbMF0ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdG9ycy5sZW5ndGg7IGkrKykgeyBmKGVkaXRvcnNbaV0pOyB9XG4gICAgfSk7IH1cbiAgfVxuXG4gIHZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVHbG9iYWxIYW5kbGVycygpIHtcbiAgICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHsgcmV0dXJuIH1cbiAgICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCk7XG4gICAgZ2xvYmFsc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgLy8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cbiAgICB2YXIgcmVzaXplVGltZXI7XG4gICAgb24od2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgeyByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNpemVUaW1lciA9IG51bGw7XG4gICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcbiAgICAgIH0sIDEwMCk7IH1cbiAgICB9KTtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcbiAgICBvbih3aW5kb3csIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KTtcbiAgfVxuICAvLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcbiAgZnVuY3Rpb24gb25SZXNpemUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgLy8gTWlnaHQgYmUgYSB0ZXh0IHNjYWxpbmcgb3BlcmF0aW9uLCBjbGVhciBzaXplIGNhY2hlcy5cbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcbiAgICBjbS5zZXRTaXplKCk7XG4gIH1cblxuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgMzogXCJQYXVzZVwiLCA4OiBcIkJhY2tzcGFjZVwiLCA5OiBcIlRhYlwiLCAxMzogXCJFbnRlclwiLCAxNjogXCJTaGlmdFwiLCAxNzogXCJDdHJsXCIsIDE4OiBcIkFsdFwiLFxuICAgIDE5OiBcIlBhdXNlXCIsIDIwOiBcIkNhcHNMb2NrXCIsIDI3OiBcIkVzY1wiLCAzMjogXCJTcGFjZVwiLCAzMzogXCJQYWdlVXBcIiwgMzQ6IFwiUGFnZURvd25cIiwgMzU6IFwiRW5kXCIsXG4gICAgMzY6IFwiSG9tZVwiLCAzNzogXCJMZWZ0XCIsIDM4OiBcIlVwXCIsIDM5OiBcIlJpZ2h0XCIsIDQwOiBcIkRvd25cIiwgNDQ6IFwiUHJpbnRTY3JuXCIsIDQ1OiBcIkluc2VydFwiLFxuICAgIDQ2OiBcIkRlbGV0ZVwiLCA1OTogXCI7XCIsIDYxOiBcIj1cIiwgOTE6IFwiTW9kXCIsIDkyOiBcIk1vZFwiLCA5MzogXCJNb2RcIixcbiAgICAxMDY6IFwiKlwiLCAxMDc6IFwiPVwiLCAxMDk6IFwiLVwiLCAxMTA6IFwiLlwiLCAxMTE6IFwiL1wiLCAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAgIDE3MzogXCItXCIsIDE4NjogXCI7XCIsIDE4NzogXCI9XCIsIDE4ODogXCIsXCIsIDE4OTogXCItXCIsIDE5MDogXCIuXCIsIDE5MTogXCIvXCIsIDE5MjogXCJgXCIsIDIxOTogXCJbXCIsIDIyMDogXCJcXFxcXCIsXG4gICAgMjIxOiBcIl1cIiwgMjIyOiBcIidcIiwgMjI0OiBcIk1vZFwiLCA2MzIzMjogXCJVcFwiLCA2MzIzMzogXCJEb3duXCIsIDYzMjM0OiBcIkxlZnRcIiwgNjMyMzU6IFwiUmlnaHRcIiwgNjMyNzI6IFwiRGVsZXRlXCIsXG4gICAgNjMyNzM6IFwiSG9tZVwiLCA2MzI3NTogXCJFbmRcIiwgNjMyNzY6IFwiUGFnZVVwXCIsIDYzMjc3OiBcIlBhZ2VEb3duXCIsIDYzMzAyOiBcIkluc2VydFwiXG4gIH07XG5cbiAgLy8gTnVtYmVyIGtleXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpOyB9XG4gIC8vIEFscGhhYmV0aWMga2V5c1xuICBmb3IgKHZhciBpJDEgPSA2NTsgaSQxIDw9IDkwOyBpJDErKykgeyBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpOyB9XG4gIC8vIEZ1bmN0aW9uIGtleXNcbiAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDw9IDEyOyBpJDIrKykgeyBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXCJGXCIgKyBpJDI7IH1cblxuICB2YXIga2V5TWFwID0ge307XG5cbiAga2V5TWFwLmJhc2ljID0ge1xuICAgIFwiTGVmdFwiOiBcImdvQ2hhckxlZnRcIiwgXCJSaWdodFwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiVXBcIjogXCJnb0xpbmVVcFwiLCBcIkRvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJFbmRcIjogXCJnb0xpbmVFbmRcIiwgXCJIb21lXCI6IFwiZ29MaW5lU3RhcnRTbWFydFwiLCBcIlBhZ2VVcFwiOiBcImdvUGFnZVVwXCIsIFwiUGFnZURvd25cIjogXCJnb1BhZ2VEb3duXCIsXG4gICAgXCJEZWxldGVcIjogXCJkZWxDaGFyQWZ0ZXJcIiwgXCJCYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsIFwiU2hpZnQtQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLFxuICAgIFwiVGFiXCI6IFwiZGVmYXVsdFRhYlwiLCBcIlNoaWZ0LVRhYlwiOiBcImluZGVudEF1dG9cIixcbiAgICBcIkVudGVyXCI6IFwibmV3bGluZUFuZEluZGVudFwiLCBcIkluc2VydFwiOiBcInRvZ2dsZU92ZXJ3cml0ZVwiLFxuICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uXCJcbiAgfTtcbiAgLy8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcbiAgLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcbiAgLy8gYXJlIHNpbXBseSBpZ25vcmVkLlxuICBrZXlNYXAucGNEZWZhdWx0ID0ge1xuICAgIFwiQ3RybC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ3RybC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkN0cmwtWlwiOiBcInVuZG9cIiwgXCJTaGlmdC1DdHJsLVpcIjogXCJyZWRvXCIsIFwiQ3RybC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ3RybC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLURvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJDdHJsLUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLCBcIkN0cmwtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJBbHQtTGVmdFwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQWx0LVJpZ2h0XCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgXCJDdHJsLUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsIFwiQ3RybC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ3RybC1TXCI6IFwic2F2ZVwiLCBcIkN0cmwtRlwiOiBcImZpbmRcIixcbiAgICBcIkN0cmwtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ3RybC1HXCI6IFwiZmluZFByZXZcIiwgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ3RybC1SXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgIFwiQ3RybC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkN0cmwtXVwiOiBcImluZGVudE1vcmVcIixcbiAgICBcIkN0cmwtVVwiOiBcInVuZG9TZWxlY3Rpb25cIiwgXCJTaGlmdC1DdHJsLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQWx0LVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsXG4gICAgXCJmYWxsdGhyb3VnaFwiOiBcImJhc2ljXCJcbiAgfTtcbiAgLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cbiAga2V5TWFwLmVtYWNzeSA9IHtcbiAgICBcIkN0cmwtRlwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiQ3RybC1CXCI6IFwiZ29DaGFyTGVmdFwiLCBcIkN0cmwtUFwiOiBcImdvTGluZVVwXCIsIFwiQ3RybC1OXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiQ3RybC1BXCI6IFwiZ29MaW5lU3RhcnRcIiwgXCJDdHJsLUVcIjogXCJnb0xpbmVFbmRcIiwgXCJDdHJsLVZcIjogXCJnb1BhZ2VEb3duXCIsIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIixcbiAgICBcIkN0cmwtRFwiOiBcImRlbENoYXJBZnRlclwiLCBcIkN0cmwtSFwiOiBcImRlbENoYXJCZWZvcmVcIiwgXCJBbHQtQmFja3NwYWNlXCI6IFwiZGVsV29yZEJlZm9yZVwiLCBcIkN0cmwtS1wiOiBcImtpbGxMaW5lXCIsXG4gICAgXCJDdHJsLVRcIjogXCJ0cmFuc3Bvc2VDaGFyc1wiLCBcIkN0cmwtT1wiOiBcIm9wZW5MaW5lXCJcbiAgfTtcbiAga2V5TWFwLm1hY0RlZmF1bHQgPSB7XG4gICAgXCJDbWQtQVwiOiBcInNlbGVjdEFsbFwiLCBcIkNtZC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkNtZC1aXCI6IFwidW5kb1wiLCBcIlNoaWZ0LUNtZC1aXCI6IFwicmVkb1wiLCBcIkNtZC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ21kLUhvbWVcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ21kLVVwXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkNtZC1FbmRcIjogXCJnb0RvY0VuZFwiLCBcIkNtZC1Eb3duXCI6IFwiZ29Eb2NFbmRcIiwgXCJBbHQtTGVmdFwiOiBcImdvR3JvdXBMZWZ0XCIsXG4gICAgXCJBbHQtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJDbWQtTGVmdFwiOiBcImdvTGluZUxlZnRcIiwgXCJDbWQtUmlnaHRcIjogXCJnb0xpbmVSaWdodFwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEJlZm9yZVwiLFxuICAgIFwiQ3RybC1BbHQtQmFja3NwYWNlXCI6IFwiZGVsR3JvdXBBZnRlclwiLCBcIkFsdC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ21kLVNcIjogXCJzYXZlXCIsIFwiQ21kLUZcIjogXCJmaW5kXCIsXG4gICAgXCJDbWQtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ21kLUdcIjogXCJmaW5kUHJldlwiLCBcIkNtZC1BbHQtRlwiOiBcInJlcGxhY2VcIiwgXCJTaGlmdC1DbWQtQWx0LUZcIjogXCJyZXBsYWNlQWxsXCIsXG4gICAgXCJDbWQtW1wiOiBcImluZGVudExlc3NcIiwgXCJDbWQtXVwiOiBcImluZGVudE1vcmVcIiwgXCJDbWQtQmFja3NwYWNlXCI6IFwiZGVsV3JhcHBlZExpbmVMZWZ0XCIsIFwiQ21kLURlbGV0ZVwiOiBcImRlbFdyYXBwZWRMaW5lUmlnaHRcIixcbiAgICBcIkNtZC1VXCI6IFwidW5kb1NlbGVjdGlvblwiLCBcIlNoaWZ0LUNtZC1VXCI6IFwicmVkb1NlbGVjdGlvblwiLCBcIkN0cmwtVXBcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ3RybC1Eb3duXCI6IFwiZ29Eb2NFbmRcIixcbiAgICBcImZhbGx0aHJvdWdoXCI6IFtcImJhc2ljXCIsIFwiZW1hY3N5XCJdXG4gIH07XG4gIGtleU1hcFtcImRlZmF1bHRcIl0gPSBtYWMgPyBrZXlNYXAubWFjRGVmYXVsdCA6IGtleU1hcC5wY0RlZmF1bHQ7XG5cbiAgLy8gS0VZTUFQIERJU1BBVENIXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgbmFtZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBhbHQsIGN0cmwsIHNoaWZ0LCBjbWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBtb2QgPSBwYXJ0c1tpXTtcbiAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHsgY21kID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL15hKGx0KT8kL2kudGVzdChtb2QpKSB7IGFsdCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpIHsgY3RybCA9IHRydWU7IH1cbiAgICAgIGVsc2UgaWYgKC9ecyhoaWZ0KT8kL2kudGVzdChtb2QpKSB7IHNoaWZ0ID0gdHJ1ZTsgfVxuICAgICAgZWxzZSB7IHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiBcIiArIG1vZCkgfVxuICAgIH1cbiAgICBpZiAoYWx0KSB7IG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7IH1cbiAgICBpZiAoY3RybCkgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICAgIGlmIChjbWQpIHsgbmFtZSA9IFwiQ21kLVwiICsgbmFtZTsgfVxuICAgIGlmIChzaGlmdCkgeyBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7IH1cbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gVGhpcyBpcyBhIGtsdWRnZSB0byBrZWVwIGtleW1hcHMgbW9zdGx5IHdvcmtpbmcgYXMgcmF3IG9iamVjdHNcbiAgLy8gKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSB3aGlsZSBhdCB0aGUgc2FtZSB0aW1lIHN1cHBvcnQgZmVhdHVyZXNcbiAgLy8gbGlrZSBub3JtYWxpemF0aW9uIGFuZCBtdWx0aS1zdHJva2Uga2V5IGJpbmRpbmdzLiBJdCBjb21waWxlcyBhXG4gIC8vIG5ldyBub3JtYWxpemVkIGtleW1hcCwgYW5kIHRoZW4gdXBkYXRlcyB0aGUgb2xkIG9iamVjdCB0byByZWZsZWN0XG4gIC8vIHRoaXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUtleU1hcChrZXltYXApIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIGZvciAodmFyIGtleW5hbWUgaW4ga2V5bWFwKSB7IGlmIChrZXltYXAuaGFzT3duUHJvcGVydHkoa2V5bmFtZSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGtleW1hcFtrZXluYW1lXTtcbiAgICAgIGlmICgvXihuYW1lfGZhbGx0aHJvdWdofChkZXxhdCl0YWNoKSQvLnRlc3Qoa2V5bmFtZSkpIHsgY29udGludWUgfVxuICAgICAgaWYgKHZhbHVlID09IFwiLi4uXCIpIHsgZGVsZXRlIGtleW1hcFtrZXluYW1lXTsgY29udGludWUgfVxuXG4gICAgICB2YXIga2V5cyA9IG1hcChrZXluYW1lLnNwbGl0KFwiIFwiKSwgbm9ybWFsaXplS2V5TmFtZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbCA9ICh2b2lkIDApLCBuYW1lID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChpID09IGtleXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG5hbWUgPSBrZXlzLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5hbWUgPSBrZXlzLnNsaWNlKDAsIGkgKyAxKS5qb2luKFwiIFwiKTtcbiAgICAgICAgICB2YWwgPSBcIi4uLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2ID0gY29weVtuYW1lXTtcbiAgICAgICAgaWYgKCFwcmV2KSB7IGNvcHlbbmFtZV0gPSB2YWw7IH1cbiAgICAgICAgZWxzZSBpZiAocHJldiAhPSB2YWwpIHsgdGhyb3cgbmV3IEVycm9yKFwiSW5jb25zaXN0ZW50IGJpbmRpbmdzIGZvciBcIiArIG5hbWUpIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBrZXltYXBba2V5bmFtZV07XG4gICAgfSB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBjb3B5KSB7IGtleW1hcFtwcm9wXSA9IGNvcHlbcHJvcF07IH1cbiAgICByZXR1cm4ga2V5bWFwXG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBLZXkoa2V5LCBtYXAsIGhhbmRsZSwgY29udGV4dCkge1xuICAgIG1hcCA9IGdldEtleU1hcChtYXApO1xuICAgIHZhciBmb3VuZCA9IG1hcC5jYWxsID8gbWFwLmNhbGwoa2V5LCBjb250ZXh0KSA6IG1hcFtrZXldO1xuICAgIGlmIChmb3VuZCA9PT0gZmFsc2UpIHsgcmV0dXJuIFwibm90aGluZ1wiIH1cbiAgICBpZiAoZm91bmQgPT09IFwiLi4uXCIpIHsgcmV0dXJuIFwibXVsdGlcIiB9XG4gICAgaWYgKGZvdW5kICE9IG51bGwgJiYgaGFuZGxlKGZvdW5kKSkgeyByZXR1cm4gXCJoYW5kbGVkXCIgfVxuXG4gICAgaWYgKG1hcC5mYWxsdGhyb3VnaCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXAuZmFsbHRocm91Z2gpICE9IFwiW29iamVjdCBBcnJheV1cIilcbiAgICAgICAgeyByZXR1cm4gbG9va3VwS2V5KGtleSwgbWFwLmZhbGx0aHJvdWdoLCBoYW5kbGUsIGNvbnRleHQpIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwLmZhbGx0aHJvdWdoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2hbaV0sIGhhbmRsZSwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTW9kaWZpZXIga2V5IHByZXNzZXMgZG9uJ3QgY291bnQgYXMgJ3JlYWwnIGtleSBwcmVzc2VzIGZvciB0aGVcbiAgLy8gcHVycG9zZSBvZiBrZXltYXAgZmFsbHRocm91Z2guXG4gIGZ1bmN0aW9uIGlzTW9kaWZpZXJLZXkodmFsdWUpIHtcbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiID8gdmFsdWUgOiBrZXlOYW1lc1t2YWx1ZS5rZXlDb2RlXTtcbiAgICByZXR1cm4gbmFtZSA9PSBcIkN0cmxcIiB8fCBuYW1lID09IFwiQWx0XCIgfHwgbmFtZSA9PSBcIlNoaWZ0XCIgfHwgbmFtZSA9PSBcIk1vZFwiXG4gIH1cblxuICBmdW5jdGlvbiBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50LCBub1NoaWZ0KSB7XG4gICAgdmFyIGJhc2UgPSBuYW1lO1xuICAgIGlmIChldmVudC5hbHRLZXkgJiYgYmFzZSAhPSBcIkFsdFwiKSB7IG5hbWUgPSBcIkFsdC1cIiArIG5hbWU7IH1cbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXkpICYmIGJhc2UgIT0gXCJDdHJsXCIpIHsgbmFtZSA9IFwiQ3RybC1cIiArIG5hbWU7IH1cbiAgICBpZiAoKGZsaXBDdHJsQ21kID8gZXZlbnQuY3RybEtleSA6IGV2ZW50Lm1ldGFLZXkpICYmIGJhc2UgIT0gXCJNb2RcIikgeyBuYW1lID0gXCJDbWQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKCFub1NoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGJhc2UgIT0gXCJTaGlmdFwiKSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBuYW1lIG9mIGEga2V5IGFzIGluZGljYXRlZCBieSBhbiBldmVudCBvYmplY3QuXG4gIGZ1bmN0aW9uIGtleU5hbWUoZXZlbnQsIG5vU2hpZnQpIHtcbiAgICBpZiAocHJlc3RvICYmIGV2ZW50LmtleUNvZGUgPT0gMzQgJiYgZXZlbnRbXCJjaGFyXCJdKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lc1tldmVudC5rZXlDb2RlXTtcbiAgICBpZiAobmFtZSA9PSBudWxsIHx8IGV2ZW50LmFsdEdyYXBoS2V5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgLy8gQ3RybC1TY3JvbGxMb2NrIGhhcyBrZXlDb2RlIDMsIHNhbWUgYXMgQ3RybC1QYXVzZSxcbiAgICAvLyBzbyB3ZSdsbCB1c2UgZXZlbnQuY29kZSB3aGVuIGF2YWlsYWJsZSAoQ2hyb21lIDQ4KywgRkYgMzgrLCBTYWZhcmkgMTAuMSspXG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMyAmJiBldmVudC5jb2RlKSB7IG5hbWUgPSBldmVudC5jb2RlOyB9XG4gICAgcmV0dXJuIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRLZXlNYXAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIiA/IGtleU1hcFt2YWxdIDogdmFsXG4gIH1cblxuICAvLyBIZWxwZXIgZm9yIGRlbGV0aW5nIHRleHQgbmVhciB0aGUgc2VsZWN0aW9uKHMpLCB1c2VkIHRvIGltcGxlbWVudFxuICAvLyBiYWNrc3BhY2UsIGRlbGV0ZSwgYW5kIHNpbWlsYXIgZnVuY3Rpb25hbGl0eS5cbiAgZnVuY3Rpb24gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgY29tcHV0ZSkge1xuICAgIHZhciByYW5nZXMgPSBjbS5kb2Muc2VsLnJhbmdlcywga2lsbCA9IFtdO1xuICAgIC8vIEJ1aWxkIHVwIGEgc2V0IG9mIHJhbmdlcyB0byBraWxsIGZpcnN0LCBtZXJnaW5nIG92ZXJsYXBwaW5nXG4gICAgLy8gcmFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9LaWxsID0gY29tcHV0ZShyYW5nZXNbaV0pO1xuICAgICAgd2hpbGUgKGtpbGwubGVuZ3RoICYmIGNtcCh0b0tpbGwuZnJvbSwgbHN0KGtpbGwpLnRvKSA8PSAwKSB7XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGtpbGwucG9wKCk7XG4gICAgICAgIGlmIChjbXAocmVwbGFjZWQuZnJvbSwgdG9LaWxsLmZyb20pIDwgMCkge1xuICAgICAgICAgIHRvS2lsbC5mcm9tID0gcmVwbGFjZWQuZnJvbTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBraWxsLnB1c2godG9LaWxsKTtcbiAgICB9XG4gICAgLy8gTmV4dCwgcmVtb3ZlIHRob3NlIGFjdHVhbCByYW5nZXMuXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IGtpbGwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwga2lsbFtpXS5mcm9tLCBraWxsW2ldLnRvLCBcIitkZWxldGVcIik7IH1cbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgY2gsIGRpcikge1xuICAgIHZhciB0YXJnZXQgPSBza2lwRXh0ZW5kaW5nQ2hhcnMobGluZS50ZXh0LCBjaCArIGRpciwgZGlyKTtcbiAgICByZXR1cm4gdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPiBsaW5lLnRleHQubGVuZ3RoID8gbnVsbCA6IHRhcmdldFxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB7XG4gICAgdmFyIGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZSwgc3RhcnQuY2gsIGRpcik7XG4gICAgcmV0dXJuIGNoID09IG51bGwgPyBudWxsIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgZGlyIDwgMCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCIpXG4gIH1cblxuICBmdW5jdGlvbiBlbmRPZkxpbmUodmlzdWFsbHksIGNtLCBsaW5lT2JqLCBsaW5lTm8sIGRpcikge1xuICAgIGlmICh2aXN1YWxseSkge1xuICAgICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIikgeyBkaXIgPSAtZGlyOyB9XG4gICAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lT2JqLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICB2YXIgcGFydCA9IGRpciA8IDAgPyBsc3Qob3JkZXIpIDogb3JkZXJbMF07XG4gICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSk7XG4gICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgICAgICB2YXIgY2g7XG4gICAgICAgIC8vIFdpdGggYSB3cmFwcGVkIHJ0bCBjaHVuayAocG9zc2libHkgc3Bhbm5pbmcgbXVsdGlwbGUgYmlkaSBwYXJ0cyksXG4gICAgICAgIC8vIGl0IGNvdWxkIGJlIHRoYXQgdGhlIGxhc3QgYmlkaSBwYXJ0IGlzIG5vdCBvbiB0aGUgbGFzdCB2aXN1YWwgbGluZSxcbiAgICAgICAgLy8gc2luY2UgdmlzdWFsIGxpbmVzIGNvbnRhaW4gY29udGVudCBvcmRlci1jb25zZWN1dGl2ZSBjaHVua3MuXG4gICAgICAgIC8vIFRodXMsIGluIHJ0bCwgd2UgYXJlIGxvb2tpbmcgZm9yIHRoZSBmaXJzdCAoY29udGVudC1vcmRlcikgY2hhcmFjdGVyXG4gICAgICAgIC8vIGluIHRoZSBydGwgY2h1bmsgdGhhdCBpcyBvbiB0aGUgbGFzdCBsaW5lICh0aGF0IGlzLCB0aGUgc2FtZSBsaW5lXG4gICAgICAgIC8vIGFzIHRoZSBsYXN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXIpLlxuICAgICAgICBpZiAocGFydC5sZXZlbCA+IDAgfHwgY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiKSB7XG4gICAgICAgICAgdmFyIHByZXAgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopO1xuICAgICAgICAgIGNoID0gZGlyIDwgMCA/IGxpbmVPYmoudGV4dC5sZW5ndGggLSAxIDogMDtcbiAgICAgICAgICB2YXIgdGFyZ2V0VG9wID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcDtcbiAgICAgICAgICBjaCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXAsIGNoKS50b3AgPT0gdGFyZ2V0VG9wOyB9LCAoZGlyIDwgMCkgPT0gKHBhcnQubGV2ZWwgPT0gMSkgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMSwgY2gpO1xuICAgICAgICAgIGlmIChzdGlja3kgPT0gXCJiZWZvcmVcIikgeyBjaCA9IG1vdmVDaGFyTG9naWNhbGx5KGxpbmVPYmosIGNoLCAxKTsgfVxuICAgICAgICB9IGVsc2UgeyBjaCA9IGRpciA8IDAgPyBwYXJ0LnRvIDogcGFydC5mcm9tOyB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zKGxpbmVObywgY2gsIHN0aWNreSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCA6IDAsIGRpciA8IDAgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiKVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVZpc3VhbGx5KGNtLCBsaW5lLCBzdGFydCwgZGlyKSB7XG4gICAgdmFyIGJpZGkgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICBpZiAoIWJpZGkpIHsgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcikgfVxuICAgIGlmIChzdGFydC5jaCA+PSBsaW5lLnRleHQubGVuZ3RoKSB7XG4gICAgICBzdGFydC5jaCA9IGxpbmUudGV4dC5sZW5ndGg7XG4gICAgICBzdGFydC5zdGlja3kgPSBcImJlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoc3RhcnQuY2ggPD0gMCkge1xuICAgICAgc3RhcnQuY2ggPSAwO1xuICAgICAgc3RhcnQuc3RpY2t5ID0gXCJhZnRlclwiO1xuICAgIH1cbiAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQoYmlkaSwgc3RhcnQuY2gsIHN0YXJ0LnN0aWNreSksIHBhcnQgPSBiaWRpW3BhcnRQb3NdO1xuICAgIGlmIChjbS5kb2MuZGlyZWN0aW9uID09IFwibHRyXCIgJiYgcGFydC5sZXZlbCAlIDIgPT0gMCAmJiAoZGlyID4gMCA/IHBhcnQudG8gPiBzdGFydC5jaCA6IHBhcnQuZnJvbSA8IHN0YXJ0LmNoKSkge1xuICAgICAgLy8gQ2FzZSAxOiBXZSBtb3ZlIHdpdGhpbiBhbiBsdHIgcGFydCBpbiBhbiBsdHIgZWRpdG9yLiBFdmVuIHdpdGggd3JhcHBlZCBsaW5lcyxcbiAgICAgIC8vIG5vdGhpbmcgaW50ZXJlc3RpbmcgaGFwcGVucy5cbiAgICAgIHJldHVybiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpXG4gICAgfVxuXG4gICAgdmFyIG12ID0gZnVuY3Rpb24gKHBvcywgZGlyKSB7IHJldHVybiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBwb3MgaW5zdGFuY2VvZiBQb3MgPyBwb3MuY2ggOiBwb3MsIGRpcik7IH07XG4gICAgdmFyIHByZXA7XG4gICAgdmFyIGdldFdyYXBwZWRMaW5lRXh0ZW50ID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IHJldHVybiB7YmVnaW46IDAsIGVuZDogbGluZS50ZXh0Lmxlbmd0aH0gfVxuICAgICAgcHJlcCA9IHByZXAgfHwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKTtcbiAgICAgIHJldHVybiB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmUsIHByZXAsIGNoKVxuICAgIH07XG4gICAgdmFyIHdyYXBwZWRMaW5lRXh0ZW50ID0gZ2V0V3JhcHBlZExpbmVFeHRlbnQoc3RhcnQuc3RpY2t5ID09IFwiYmVmb3JlXCIgPyBtdihzdGFydCwgLTEpIDogc3RhcnQuY2gpO1xuXG4gICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiB8fCBwYXJ0LmxldmVsID09IDEpIHtcbiAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAocGFydC5sZXZlbCA9PSAxKSA9PSAoZGlyIDwgMCk7XG4gICAgICB2YXIgY2ggPSBtdihzdGFydCwgbW92ZUluU3RvcmFnZU9yZGVyID8gMSA6IC0xKTtcbiAgICAgIGlmIChjaCAhPSBudWxsICYmICghbW92ZUluU3RvcmFnZU9yZGVyID8gY2ggPj0gcGFydC5mcm9tICYmIGNoID49IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogY2ggPD0gcGFydC50byAmJiBjaCA8PSB3cmFwcGVkTGluZUV4dGVudC5lbmQpKSB7XG4gICAgICAgIC8vIENhc2UgMjogV2UgbW92ZSB3aXRoaW4gYW4gcnRsIHBhcnQgb3IgaW4gYW4gcnRsIGVkaXRvciBvbiB0aGUgc2FtZSB2aXN1YWwgbGluZVxuICAgICAgICB2YXIgc3RpY2t5ID0gbW92ZUluU3RvcmFnZU9yZGVyID8gXCJiZWZvcmVcIiA6IFwiYWZ0ZXJcIjtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIHN0aWNreSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYXNlIDM6IENvdWxkIG5vdCBtb3ZlIHdpdGhpbiB0aGlzIGJpZGkgcGFydCBpbiB0aGlzIHZpc3VhbCBsaW5lLCBzbyBsZWF2ZVxuICAgIC8vIHRoZSBjdXJyZW50IGJpZGkgcGFydFxuXG4gICAgdmFyIHNlYXJjaEluVmlzdWFsTGluZSA9IGZ1bmN0aW9uIChwYXJ0UG9zLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KSB7XG4gICAgICB2YXIgZ2V0UmVzID0gZnVuY3Rpb24gKGNoLCBtb3ZlSW5TdG9yYWdlT3JkZXIpIHsgcmV0dXJuIG1vdmVJblN0b3JhZ2VPcmRlclxuICAgICAgICA/IG5ldyBQb3Moc3RhcnQubGluZSwgbXYoY2gsIDEpLCBcImJlZm9yZVwiKVxuICAgICAgICA6IG5ldyBQb3Moc3RhcnQubGluZSwgY2gsIFwiYWZ0ZXJcIik7IH07XG5cbiAgICAgIGZvciAoOyBwYXJ0UG9zID49IDAgJiYgcGFydFBvcyA8IGJpZGkubGVuZ3RoOyBwYXJ0UG9zICs9IGRpcikge1xuICAgICAgICB2YXIgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgICAgIHZhciBtb3ZlSW5TdG9yYWdlT3JkZXIgPSAoZGlyID4gMCkgPT0gKHBhcnQubGV2ZWwgIT0gMSk7XG4gICAgICAgIHZhciBjaCA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDogbXYod3JhcHBlZExpbmVFeHRlbnQuZW5kLCAtMSk7XG4gICAgICAgIGlmIChwYXJ0LmZyb20gPD0gY2ggJiYgY2ggPCBwYXJ0LnRvKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxuICAgICAgICBjaCA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IHBhcnQuZnJvbSA6IG12KHBhcnQudG8sIC0xKTtcbiAgICAgICAgaWYgKHdyYXBwZWRMaW5lRXh0ZW50LmJlZ2luIDw9IGNoICYmIGNoIDwgd3JhcHBlZExpbmVFeHRlbnQuZW5kKSB7IHJldHVybiBnZXRSZXMoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYXNlIDNhOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXG4gICAgdmFyIHJlcyA9IHNlYXJjaEluVmlzdWFsTGluZShwYXJ0UG9zICsgZGlyLCBkaXIsIHdyYXBwZWRMaW5lRXh0ZW50KTtcbiAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxuXG4gICAgLy8gQ2FzZSAzYjogTG9vayBmb3Igb3RoZXIgYmlkaSBwYXJ0cyBvbiB0aGUgbmV4dCB2aXN1YWwgbGluZVxuICAgIHZhciBuZXh0Q2ggPSBkaXIgPiAwID8gd3JhcHBlZExpbmVFeHRlbnQuZW5kIDogbXYod3JhcHBlZExpbmVFeHRlbnQuYmVnaW4sIC0xKTtcbiAgICBpZiAobmV4dENoICE9IG51bGwgJiYgIShkaXIgPiAwICYmIG5leHRDaCA9PSBsaW5lLnRleHQubGVuZ3RoKSkge1xuICAgICAgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKGRpciA+IDAgPyAwIDogYmlkaS5sZW5ndGggLSAxLCBkaXIsIGdldFdyYXBwZWRMaW5lRXh0ZW50KG5leHRDaCkpO1xuICAgICAgaWYgKHJlcykgeyByZXR1cm4gcmVzIH1cbiAgICB9XG5cbiAgICAvLyBDYXNlIDQ6IE5vd2hlcmUgdG8gbW92ZVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyBDb21tYW5kcyBhcmUgcGFyYW1ldGVyLWxlc3MgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgb24gYW5cbiAgLy8gZWRpdG9yLCBtb3N0bHkgdXNlZCBmb3Iga2V5YmluZGluZ3MuXG4gIHZhciBjb21tYW5kcyA9IHtcbiAgICBzZWxlY3RBbGw6IHNlbGVjdEFsbCxcbiAgICBzaW5nbGVTZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uc2V0U2VsZWN0aW9uKGNtLmdldEN1cnNvcihcImFuY2hvclwiKSwgY20uZ2V0Q3Vyc29yKFwiaGVhZFwiKSwgc2VsX2RvbnRTY3JvbGwpOyB9LFxuICAgIGtpbGxMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlLmVtcHR5KCkpIHtcbiAgICAgICAgdmFyIGxlbiA9IGdldExpbmUoY20uZG9jLCByYW5nZS5oZWFkLmxpbmUpLnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocmFuZ2UuaGVhZC5jaCA9PSBsZW4gJiYgcmFuZ2UuaGVhZC5saW5lIDwgY20ubGFzdExpbmUoKSlcbiAgICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUgKyAxLCAwKX0gfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZXR1cm4ge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBQb3MocmFuZ2UuaGVhZC5saW5lLCBsZW4pfSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge2Zyb206IHJhbmdlLmZyb20oKSwgdG86IHJhbmdlLnRvKCl9XG4gICAgICB9XG4gICAgfSk7IH0sXG4gICAgZGVsZXRlTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuICh7XG4gICAgICBmcm9tOiBQb3MocmFuZ2UuZnJvbSgpLmxpbmUsIDApLFxuICAgICAgdG86IGNsaXBQb3MoY20uZG9jLCBQb3MocmFuZ2UudG8oKS5saW5lICsgMSwgMCkpXG4gICAgfSk7IH0pOyB9LFxuICAgIGRlbExpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcbiAgICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksIHRvOiByYW5nZS5mcm9tKClcbiAgICB9KTsgfSk7IH0sXG4gICAgZGVsV3JhcHBlZExpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciBsZWZ0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIHJldHVybiB7ZnJvbTogbGVmdFBvcywgdG86IHJhbmdlLmZyb20oKX1cbiAgICB9KTsgfSxcbiAgICBkZWxXcmFwcGVkTGluZVJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmNoYXJDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciByaWdodFBvcyA9IGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmlnaHRQb3MgfVxuICAgIH0pOyB9LFxuICAgIHVuZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kbygpOyB9LFxuICAgIHJlZG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkbygpOyB9LFxuICAgIHVuZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udW5kb1NlbGVjdGlvbigpOyB9LFxuICAgIHJlZG9TZWxlY3Rpb246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVkb1NlbGVjdGlvbigpOyB9LFxuICAgIGdvRG9jU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5maXJzdExpbmUoKSwgMCkpOyB9LFxuICAgIGdvRG9jRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbihQb3MoY20ubGFzdExpbmUoKSkpOyB9LFxuICAgIGdvTGluZVN0YXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVTdGFydChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogMX1cbiAgICApOyB9LFxuICAgIGdvTGluZVN0YXJ0U21hcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0U21hcnQoY20sIHJhbmdlLmhlYWQpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfVxuICAgICk7IH0sXG4gICAgZ29MaW5lRW5kOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHsgcmV0dXJuIGxpbmVFbmQoY20sIHJhbmdlLmhlYWQubGluZSk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IC0xfVxuICAgICk7IH0sXG4gICAgZ29MaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IGNtLmRpc3BsYXkubGluZURpdi5vZmZzZXRXaWR0aCArIDEwMCwgdG9wOiB0b3B9LCBcImRpdlwiKVxuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHJldHVybiBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZUxlZnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogMCwgdG9wOiB0b3B9LCBcImRpdlwiKTtcbiAgICAgIGlmIChwb3MuY2ggPCBjbS5nZXRMaW5lKHBvcy5saW5lKS5zZWFyY2goL1xcUy8pKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCkgfVxuICAgICAgcmV0dXJuIHBvc1xuICAgIH0sIHNlbF9tb3ZlKTsgfSxcbiAgICBnb0xpbmVVcDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigtMSwgXCJsaW5lXCIpOyB9LFxuICAgIGdvTGluZURvd246IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoMSwgXCJsaW5lXCIpOyB9LFxuICAgIGdvUGFnZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcInBhZ2VcIik7IH0sXG4gICAgZ29QYWdlRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcInBhZ2VcIik7IH0sXG4gICAgZ29DaGFyTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJjaGFyXCIpOyB9LFxuICAgIGdvQ2hhclJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiY2hhclwiKTsgfSxcbiAgICBnb0NvbHVtbkxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiY29sdW1uXCIpOyB9LFxuICAgIGdvQ29sdW1uUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJjb2x1bW5cIik7IH0sXG4gICAgZ29Xb3JkTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGdvR3JvdXBSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImdyb3VwXCIpOyB9LFxuICAgIGdvR3JvdXBMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImdyb3VwXCIpOyB9LFxuICAgIGdvV29yZFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxDaGFyQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwiY29kZXBvaW50XCIpOyB9LFxuICAgIGRlbENoYXJBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwiY2hhclwiKTsgfSxcbiAgICBkZWxXb3JkQmVmb3JlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoLTEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxXb3JkQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcIndvcmRcIik7IH0sXG4gICAgZGVsR3JvdXBCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJncm91cFwiKTsgfSxcbiAgICBkZWxHcm91cEFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJncm91cFwiKTsgfSxcbiAgICBpbmRlbnRBdXRvOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmluZGVudFNlbGVjdGlvbihcInNtYXJ0XCIpOyB9LFxuICAgIGluZGVudE1vcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpOyB9LFxuICAgIGluZGVudExlc3M6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwic3VidHJhY3RcIik7IH0sXG4gICAgaW5zZXJ0VGFiOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXHRcIik7IH0sXG4gICAgaW5zZXJ0U29mdFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICB2YXIgc3BhY2VzID0gW10sIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcG9zID0gcmFuZ2VzW2ldLmZyb20oKTtcbiAgICAgICAgdmFyIGNvbCA9IGNvdW50Q29sdW1uKGNtLmdldExpbmUocG9zLmxpbmUpLCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICBzcGFjZXMucHVzaChzcGFjZVN0cih0YWJTaXplIC0gY29sICUgdGFiU2l6ZSkpO1xuICAgICAgfVxuICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbnMoc3BhY2VzKTtcbiAgICB9LFxuICAgIGRlZmF1bHRUYWI6IGZ1bmN0aW9uIChjbSkge1xuICAgICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgY20uaW5kZW50U2VsZWN0aW9uKFwiYWRkXCIpOyB9XG4gICAgICBlbHNlIHsgY20uZXhlY0NvbW1hbmQoXCJpbnNlcnRUYWJcIik7IH1cbiAgICB9LFxuICAgIC8vIFN3YXAgdGhlIHR3byBjaGFycyBsZWZ0IGFuZCByaWdodCBvZiBlYWNoIHNlbGVjdGlvbidzIGhlYWQuXG4gICAgLy8gTW92ZSBjdXJzb3IgYmVoaW5kIHRoZSB0d28gc3dhcHBlZCBjaGFyYWN0ZXJzIGFmdGVyd2FyZHMuXG4gICAgLy9cbiAgICAvLyBEb2Vzbid0IGNvbnNpZGVyIGxpbmUgZmVlZHMgYSBjaGFyYWN0ZXIuXG4gICAgLy8gRG9lc24ndCBzY2FuIG1vcmUgdGhhbiBvbmUgbGluZSBhYm92ZSB0byBmaW5kIGEgY2hhcmFjdGVyLlxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgb24gYW4gZW1wdHkgbGluZS5cbiAgICAvLyBEb2Vzbid0IGRvIGFueXRoaW5nIHdpdGggbm9uLWVtcHR5IHNlbGVjdGlvbnMuXG4gICAgdHJhbnNwb3NlQ2hhcnM6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJhbmdlcyA9IGNtLmxpc3RTZWxlY3Rpb25zKCksIG5ld1NlbCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFyYW5nZXNbaV0uZW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBjdXIgPSByYW5nZXNbaV0uaGVhZCwgbGluZSA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSkudGV4dDtcbiAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICBpZiAoY3VyLmNoID09IGxpbmUubGVuZ3RoKSB7IGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDEpOyB9XG4gICAgICAgICAgaWYgKGN1ci5jaCA+IDApIHtcbiAgICAgICAgICAgIGN1ciA9IG5ldyBQb3MoY3VyLmxpbmUsIGN1ci5jaCArIDEpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KGN1ci5jaCAtIDEpICsgbGluZS5jaGFyQXQoY3VyLmNoIC0gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lLCBjdXIuY2ggLSAyKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIubGluZSA+IGNtLmRvYy5maXJzdCkge1xuICAgICAgICAgICAgdmFyIHByZXYgPSBnZXRMaW5lKGNtLmRvYywgY3VyLmxpbmUgLSAxKS50ZXh0O1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgMSk7XG4gICAgICAgICAgICAgIGNtLnJlcGxhY2VSYW5nZShsaW5lLmNoYXJBdCgwKSArIGNtLmRvYy5saW5lU2VwYXJhdG9yKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jaGFyQXQocHJldi5sZW5ndGggLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvcyhjdXIubGluZSAtIDEsIHByZXYubGVuZ3RoIC0gMSksIGN1ciwgXCIrdHJhbnNwb3NlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTZWwucHVzaChuZXcgUmFuZ2UoY3VyLCBjdXIpKTtcbiAgICAgIH1cbiAgICAgIGNtLnNldFNlbGVjdGlvbnMobmV3U2VsKTtcbiAgICB9KTsgfSxcbiAgICBuZXdsaW5lQW5kSW5kZW50OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkgPSBzZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IGNtLnJlcGxhY2VSYW5nZShjbS5kb2MubGluZVNlcGFyYXRvcigpLCBzZWxzW2ldLmFuY2hvciwgc2Vsc1tpXS5oZWFkLCBcIitpbnB1dFwiKTsgfVxuICAgICAgc2VscyA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzZWxzLmxlbmd0aDsgaSQxKyspXG4gICAgICAgIHsgY20uaW5kZW50TGluZShzZWxzW2kkMV0uZnJvbSgpLmxpbmUsIG51bGwsIHRydWUpOyB9XG4gICAgICBlbnN1cmVDdXJzb3JWaXNpYmxlKGNtKTtcbiAgICB9KTsgfSxcbiAgICBvcGVuTGluZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXFxuXCIsIFwic3RhcnRcIik7IH0sXG4gICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnRvZ2dsZU92ZXJ3cml0ZSgpOyB9XG4gIH07XG5cblxuICBmdW5jdGlvbiBsaW5lU3RhcnQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XG4gICAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgdmlzdWFsLCBsaW5lTiwgMSlcbiAgfVxuICBmdW5jdGlvbiBsaW5lRW5kKGNtLCBsaW5lTikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGxpbmVOKTtcbiAgICB2YXIgdmlzdWFsID0gdmlzdWFsTGluZUVuZChsaW5lKTtcbiAgICBpZiAodmlzdWFsICE9IGxpbmUpIHsgbGluZU4gPSBsaW5lTm8odmlzdWFsKTsgfVxuICAgIHJldHVybiBlbmRPZkxpbmUodHJ1ZSwgY20sIGxpbmUsIGxpbmVOLCAtMSlcbiAgfVxuICBmdW5jdGlvbiBsaW5lU3RhcnRTbWFydChjbSwgcG9zKSB7XG4gICAgdmFyIHN0YXJ0ID0gbGluZVN0YXJ0KGNtLCBwb3MubGluZSk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgc3RhcnQubGluZSk7XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgaWYgKCFvcmRlciB8fCBvcmRlclswXS5sZXZlbCA9PSAwKSB7XG4gICAgICB2YXIgZmlyc3ROb25XUyA9IE1hdGgubWF4KHN0YXJ0LmNoLCBsaW5lLnRleHQuc2VhcmNoKC9cXFMvKSk7XG4gICAgICB2YXIgaW5XUyA9IHBvcy5saW5lID09IHN0YXJ0LmxpbmUgJiYgcG9zLmNoIDw9IGZpcnN0Tm9uV1MgJiYgcG9zLmNoO1xuICAgICAgcmV0dXJuIFBvcyhzdGFydC5saW5lLCBpbldTID8gMCA6IGZpcnN0Tm9uV1MsIHN0YXJ0LnN0aWNreSlcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0XG4gIH1cblxuICAvLyBSdW4gYSBoYW5kbGVyIHRoYXQgd2FzIGJvdW5kIHRvIGEga2V5LlxuICBmdW5jdGlvbiBkb0hhbmRsZUJpbmRpbmcoY20sIGJvdW5kLCBkcm9wU2hpZnQpIHtcbiAgICBpZiAodHlwZW9mIGJvdW5kID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGJvdW5kID0gY29tbWFuZHNbYm91bmRdO1xuICAgICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICAvLyBFbnN1cmUgcHJldmlvdXMgaW5wdXQgaGFzIGJlZW4gcmVhZCwgc28gdGhhdCB0aGUgaGFuZGxlciBzZWVzIGFcbiAgICAvLyBjb25zaXN0ZW50IHZpZXcgb2YgdGhlIGRvY3VtZW50XG4gICAgY20uZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICB2YXIgcHJldlNoaWZ0ID0gY20uZGlzcGxheS5zaGlmdCwgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoY20uaXNSZWFkT25seSgpKSB7IGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSB0cnVlOyB9XG4gICAgICBpZiAoZHJvcFNoaWZ0KSB7IGNtLmRpc3BsYXkuc2hpZnQgPSBmYWxzZTsgfVxuICAgICAgZG9uZSA9IGJvdW5kKGNtKSAhPSBQYXNzO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gcHJldlNoaWZ0O1xuICAgICAgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZG9uZVxuICB9XG5cbiAgZnVuY3Rpb24gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLnN0YXRlLmtleU1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXN1bHQgPSBsb29rdXBLZXkobmFtZSwgY20uc3RhdGUua2V5TWFwc1tpXSwgaGFuZGxlLCBjbSk7XG4gICAgICBpZiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQgfVxuICAgIH1cbiAgICByZXR1cm4gKGNtLm9wdGlvbnMuZXh0cmFLZXlzICYmIGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmV4dHJhS2V5cywgaGFuZGxlLCBjbSkpXG4gICAgICB8fCBsb29rdXBLZXkobmFtZSwgY20ub3B0aW9ucy5rZXlNYXAsIGhhbmRsZSwgY20pXG4gIH1cblxuICAvLyBOb3RlIHRoYXQsIGRlc3BpdGUgdGhlIG5hbWUsIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIHRvIGNoZWNrXG4gIC8vIGZvciBib3VuZCBtb3VzZSBjbGlja3MuXG5cbiAgdmFyIHN0b3BTZXEgPSBuZXcgRGVsYXllZDtcblxuICBmdW5jdGlvbiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XG4gICAgdmFyIHNlcSA9IGNtLnN0YXRlLmtleVNlcTtcbiAgICBpZiAoc2VxKSB7XG4gICAgICBpZiAoaXNNb2RpZmllcktleShuYW1lKSkgeyByZXR1cm4gXCJoYW5kbGVkXCIgfVxuICAgICAgaWYgKC9cXCckLy50ZXN0KG5hbWUpKVxuICAgICAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG51bGw7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBzdG9wU2VxLnNldCg1MCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5rZXlTZXEgPT0gc2VxKSB7XG4gICAgICAgICAgICBjbS5zdGF0ZS5rZXlTZXEgPSBudWxsO1xuICAgICAgICAgICAgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7IH1cbiAgICAgIGlmIChkaXNwYXRjaEtleUlubmVyKGNtLCBzZXEgKyBcIiBcIiArIG5hbWUsIGUsIGhhbmRsZSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hLZXlJbm5lcihjbSwgbmFtZSwgZSwgaGFuZGxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleUZvckVkaXRvcihjbSwgbmFtZSwgaGFuZGxlKTtcblxuICAgIGlmIChyZXN1bHQgPT0gXCJtdWx0aVwiKVxuICAgICAgeyBjbS5zdGF0ZS5rZXlTZXEgPSBuYW1lOyB9XG4gICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIilcbiAgICAgIHsgc2lnbmFsTGF0ZXIoY20sIFwia2V5SGFuZGxlZFwiLCBjbSwgbmFtZSwgZSk7IH1cblxuICAgIGlmIChyZXN1bHQgPT0gXCJoYW5kbGVkXCIgfHwgcmVzdWx0ID09IFwibXVsdGlcIikge1xuICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIHJlc3RhcnRCbGluayhjbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICEhcmVzdWx0XG4gIH1cblxuICAvLyBIYW5kbGUgYSBrZXkgZnJvbSB0aGUga2V5ZG93biBldmVudC5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5QmluZGluZyhjbSwgZSkge1xuICAgIHZhciBuYW1lID0ga2V5TmFtZShlLCB0cnVlKTtcbiAgICBpZiAoIW5hbWUpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChlLnNoaWZ0S2V5ICYmICFjbS5zdGF0ZS5rZXlTZXEpIHtcbiAgICAgIC8vIEZpcnN0IHRyeSB0byByZXNvbHZlIGZ1bGwgbmFtZSAoaW5jbHVkaW5nICdTaGlmdC0nKS4gRmFpbGluZ1xuICAgICAgLy8gdGhhdCwgc2VlIGlmIHRoZXJlIGlzIGEgY3Vyc29yLW1vdGlvbiBjb21tYW5kIChzdGFydGluZyB3aXRoXG4gICAgICAvLyAnZ28nKSBib3VuZCB0byB0aGUga2V5bmFtZSB3aXRob3V0ICdTaGlmdC0nLlxuICAgICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCBcIlNoaWZ0LVwiICsgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXG4gICAgICAgICAgfHwgZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IC9eZ29bQS1aXS8udGVzdChiKSA6IGIubW90aW9uKVxuICAgICAgICAgICAgICAgICB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpIH1cbiAgICAgICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIG5hbWUsIGUsIGZ1bmN0aW9uIChiKSB7IHJldHVybiBkb0hhbmRsZUJpbmRpbmcoY20sIGIpOyB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlwcmVzcyBldmVudFxuICBmdW5jdGlvbiBoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiJ1wiICsgY2ggKyBcIidcIiwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYiwgdHJ1ZSk7IH0pXG4gIH1cblxuICB2YXIgbGFzdFN0b3BwZWRLZXkgPSBudWxsO1xuICBmdW5jdGlvbiBvbktleURvd24oZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0ICE9IGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSkgeyByZXR1cm4gfVxuICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIC8vIElFIGRvZXMgc3RyYW5nZSB0aGluZ3Mgd2l0aCBlc2NhcGUuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSAmJiBlLmtleUNvZGUgPT0gMjcpIHsgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlOyB9XG4gICAgdmFyIGNvZGUgPSBlLmtleUNvZGU7XG4gICAgY20uZGlzcGxheS5zaGlmdCA9IGNvZGUgPT0gMTYgfHwgZS5zaGlmdEtleTtcbiAgICB2YXIgaGFuZGxlZCA9IGhhbmRsZUtleUJpbmRpbmcoY20sIGUpO1xuICAgIGlmIChwcmVzdG8pIHtcbiAgICAgIGxhc3RTdG9wcGVkS2V5ID0gaGFuZGxlZCA/IGNvZGUgOiBudWxsO1xuICAgICAgLy8gT3BlcmEgaGFzIG5vIGN1dCBldmVudC4uLiB3ZSB0cnkgdG8gYXQgbGVhc3QgY2F0Y2ggdGhlIGtleSBjb21ib1xuICAgICAgaWYgKCFoYW5kbGVkICYmIGNvZGUgPT0gODggJiYgIWhhc0NvcHlFdmVudCAmJiAobWFjID8gZS5tZXRhS2V5IDogZS5jdHJsS2V5KSlcbiAgICAgICAgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpOyB9XG4gICAgfVxuICAgIGlmIChnZWNrbyAmJiAhbWFjICYmICFoYW5kbGVkICYmIGNvZGUgPT0gNDYgJiYgZS5zaGlmdEtleSAmJiAhZS5jdHJsS2V5ICYmIGRvY3VtZW50LmV4ZWNDb21tYW5kKVxuICAgICAgeyBkb2N1bWVudC5leGVjQ29tbWFuZChcImN1dFwiKTsgfVxuXG4gICAgLy8gVHVybiBtb3VzZSBpbnRvIGNyb3NzaGFpciB3aGVuIEFsdCBpcyBoZWxkIG9uIE1hYy5cbiAgICBpZiAoY29kZSA9PSAxOCAmJiAhL1xcYkNvZGVNaXJyb3ItY3Jvc3NoYWlyXFxiLy50ZXN0KGNtLmRpc3BsYXkubGluZURpdi5jbGFzc05hbWUpKVxuICAgICAgeyBzaG93Q3Jvc3NIYWlyKGNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvd0Nyb3NzSGFpcihjbSkge1xuICAgIHZhciBsaW5lRGl2ID0gY20uZGlzcGxheS5saW5lRGl2O1xuICAgIGFkZENsYXNzKGxpbmVEaXYsIFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7XG5cbiAgICBmdW5jdGlvbiB1cChlKSB7XG4gICAgICBpZiAoZS5rZXlDb2RlID09IDE4IHx8ICFlLmFsdEtleSkge1xuICAgICAgICBybUNsYXNzKGxpbmVEaXYsIFwiQ29kZU1pcnJvci1jcm9zc2hhaXJcIik7XG4gICAgICAgIG9mZihkb2N1bWVudCwgXCJrZXl1cFwiLCB1cCk7XG4gICAgICAgIG9mZihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICAgICAgfVxuICAgIH1cbiAgICBvbihkb2N1bWVudCwgXCJrZXl1cFwiLCB1cCk7XG4gICAgb24oZG9jdW1lbnQsIFwibW91c2VvdmVyXCIsIHVwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5VXAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gMTYpIHsgdGhpcy5kb2Muc2VsLnNoaWZ0ID0gZmFsc2U7IH1cbiAgICBzaWduYWxET01FdmVudCh0aGlzLCBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uS2V5UHJlc3MoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0ICE9IGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKSkgeyByZXR1cm4gfVxuICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlLmN0cmxLZXkgJiYgIWUuYWx0S2V5IHx8IG1hYyAmJiBlLm1ldGFLZXkpIHsgcmV0dXJuIH1cbiAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZSwgY2hhckNvZGUgPSBlLmNoYXJDb2RlO1xuICAgIGlmIChwcmVzdG8gJiYga2V5Q29kZSA9PSBsYXN0U3RvcHBlZEtleSkge2xhc3RTdG9wcGVkS2V5ID0gbnVsbDsgZV9wcmV2ZW50RGVmYXVsdChlKTsgcmV0dXJufVxuICAgIGlmICgocHJlc3RvICYmICghZS53aGljaCB8fCBlLndoaWNoIDwgMTApKSAmJiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgPT0gbnVsbCA/IGtleUNvZGUgOiBjaGFyQ29kZSk7XG4gICAgLy8gU29tZSBicm93c2VycyBmaXJlIGtleXByZXNzIGV2ZW50cyBmb3IgYmFja3NwYWNlXG4gICAgaWYgKGNoID09IFwiXFx4MDhcIikgeyByZXR1cm4gfVxuICAgIGlmIChoYW5kbGVDaGFyQmluZGluZyhjbSwgZSwgY2gpKSB7IHJldHVybiB9XG4gICAgY20uZGlzcGxheS5pbnB1dC5vbktleVByZXNzKGUpO1xuICB9XG5cbiAgdmFyIERPVUJMRUNMSUNLX0RFTEFZID0gNDAwO1xuXG4gIHZhciBQYXN0Q2xpY2sgPSBmdW5jdGlvbih0aW1lLCBwb3MsIGJ1dHRvbikge1xuICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5idXR0b24gPSBidXR0b247XG4gIH07XG5cbiAgUGFzdENsaWNrLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGltZSArIERPVUJMRUNMSUNLX0RFTEFZID4gdGltZSAmJlxuICAgICAgY21wKHBvcywgdGhpcy5wb3MpID09IDAgJiYgYnV0dG9uID09IHRoaXMuYnV0dG9uXG4gIH07XG5cbiAgdmFyIGxhc3RDbGljaywgbGFzdERvdWJsZUNsaWNrO1xuICBmdW5jdGlvbiBjbGlja1JlcGVhdChwb3MsIGJ1dHRvbikge1xuICAgIHZhciBub3cgPSArbmV3IERhdGU7XG4gICAgaWYgKGxhc3REb3VibGVDbGljayAmJiBsYXN0RG91YmxlQ2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgbGFzdENsaWNrID0gbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcInRyaXBsZVwiXG4gICAgfSBlbHNlIGlmIChsYXN0Q2xpY2sgJiYgbGFzdENsaWNrLmNvbXBhcmUobm93LCBwb3MsIGJ1dHRvbikpIHtcbiAgICAgIGxhc3REb3VibGVDbGljayA9IG5ldyBQYXN0Q2xpY2sobm93LCBwb3MsIGJ1dHRvbik7XG4gICAgICBsYXN0Q2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwiZG91YmxlXCJcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdENsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgIGxhc3REb3VibGVDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJzaW5nbGVcIlxuICAgIH1cbiAgfVxuXG4gIC8vIEEgbW91c2UgZG93biBjYW4gYmUgYSBzaW5nbGUgY2xpY2ssIGRvdWJsZSBjbGljaywgdHJpcGxlIGNsaWNrLFxuICAvLyBzdGFydCBvZiBzZWxlY3Rpb24gZHJhZywgc3RhcnQgb2YgdGV4dCBkcmFnLCBuZXcgY3Vyc29yXG4gIC8vIChjdHJsLWNsaWNrKSwgcmVjdGFuZ2xlIGRyYWcgKGFsdC1kcmFnKSwgb3IgeHdpblxuICAvLyBtaWRkbGUtY2xpY2stcGFzdGUuIE9yIGl0IG1pZ2h0IGJlIGEgY2xpY2sgb24gc29tZXRoaW5nIHdlIHNob3VsZFxuICAvLyBub3QgaW50ZXJmZXJlIHdpdGgsIHN1Y2ggYXMgYSBzY3JvbGxiYXIgb3Igd2lkZ2V0LlxuICBmdW5jdGlvbiBvbk1vdXNlRG93bihlKSB7XG4gICAgdmFyIGNtID0gdGhpcywgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBkaXNwbGF5LmFjdGl2ZVRvdWNoICYmIGRpc3BsYXkuaW5wdXQuc3VwcG9ydHNUb3VjaCgpKSB7IHJldHVybiB9XG4gICAgZGlzcGxheS5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICBkaXNwbGF5LnNoaWZ0ID0gZS5zaGlmdEtleTtcblxuICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7XG4gICAgICBpZiAoIXdlYmtpdCkge1xuICAgICAgICAvLyBCcmllZmx5IHR1cm4gb2ZmIGRyYWdnYWJpbGl0eSwgdG8gYWxsb3cgd2lkZ2V0cyB0byBkb1xuICAgICAgICAvLyBub3JtYWwgZHJhZ2dpbmcgdGhpbmdzLlxuICAgICAgICBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gdHJ1ZTsgfSwgMTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2xpY2tJbkd1dHRlcihjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgYnV0dG9uID0gZV9idXR0b24oZSksIHJlcGVhdCA9IHBvcyA/IGNsaWNrUmVwZWF0KHBvcywgYnV0dG9uKSA6IFwic2luZ2xlXCI7XG4gICAgd2luZG93LmZvY3VzKCk7XG5cbiAgICAvLyAjMzI2MTogbWFrZSBzdXJlLCB0aGF0IHdlJ3JlIG5vdCBzdGFydGluZyBhIHNlY29uZCBzZWxlY3Rpb25cbiAgICBpZiAoYnV0dG9uID09IDEgJiYgY20uc3RhdGUuc2VsZWN0aW5nVGV4dClcbiAgICAgIHsgY20uc3RhdGUuc2VsZWN0aW5nVGV4dChlKTsgfVxuXG4gICAgaWYgKHBvcyAmJiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGUpKSB7IHJldHVybiB9XG5cbiAgICBpZiAoYnV0dG9uID09IDEpIHtcbiAgICAgIGlmIChwb3MpIHsgbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBlKTsgfVxuICAgICAgZWxzZSBpZiAoZV90YXJnZXQoZSkgPT0gZGlzcGxheS5zY3JvbGxlcikgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT0gMikge1xuICAgICAgaWYgKHBvcykgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MpOyB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfSwgMjApO1xuICAgIH0gZWxzZSBpZiAoYnV0dG9uID09IDMpIHtcbiAgICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykgeyBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7IH1cbiAgICAgIGVsc2UgeyBkZWxheUJsdXJFdmVudChjbSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNYXBwZWRCdXR0b24oY20sIGJ1dHRvbiwgcG9zLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgdmFyIG5hbWUgPSBcIkNsaWNrXCI7XG4gICAgaWYgKHJlcGVhdCA9PSBcImRvdWJsZVwiKSB7IG5hbWUgPSBcIkRvdWJsZVwiICsgbmFtZTsgfVxuICAgIGVsc2UgaWYgKHJlcGVhdCA9PSBcInRyaXBsZVwiKSB7IG5hbWUgPSBcIlRyaXBsZVwiICsgbmFtZTsgfVxuICAgIG5hbWUgPSAoYnV0dG9uID09IDEgPyBcIkxlZnRcIiA6IGJ1dHRvbiA9PSAyID8gXCJNaWRkbGVcIiA6IFwiUmlnaHRcIikgKyBuYW1lO1xuXG4gICAgcmV0dXJuIGRpc3BhdGNoS2V5KGNtLCAgYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCksIGV2ZW50LCBmdW5jdGlvbiAoYm91bmQpIHtcbiAgICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikgeyBib3VuZCA9IGNvbW1hbmRzW2JvdW5kXTsgfVxuICAgICAgaWYgKCFib3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cbiAgICAgICAgZG9uZSA9IGJvdW5kKGNtLCBwb3MpICE9IFBhc3M7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9uZVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCkge1xuICAgIHZhciBvcHRpb24gPSBjbS5nZXRPcHRpb24oXCJjb25maWd1cmVNb3VzZVwiKTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb24gPyBvcHRpb24oY20sIHJlcGVhdCwgZXZlbnQpIDoge307XG4gICAgaWYgKHZhbHVlLnVuaXQgPT0gbnVsbCkge1xuICAgICAgdmFyIHJlY3QgPSBjaHJvbWVPUyA/IGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50Lm1ldGFLZXkgOiBldmVudC5hbHRLZXk7XG4gICAgICB2YWx1ZS51bml0ID0gcmVjdCA/IFwicmVjdGFuZ2xlXCIgOiByZXBlYXQgPT0gXCJzaW5nbGVcIiA/IFwiY2hhclwiIDogcmVwZWF0ID09IFwiZG91YmxlXCIgPyBcIndvcmRcIiA6IFwibGluZVwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUuZXh0ZW5kID09IG51bGwgfHwgY20uZG9jLmV4dGVuZCkgeyB2YWx1ZS5leHRlbmQgPSBjbS5kb2MuZXh0ZW5kIHx8IGV2ZW50LnNoaWZ0S2V5OyB9XG4gICAgaWYgKHZhbHVlLmFkZE5ldyA9PSBudWxsKSB7IHZhbHVlLmFkZE5ldyA9IG1hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5OyB9XG4gICAgaWYgKHZhbHVlLm1vdmVPbkRyYWcgPT0gbnVsbCkgeyB2YWx1ZS5tb3ZlT25EcmFnID0gIShtYWMgPyBldmVudC5hbHRLZXkgOiBldmVudC5jdHJsS2V5KTsgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvbkRvd24oY20sIHBvcywgcmVwZWF0LCBldmVudCkge1xuICAgIGlmIChpZSkgeyBzZXRUaW1lb3V0KGJpbmQoZW5zdXJlRm9jdXMsIGNtKSwgMCk7IH1cbiAgICBlbHNlIHsgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTsgfVxuXG4gICAgdmFyIGJlaGF2aW9yID0gY29uZmlndXJlTW91c2UoY20sIHJlcGVhdCwgZXZlbnQpO1xuXG4gICAgdmFyIHNlbCA9IGNtLmRvYy5zZWwsIGNvbnRhaW5lZDtcbiAgICBpZiAoY20ub3B0aW9ucy5kcmFnRHJvcCAmJiBkcmFnQW5kRHJvcCAmJiAhY20uaXNSZWFkT25seSgpICYmXG4gICAgICAgIHJlcGVhdCA9PSBcInNpbmdsZVwiICYmIChjb250YWluZWQgPSBzZWwuY29udGFpbnMocG9zKSkgPiAtMSAmJlxuICAgICAgICAoY21wKChjb250YWluZWQgPSBzZWwucmFuZ2VzW2NvbnRhaW5lZF0pLmZyb20oKSwgcG9zKSA8IDAgfHwgcG9zLnhSZWwgPiAwKSAmJlxuICAgICAgICAoY21wKGNvbnRhaW5lZC50bygpLCBwb3MpID4gMCB8fCBwb3MueFJlbCA8IDApKVxuICAgICAgeyBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcik7IH1cbiAgICBlbHNlXG4gICAgICB7IGxlZnRCdXR0b25TZWxlY3QoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKTsgfVxuICB9XG5cbiAgLy8gU3RhcnQgYSB0ZXh0IGRyYWcuIFdoZW4gaXQgZW5kcywgc2VlIGlmIGFueSBkcmFnZ2luZyBhY3R1YWxseVxuICAvLyBoYXBwZW4sIGFuZCB0cmVhdCBhcyBhIGNsaWNrIGlmIGl0IGRpZG4ndC5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvblN0YXJ0RHJhZyhjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIG1vdmVkID0gZmFsc2U7XG4gICAgdmFyIGRyYWdFbmQgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAod2Via2l0KSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7IH1cbiAgICAgIGNtLnN0YXRlLmRyYWdnaW5nVGV4dCA9IGZhbHNlO1xuICAgICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50KSB7XG4gICAgICAgIGlmIChjbS5oYXNGb2N1cygpKSB7IGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ID0gZmFsc2U7IH1cbiAgICAgICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgICAgfVxuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ0VuZCk7XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgICBvZmYoZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZHJhZ1N0YXJ0KTtcbiAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG4gICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGlmICghYmVoYXZpb3IuYWRkTmV3KVxuICAgICAgICAgIHsgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgcG9zLCBudWxsLCBudWxsLCBiZWhhdmlvci5leHRlbmQpOyB9XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIHVuZXhwbGFpbmFibGUgZm9jdXMgcHJvYmxlbSBpbiBJRTkgKCMyMTI3KSBhbmQgQ2hyb21lICgjMzA4MSlcbiAgICAgICAgaWYgKCh3ZWJraXQgJiYgIXNhZmFyaSkgfHwgaWUgJiYgaWVfdmVyc2lvbiA9PSA5KVxuICAgICAgICAgIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7ZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuYm9keS5mb2N1cyh7cHJldmVudFNjcm9sbDogdHJ1ZX0pOyBkaXNwbGF5LmlucHV0LmZvY3VzKCk7fSwgMjApOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtb3VzZU1vdmUgPSBmdW5jdGlvbihlMikge1xuICAgICAgbW92ZWQgPSBtb3ZlZCB8fCBNYXRoLmFicyhldmVudC5jbGllbnRYIC0gZTIuY2xpZW50WCkgKyBNYXRoLmFicyhldmVudC5jbGllbnRZIC0gZTIuY2xpZW50WSkgPj0gMTA7XG4gICAgfTtcbiAgICB2YXIgZHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbW92ZWQgPSB0cnVlOyB9O1xuICAgIC8vIExldCB0aGUgZHJhZyBoYW5kbGVyIGhhbmRsZSB0aGlzLlxuICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XG4gICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZHJhZ0VuZDtcbiAgICBkcmFnRW5kLmNvcHkgPSAhYmVoYXZpb3IubW92ZU9uRHJhZztcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZXVwXCIsIGRyYWdFbmQpO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmUpO1xuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ3N0YXJ0XCIsIGRyYWdTdGFydCk7XG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIGRyYWdFbmQpO1xuXG4gICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgLy8gSUUncyBhcHByb2FjaCB0byBkcmFnZ2FibGVcbiAgICBpZiAoZGlzcGxheS5zY3JvbGxlci5kcmFnRHJvcCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKCk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmdlRm9yVW5pdChjbSwgcG9zLCB1bml0KSB7XG4gICAgaWYgKHVuaXQgPT0gXCJjaGFyXCIpIHsgcmV0dXJuIG5ldyBSYW5nZShwb3MsIHBvcykgfVxuICAgIGlmICh1bml0ID09IFwid29yZFwiKSB7IHJldHVybiBjbS5maW5kV29yZEF0KHBvcykgfVxuICAgIGlmICh1bml0ID09IFwibGluZVwiKSB7IHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhjbS5kb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSkgfVxuICAgIHZhciByZXN1bHQgPSB1bml0KGNtLCBwb3MpO1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmVzdWx0LmZyb20sIHJlc3VsdC50bylcbiAgfVxuXG4gIC8vIE5vcm1hbCBzZWxlY3Rpb24sIGFzIG9wcG9zZWQgdG8gdGV4dCBkcmFnZ2luZy5cbiAgZnVuY3Rpb24gbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHN0YXJ0LCBiZWhhdmlvcikge1xuICAgIGlmIChpZSkgeyBkZWxheUJsdXJFdmVudChjbSk7IH1cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICBlX3ByZXZlbnREZWZhdWx0KGV2ZW50KTtcblxuICAgIHZhciBvdXJSYW5nZSwgb3VySW5kZXgsIHN0YXJ0U2VsID0gZG9jLnNlbCwgcmFuZ2VzID0gc3RhcnRTZWwucmFuZ2VzO1xuICAgIGlmIChiZWhhdmlvci5hZGROZXcgJiYgIWJlaGF2aW9yLmV4dGVuZCkge1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLmNvbnRhaW5zKHN0YXJ0KTtcbiAgICAgIGlmIChvdXJJbmRleCA+IC0xKVxuICAgICAgICB7IG91clJhbmdlID0gcmFuZ2VzW291ckluZGV4XTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG91clJhbmdlID0gbmV3IFJhbmdlKHN0YXJ0LCBzdGFydCk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3VyUmFuZ2UgPSBkb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgIG91ckluZGV4ID0gZG9jLnNlbC5wcmltSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgaWYgKCFiZWhhdmlvci5hZGROZXcpIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxuICAgICAgc3RhcnQgPSBwb3NGcm9tTW91c2UoY20sIGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgIG91ckluZGV4ID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmdlRm9yVW5pdChjbSwgc3RhcnQsIGJlaGF2aW9yLnVuaXQpO1xuICAgICAgaWYgKGJlaGF2aW9yLmV4dGVuZClcbiAgICAgICAgeyBvdXJSYW5nZSA9IGV4dGVuZFJhbmdlKG91clJhbmdlLCByYW5nZS5hbmNob3IsIHJhbmdlLmhlYWQsIGJlaGF2aW9yLmV4dGVuZCk7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBvdXJSYW5nZSA9IHJhbmdlOyB9XG4gICAgfVxuXG4gICAgaWYgKCFiZWhhdmlvci5hZGROZXcpIHtcbiAgICAgIG91ckluZGV4ID0gMDtcbiAgICAgIHNldFNlbGVjdGlvbihkb2MsIG5ldyBTZWxlY3Rpb24oW291clJhbmdlXSwgMCksIHNlbF9tb3VzZSk7XG4gICAgICBzdGFydFNlbCA9IGRvYy5zZWw7XG4gICAgfSBlbHNlIGlmIChvdXJJbmRleCA9PSAtMSkge1xuICAgICAgb3VySW5kZXggPSByYW5nZXMubGVuZ3RoO1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMuY29uY2F0KFtvdXJSYW5nZV0pLCBvdXJJbmRleCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgIH0gZWxzZSBpZiAocmFuZ2VzLmxlbmd0aCA+IDEgJiYgcmFuZ2VzW291ckluZGV4XS5lbXB0eSgpICYmIGJlaGF2aW9yLnVuaXQgPT0gXCJjaGFyXCIgJiYgIWJlaGF2aW9yLmV4dGVuZCkge1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMuc2xpY2Uob3VySW5kZXggKyAxKSksIDApLFxuICAgICAgICAgICAgICAgICAgIHtzY3JvbGw6IGZhbHNlLCBvcmlnaW46IFwiKm1vdXNlXCJ9KTtcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIG91ckluZGV4LCBvdXJSYW5nZSwgc2VsX21vdXNlKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdFBvcyA9IHN0YXJ0O1xuICAgIGZ1bmN0aW9uIGV4dGVuZFRvKHBvcykge1xuICAgICAgaWYgKGNtcChsYXN0UG9zLCBwb3MpID09IDApIHsgcmV0dXJuIH1cbiAgICAgIGxhc3RQb3MgPSBwb3M7XG5cbiAgICAgIGlmIChiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpIHtcbiAgICAgICAgdmFyIHJhbmdlcyA9IFtdLCB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgICAgICB2YXIgc3RhcnRDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgc3RhcnQubGluZSkudGV4dCwgc3RhcnQuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgcG9zQ29sID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0LCBwb3MuY2gsIHRhYlNpemUpO1xuICAgICAgICB2YXIgbGVmdCA9IE1hdGgubWluKHN0YXJ0Q29sLCBwb3NDb2wpLCByaWdodCA9IE1hdGgubWF4KHN0YXJ0Q29sLCBwb3NDb2wpO1xuICAgICAgICBmb3IgKHZhciBsaW5lID0gTWF0aC5taW4oc3RhcnQubGluZSwgcG9zLmxpbmUpLCBlbmQgPSBNYXRoLm1pbihjbS5sYXN0TGluZSgpLCBNYXRoLm1heChzdGFydC5saW5lLCBwb3MubGluZSkpO1xuICAgICAgICAgICAgIGxpbmUgPD0gZW5kOyBsaW5lKyspIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGdldExpbmUoZG9jLCBsaW5lKS50ZXh0LCBsZWZ0UG9zID0gZmluZENvbHVtbih0ZXh0LCBsZWZ0LCB0YWJTaXplKTtcbiAgICAgICAgICBpZiAobGVmdCA9PSByaWdodClcbiAgICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGxlZnRQb3MpKSk7IH1cbiAgICAgICAgICBlbHNlIGlmICh0ZXh0Lmxlbmd0aCA+IGxlZnRQb3MpXG4gICAgICAgICAgICB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShQb3MobGluZSwgbGVmdFBvcyksIFBvcyhsaW5lLCBmaW5kQ29sdW1uKHRleHQsIHJpZ2h0LCB0YWJTaXplKSkpKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2VzLmxlbmd0aCkgeyByYW5nZXMucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KSk7IH1cbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCBzdGFydFNlbC5yYW5nZXMuc2xpY2UoMCwgb3VySW5kZXgpLmNvbmNhdChyYW5nZXMpLCBvdXJJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICB7b3JpZ2luOiBcIiptb3VzZVwiLCBzY3JvbGw6IGZhbHNlfSk7XG4gICAgICAgIGNtLnNjcm9sbEludG9WaWV3KHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb2xkUmFuZ2UgPSBvdXJSYW5nZTtcbiAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VGb3JVbml0KGNtLCBwb3MsIGJlaGF2aW9yLnVuaXQpO1xuICAgICAgICB2YXIgYW5jaG9yID0gb2xkUmFuZ2UuYW5jaG9yLCBoZWFkO1xuICAgICAgICBpZiAoY21wKHJhbmdlLmFuY2hvciwgYW5jaG9yKSA+IDApIHtcbiAgICAgICAgICBoZWFkID0gcmFuZ2UuaGVhZDtcbiAgICAgICAgICBhbmNob3IgPSBtaW5Qb3Mob2xkUmFuZ2UuZnJvbSgpLCByYW5nZS5hbmNob3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhlYWQgPSByYW5nZS5hbmNob3I7XG4gICAgICAgICAgYW5jaG9yID0gbWF4UG9zKG9sZFJhbmdlLnRvKCksIHJhbmdlLmhlYWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5nZXMkMSA9IHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwKTtcbiAgICAgICAgcmFuZ2VzJDFbb3VySW5kZXhdID0gYmlkaVNpbXBsaWZ5KGNtLCBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIGFuY2hvciksIGhlYWQpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGNtLCByYW5nZXMkMSwgb3VySW5kZXgpLCBzZWxfbW91c2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlZGl0b3JTaXplID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIFVzZWQgdG8gZW5zdXJlIHRpbWVvdXQgcmUtdHJpZXMgZG9uJ3QgZmlyZSB3aGVuIGFub3RoZXIgZXh0ZW5kXG4gICAgLy8gaGFwcGVuZWQgaW4gdGhlIG1lYW50aW1lIChjbGVhclRpbWVvdXQgaXNuJ3QgcmVsaWFibGUgLS0gYXRcbiAgICAvLyBsZWFzdCBvbiBDaHJvbWUsIHRoZSB0aW1lb3V0cyBzdGlsbCBoYXBwZW4gZXZlbiB3aGVuIGNsZWFyZWQsXG4gICAgLy8gaWYgdGhlIGNsZWFyIGhhcHBlbnMgYWZ0ZXIgdGhlaXIgc2NoZWR1bGVkIGZpcmluZyB0aW1lKS5cbiAgICB2YXIgY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoZSkge1xuICAgICAgdmFyIGN1ckNvdW50ID0gKytjb3VudGVyO1xuICAgICAgdmFyIGN1ciA9IHBvc0Zyb21Nb3VzZShjbSwgZSwgdHJ1ZSwgYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKTtcbiAgICAgIGlmICghY3VyKSB7IHJldHVybiB9XG4gICAgICBpZiAoY21wKGN1ciwgbGFzdFBvcykgIT0gMCkge1xuICAgICAgICBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgICBleHRlbmRUbyhjdXIpO1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBkb2MpO1xuICAgICAgICBpZiAoY3VyLmxpbmUgPj0gdmlzaWJsZS50byB8fCBjdXIubGluZSA8IHZpc2libGUuZnJvbSlcbiAgICAgICAgICB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7aWYgKGNvdW50ZXIgPT0gY3VyQ291bnQpIHsgZXh0ZW5kKGUpOyB9fSksIDE1MCk7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXRzaWRlID0gZS5jbGllbnRZIDwgZWRpdG9yU2l6ZS50b3AgPyAtMjAgOiBlLmNsaWVudFkgPiBlZGl0b3JTaXplLmJvdHRvbSA/IDIwIDogMDtcbiAgICAgICAgaWYgKG91dHNpZGUpIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY291bnRlciAhPSBjdXJDb3VudCkgeyByZXR1cm4gfVxuICAgICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wICs9IG91dHNpZGU7XG4gICAgICAgICAgZXh0ZW5kKGUpO1xuICAgICAgICB9KSwgNTApOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9uZShlKSB7XG4gICAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gZmFsc2U7XG4gICAgICBjb3VudGVyID0gSW5maW5pdHk7XG4gICAgICAvLyBJZiBlIGlzIG51bGwgb3IgdW5kZWZpbmVkIHdlIGludGVycHJldCB0aGlzIGFzIHNvbWVvbmUgdHJ5aW5nXG4gICAgICAvLyB0byBleHBsaWNpdGx5IGNhbmNlbCB0aGUgc2VsZWN0aW9uIHJhdGhlciB0aGFuIHRoZSB1c2VyXG4gICAgICAvLyBsZXR0aW5nIGdvIG9mIHRoZSBtb3VzZSBidXR0b24uXG4gICAgICBpZiAoZSkge1xuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgICAgb2ZmKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgdXApO1xuICAgICAgZG9jLmhpc3RvcnkubGFzdFNlbE9yaWdpbiA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1vdmUgPSBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZS5idXR0b25zID09PSAwIHx8ICFlX2J1dHRvbihlKSkgeyBkb25lKGUpOyB9XG4gICAgICBlbHNlIHsgZXh0ZW5kKGUpOyB9XG4gICAgfSk7XG4gICAgdmFyIHVwID0gb3BlcmF0aW9uKGNtLCBkb25lKTtcbiAgICBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0ID0gdXA7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdmUpO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgdXApO1xuICB9XG5cbiAgLy8gVXNlZCB3aGVuIG1vdXNlLXNlbGVjdGluZyB0byBhZGp1c3QgdGhlIGFuY2hvciB0byB0aGUgcHJvcGVyIHNpZGVcbiAgLy8gb2YgYSBiaWRpIGp1bXAgZGVwZW5kaW5nIG9uIHRoZSB2aXN1YWwgcG9zaXRpb24gb2YgdGhlIGhlYWQuXG4gIGZ1bmN0aW9uIGJpZGlTaW1wbGlmeShjbSwgcmFuZ2UpIHtcbiAgICB2YXIgYW5jaG9yID0gcmFuZ2UuYW5jaG9yO1xuICAgIHZhciBoZWFkID0gcmFuZ2UuaGVhZDtcbiAgICB2YXIgYW5jaG9yTGluZSA9IGdldExpbmUoY20uZG9jLCBhbmNob3IubGluZSk7XG4gICAgaWYgKGNtcChhbmNob3IsIGhlYWQpID09IDAgJiYgYW5jaG9yLnN0aWNreSA9PSBoZWFkLnN0aWNreSkgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGFuY2hvckxpbmUpO1xuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgaW5kZXggPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBhbmNob3IuY2gsIGFuY2hvci5zdGlja3kpLCBwYXJ0ID0gb3JkZXJbaW5kZXhdO1xuICAgIGlmIChwYXJ0LmZyb20gIT0gYW5jaG9yLmNoICYmIHBhcnQudG8gIT0gYW5jaG9yLmNoKSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIGJvdW5kYXJ5ID0gaW5kZXggKyAoKHBhcnQuZnJvbSA9PSBhbmNob3IuY2gpID09IChwYXJ0LmxldmVsICE9IDEpID8gMCA6IDEpO1xuICAgIGlmIChib3VuZGFyeSA9PSAwIHx8IGJvdW5kYXJ5ID09IG9yZGVyLmxlbmd0aCkgeyByZXR1cm4gcmFuZ2UgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcmVsYXRpdmUgdmlzdWFsIHBvc2l0aW9uIG9mIHRoZSBoZWFkIGNvbXBhcmVkIHRvIHRoZVxuICAgIC8vIGFuY2hvciAoPDAgaXMgdG8gdGhlIGxlZnQsID4wIHRvIHRoZSByaWdodClcbiAgICB2YXIgbGVmdFNpZGU7XG4gICAgaWYgKGhlYWQubGluZSAhPSBhbmNob3IubGluZSkge1xuICAgICAgbGVmdFNpZGUgPSAoaGVhZC5saW5lIC0gYW5jaG9yLmxpbmUpICogKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIiA/IDEgOiAtMSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGVhZEluZGV4ID0gZ2V0QmlkaVBhcnRBdChvcmRlciwgaGVhZC5jaCwgaGVhZC5zdGlja3kpO1xuICAgICAgdmFyIGRpciA9IGhlYWRJbmRleCAtIGluZGV4IHx8IChoZWFkLmNoIC0gYW5jaG9yLmNoKSAqIChwYXJ0LmxldmVsID09IDEgPyAtMSA6IDEpO1xuICAgICAgaWYgKGhlYWRJbmRleCA9PSBib3VuZGFyeSAtIDEgfHwgaGVhZEluZGV4ID09IGJvdW5kYXJ5KVxuICAgICAgICB7IGxlZnRTaWRlID0gZGlyIDwgMDsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IGxlZnRTaWRlID0gZGlyID4gMDsgfVxuICAgIH1cblxuICAgIHZhciB1c2VQYXJ0ID0gb3JkZXJbYm91bmRhcnkgKyAobGVmdFNpZGUgPyAtMSA6IDApXTtcbiAgICB2YXIgZnJvbSA9IGxlZnRTaWRlID09ICh1c2VQYXJ0LmxldmVsID09IDEpO1xuICAgIHZhciBjaCA9IGZyb20gPyB1c2VQYXJ0LmZyb20gOiB1c2VQYXJ0LnRvLCBzdGlja3kgPSBmcm9tID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICByZXR1cm4gYW5jaG9yLmNoID09IGNoICYmIGFuY2hvci5zdGlja3kgPT0gc3RpY2t5ID8gcmFuZ2UgOiBuZXcgUmFuZ2UobmV3IFBvcyhhbmNob3IubGluZSwgY2gsIHN0aWNreSksIGhlYWQpXG4gIH1cblxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciBhbiBldmVudCBoYXBwZW5lZCBpbiB0aGUgZ3V0dGVyLCBhbmQgZmlyZXMgdGhlXG4gIC8vIGhhbmRsZXJzIGZvciB0aGUgY29ycmVzcG9uZGluZyBldmVudC5cbiAgZnVuY3Rpb24gZ3V0dGVyRXZlbnQoY20sIGUsIHR5cGUsIHByZXZlbnQpIHtcbiAgICB2YXIgbVgsIG1ZO1xuICAgIGlmIChlLnRvdWNoZXMpIHtcbiAgICAgIG1YID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICBtWSA9IGUudG91Y2hlc1swXS5jbGllbnRZO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkgeyBtWCA9IGUuY2xpZW50WDsgbVkgPSBlLmNsaWVudFk7IH1cbiAgICAgIGNhdGNoKGUkMSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICBpZiAobVggPj0gTWF0aC5mbG9vcihjbS5kaXNwbGF5Lmd1dHRlcnMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHByZXZlbnQpIHsgZV9wcmV2ZW50RGVmYXVsdChlKTsgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBsaW5lQm94ID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgaWYgKG1ZID4gbGluZUJveC5ib3R0b20gfHwgIWhhc0hhbmRsZXIoY20sIHR5cGUpKSB7IHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSkgfVxuICAgIG1ZIC09IGxpbmVCb3gudG9wIC0gZGlzcGxheS52aWV3T2Zmc2V0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZyA9IGRpc3BsYXkuZ3V0dGVycy5jaGlsZE5vZGVzW2ldO1xuICAgICAgaWYgKGcgJiYgZy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCA+PSBtWCkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVBdEhlaWdodChjbS5kb2MsIG1ZKTtcbiAgICAgICAgdmFyIGd1dHRlciA9IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3NbaV07XG4gICAgICAgIHNpZ25hbChjbSwgdHlwZSwgY20sIGxpbmUsIGd1dHRlci5jbGFzc05hbWUsIGUpO1xuICAgICAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xpY2tJbkd1dHRlcihjbSwgZSkge1xuICAgIHJldHVybiBndXR0ZXJFdmVudChjbSwgZSwgXCJndXR0ZXJDbGlja1wiLCB0cnVlKVxuICB9XG5cbiAgLy8gQ09OVEVYVCBNRU5VIEhBTkRMSU5HXG5cbiAgLy8gVG8gbWFrZSB0aGUgY29udGV4dCBtZW51IHdvcmssIHdlIG5lZWQgdG8gYnJpZWZseSB1bmhpZGUgdGhlXG4gIC8vIHRleHRhcmVhIChtYWtpbmcgaXQgYXMgdW5vYnRydXNpdmUgYXMgcG9zc2libGUpIHRvIGxldCB0aGVcbiAgLy8gcmlnaHQtY2xpY2sgdGFrZSBlZmZlY3Qgb24gaXQuXG4gIGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoY20sIGUpIHtcbiAgICBpZiAoZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSB8fCBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSwgXCJjb250ZXh0bWVudVwiKSkgeyByZXR1cm4gfVxuICAgIGlmICghY2FwdHVyZVJpZ2h0Q2xpY2spIHsgY20uZGlzcGxheS5pbnB1dC5vbkNvbnRleHRNZW51KGUpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBjb250ZXh0TWVudUluR3V0dGVyKGNtLCBlKSB7XG4gICAgaWYgKCFoYXNIYW5kbGVyKGNtLCBcImd1dHRlckNvbnRleHRNZW51XCIpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNvbnRleHRNZW51XCIsIGZhbHNlKVxuICB9XG5cbiAgZnVuY3Rpb24gdGhlbWVDaGFuZ2VkKGNtKSB7XG4gICAgY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZSA9IGNtLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUucmVwbGFjZSgvXFxzKmNtLXMtXFxTKy9nLCBcIlwiKSArXG4gICAgICBjbS5vcHRpb25zLnRoZW1lLnJlcGxhY2UoLyhefFxccylcXHMqL2csIFwiIGNtLXMtXCIpO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgfVxuXG4gIHZhciBJbml0ID0ge3RvU3RyaW5nOiBmdW5jdGlvbigpe3JldHVybiBcIkNvZGVNaXJyb3IuSW5pdFwifX07XG5cbiAgdmFyIGRlZmF1bHRzID0ge307XG4gIHZhciBvcHRpb25IYW5kbGVycyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGRlZmluZU9wdGlvbnMoQ29kZU1pcnJvcikge1xuICAgIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7XG5cbiAgICBmdW5jdGlvbiBvcHRpb24obmFtZSwgZGVmbHQsIGhhbmRsZSwgbm90T25Jbml0KSB7XG4gICAgICBDb2RlTWlycm9yLmRlZmF1bHRzW25hbWVdID0gZGVmbHQ7XG4gICAgICBpZiAoaGFuZGxlKSB7IG9wdGlvbkhhbmRsZXJzW25hbWVdID1cbiAgICAgICAgbm90T25Jbml0ID8gZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge2lmIChvbGQgIT0gSW5pdCkgeyBoYW5kbGUoY20sIHZhbCwgb2xkKTsgfX0gOiBoYW5kbGU7IH1cbiAgICB9XG5cbiAgICBDb2RlTWlycm9yLmRlZmluZU9wdGlvbiA9IG9wdGlvbjtcblxuICAgIC8vIFBhc3NlZCB0byBvcHRpb24gaGFuZGxlcnMgd2hlbiB0aGVyZSBpcyBubyBvbGQgdmFsdWUuXG4gICAgQ29kZU1pcnJvci5Jbml0ID0gSW5pdDtcblxuICAgIC8vIFRoZXNlIHR3byBhcmUsIG9uIGluaXQsIGNhbGxlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlIHRoZXlcbiAgICAvLyBoYXZlIHRvIGJlIGluaXRpYWxpemVkIGJlZm9yZSB0aGUgZWRpdG9yIGNhbiBzdGFydCBhdCBhbGwuXG4gICAgb3B0aW9uKFwidmFsdWVcIiwgXCJcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLnNldFZhbHVlKHZhbCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcIm1vZGVcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRvYy5tb2RlT3B0aW9uID0gdmFsO1xuICAgICAgbG9hZE1vZGUoY20pO1xuICAgIH0sIHRydWUpO1xuXG4gICAgb3B0aW9uKFwiaW5kZW50VW5pdFwiLCAyLCBsb2FkTW9kZSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiaW5kZW50V2l0aFRhYnNcIiwgZmFsc2UpO1xuICAgIG9wdGlvbihcInNtYXJ0SW5kZW50XCIsIHRydWUpO1xuICAgIG9wdGlvbihcInRhYlNpemVcIiwgNCwgZnVuY3Rpb24gKGNtKSB7XG4gICAgICByZXNldE1vZGVTdGF0ZShjbSk7XG4gICAgICBjbGVhckNhY2hlcyhjbSk7XG4gICAgICByZWdDaGFuZ2UoY20pO1xuICAgIH0sIHRydWUpO1xuXG4gICAgb3B0aW9uKFwibGluZVNlcGFyYXRvclwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZG9jLmxpbmVTZXAgPSB2YWw7XG4gICAgICBpZiAoIXZhbCkgeyByZXR1cm4gfVxuICAgICAgdmFyIG5ld0JyZWFrcyA9IFtdLCBsaW5lTm8gPSBjbS5kb2MuZmlyc3Q7XG4gICAgICBjbS5kb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBmb3IgKHZhciBwb3MgPSAwOzspIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBsaW5lLnRleHQuaW5kZXhPZih2YWwsIHBvcyk7XG4gICAgICAgICAgaWYgKGZvdW5kID09IC0xKSB7IGJyZWFrIH1cbiAgICAgICAgICBwb3MgPSBmb3VuZCArIHZhbC5sZW5ndGg7XG4gICAgICAgICAgbmV3QnJlYWtzLnB1c2goUG9zKGxpbmVObywgZm91bmQpKTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lTm8rKztcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgaSA9IG5ld0JyZWFrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCB2YWwsIG5ld0JyZWFrc1tpXSwgUG9zKG5ld0JyZWFrc1tpXS5saW5lLCBuZXdCcmVha3NbaV0uY2ggKyB2YWwubGVuZ3RoKSk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJzcGVjaWFsQ2hhcnNcIiwgL1tcXHUwMDAwLVxcdTAwMWZcXHUwMDdmLVxcdTAwOWZcXHUwMGFkXFx1MDYxY1xcdTIwMGJcXHUyMDBlXFx1MjAwZlxcdTIwMjhcXHUyMDI5XFx1ZmVmZlxcdWZmZjktXFx1ZmZmY10vZywgZnVuY3Rpb24gKGNtLCB2YWwsIG9sZCkge1xuICAgICAgY20uc3RhdGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cCh2YWwuc291cmNlICsgKHZhbC50ZXN0KFwiXFx0XCIpID8gXCJcIiA6IFwifFxcdFwiKSwgXCJnXCIpO1xuICAgICAgaWYgKG9sZCAhPSBJbml0KSB7IGNtLnJlZnJlc2goKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyUGxhY2Vob2xkZXJcIiwgZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJlbGVjdHJpY0NoYXJzXCIsIHRydWUpO1xuICAgIG9wdGlvbihcImlucHV0U3R5bGVcIiwgbW9iaWxlID8gXCJjb250ZW50ZWRpdGFibGVcIiA6IFwidGV4dGFyZWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRTdHlsZSBjYW4gbm90ICh5ZXQpIGJlIGNoYW5nZWQgaW4gYSBydW5uaW5nIGVkaXRvclwiKSAvLyBGSVhNRVxuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcInNwZWxsY2hlY2tcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuc3BlbGxjaGVjayA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYXV0b2NvcnJlY3RcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5nZXRJbnB1dEZpZWxkKCkuYXV0b2NvcnJlY3QgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImF1dG9jYXBpdGFsaXplXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLmF1dG9jYXBpdGFsaXplID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJydGxNb3ZlVmlzdWFsbHlcIiwgIXdpbmRvd3MpO1xuICAgIG9wdGlvbihcIndob2xlTGluZVVwZGF0ZUJlZm9yZVwiLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInRoZW1lXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHRoZW1lQ2hhbmdlZChjbSk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJrZXlNYXBcIiwgXCJkZWZhdWx0XCIsIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcbiAgICAgIHZhciBuZXh0ID0gZ2V0S2V5TWFwKHZhbCk7XG4gICAgICB2YXIgcHJldiA9IG9sZCAhPSBJbml0ICYmIGdldEtleU1hcChvbGQpO1xuICAgICAgaWYgKHByZXYgJiYgcHJldi5kZXRhY2gpIHsgcHJldi5kZXRhY2goY20sIG5leHQpOyB9XG4gICAgICBpZiAobmV4dC5hdHRhY2gpIHsgbmV4dC5hdHRhY2goY20sIHByZXYgfHwgbnVsbCk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJleHRyYUtleXNcIiwgbnVsbCk7XG4gICAgb3B0aW9uKFwiY29uZmlndXJlTW91c2VcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJsaW5lV3JhcHBpbmdcIiwgZmFsc2UsIHdyYXBwaW5nQ2hhbmdlZCwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZ3V0dGVyc1wiLCBbXSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKHZhbCwgY20ub3B0aW9ucy5saW5lTnVtYmVycyk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJmaXhlZEd1dHRlclwiLCB0cnVlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSB2YWwgPyBjb21wZW5zYXRlRm9ySFNjcm9sbChjbS5kaXNwbGF5KSArIFwicHhcIiA6IFwiMFwiO1xuICAgICAgY20ucmVmcmVzaCgpO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJzY3JvbGxiYXJTdHlsZVwiLCBcIm5hdGl2ZVwiLCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGluaXRTY3JvbGxiYXJzKGNtKTtcbiAgICAgIHVwZGF0ZVNjcm9sbGJhcnMoY20pO1xuICAgICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChjbS5kb2Muc2Nyb2xsVG9wKTtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KGNtLmRvYy5zY3JvbGxMZWZ0KTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyc1wiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MgPSBnZXRHdXR0ZXJzKGNtLm9wdGlvbnMuZ3V0dGVycywgdmFsKTtcbiAgICAgIHVwZGF0ZUd1dHRlcnMoY20pO1xuICAgIH0sIHRydWUpO1xuICAgIG9wdGlvbihcImZpcnN0TGluZU51bWJlclwiLCAxLCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lTnVtYmVyRm9ybWF0dGVyXCIsIGZ1bmN0aW9uIChpbnRlZ2VyKSB7IHJldHVybiBpbnRlZ2VyOyB9LCB1cGRhdGVHdXR0ZXJzLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZ1wiLCBmYWxzZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcblxuICAgIG9wdGlvbihcInJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudVwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJsaW5lV2lzZUNvcHlDdXRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGFzdGVMaW5lc1BlclNlbGVjdGlvblwiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJzZWxlY3Rpb25zTWF5VG91Y2hcIiwgZmFsc2UpO1xuXG4gICAgb3B0aW9uKFwicmVhZE9ubHlcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBpZiAodmFsID09IFwibm9jdXJzb3JcIikge1xuICAgICAgICBvbkJsdXIoY20pO1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVhZE9ubHlDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJzY3JlZW5SZWFkZXJMYWJlbFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgdmFsID0gKHZhbCA9PT0gJycpID8gbnVsbCA6IHZhbDtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQuc2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkKHZhbCk7XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJkaXNhYmxlSW5wdXRcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7aWYgKCF2YWwpIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldCgpOyB9fSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZHJhZ0Ryb3BcIiwgdHJ1ZSwgZHJhZ0Ryb3BDaGFuZ2VkKTtcbiAgICBvcHRpb24oXCJhbGxvd0Ryb3BGaWxlVHlwZXNcIiwgbnVsbCk7XG5cbiAgICBvcHRpb24oXCJjdXJzb3JCbGlua1JhdGVcIiwgNTMwKTtcbiAgICBvcHRpb24oXCJjdXJzb3JTY3JvbGxNYXJnaW5cIiwgMCk7XG4gICAgb3B0aW9uKFwiY3Vyc29ySGVpZ2h0XCIsIDEsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZVwiLCB0cnVlLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICAgIG9wdGlvbihcIndvcmtUaW1lXCIsIDEwMCk7XG4gICAgb3B0aW9uKFwid29ya0RlbGF5XCIsIDEwMCk7XG4gICAgb3B0aW9uKFwiZmxhdHRlblNwYW5zXCIsIHRydWUsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJhZGRNb2RlQ2xhc3NcIiwgZmFsc2UsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJwb2xsSW50ZXJ2YWxcIiwgMTAwKTtcbiAgICBvcHRpb24oXCJ1bmRvRGVwdGhcIiwgMjAwLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZG9jLmhpc3RvcnkudW5kb0RlcHRoID0gdmFsOyB9KTtcbiAgICBvcHRpb24oXCJoaXN0b3J5RXZlbnREZWxheVwiLCAxMjUwKTtcbiAgICBvcHRpb24oXCJ2aWV3cG9ydE1hcmdpblwiLCAxMCwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWZyZXNoKCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcIm1heEhpZ2hsaWdodExlbmd0aFwiLCAxMDAwMCwgcmVzZXRNb2RlU3RhdGUsIHRydWUpO1xuICAgIG9wdGlvbihcIm1vdmVJbnB1dFdpdGhDdXJzb3JcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGlmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXRQb3NpdGlvbigpOyB9XG4gICAgfSk7XG5cbiAgICBvcHRpb24oXCJ0YWJpbmRleFwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpLnRhYkluZGV4ID0gdmFsIHx8IFwiXCI7IH0pO1xuICAgIG9wdGlvbihcImF1dG9mb2N1c1wiLCBudWxsKTtcbiAgICBvcHRpb24oXCJkaXJlY3Rpb25cIiwgXCJsdHJcIiwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRvYy5zZXREaXJlY3Rpb24odmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicGhyYXNlc1wiLCBudWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWdEcm9wQ2hhbmdlZChjbSwgdmFsdWUsIG9sZCkge1xuICAgIHZhciB3YXNPbiA9IG9sZCAmJiBvbGQgIT0gSW5pdDtcbiAgICBpZiAoIXZhbHVlICE9ICF3YXNPbikge1xuICAgICAgdmFyIGZ1bmNzID0gY20uZGlzcGxheS5kcmFnRnVuY3Rpb25zO1xuICAgICAgdmFyIHRvZ2dsZSA9IHZhbHVlID8gb24gOiBvZmY7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZnVuY3Muc3RhcnQpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2VudGVyXCIsIGZ1bmNzLmVudGVyKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdvdmVyXCIsIGZ1bmNzLm92ZXIpO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ2xlYXZlXCIsIGZ1bmNzLmxlYXZlKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZnVuY3MuZHJvcCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBpbmdDaGFuZ2VkKGNtKSB7XG4gICAgaWYgKGNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xuICAgICAgY20uZGlzcGxheS5zaXplci5zdHlsZS5taW5XaWR0aCA9IFwiXCI7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgXCJDb2RlTWlycm9yLXdyYXBcIik7XG4gICAgICBmaW5kTWF4TGluZShjbSk7XG4gICAgfVxuICAgIGVzdGltYXRlTGluZUhlaWdodHMoY20pO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdXBkYXRlU2Nyb2xsYmFycyhjbSk7IH0sIDEwMCk7XG4gIH1cblxuICAvLyBBIENvZGVNaXJyb3IgaW5zdGFuY2UgcmVwcmVzZW50cyBhbiBlZGl0b3IuIFRoaXMgaXMgdGhlIG9iamVjdFxuICAvLyB0aGF0IHVzZXIgY29kZSBpcyB1c3VhbGx5IGRlYWxpbmcgd2l0aC5cblxuICBmdW5jdGlvbiBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29kZU1pcnJvcikpIHsgcmV0dXJuIG5ldyBDb2RlTWlycm9yKHBsYWNlLCBvcHRpb25zKSB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zID0gb3B0aW9ucyA/IGNvcHlPYmoob3B0aW9ucykgOiB7fTtcbiAgICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIG9wdGlvbnMgYmFzZWQgb24gZ2l2ZW4gdmFsdWVzIGFuZCBkZWZhdWx0cy5cbiAgICBjb3B5T2JqKGRlZmF1bHRzLCBvcHRpb25zLCBmYWxzZSk7XG5cbiAgICB2YXIgZG9jID0gb3B0aW9ucy52YWx1ZTtcbiAgICBpZiAodHlwZW9mIGRvYyA9PSBcInN0cmluZ1wiKSB7IGRvYyA9IG5ldyBEb2MoZG9jLCBvcHRpb25zLm1vZGUsIG51bGwsIG9wdGlvbnMubGluZVNlcGFyYXRvciwgb3B0aW9ucy5kaXJlY3Rpb24pOyB9XG4gICAgZWxzZSBpZiAob3B0aW9ucy5tb2RlKSB7IGRvYy5tb2RlT3B0aW9uID0gb3B0aW9ucy5tb2RlOyB9XG4gICAgdGhpcy5kb2MgPSBkb2M7XG5cbiAgICB2YXIgaW5wdXQgPSBuZXcgQ29kZU1pcnJvci5pbnB1dFN0eWxlc1tvcHRpb25zLmlucHV0U3R5bGVdKHRoaXMpO1xuICAgIHZhciBkaXNwbGF5ID0gdGhpcy5kaXNwbGF5ID0gbmV3IERpc3BsYXkocGxhY2UsIGRvYywgaW5wdXQsIG9wdGlvbnMpO1xuICAgIGRpc3BsYXkud3JhcHBlci5Db2RlTWlycm9yID0gdGhpcztcbiAgICB0aGVtZUNoYW5nZWQodGhpcyk7XG4gICAgaWYgKG9wdGlvbnMubGluZVdyYXBwaW5nKVxuICAgICAgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5jbGFzc05hbWUgKz0gXCIgQ29kZU1pcnJvci13cmFwXCI7IH1cbiAgICBpbml0U2Nyb2xsYmFycyh0aGlzKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBrZXlNYXBzOiBbXSwgIC8vIHN0b3JlcyBtYXBzIGFkZGVkIGJ5IGFkZEtleU1hcFxuICAgICAgb3ZlcmxheXM6IFtdLCAvLyBoaWdobGlnaHRpbmcgb3ZlcmxheXMsIGFzIGFkZGVkIGJ5IGFkZE92ZXJsYXlcbiAgICAgIG1vZGVHZW46IDAsICAgLy8gYnVtcGVkIHdoZW4gbW9kZS9vdmVybGF5IGNoYW5nZXMsIHVzZWQgdG8gaW52YWxpZGF0ZSBoaWdobGlnaHRpbmcgaW5mb1xuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5aW5nQmx1ckV2ZW50OiBmYWxzZSxcbiAgICAgIGZvY3VzZWQ6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NFZGl0czogZmFsc2UsIC8vIHVzZWQgdG8gZGlzYWJsZSBlZGl0aW5nIGR1cmluZyBrZXkgaGFuZGxlcnMgd2hlbiBpbiByZWFkT25seSBtb2RlXG4gICAgICBwYXN0ZUluY29taW5nOiAtMSwgY3V0SW5jb21pbmc6IC0xLCAvLyBoZWxwIHJlY29nbml6ZSBwYXN0ZS9jdXQgZWRpdHMgaW4gaW5wdXQucG9sbFxuICAgICAgc2VsZWN0aW5nVGV4dDogZmFsc2UsXG4gICAgICBkcmFnZ2luZ1RleHQ6IGZhbHNlLFxuICAgICAgaGlnaGxpZ2h0OiBuZXcgRGVsYXllZCgpLCAvLyBzdG9yZXMgaGlnaGxpZ2h0IHdvcmtlciB0aW1lb3V0XG4gICAgICBrZXlTZXE6IG51bGwsICAvLyBVbmZpbmlzaGVkIGtleSBzZXF1ZW5jZVxuICAgICAgc3BlY2lhbENoYXJzOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTsgfVxuXG4gICAgLy8gT3ZlcnJpZGUgbWFnaWMgdGV4dGFyZWEgY29udGVudCByZXN0b3JlIHRoYXQgSUUgc29tZXRpbWVzIGRvZXNcbiAgICAvLyBvbiBvdXIgaGlkZGVuIHRleHRhcmVhIG9uIHJlbG9hZFxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgMTEpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuZGlzcGxheS5pbnB1dC5yZXNldCh0cnVlKTsgfSwgMjApOyB9XG5cbiAgICByZWdpc3RlckV2ZW50SGFuZGxlcnModGhpcyk7XG4gICAgZW5zdXJlR2xvYmFsSGFuZGxlcnMoKTtcblxuICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xuICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIGF0dGFjaERvYyh0aGlzLCBkb2MpO1xuXG4gICAgaWYgKChvcHRpb25zLmF1dG9mb2N1cyAmJiAhbW9iaWxlKSB8fCB0aGlzLmhhc0ZvY3VzKCkpXG4gICAgICB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyQxLmhhc0ZvY3VzKCkgJiYgIXRoaXMkMS5zdGF0ZS5mb2N1c2VkKSB7IG9uRm9jdXModGhpcyQxKTsgfVxuICAgICAgfSwgMjApOyB9XG4gICAgZWxzZVxuICAgICAgeyBvbkJsdXIodGhpcyk7IH1cblxuICAgIGZvciAodmFyIG9wdCBpbiBvcHRpb25IYW5kbGVycykgeyBpZiAob3B0aW9uSGFuZGxlcnMuaGFzT3duUHJvcGVydHkob3B0KSlcbiAgICAgIHsgb3B0aW9uSGFuZGxlcnNbb3B0XSh0aGlzLCBvcHRpb25zW29wdF0sIEluaXQpOyB9IH1cbiAgICBtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCh0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5maW5pc2hJbml0KSB7IG9wdGlvbnMuZmluaXNoSW5pdCh0aGlzKTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdEhvb2tzLmxlbmd0aDsgKytpKSB7IGluaXRIb29rc1tpXSh0aGlzKTsgfVxuICAgIGVuZE9wZXJhdGlvbih0aGlzKTtcbiAgICAvLyBTdXBwcmVzcyBvcHRpbWl6ZWxlZ2liaWxpdHkgaW4gV2Via2l0LCBzaW5jZSBpdCBicmVha3MgdGV4dFxuICAgIC8vIG1lYXN1cmluZyBvbiBsaW5lIHdyYXBwaW5nIGJvdW5kYXJpZXMuXG4gICAgaWYgKHdlYmtpdCAmJiBvcHRpb25zLmxpbmVXcmFwcGluZyAmJlxuICAgICAgICBnZXRDb21wdXRlZFN0eWxlKGRpc3BsYXkubGluZURpdikudGV4dFJlbmRlcmluZyA9PSBcIm9wdGltaXplbGVnaWJpbGl0eVwiKVxuICAgICAgeyBkaXNwbGF5LmxpbmVEaXYuc3R5bGUudGV4dFJlbmRlcmluZyA9IFwiYXV0b1wiOyB9XG4gIH1cblxuICAvLyBUaGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIENvZGVNaXJyb3IuZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgLy8gRnVuY3Rpb25zIHRvIHJ1biB3aGVuIG9wdGlvbnMgYXJlIGNoYW5nZWQuXG4gIENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnMgPSBvcHRpb25IYW5kbGVycztcblxuICAvLyBBdHRhY2ggdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB3aGVuIGluaXRpYWxpemluZyB0aGUgZWRpdG9yXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRIYW5kbGVycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheTtcbiAgICBvbihkLnNjcm9sbGVyLCBcIm1vdXNlZG93blwiLCBvcGVyYXRpb24oY20sIG9uTW91c2VEb3duKSk7XG4gICAgLy8gT2xkZXIgSUUncyB3aWxsIG5vdCBmaXJlIGEgc2Vjb25kIG1vdXNlZG93biBmb3IgYSBkb3VibGUgY2xpY2tcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKVxuICAgICAgeyBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICAgICAgaWYgKCFwb3MgfHwgY2xpY2tJbkd1dHRlcihjbSwgZSkgfHwgZXZlbnRJbldpZGdldChjbS5kaXNwbGF5LCBlKSkgeyByZXR1cm4gfVxuICAgICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB2YXIgd29yZCA9IGNtLmZpbmRXb3JkQXQocG9zKTtcbiAgICAgICAgZXh0ZW5kU2VsZWN0aW9uKGNtLmRvYywgd29yZC5hbmNob3IsIHdvcmQuaGVhZCk7XG4gICAgICB9KSk7IH1cbiAgICBlbHNlXG4gICAgICB7IG9uKGQuc2Nyb2xsZXIsIFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBlX3ByZXZlbnREZWZhdWx0KGUpOyB9KTsgfVxuICAgIC8vIFNvbWUgYnJvd3NlcnMgZmlyZSBjb250ZXh0bWVudSAqYWZ0ZXIqIG9wZW5pbmcgdGhlIG1lbnUsIGF0XG4gICAgLy8gd2hpY2ggcG9pbnQgd2UgY2FuJ3QgbWVzcyB3aXRoIGl0IGFueW1vcmUuIENvbnRleHQgbWVudSBpc1xuICAgIC8vIGhhbmRsZWQgaW4gb25Nb3VzZURvd24gZm9yIHRoZXNlIGJyb3dzZXJzLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQ29udGV4dE1lbnUoY20sIGUpOyB9KTtcbiAgICBvbihkLmlucHV0LmdldEZpZWxkKCksIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZC5zY3JvbGxlci5jb250YWlucyhlLnRhcmdldCkpIHsgb25Db250ZXh0TWVudShjbSwgZSk7IH1cbiAgICB9KTtcblxuICAgIC8vIFVzZWQgdG8gc3VwcHJlc3MgbW91c2UgZXZlbnQgaGFuZGxpbmcgd2hlbiBhIHRvdWNoIGhhcHBlbnNcbiAgICB2YXIgdG91Y2hGaW5pc2hlZCwgcHJldlRvdWNoID0ge2VuZDogMH07XG4gICAgZnVuY3Rpb24gZmluaXNoVG91Y2goKSB7XG4gICAgICBpZiAoZC5hY3RpdmVUb3VjaCkge1xuICAgICAgICB0b3VjaEZpbmlzaGVkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkLmFjdGl2ZVRvdWNoID0gbnVsbDsgfSwgMTAwMCk7XG4gICAgICAgIHByZXZUb3VjaCA9IGQuYWN0aXZlVG91Y2g7XG4gICAgICAgIHByZXZUb3VjaC5lbmQgPSArbmV3IERhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTW91c2VMaWtlVG91Y2hFdmVudChlKSB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCAhPSAxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICByZXR1cm4gdG91Y2gucmFkaXVzWCA8PSAxICYmIHRvdWNoLnJhZGl1c1kgPD0gMVxuICAgIH1cbiAgICBmdW5jdGlvbiBmYXJBd2F5KHRvdWNoLCBvdGhlcikge1xuICAgICAgaWYgKG90aGVyLmxlZnQgPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICB2YXIgZHggPSBvdGhlci5sZWZ0IC0gdG91Y2gubGVmdCwgZHkgPSBvdGhlci50b3AgLSB0b3VjaC50b3A7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgPiAyMCAqIDIwXG4gICAgfVxuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFzaWduYWxET01FdmVudChjbSwgZSkgJiYgIWlzTW91c2VMaWtlVG91Y2hFdmVudChlKSAmJiAhY2xpY2tJbkd1dHRlcihjbSwgZSkpIHtcbiAgICAgICAgZC5pbnB1dC5lbnN1cmVQb2xsZWQoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRvdWNoRmluaXNoZWQpO1xuICAgICAgICB2YXIgbm93ID0gK25ldyBEYXRlO1xuICAgICAgICBkLmFjdGl2ZVRvdWNoID0ge3N0YXJ0OiBub3csIG1vdmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2OiBub3cgLSBwcmV2VG91Y2guZW5kIDw9IDMwMCA/IHByZXZUb3VjaCA6IG51bGx9O1xuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgZC5hY3RpdmVUb3VjaC5sZWZ0ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgIGQuYWN0aXZlVG91Y2gudG9wID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaG1vdmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIHsgZC5hY3RpdmVUb3VjaC5tb3ZlZCA9IHRydWU7IH1cbiAgICB9KTtcbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgdG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xuICAgICAgaWYgKHRvdWNoICYmICFldmVudEluV2lkZ2V0KGQsIGUpICYmIHRvdWNoLmxlZnQgIT0gbnVsbCAmJlxuICAgICAgICAgICF0b3VjaC5tb3ZlZCAmJiBuZXcgRGF0ZSAtIHRvdWNoLnN0YXJ0IDwgMzAwKSB7XG4gICAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKGQuYWN0aXZlVG91Y2gsIFwicGFnZVwiKSwgcmFuZ2U7XG4gICAgICAgIGlmICghdG91Y2gucHJldiB8fCBmYXJBd2F5KHRvdWNoLCB0b3VjaC5wcmV2KSkgLy8gU2luZ2xlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UocG9zLCBwb3MpOyB9XG4gICAgICAgIGVsc2UgaWYgKCF0b3VjaC5wcmV2LnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldi5wcmV2KSkgLy8gRG91YmxlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBjbS5maW5kV29yZEF0KHBvcyk7IH1cbiAgICAgICAgZWxzZSAvLyBUcmlwbGUgdGFwXG4gICAgICAgICAgeyByYW5nZSA9IG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKTsgfVxuICAgICAgICBjbS5zZXRTZWxlY3Rpb24ocmFuZ2UuYW5jaG9yLCByYW5nZS5oZWFkKTtcbiAgICAgICAgY20uZm9jdXMoKTtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgIH1cbiAgICAgIGZpbmlzaFRvdWNoKCk7XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaGNhbmNlbFwiLCBmaW5pc2hUb3VjaCk7XG5cbiAgICAvLyBTeW5jIHNjcm9sbGluZyBiZXR3ZWVuIGZha2Ugc2Nyb2xsYmFycyBhbmQgcmVhbCBzY3JvbGxhYmxlXG4gICAgLy8gYXJlYSwgZW5zdXJlIHZpZXdwb3J0IGlzIHVwZGF0ZWQgd2hlbiBzY3JvbGxpbmcuXG4gICAgb24oZC5zY3JvbGxlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGQuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgZC5zY3JvbGxlci5zY3JvbGxUb3ApO1xuICAgICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBkLnNjcm9sbGVyLnNjcm9sbExlZnQsIHRydWUpO1xuICAgICAgICBzaWduYWwoY20sIFwic2Nyb2xsXCIsIGNtKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExpc3RlbiB0byB3aGVlbCBldmVudHMgaW4gb3JkZXIgdG8gdHJ5IGFuZCB1cGRhdGUgdGhlIHZpZXdwb3J0IG9uIHRpbWUuXG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZXdoZWVsXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvblNjcm9sbFdoZWVsKGNtLCBlKTsgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJET01Nb3VzZVNjcm9sbFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pO1xuXG4gICAgLy8gUHJldmVudCB3cmFwcGVyIGZyb20gZXZlciBzY3JvbGxpbmdcbiAgICBvbihkLndyYXBwZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGQud3JhcHBlci5zY3JvbGxUb3AgPSBkLndyYXBwZXIuc2Nyb2xsTGVmdCA9IDA7IH0pO1xuXG4gICAgZC5kcmFnRnVuY3Rpb25zID0ge1xuICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgZV9zdG9wKGUpOyB9fSxcbiAgICAgIG92ZXI6IGZ1bmN0aW9uIChlKSB7aWYgKCFzaWduYWxET01FdmVudChjbSwgZSkpIHsgb25EcmFnT3ZlcihjbSwgZSk7IGVfc3RvcChlKTsgfX0sXG4gICAgICBzdGFydDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRHJhZ1N0YXJ0KGNtLCBlKTsgfSxcbiAgICAgIGRyb3A6IG9wZXJhdGlvbihjbSwgb25Ecm9wKSxcbiAgICAgIGxlYXZlOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGNsZWFyRHJhZ0N1cnNvcihjbSk7IH19XG4gICAgfTtcblxuICAgIHZhciBpbnAgPSBkLmlucHV0LmdldEZpZWxkKCk7XG4gICAgb24oaW5wLCBcImtleXVwXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbktleVVwLmNhbGwoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwia2V5ZG93blwiLCBvcGVyYXRpb24oY20sIG9uS2V5RG93bikpO1xuICAgIG9uKGlucCwgXCJrZXlwcmVzc1wiLCBvcGVyYXRpb24oY20sIG9uS2V5UHJlc3MpKTtcbiAgICBvbihpbnAsIFwiZm9jdXNcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uRm9jdXMoY20sIGUpOyB9KTtcbiAgICBvbihpbnAsIFwiYmx1clwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25CbHVyKGNtLCBlKTsgfSk7XG4gIH1cblxuICB2YXIgaW5pdEhvb2tzID0gW107XG4gIENvZGVNaXJyb3IuZGVmaW5lSW5pdEhvb2sgPSBmdW5jdGlvbiAoZikgeyByZXR1cm4gaW5pdEhvb2tzLnB1c2goZik7IH07XG5cbiAgLy8gSW5kZW50IHRoZSBnaXZlbiBsaW5lLiBUaGUgaG93IHBhcmFtZXRlciBjYW4gYmUgXCJzbWFydFwiLFxuICAvLyBcImFkZFwiL251bGwsIFwic3VidHJhY3RcIiwgb3IgXCJwcmV2XCIuIFdoZW4gYWdncmVzc2l2ZSBpcyBmYWxzZVxuICAvLyAodHlwaWNhbGx5IHNldCB0byB0cnVlIGZvciBmb3JjZWQgc2luZ2xlLWxpbmUgaW5kZW50cyksIGVtcHR5XG4gIC8vIGxpbmVzIGFyZSBub3QgaW5kZW50ZWQsIGFuZCBwbGFjZXMgd2hlcmUgdGhlIG1vZGUgcmV0dXJucyBQYXNzXG4gIC8vIGFyZSBsZWZ0IGFsb25lLlxuICBmdW5jdGlvbiBpbmRlbnRMaW5lKGNtLCBuLCBob3csIGFnZ3Jlc3NpdmUpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBzdGF0ZTtcbiAgICBpZiAoaG93ID09IG51bGwpIHsgaG93ID0gXCJhZGRcIjsgfVxuICAgIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gXCJwcmV2XCIgd2hlbiB0aGUgbW9kZSBkb2Vzbid0IGhhdmUgYW4gaW5kZW50YXRpb25cbiAgICAgIC8vIG1ldGhvZC5cbiAgICAgIGlmICghZG9jLm1vZGUuaW5kZW50KSB7IGhvdyA9IFwicHJldlwiOyB9XG4gICAgICBlbHNlIHsgc3RhdGUgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBuKS5zdGF0ZTsgfVxuICAgIH1cblxuICAgIHZhciB0YWJTaXplID0gY20ub3B0aW9ucy50YWJTaXplO1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIG4pLCBjdXJTcGFjZSA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgdGFiU2l6ZSk7XG4gICAgaWYgKGxpbmUuc3RhdGVBZnRlcikgeyBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsOyB9XG4gICAgdmFyIGN1clNwYWNlU3RyaW5nID0gbGluZS50ZXh0Lm1hdGNoKC9eXFxzKi8pWzBdLCBpbmRlbnRhdGlvbjtcbiAgICBpZiAoIWFnZ3Jlc3NpdmUgJiYgIS9cXFMvLnRlc3QobGluZS50ZXh0KSkge1xuICAgICAgaW5kZW50YXRpb24gPSAwO1xuICAgICAgaG93ID0gXCJub3RcIjtcbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcInNtYXJ0XCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gZG9jLm1vZGUuaW5kZW50KHN0YXRlLCBsaW5lLnRleHQuc2xpY2UoY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgbGluZS50ZXh0KTtcbiAgICAgIGlmIChpbmRlbnRhdGlvbiA9PSBQYXNzIHx8IGluZGVudGF0aW9uID4gMTUwKSB7XG4gICAgICAgIGlmICghYWdncmVzc2l2ZSkgeyByZXR1cm4gfVxuICAgICAgICBob3cgPSBcInByZXZcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhvdyA9PSBcInByZXZcIikge1xuICAgICAgaWYgKG4gPiBkb2MuZmlyc3QpIHsgaW5kZW50YXRpb24gPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgbi0xKS50ZXh0LCBudWxsLCB0YWJTaXplKTsgfVxuICAgICAgZWxzZSB7IGluZGVudGF0aW9uID0gMDsgfVxuICAgIH0gZWxzZSBpZiAoaG93ID09IFwiYWRkXCIpIHtcbiAgICAgIGluZGVudGF0aW9uID0gY3VyU3BhY2UgKyBjbS5vcHRpb25zLmluZGVudFVuaXQ7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzdWJ0cmFjdFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlIC0gY20ub3B0aW9ucy5pbmRlbnRVbml0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdyA9PSBcIm51bWJlclwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgaG93O1xuICAgIH1cbiAgICBpbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIGluZGVudGF0aW9uKTtcblxuICAgIHZhciBpbmRlbnRTdHJpbmcgPSBcIlwiLCBwb3MgPSAwO1xuICAgIGlmIChjbS5vcHRpb25zLmluZGVudFdpdGhUYWJzKVxuICAgICAgeyBmb3IgKHZhciBpID0gTWF0aC5mbG9vcihpbmRlbnRhdGlvbiAvIHRhYlNpemUpOyBpOyAtLWkpIHtwb3MgKz0gdGFiU2l6ZTsgaW5kZW50U3RyaW5nICs9IFwiXFx0XCI7fSB9XG4gICAgaWYgKHBvcyA8IGluZGVudGF0aW9uKSB7IGluZGVudFN0cmluZyArPSBzcGFjZVN0cihpbmRlbnRhdGlvbiAtIHBvcyk7IH1cblxuICAgIGlmIChpbmRlbnRTdHJpbmcgIT0gY3VyU3BhY2VTdHJpbmcpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShkb2MsIGluZGVudFN0cmluZywgUG9zKG4sIDApLCBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSwgXCIraW5wdXRcIik7XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIHRoYXQsIGlmIHRoZSBjdXJzb3Igd2FzIGluIHRoZSB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydFxuICAgICAgLy8gb2YgdGhlIGxpbmUsIGl0IGlzIG1vdmVkIHRvIHRoZSBlbmQgb2YgdGhhdCBzcGFjZS5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZG9jLnNlbC5yYW5nZXNbaSQxXTtcbiAgICAgICAgaWYgKHJhbmdlLmhlYWQubGluZSA9PSBuICYmIHJhbmdlLmhlYWQuY2ggPCBjdXJTcGFjZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcG9zJDEgPSBQb3MobiwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKTtcbiAgICAgICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSQxLCBuZXcgUmFuZ2UocG9zJDEsIHBvcyQxKSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRoaXMgd2lsbCBiZSBzZXQgdG8gYSB7bGluZVdpc2U6IGJvb2wsIHRleHQ6IFtzdHJpbmddfSBvYmplY3QsIHNvXG4gIC8vIHRoYXQsIHdoZW4gcGFzdGluZywgd2Uga25vdyB3aGF0IGtpbmQgb2Ygc2VsZWN0aW9ucyB0aGUgY29waWVkXG4gIC8vIHRleHQgd2FzIG1hZGUgb3V0IG9mLlxuICB2YXIgbGFzdENvcGllZCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc2V0TGFzdENvcGllZChuZXdMYXN0Q29waWVkKSB7XG4gICAgbGFzdENvcGllZCA9IG5ld0xhc3RDb3BpZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRleHRJbnB1dChjbSwgaW5zZXJ0ZWQsIGRlbGV0ZWQsIHNlbCwgb3JpZ2luKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYztcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gZmFsc2U7XG4gICAgaWYgKCFzZWwpIHsgc2VsID0gZG9jLnNlbDsgfVxuXG4gICAgdmFyIHJlY2VudCA9ICtuZXcgRGF0ZSAtIDIwMDtcbiAgICB2YXIgcGFzdGUgPSBvcmlnaW4gPT0gXCJwYXN0ZVwiIHx8IGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPiByZWNlbnQ7XG4gICAgdmFyIHRleHRMaW5lcyA9IHNwbGl0TGluZXNBdXRvKGluc2VydGVkKSwgbXVsdGlQYXN0ZSA9IG51bGw7XG4gICAgLy8gV2hlbiBwYXN0aW5nIE4gbGluZXMgaW50byBOIHNlbGVjdGlvbnMsIGluc2VydCBvbmUgbGluZSBwZXIgc2VsZWN0aW9uXG4gICAgaWYgKHBhc3RlICYmIHNlbC5yYW5nZXMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIikgPT0gaW5zZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHNlbC5yYW5nZXMubGVuZ3RoICUgbGFzdENvcGllZC50ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgbXVsdGlQYXN0ZSA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGFzdENvcGllZC50ZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBtdWx0aVBhc3RlLnB1c2goZG9jLnNwbGl0TGluZXMobGFzdENvcGllZC50ZXh0W2ldKSk7IH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0ZXh0TGluZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmIGNtLm9wdGlvbnMucGFzdGVMaW5lc1BlclNlbGVjdGlvbikge1xuICAgICAgICBtdWx0aVBhc3RlID0gbWFwKHRleHRMaW5lcywgZnVuY3Rpb24gKGwpIHsgcmV0dXJuIFtsXTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUlucHV0ID0gY20uY3VyT3AudXBkYXRlSW5wdXQ7XG4gICAgLy8gTm9ybWFsIGJlaGF2aW9yIGlzIHRvIGluc2VydCB0aGUgbmV3IHRleHQgaW50byBldmVyeSBzZWxlY3Rpb25cbiAgICBmb3IgKHZhciBpJDEgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgdmFyIHJhbmdlID0gc2VsLnJhbmdlc1tpJDFdO1xuICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgIGlmIChyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgIGlmIChkZWxldGVkICYmIGRlbGV0ZWQgPiAwKSAvLyBIYW5kbGUgZGVsZXRpb25cbiAgICAgICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lLCBmcm9tLmNoIC0gZGVsZXRlZCk7IH1cbiAgICAgICAgZWxzZSBpZiAoY20uc3RhdGUub3ZlcndyaXRlICYmICFwYXN0ZSkgLy8gSGFuZGxlIG92ZXJ3cml0ZVxuICAgICAgICAgIHsgdG8gPSBQb3ModG8ubGluZSwgTWF0aC5taW4oZ2V0TGluZShkb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoLCB0by5jaCArIGxzdCh0ZXh0TGluZXMpLmxlbmd0aCkpOyB9XG4gICAgICAgIGVsc2UgaWYgKHBhc3RlICYmIGxhc3RDb3BpZWQgJiYgbGFzdENvcGllZC5saW5lV2lzZSAmJiBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKSA9PSB0ZXh0TGluZXMuam9pbihcIlxcblwiKSlcbiAgICAgICAgICB7IGZyb20gPSB0byA9IFBvcyhmcm9tLmxpbmUsIDApOyB9XG4gICAgICB9XG4gICAgICB2YXIgY2hhbmdlRXZlbnQgPSB7ZnJvbTogZnJvbSwgdG86IHRvLCB0ZXh0OiBtdWx0aVBhc3RlID8gbXVsdGlQYXN0ZVtpJDEgJSBtdWx0aVBhc3RlLmxlbmd0aF0gOiB0ZXh0TGluZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4gfHwgKHBhc3RlID8gXCJwYXN0ZVwiIDogY20uc3RhdGUuY3V0SW5jb21pbmcgPiByZWNlbnQgPyBcImN1dFwiIDogXCIraW5wdXRcIil9O1xuICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZUV2ZW50KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImlucHV0UmVhZFwiLCBjbSwgY2hhbmdlRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQgJiYgIXBhc3RlKVxuICAgICAgeyB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKTsgfVxuXG4gICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgaWYgKGNtLmN1ck9wLnVwZGF0ZUlucHV0IDwgMikgeyBjbS5jdXJPcC51cGRhdGVJbnB1dCA9IHVwZGF0ZUlucHV0OyB9XG4gICAgY20uY3VyT3AudHlwaW5nID0gdHJ1ZTtcbiAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gY20uc3RhdGUuY3V0SW5jb21pbmcgPSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlKGUsIGNtKSB7XG4gICAgdmFyIHBhc3RlZCA9IGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHBhc3RlZCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFjbS5pc1JlYWRPbmx5KCkgJiYgIWNtLm9wdGlvbnMuZGlzYWJsZUlucHV0KVxuICAgICAgICB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwcGx5VGV4dElucHV0KGNtLCBwYXN0ZWQsIDAsIG51bGwsIFwicGFzdGVcIik7IH0pOyB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJFbGVjdHJpYyhjbSwgaW5zZXJ0ZWQpIHtcbiAgICAvLyBXaGVuIGFuICdlbGVjdHJpYycgY2hhcmFjdGVyIGlzIGluc2VydGVkLCBpbW1lZGlhdGVseSB0cmlnZ2VyIGEgcmVpbmRlbnRcbiAgICBpZiAoIWNtLm9wdGlvbnMuZWxlY3RyaWNDaGFycyB8fCAhY20ub3B0aW9ucy5zbWFydEluZGVudCkgeyByZXR1cm4gfVxuICAgIHZhciBzZWwgPSBjbS5kb2Muc2VsO1xuXG4gICAgZm9yICh2YXIgaSA9IHNlbC5yYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICBpZiAocmFuZ2UuaGVhZC5jaCA+IDEwMCB8fCAoaSAmJiBzZWwucmFuZ2VzW2kgLSAxXS5oZWFkLmxpbmUgPT0gcmFuZ2UuaGVhZC5saW5lKSkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgbW9kZSA9IGNtLmdldE1vZGVBdChyYW5nZS5oZWFkKTtcbiAgICAgIHZhciBpbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgaWYgKG1vZGUuZWxlY3RyaWNDaGFycykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1vZGUuZWxlY3RyaWNDaGFycy5sZW5ndGg7IGorKylcbiAgICAgICAgICB7IGlmIChpbnNlcnRlZC5pbmRleE9mKG1vZGUuZWxlY3RyaWNDaGFycy5jaGFyQXQoaikpID4gLTEpIHtcbiAgICAgICAgICAgIGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IH1cbiAgICAgIH0gZWxzZSBpZiAobW9kZS5lbGVjdHJpY0lucHV0KSB7XG4gICAgICAgIGlmIChtb2RlLmVsZWN0cmljSW5wdXQudGVzdChnZXRMaW5lKGNtLmRvYywgcmFuZ2UuaGVhZC5saW5lKS50ZXh0LnNsaWNlKDAsIHJhbmdlLmhlYWQuY2gpKSlcbiAgICAgICAgICB7IGluZGVudGVkID0gaW5kZW50TGluZShjbSwgcmFuZ2UuaGVhZC5saW5lLCBcInNtYXJ0XCIpOyB9XG4gICAgICB9XG4gICAgICBpZiAoaW5kZW50ZWQpIHsgc2lnbmFsTGF0ZXIoY20sIFwiZWxlY3RyaWNJbnB1dFwiLCBjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlhYmxlUmFuZ2VzKGNtKSB7XG4gICAgdmFyIHRleHQgPSBbXSwgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmUgPSBjbS5kb2Muc2VsLnJhbmdlc1tpXS5oZWFkLmxpbmU7XG4gICAgICB2YXIgbGluZVJhbmdlID0ge2FuY2hvcjogUG9zKGxpbmUsIDApLCBoZWFkOiBQb3MobGluZSArIDEsIDApfTtcbiAgICAgIHJhbmdlcy5wdXNoKGxpbmVSYW5nZSk7XG4gICAgICB0ZXh0LnB1c2goY20uZ2V0UmFuZ2UobGluZVJhbmdlLmFuY2hvciwgbGluZVJhbmdlLmhlYWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0OiB0ZXh0LCByYW5nZXM6IHJhbmdlc31cbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc2FibGVCcm93c2VyTWFnaWMoZmllbGQsIHNwZWxsY2hlY2ssIGF1dG9jb3JyZWN0LCBhdXRvY2FwaXRhbGl6ZSkge1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jb3JyZWN0XCIsIGF1dG9jb3JyZWN0ID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcImF1dG9jYXBpdGFsaXplXCIsIGF1dG9jYXBpdGFsaXplID8gXCJcIiA6IFwib2ZmXCIpO1xuICAgIGZpZWxkLnNldEF0dHJpYnV0ZShcInNwZWxsY2hlY2tcIiwgISFzcGVsbGNoZWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZGRlblRleHRhcmVhKCkge1xuICAgIHZhciB0ZSA9IGVsdChcInRleHRhcmVhXCIsIG51bGwsIG51bGwsIFwicG9zaXRpb246IGFic29sdXRlOyBib3R0b206IC0xZW07IHBhZGRpbmc6IDA7IHdpZHRoOiAxcHg7IGhlaWdodDogMWVtOyBvdXRsaW5lOiBub25lXCIpO1xuICAgIHZhciBkaXYgPSBlbHQoXCJkaXZcIiwgW3RlXSwgbnVsbCwgXCJvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAzcHg7IGhlaWdodDogMHB4O1wiKTtcbiAgICAvLyBUaGUgdGV4dGFyZWEgaXMga2VwdCBwb3NpdGlvbmVkIG5lYXIgdGhlIGN1cnNvciB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGZhY3QgdGhhdCBpdCdsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgb24gaW5wdXQgZnJvbSBzY3JvbGxpbmdcbiAgICAvLyBvdXIgZmFrZSBjdXJzb3Igb3V0IG9mIHZpZXcuIE9uIHdlYmtpdCwgd2hlbiB3cmFwPW9mZiwgcGFzdGUgaXNcbiAgICAvLyB2ZXJ5IHNsb3cuIFNvIG1ha2UgdGhlIGFyZWEgd2lkZSBpbnN0ZWFkLlxuICAgIGlmICh3ZWJraXQpIHsgdGUuc3R5bGUud2lkdGggPSBcIjEwMDBweFwiOyB9XG4gICAgZWxzZSB7IHRlLnNldEF0dHJpYnV0ZShcIndyYXBcIiwgXCJvZmZcIik7IH1cbiAgICAvLyBJZiBib3JkZXI6IDA7IC0tIGlPUyBmYWlscyB0byBvcGVuIGtleWJvYXJkIChpc3N1ZSAjMTI4NylcbiAgICBpZiAoaW9zKSB7IHRlLnN0eWxlLmJvcmRlciA9IFwiMXB4IHNvbGlkIGJsYWNrXCI7IH1cbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKHRlKTtcbiAgICByZXR1cm4gZGl2XG4gIH1cblxuICAvLyBUaGUgcHVibGljbHkgdmlzaWJsZSBBUEkuIE5vdGUgdGhhdCBtZXRob2RPcChmKSBtZWFuc1xuICAvLyAnd3JhcCBmIGluIGFuIG9wZXJhdGlvbiwgcGVyZm9ybWVkIG9uIGl0cyBgdGhpc2AgcGFyYW1ldGVyJy5cblxuICAvLyBUaGlzIGlzIG5vdCB0aGUgY29tcGxldGUgc2V0IG9mIGVkaXRvciBtZXRob2RzLiBNb3N0IG9mIHRoZVxuICAvLyBtZXRob2RzIGRlZmluZWQgb24gdGhlIERvYyB0eXBlIGFyZSBhbHNvIGluamVjdGVkIGludG9cbiAgLy8gQ29kZU1pcnJvci5wcm90b3R5cGUsIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmRcbiAgLy8gY29udmVuaWVuY2UuXG5cbiAgZnVuY3Rpb24gYWRkRWRpdG9yTWV0aG9kcyhDb2RlTWlycm9yKSB7XG4gICAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycztcblxuICAgIHZhciBoZWxwZXJzID0gQ29kZU1pcnJvci5oZWxwZXJzID0ge307XG5cbiAgICBDb2RlTWlycm9yLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiBDb2RlTWlycm9yLFxuICAgICAgZm9jdXM6IGZ1bmN0aW9uKCl7d2luZG93LmZvY3VzKCk7IHRoaXMuZGlzcGxheS5pbnB1dC5mb2N1cygpO30sXG5cbiAgICAgIHNldE9wdGlvbjogZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgb2xkID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25dID09IHZhbHVlICYmIG9wdGlvbiAhPSBcIm1vZGVcIikgeyByZXR1cm4gfVxuICAgICAgICBvcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdGlvbikpXG4gICAgICAgICAgeyBvcGVyYXRpb24odGhpcywgb3B0aW9uSGFuZGxlcnNbb3B0aW9uXSkodGhpcywgdmFsdWUsIG9sZCk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwib3B0aW9uQ2hhbmdlXCIsIHRoaXMsIG9wdGlvbik7XG4gICAgICB9LFxuXG4gICAgICBnZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbikge3JldHVybiB0aGlzLm9wdGlvbnNbb3B0aW9uXX0sXG4gICAgICBnZXREb2M6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLmRvY30sXG5cbiAgICAgIGFkZEtleU1hcDogZnVuY3Rpb24obWFwLCBib3R0b20pIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5rZXlNYXBzW2JvdHRvbSA/IFwicHVzaFwiIDogXCJ1bnNoaWZ0XCJdKGdldEtleU1hcChtYXApKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVLZXlNYXA6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICB2YXIgbWFwcyA9IHRoaXMuc3RhdGUua2V5TWFwcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKG1hcHNbaV0gPT0gbWFwIHx8IG1hcHNbaV0ubmFtZSA9PSBtYXApIHtcbiAgICAgICAgICAgIG1hcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9IH1cbiAgICAgIH0sXG5cbiAgICAgIGFkZE92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBzcGVjLnRva2VuID8gc3BlYyA6IENvZGVNaXJyb3IuZ2V0TW9kZSh0aGlzLm9wdGlvbnMsIHNwZWMpO1xuICAgICAgICBpZiAobW9kZS5zdGFydFN0YXRlKSB7IHRocm93IG5ldyBFcnJvcihcIk92ZXJsYXlzIG1heSBub3QgYmUgc3RhdGVmdWwuXCIpIH1cbiAgICAgICAgaW5zZXJ0U29ydGVkKHRoaXMuc3RhdGUub3ZlcmxheXMsXG4gICAgICAgICAgICAgICAgICAgICB7bW9kZTogbW9kZSwgbW9kZVNwZWM6IHNwZWMsIG9wYXF1ZTogb3B0aW9ucyAmJiBvcHRpb25zLm9wYXF1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogKG9wdGlvbnMgJiYgb3B0aW9ucy5wcmlvcml0eSkgfHwgMH0sXG4gICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3ZlcmxheSkgeyByZXR1cm4gb3ZlcmxheS5wcmlvcml0eTsgfSk7XG4gICAgICAgIHRoaXMuc3RhdGUubW9kZUdlbisrO1xuICAgICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICB9KSxcbiAgICAgIHJlbW92ZU92ZXJsYXk6IG1ldGhvZE9wKGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAgICAgdmFyIG92ZXJsYXlzID0gdGhpcy5zdGF0ZS5vdmVybGF5cztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGF5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBjdXIgPSBvdmVybGF5c1tpXS5tb2RlU3BlYztcbiAgICAgICAgICBpZiAoY3VyID09IHNwZWMgfHwgdHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIiAmJiBjdXIubmFtZSA9PSBzcGVjKSB7XG4gICAgICAgICAgICBvdmVybGF5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIGluZGVudExpbmU6IG1ldGhvZE9wKGZ1bmN0aW9uKG4sIGRpciwgYWdncmVzc2l2ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRpciAhPSBcInN0cmluZ1wiICYmIHR5cGVvZiBkaXIgIT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGlmIChkaXIgPT0gbnVsbCkgeyBkaXIgPSB0aGlzLm9wdGlvbnMuc21hcnRJbmRlbnQgPyBcInNtYXJ0XCIgOiBcInByZXZcIjsgfVxuICAgICAgICAgIGVsc2UgeyBkaXIgPSBkaXIgPyBcImFkZFwiIDogXCJzdWJ0cmFjdFwiOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGluZSh0aGlzLmRvYywgbikpIHsgaW5kZW50TGluZSh0aGlzLCBuLCBkaXIsIGFnZ3Jlc3NpdmUpOyB9XG4gICAgICB9KSxcbiAgICAgIGluZGVudFNlbGVjdGlvbjogbWV0aG9kT3AoZnVuY3Rpb24oaG93KSB7XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzLCBlbmQgPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHJhbmdlLmZyb20oKSwgdG8gPSByYW5nZS50bygpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoZW5kLCBmcm9tLmxpbmUpO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4odGhpcy5sYXN0TGluZSgpLCB0by5saW5lIC0gKHRvLmNoID8gMCA6IDEpKSArIDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gc3RhcnQ7IGogPCBlbmQ7ICsrailcbiAgICAgICAgICAgICAgeyBpbmRlbnRMaW5lKHRoaXMsIGosIGhvdyk7IH1cbiAgICAgICAgICAgIHZhciBuZXdSYW5nZXMgPSB0aGlzLmRvYy5zZWwucmFuZ2VzO1xuICAgICAgICAgICAgaWYgKGZyb20uY2ggPT0gMCAmJiByYW5nZXMubGVuZ3RoID09IG5ld1Jhbmdlcy5sZW5ndGggJiYgbmV3UmFuZ2VzW2ldLmZyb20oKS5jaCA+IDApXG4gICAgICAgICAgICAgIHsgcmVwbGFjZU9uZVNlbGVjdGlvbih0aGlzLmRvYywgaSwgbmV3IFJhbmdlKGZyb20sIG5ld1Jhbmdlc1tpXS50bygpKSwgc2VsX2RvbnRTY3JvbGwpOyB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5oZWFkLmxpbmUgPiBlbmQpIHtcbiAgICAgICAgICAgIGluZGVudExpbmUodGhpcywgcmFuZ2UuaGVhZC5saW5lLCBob3csIHRydWUpO1xuICAgICAgICAgICAgZW5kID0gcmFuZ2UuaGVhZC5saW5lO1xuICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5kb2Muc2VsLnByaW1JbmRleCkgeyBlbnN1cmVDdXJzb3JWaXNpYmxlKHRoaXMpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgLy8gRmV0Y2ggdGhlIHBhcnNlciB0b2tlbiBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuIFVzZWZ1bCBmb3IgaGFja3NcbiAgICAgIC8vIHRoYXQgd2FudCB0byBpbnNwZWN0IHRoZSBtb2RlIHN0YXRlIChzYXksIGZvciBjb21wbGV0aW9uKS5cbiAgICAgIGdldFRva2VuQXQ6IGZ1bmN0aW9uKHBvcywgcHJlY2lzZSkge1xuICAgICAgICByZXR1cm4gdGFrZVRva2VuKHRoaXMsIHBvcywgcHJlY2lzZSlcbiAgICAgIH0sXG5cbiAgICAgIGdldExpbmVUb2tlbnM6IGZ1bmN0aW9uKGxpbmUsIHByZWNpc2UpIHtcbiAgICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBQb3MobGluZSksIHByZWNpc2UsIHRydWUpXG4gICAgICB9LFxuXG4gICAgICBnZXRUb2tlblR5cGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHBvcyA9IGNsaXBQb3ModGhpcy5kb2MsIHBvcyk7XG4gICAgICAgIHZhciBzdHlsZXMgPSBnZXRMaW5lU3R5bGVzKHRoaXMsIGdldExpbmUodGhpcy5kb2MsIHBvcy5saW5lKSk7XG4gICAgICAgIHZhciBiZWZvcmUgPSAwLCBhZnRlciA9IChzdHlsZXMubGVuZ3RoIC0gMSkgLyAyLCBjaCA9IHBvcy5jaDtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIGlmIChjaCA9PSAwKSB7IHR5cGUgPSBzdHlsZXNbMl07IH1cbiAgICAgICAgZWxzZSB7IGZvciAoOzspIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGJlZm9yZSArIGFmdGVyKSA+PiAxO1xuICAgICAgICAgIGlmICgobWlkID8gc3R5bGVzW21pZCAqIDIgLSAxXSA6IDApID49IGNoKSB7IGFmdGVyID0gbWlkOyB9XG4gICAgICAgICAgZWxzZSBpZiAoc3R5bGVzW21pZCAqIDIgKyAxXSA8IGNoKSB7IGJlZm9yZSA9IG1pZCArIDE7IH1cbiAgICAgICAgICBlbHNlIHsgdHlwZSA9IHN0eWxlc1ttaWQgKiAyICsgMl07IGJyZWFrIH1cbiAgICAgICAgfSB9XG4gICAgICAgIHZhciBjdXQgPSB0eXBlID8gdHlwZS5pbmRleE9mKFwib3ZlcmxheSBcIikgOiAtMTtcbiAgICAgICAgcmV0dXJuIGN1dCA8IDAgPyB0eXBlIDogY3V0ID09IDAgPyBudWxsIDogdHlwZS5zbGljZSgwLCBjdXQgLSAxKVxuICAgICAgfSxcblxuICAgICAgZ2V0TW9kZUF0OiBmdW5jdGlvbihwb3MpIHtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLmRvYy5tb2RlO1xuICAgICAgICBpZiAoIW1vZGUuaW5uZXJNb2RlKSB7IHJldHVybiBtb2RlIH1cbiAgICAgICAgcmV0dXJuIENvZGVNaXJyb3IuaW5uZXJNb2RlKG1vZGUsIHRoaXMuZ2V0VG9rZW5BdChwb3MpLnN0YXRlKS5tb2RlXG4gICAgICB9LFxuXG4gICAgICBnZXRIZWxwZXI6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWxwZXJzKHBvcywgdHlwZSlbMF1cbiAgICAgIH0sXG5cbiAgICAgIGdldEhlbHBlcnM6IGZ1bmN0aW9uKHBvcywgdHlwZSkge1xuICAgICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IHJldHVybiBmb3VuZCB9XG4gICAgICAgIHZhciBoZWxwID0gaGVscGVyc1t0eXBlXSwgbW9kZSA9IHRoaXMuZ2V0TW9kZUF0KHBvcyk7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kZVt0eXBlXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGhlbHBbbW9kZVt0eXBlXV0pIHsgZm91bmQucHVzaChoZWxwW21vZGVbdHlwZV1dKTsgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGVbdHlwZV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vZGVbdHlwZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBoZWxwW21vZGVbdHlwZV1baV1dO1xuICAgICAgICAgICAgaWYgKHZhbCkgeyBmb3VuZC5wdXNoKHZhbCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5oZWxwZXJUeXBlICYmIGhlbHBbbW9kZS5oZWxwZXJUeXBlXSkge1xuICAgICAgICAgIGZvdW5kLnB1c2goaGVscFttb2RlLmhlbHBlclR5cGVdKTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWxwW21vZGUubmFtZV0pIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5uYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaGVscC5fZ2xvYmFsLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICB2YXIgY3VyID0gaGVscC5fZ2xvYmFsW2kkMV07XG4gICAgICAgICAgaWYgKGN1ci5wcmVkKG1vZGUsIHRoaXMpICYmIGluZGV4T2YoZm91bmQsIGN1ci52YWwpID09IC0xKVxuICAgICAgICAgICAgeyBmb3VuZC5wdXNoKGN1ci52YWwpOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kXG4gICAgICB9LFxuXG4gICAgICBnZXRTdGF0ZUFmdGVyOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYztcbiAgICAgICAgbGluZSA9IGNsaXBMaW5lKGRvYywgbGluZSA9PSBudWxsID8gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxOiBsaW5lKTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHRCZWZvcmUodGhpcywgbGluZSArIDEsIHByZWNpc2UpLnN0YXRlXG4gICAgICB9LFxuXG4gICAgICBjdXJzb3JDb29yZHM6IGZ1bmN0aW9uKHN0YXJ0LCBtb2RlKSB7XG4gICAgICAgIHZhciBwb3MsIHJhbmdlID0gdGhpcy5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgcG9zID0gcmFuZ2UuaGVhZDsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RhcnQgPT0gXCJvYmplY3RcIikgeyBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBzdGFydCk7IH1cbiAgICAgICAgZWxzZSB7IHBvcyA9IHN0YXJ0ID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKTsgfVxuICAgICAgICByZXR1cm4gY3Vyc29yQ29vcmRzKHRoaXMsIHBvcywgbW9kZSB8fCBcInBhZ2VcIilcbiAgICAgIH0sXG5cbiAgICAgIGNoYXJDb29yZHM6IGZ1bmN0aW9uKHBvcywgbW9kZSkge1xuICAgICAgICByZXR1cm4gY2hhckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpLCBtb2RlIHx8IFwicGFnZVwiKVxuICAgICAgfSxcblxuICAgICAgY29vcmRzQ2hhcjogZnVuY3Rpb24oY29vcmRzLCBtb2RlKSB7XG4gICAgICAgIGNvb3JkcyA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCBjb29yZHMsIG1vZGUgfHwgXCJwYWdlXCIpO1xuICAgICAgICByZXR1cm4gY29vcmRzQ2hhcih0aGlzLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcClcbiAgICAgIH0sXG5cbiAgICAgIGxpbmVBdEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0LCBtb2RlKSB7XG4gICAgICAgIGhlaWdodCA9IGZyb21Db29yZFN5c3RlbSh0aGlzLCB7dG9wOiBoZWlnaHQsIGxlZnQ6IDB9LCBtb2RlIHx8IFwicGFnZVwiKS50b3A7XG4gICAgICAgIHJldHVybiBsaW5lQXRIZWlnaHQodGhpcy5kb2MsIGhlaWdodCArIHRoaXMuZGlzcGxheS52aWV3T2Zmc2V0KVxuICAgICAgfSxcbiAgICAgIGhlaWdodEF0TGluZTogZnVuY3Rpb24obGluZSwgbW9kZSwgaW5jbHVkZVdpZGdldHMpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlLCBsaW5lT2JqO1xuICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5kb2MuZmlyc3QgKyB0aGlzLmRvYy5zaXplIC0gMTtcbiAgICAgICAgICBpZiAobGluZSA8IHRoaXMuZG9jLmZpcnN0KSB7IGxpbmUgPSB0aGlzLmRvYy5maXJzdDsgfVxuICAgICAgICAgIGVsc2UgaWYgKGxpbmUgPiBsYXN0KSB7IGxpbmUgPSBsYXN0OyBlbmQgPSB0cnVlOyB9XG4gICAgICAgICAgbGluZU9iaiA9IGdldExpbmUodGhpcy5kb2MsIGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVPYmogPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0odGhpcywgbGluZU9iaiwge3RvcDogMCwgbGVmdDogMH0sIG1vZGUgfHwgXCJwYWdlXCIsIGluY2x1ZGVXaWRnZXRzIHx8IGVuZCkudG9wICtcbiAgICAgICAgICAoZW5kID8gdGhpcy5kb2MuaGVpZ2h0IC0gaGVpZ2h0QXRMaW5lKGxpbmVPYmopIDogMClcbiAgICAgIH0sXG5cbiAgICAgIGRlZmF1bHRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRleHRIZWlnaHQodGhpcy5kaXNwbGF5KSB9LFxuICAgICAgZGVmYXVsdENoYXJXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiBjaGFyV2lkdGgodGhpcy5kaXNwbGF5KSB9LFxuXG4gICAgICBnZXRWaWV3cG9ydDogZnVuY3Rpb24oKSB7IHJldHVybiB7ZnJvbTogdGhpcy5kaXNwbGF5LnZpZXdGcm9tLCB0bzogdGhpcy5kaXNwbGF5LnZpZXdUb319LFxuXG4gICAgICBhZGRXaWRnZXQ6IGZ1bmN0aW9uKHBvcywgbm9kZSwgc2Nyb2xsLCB2ZXJ0LCBob3Jpeikge1xuICAgICAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheTtcbiAgICAgICAgcG9zID0gY3Vyc29yQ29vcmRzKHRoaXMsIGNsaXBQb3ModGhpcy5kb2MsIHBvcykpO1xuICAgICAgICB2YXIgdG9wID0gcG9zLmJvdHRvbSwgbGVmdCA9IHBvcy5sZWZ0O1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpO1xuICAgICAgICB0aGlzLmRpc3BsYXkuaW5wdXQuc2V0VW5lZGl0YWJsZShub2RlKTtcbiAgICAgICAgZGlzcGxheS5zaXplci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgaWYgKHZlcnQgPT0gXCJvdmVyXCIpIHtcbiAgICAgICAgICB0b3AgPSBwb3MudG9wO1xuICAgICAgICB9IGVsc2UgaWYgKHZlcnQgPT0gXCJhYm92ZVwiIHx8IHZlcnQgPT0gXCJuZWFyXCIpIHtcbiAgICAgICAgICB2YXIgdnNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgdGhpcy5kb2MuaGVpZ2h0KSxcbiAgICAgICAgICBoc3BhY2UgPSBNYXRoLm1heChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoLCBkaXNwbGF5LmxpbmVTcGFjZS5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgLy8gRGVmYXVsdCB0byBwb3NpdGlvbmluZyBhYm92ZSAoaWYgc3BlY2lmaWVkIGFuZCBwb3NzaWJsZSk7IG90aGVyd2lzZSBkZWZhdWx0IHRvIHBvc2l0aW9uaW5nIGJlbG93XG4gICAgICAgICAgaWYgKCh2ZXJ0ID09ICdhYm92ZScgfHwgcG9zLmJvdHRvbSArIG5vZGUub2Zmc2V0SGVpZ2h0ID4gdnNwYWNlKSAmJiBwb3MudG9wID4gbm9kZS5vZmZzZXRIZWlnaHQpXG4gICAgICAgICAgICB7IHRvcCA9IHBvcy50b3AgLSBub2RlLm9mZnNldEhlaWdodDsgfVxuICAgICAgICAgIGVsc2UgaWYgKHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA8PSB2c3BhY2UpXG4gICAgICAgICAgICB7IHRvcCA9IHBvcy5ib3R0b207IH1cbiAgICAgICAgICBpZiAobGVmdCArIG5vZGUub2Zmc2V0V2lkdGggPiBoc3BhY2UpXG4gICAgICAgICAgICB7IGxlZnQgPSBoc3BhY2UgLSBub2RlLm9mZnNldFdpZHRoOyB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IG5vZGUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICBpZiAoaG9yaXogPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgbGVmdCA9IGRpc3BsYXkuc2l6ZXIuY2xpZW50V2lkdGggLSBub2RlLm9mZnNldFdpZHRoO1xuICAgICAgICAgIG5vZGUuc3R5bGUucmlnaHQgPSBcIjBweFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChob3JpeiA9PSBcImxlZnRcIikgeyBsZWZ0ID0gMDsgfVxuICAgICAgICAgIGVsc2UgaWYgKGhvcml6ID09IFwibWlkZGxlXCIpIHsgbGVmdCA9IChkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCkgLyAyOyB9XG4gICAgICAgICAgbm9kZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2Nyb2xsKVxuICAgICAgICAgIHsgc2Nyb2xsSW50b1ZpZXcodGhpcywge2xlZnQ6IGxlZnQsIHRvcDogdG9wLCByaWdodDogbGVmdCArIG5vZGUub2Zmc2V0V2lkdGgsIGJvdHRvbTogdG9wICsgbm9kZS5vZmZzZXRIZWlnaHR9KTsgfVxuICAgICAgfSxcblxuICAgICAgdHJpZ2dlck9uS2V5RG93bjogbWV0aG9kT3Aob25LZXlEb3duKSxcbiAgICAgIHRyaWdnZXJPbktleVByZXNzOiBtZXRob2RPcChvbktleVByZXNzKSxcbiAgICAgIHRyaWdnZXJPbktleVVwOiBvbktleVVwLFxuICAgICAgdHJpZ2dlck9uTW91c2VEb3duOiBtZXRob2RPcChvbk1vdXNlRG93biksXG5cbiAgICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbihjbWQpIHtcbiAgICAgICAgaWYgKGNvbW1hbmRzLmhhc093blByb3BlcnR5KGNtZCkpXG4gICAgICAgICAgeyByZXR1cm4gY29tbWFuZHNbY21kXS5jYWxsKG51bGwsIHRoaXMpIH1cbiAgICAgIH0sXG5cbiAgICAgIHRyaWdnZXJFbGVjdHJpYzogbWV0aG9kT3AoZnVuY3Rpb24odGV4dCkgeyB0cmlnZ2VyRWxlY3RyaWModGhpcywgdGV4dCk7IH0pLFxuXG4gICAgICBmaW5kUG9zSDogZnVuY3Rpb24oZnJvbSwgYW1vdW50LCB1bml0LCB2aXN1YWxseSkge1xuICAgICAgICB2YXIgZGlyID0gMTtcbiAgICAgICAgaWYgKGFtb3VudCA8IDApIHsgZGlyID0gLTE7IGFtb3VudCA9IC1hbW91bnQ7IH1cbiAgICAgICAgdmFyIGN1ciA9IGNsaXBQb3ModGhpcy5kb2MsIGZyb20pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgY3VyID0gZmluZFBvc0godGhpcy5kb2MsIGN1ciwgZGlyLCB1bml0LCB2aXN1YWxseSk7XG4gICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyXG4gICAgICB9LFxuXG4gICAgICBtb3ZlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgIGlmICh0aGlzJDEuZGlzcGxheS5zaGlmdCB8fCB0aGlzJDEuZG9jLmV4dGVuZCB8fCByYW5nZS5lbXB0eSgpKVxuICAgICAgICAgICAgeyByZXR1cm4gZmluZFBvc0godGhpcyQxLmRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCB0aGlzJDEub3B0aW9ucy5ydGxNb3ZlVmlzdWFsbHkpIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7IHJldHVybiBkaXIgPCAwID8gcmFuZ2UuZnJvbSgpIDogcmFuZ2UudG8oKSB9XG4gICAgICAgIH0sIHNlbF9tb3ZlKTtcbiAgICAgIH0pLFxuXG4gICAgICBkZWxldGVIOiBtZXRob2RPcChmdW5jdGlvbihkaXIsIHVuaXQpIHtcbiAgICAgICAgdmFyIHNlbCA9IHRoaXMuZG9jLnNlbCwgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIGlmIChzZWwuc29tZXRoaW5nU2VsZWN0ZWQoKSlcbiAgICAgICAgICB7IGRvYy5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiK2RlbGV0ZVwiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBkZWxldGVOZWFyU2VsZWN0aW9uKHRoaXMsIGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gZmluZFBvc0goZG9jLCByYW5nZS5oZWFkLCBkaXIsIHVuaXQsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBkaXIgPCAwID8ge2Zyb206IG90aGVyLCB0bzogcmFuZ2UuaGVhZH0gOiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IG90aGVyfVxuICAgICAgICAgIH0pOyB9XG4gICAgICB9KSxcblxuICAgICAgZmluZFBvc1Y6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgZ29hbENvbHVtbikge1xuICAgICAgICB2YXIgZGlyID0gMSwgeCA9IGdvYWxDb2x1bW47XG4gICAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XG4gICAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHModGhpcywgY3VyLCBcImRpdlwiKTtcbiAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7IHggPSBjb29yZHMubGVmdDsgfVxuICAgICAgICAgIGVsc2UgeyBjb29yZHMubGVmdCA9IHg7IH1cbiAgICAgICAgICBjdXIgPSBmaW5kUG9zVih0aGlzLCBjb29yZHMsIGRpciwgdW5pdCk7XG4gICAgICAgICAgaWYgKGN1ci5oaXRTaWRlKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VyXG4gICAgICB9LFxuXG4gICAgICBtb3ZlVjogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgZ29hbHMgPSBbXTtcbiAgICAgICAgdmFyIGNvbGxhcHNlID0gIXRoaXMuZGlzcGxheS5zaGlmdCAmJiAhZG9jLmV4dGVuZCAmJiBkb2Muc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgIGRvYy5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKGNvbGxhcHNlKVxuICAgICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxuICAgICAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKHRoaXMkMSwgcmFuZ2UuaGVhZCwgXCJkaXZcIik7XG4gICAgICAgICAgaWYgKHJhbmdlLmdvYWxDb2x1bW4gIT0gbnVsbCkgeyBoZWFkUG9zLmxlZnQgPSByYW5nZS5nb2FsQ29sdW1uOyB9XG4gICAgICAgICAgZ29hbHMucHVzaChoZWFkUG9zLmxlZnQpO1xuICAgICAgICAgIHZhciBwb3MgPSBmaW5kUG9zVih0aGlzJDEsIGhlYWRQb3MsIGRpciwgdW5pdCk7XG4gICAgICAgICAgaWYgKHVuaXQgPT0gXCJwYWdlXCIgJiYgcmFuZ2UgPT0gZG9jLnNlbC5wcmltYXJ5KCkpXG4gICAgICAgICAgICB7IGFkZFRvU2Nyb2xsVG9wKHRoaXMkMSwgY2hhckNvb3Jkcyh0aGlzJDEsIHBvcywgXCJkaXZcIikudG9wIC0gaGVhZFBvcy50b3ApOyB9XG4gICAgICAgICAgcmV0dXJuIHBvc1xuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICAgIGlmIChnb2Fscy5sZW5ndGgpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IGRvYy5zZWwucmFuZ2VzW2ldLmdvYWxDb2x1bW4gPSBnb2Fsc1tpXTsgfSB9XG4gICAgICB9KSxcblxuICAgICAgLy8gRmluZCB0aGUgd29yZCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gKGFzIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIpLlxuICAgICAgZmluZFdvcmRBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBkb2MgPSB0aGlzLmRvYywgbGluZSA9IGdldExpbmUoZG9jLCBwb3MubGluZSkudGV4dDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcG9zLmNoLCBlbmQgPSBwb3MuY2g7XG4gICAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgICAgdmFyIGhlbHBlciA9IHRoaXMuZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICAgICAgaWYgKChwb3Muc3RpY2t5ID09IFwiYmVmb3JlXCIgfHwgZW5kID09IGxpbmUubGVuZ3RoKSAmJiBzdGFydCkgeyAtLXN0YXJ0OyB9IGVsc2UgeyArK2VuZDsgfVxuICAgICAgICAgIHZhciBzdGFydENoYXIgPSBsaW5lLmNoYXJBdChzdGFydCk7XG4gICAgICAgICAgdmFyIGNoZWNrID0gaXNXb3JkQ2hhcihzdGFydENoYXIsIGhlbHBlcilcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGNoKSB7IHJldHVybiBpc1dvcmRDaGFyKGNoLCBoZWxwZXIpOyB9XG4gICAgICAgICAgICA6IC9cXHMvLnRlc3Qoc3RhcnRDaGFyKSA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gL1xccy8udGVzdChjaCk7IH1cbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGNoKSB7IHJldHVybiAoIS9cXHMvLnRlc3QoY2gpICYmICFpc1dvcmRDaGFyKGNoKSk7IH07XG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBjaGVjayhsaW5lLmNoYXJBdChzdGFydCAtIDEpKSkgeyAtLXN0YXJ0OyB9XG4gICAgICAgICAgd2hpbGUgKGVuZCA8IGxpbmUubGVuZ3RoICYmIGNoZWNrKGxpbmUuY2hhckF0KGVuZCkpKSB7ICsrZW5kOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIHN0YXJ0KSwgUG9zKHBvcy5saW5lLCBlbmQpKVxuICAgICAgfSxcblxuICAgICAgdG9nZ2xlT3ZlcndyaXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA9PSB0aGlzLnN0YXRlLm92ZXJ3cml0ZSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5vdmVyd3JpdGUgPSAhdGhpcy5zdGF0ZS5vdmVyd3JpdGUpXG4gICAgICAgICAgeyBhZGRDbGFzcyh0aGlzLmRpc3BsYXkuY3Vyc29yRGl2LCBcIkNvZGVNaXJyb3Itb3ZlcndyaXRlXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJtQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTsgfVxuXG4gICAgICAgIHNpZ25hbCh0aGlzLCBcIm92ZXJ3cml0ZVRvZ2dsZVwiLCB0aGlzLCB0aGlzLnN0YXRlLm92ZXJ3cml0ZSk7XG4gICAgICB9LFxuICAgICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCkgPT0gYWN0aXZlRWx0KCkgfSxcbiAgICAgIGlzUmVhZE9ubHk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gISEodGhpcy5vcHRpb25zLnJlYWRPbmx5IHx8IHRoaXMuZG9jLmNhbnRFZGl0KSB9LFxuXG4gICAgICBzY3JvbGxUbzogbWV0aG9kT3AoZnVuY3Rpb24gKHgsIHkpIHsgc2Nyb2xsVG9Db29yZHModGhpcywgeCwgeSk7IH0pLFxuICAgICAgZ2V0U2Nyb2xsSW5mbzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzY3JvbGxlciA9IHRoaXMuZGlzcGxheS5zY3JvbGxlcjtcbiAgICAgICAgcmV0dXJuIHtsZWZ0OiBzY3JvbGxlci5zY3JvbGxMZWZ0LCB0b3A6IHNjcm9sbGVyLnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbGVyLnNjcm9sbFdpZHRoIC0gc2Nyb2xsR2FwKHRoaXMpIC0gdGhpcy5kaXNwbGF5LmJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGlzcGxheUhlaWdodCh0aGlzKSwgY2xpZW50V2lkdGg6IGRpc3BsYXlXaWR0aCh0aGlzKX1cbiAgICAgIH0sXG5cbiAgICAgIHNjcm9sbEludG9WaWV3OiBtZXRob2RPcChmdW5jdGlvbihyYW5nZSwgbWFyZ2luKSB7XG4gICAgICAgIGlmIChyYW5nZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogdGhpcy5kb2Muc2VsLnByaW1hcnkoKS5oZWFkLCB0bzogbnVsbH07XG4gICAgICAgICAgaWYgKG1hcmdpbiA9PSBudWxsKSB7IG1hcmdpbiA9IHRoaXMub3B0aW9ucy5jdXJzb3JTY3JvbGxNYXJnaW47IH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmFuZ2UgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IFBvcyhyYW5nZSwgMCksIHRvOiBudWxsfTtcbiAgICAgICAgfSBlbHNlIGlmIChyYW5nZS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiByYW5nZSwgdG86IG51bGx9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmFuZ2UudG8pIHsgcmFuZ2UudG8gPSByYW5nZS5mcm9tOyB9XG4gICAgICAgIHJhbmdlLm1hcmdpbiA9IG1hcmdpbiB8fCAwO1xuXG4gICAgICAgIGlmIChyYW5nZS5mcm9tLmxpbmUgIT0gbnVsbCkge1xuICAgICAgICAgIHNjcm9sbFRvUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbFRvQ29vcmRzUmFuZ2UodGhpcywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHJhbmdlLm1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBzZXRTaXplOiBtZXRob2RPcChmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciBpbnRlcnByZXQgPSBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB0eXBlb2YgdmFsID09IFwibnVtYmVyXCIgfHwgL15cXGQrJC8udGVzdChTdHJpbmcodmFsKSkgPyB2YWwgKyBcInB4XCIgOiB2YWw7IH07XG4gICAgICAgIGlmICh3aWR0aCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLndpZHRoID0gaW50ZXJwcmV0KHdpZHRoKTsgfVxuICAgICAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gaW50ZXJwcmV0KGhlaWdodCk7IH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZSh0aGlzKTsgfVxuICAgICAgICB2YXIgbGluZU5vID0gdGhpcy5kaXNwbGF5LnZpZXdGcm9tO1xuICAgICAgICB0aGlzLmRvYy5pdGVyKGxpbmVObywgdGhpcy5kaXNwbGF5LnZpZXdUbywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgeyBpZiAobGluZS53aWRnZXRzW2ldLm5vSFNjcm9sbCkgeyByZWdMaW5lQ2hhbmdlKHRoaXMkMSwgbGluZU5vLCBcIndpZGdldFwiKTsgYnJlYWsgfSB9IH1cbiAgICAgICAgICArK2xpbmVObztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzaWduYWwodGhpcywgXCJyZWZyZXNoXCIsIHRoaXMpO1xuICAgICAgfSksXG5cbiAgICAgIG9wZXJhdGlvbjogZnVuY3Rpb24oZil7cmV0dXJuIHJ1bkluT3AodGhpcywgZil9LFxuICAgICAgc3RhcnRPcGVyYXRpb246IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXJ0T3BlcmF0aW9uKHRoaXMpfSxcbiAgICAgIGVuZE9wZXJhdGlvbjogZnVuY3Rpb24oKXtyZXR1cm4gZW5kT3BlcmF0aW9uKHRoaXMpfSxcblxuICAgICAgcmVmcmVzaDogbWV0aG9kT3AoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRIZWlnaHQgPSB0aGlzLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodDtcbiAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHNjcm9sbFRvQ29vcmRzKHRoaXMsIHRoaXMuZG9jLnNjcm9sbExlZnQsIHRoaXMuZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHVwZGF0ZUd1dHRlclNwYWNlKHRoaXMuZGlzcGxheSk7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgPT0gbnVsbCB8fCBNYXRoLmFicyhvbGRIZWlnaHQgLSB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkpID4gLjUgfHwgdGhpcy5vcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgICAgICB7IGVzdGltYXRlTGluZUhlaWdodHModGhpcyk7IH1cbiAgICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICAgIH0pLFxuXG4gICAgICBzd2FwRG9jOiBtZXRob2RPcChmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuZG9jO1xuICAgICAgICBvbGQuY20gPSBudWxsO1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gaWYgYW55ICgjNTgyMSlcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VsZWN0aW5nVGV4dCkgeyB0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQoKTsgfVxuICAgICAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcbiAgICAgICAgY2xlYXJDYWNoZXModGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGxheS5pbnB1dC5yZXNldCgpO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCBkb2Muc2Nyb2xsTGVmdCwgZG9jLnNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuY3VyT3AuZm9yY2VTY3JvbGwgPSB0cnVlO1xuICAgICAgICBzaWduYWxMYXRlcih0aGlzLCBcInN3YXBEb2NcIiwgdGhpcywgb2xkKTtcbiAgICAgICAgcmV0dXJuIG9sZFxuICAgICAgfSksXG5cbiAgICAgIHBocmFzZTogZnVuY3Rpb24ocGhyYXNlVGV4dCkge1xuICAgICAgICB2YXIgcGhyYXNlcyA9IHRoaXMub3B0aW9ucy5waHJhc2VzO1xuICAgICAgICByZXR1cm4gcGhyYXNlcyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGhyYXNlcywgcGhyYXNlVGV4dCkgPyBwaHJhc2VzW3BocmFzZVRleHRdIDogcGhyYXNlVGV4dFxuICAgICAgfSxcblxuICAgICAgZ2V0SW5wdXRGaWVsZDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LmlucHV0LmdldEZpZWxkKCl9LFxuICAgICAgZ2V0V3JhcHBlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS53cmFwcGVyfSxcbiAgICAgIGdldFNjcm9sbGVyRWxlbWVudDogZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNwbGF5LnNjcm9sbGVyfSxcbiAgICAgIGdldEd1dHRlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5ndXR0ZXJzfVxuICAgIH07XG4gICAgZXZlbnRNaXhpbihDb2RlTWlycm9yKTtcblxuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgaWYgKCFoZWxwZXJzLmhhc093blByb3BlcnR5KHR5cGUpKSB7IGhlbHBlcnNbdHlwZV0gPSBDb2RlTWlycm9yW3R5cGVdID0ge19nbG9iYWw6IFtdfTsgfVxuICAgICAgaGVscGVyc1t0eXBlXVtuYW1lXSA9IHZhbHVlO1xuICAgIH07XG4gICAgQ29kZU1pcnJvci5yZWdpc3Rlckdsb2JhbEhlbHBlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHByZWRpY2F0ZSwgdmFsdWUpIHtcbiAgICAgIENvZGVNaXJyb3IucmVnaXN0ZXJIZWxwZXIodHlwZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgaGVscGVyc1t0eXBlXS5fZ2xvYmFsLnB1c2goe3ByZWQ6IHByZWRpY2F0ZSwgdmFsOiB2YWx1ZX0pO1xuICAgIH07XG4gIH1cblxuICAvLyBVc2VkIGZvciBob3Jpem9udGFsIHJlbGF0aXZlIG1vdGlvbi4gRGlyIGlzIC0xIG9yIDEgKGxlZnQgb3JcbiAgLy8gcmlnaHQpLCB1bml0IGNhbiBiZSBcImNvZGVwb2ludFwiLCBcImNoYXJcIiwgXCJjb2x1bW5cIiAobGlrZSBjaGFyLCBidXRcbiAgLy8gZG9lc24ndCBjcm9zcyBsaW5lIGJvdW5kYXJpZXMpLCBcIndvcmRcIiAoYWNyb3NzIG5leHQgd29yZCksIG9yXG4gIC8vIFwiZ3JvdXBcIiAodG8gdGhlIHN0YXJ0IG9mIG5leHQgZ3JvdXAgb2Ygd29yZCBvclxuICAvLyBub24td29yZC1ub24td2hpdGVzcGFjZSBjaGFycykuIFRoZSB2aXN1YWxseSBwYXJhbSBjb250cm9sc1xuICAvLyB3aGV0aGVyLCBpbiByaWdodC10by1sZWZ0IHRleHQsIGRpcmVjdGlvbiAxIG1lYW5zIHRvIG1vdmUgdG93YXJkc1xuICAvLyB0aGUgbmV4dCBpbmRleCBpbiB0aGUgc3RyaW5nLCBvciB0b3dhcmRzIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0XG4gIC8vIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uLiBUaGUgcmVzdWx0aW5nIHBvc2l0aW9uIHdpbGwgaGF2ZSBhXG4gIC8vIGhpdFNpZGU9dHJ1ZSBwcm9wZXJ0eSBpZiBpdCByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBmaW5kUG9zSChkb2MsIHBvcywgZGlyLCB1bml0LCB2aXN1YWxseSkge1xuICAgIHZhciBvbGRQb3MgPSBwb3M7XG4gICAgdmFyIG9yaWdEaXIgPSBkaXI7XG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpO1xuICAgIHZhciBsaW5lRGlyID0gdmlzdWFsbHkgJiYgZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gLWRpciA6IGRpcjtcbiAgICBmdW5jdGlvbiBmaW5kTmV4dExpbmUoKSB7XG4gICAgICB2YXIgbCA9IHBvcy5saW5lICsgbGluZURpcjtcbiAgICAgIGlmIChsIDwgZG9jLmZpcnN0IHx8IGwgPj0gZG9jLmZpcnN0ICsgZG9jLnNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHBvcyA9IG5ldyBQb3MobCwgcG9zLmNoLCBwb3Muc3RpY2t5KTtcbiAgICAgIHJldHVybiBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGwpXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVPbmNlKGJvdW5kVG9MaW5lKSB7XG4gICAgICB2YXIgbmV4dDtcbiAgICAgIGlmICh1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgICAgdmFyIGNoID0gbGluZU9iai50ZXh0LmNoYXJDb2RlQXQocG9zLmNoICsgKGRpciA+IDAgPyAwIDogLTEpKTtcbiAgICAgICAgaWYgKGlzTmFOKGNoKSkge1xuICAgICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhc3RyYWwgPSBkaXIgPiAwID8gY2ggPj0gMHhEODAwICYmIGNoIDwgMHhEQzAwIDogY2ggPj0gMHhEQzAwICYmIGNoIDwgMHhERkZGO1xuICAgICAgICAgIG5leHQgPSBuZXcgUG9zKHBvcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLm1pbihsaW5lT2JqLnRleHQubGVuZ3RoLCBwb3MuY2ggKyBkaXIgKiAoYXN0cmFsID8gMiA6IDEpKSksIC1kaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZpc3VhbGx5KSB7XG4gICAgICAgIG5leHQgPSBtb3ZlVmlzdWFsbHkoZG9jLmNtLCBsaW5lT2JqLCBwb3MsIGRpcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gbW92ZUxvZ2ljYWxseShsaW5lT2JqLCBwb3MsIGRpcik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgIGlmICghYm91bmRUb0xpbmUgJiYgZmluZE5leHRMaW5lKCkpXG4gICAgICAgICAgeyBwb3MgPSBlbmRPZkxpbmUodmlzdWFsbHksIGRvYy5jbSwgbGluZU9iaiwgcG9zLmxpbmUsIGxpbmVEaXIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIiB8fCB1bml0ID09IFwiY29kZXBvaW50XCIpIHtcbiAgICAgIG1vdmVPbmNlKCk7XG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwiY29sdW1uXCIpIHtcbiAgICAgIG1vdmVPbmNlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcIndvcmRcIiB8fCB1bml0ID09IFwiZ3JvdXBcIikge1xuICAgICAgdmFyIHNhd1R5cGUgPSBudWxsLCBncm91cCA9IHVuaXQgPT0gXCJncm91cFwiO1xuICAgICAgdmFyIGhlbHBlciA9IGRvYy5jbSAmJiBkb2MuY20uZ2V0SGVscGVyKHBvcywgXCJ3b3JkQ2hhcnNcIik7XG4gICAgICBmb3IgKHZhciBmaXJzdCA9IHRydWU7OyBmaXJzdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChkaXIgPCAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cbiAgICAgICAgdmFyIGN1ciA9IGxpbmVPYmoudGV4dC5jaGFyQXQocG9zLmNoKSB8fCBcIlxcblwiO1xuICAgICAgICB2YXIgdHlwZSA9IGlzV29yZENoYXIoY3VyLCBoZWxwZXIpID8gXCJ3XCJcbiAgICAgICAgICA6IGdyb3VwICYmIGN1ciA9PSBcIlxcblwiID8gXCJuXCJcbiAgICAgICAgICA6ICFncm91cCB8fCAvXFxzLy50ZXN0KGN1cikgPyBudWxsXG4gICAgICAgICAgOiBcInBcIjtcbiAgICAgICAgaWYgKGdyb3VwICYmICFmaXJzdCAmJiAhdHlwZSkgeyB0eXBlID0gXCJzXCI7IH1cbiAgICAgICAgaWYgKHNhd1R5cGUgJiYgc2F3VHlwZSAhPSB0eXBlKSB7XG4gICAgICAgICAgaWYgKGRpciA8IDApIHtkaXIgPSAxOyBtb3ZlT25jZSgpOyBwb3Muc3RpY2t5ID0gXCJhZnRlclwiO31cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUpIHsgc2F3VHlwZSA9IHR5cGU7IH1cbiAgICAgICAgaWYgKGRpciA+IDAgJiYgIW1vdmVPbmNlKCFmaXJzdCkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBvcmlnRGlyLCB0cnVlKTtcbiAgICBpZiAoZXF1YWxDdXJzb3JQb3Mob2xkUG9zLCByZXN1bHQpKSB7IHJlc3VsdC5oaXRTaWRlID0gdHJ1ZTsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIEZvciByZWxhdGl2ZSB2ZXJ0aWNhbCBtb3ZlbWVudC4gRGlyIG1heSBiZSAtMSBvciAxLiBVbml0IGNhbiBiZVxuICAvLyBcInBhZ2VcIiBvciBcImxpbmVcIi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYSBoaXRTaWRlPXRydWVcbiAgLy8gcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc1YoY20sIHBvcywgZGlyLCB1bml0KSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgeCA9IHBvcy5sZWZ0LCB5O1xuICAgIGlmICh1bml0ID09IFwicGFnZVwiKSB7XG4gICAgICB2YXIgcGFnZVNpemUgPSBNYXRoLm1pbihjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB2YXIgbW92ZUFtb3VudCA9IE1hdGgubWF4KHBhZ2VTaXplIC0gLjUgKiB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpLCAzKTtcbiAgICAgIHkgPSAoZGlyID4gMCA/IHBvcy5ib3R0b20gOiBwb3MudG9wKSArIGRpciAqIG1vdmVBbW91bnQ7XG5cbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHtcbiAgICAgIHkgPSBkaXIgPiAwID8gcG9zLmJvdHRvbSArIDMgOiBwb3MudG9wIC0gMztcbiAgICB9XG4gICAgdmFyIHRhcmdldDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICB0YXJnZXQgPSBjb29yZHNDaGFyKGNtLCB4LCB5KTtcbiAgICAgIGlmICghdGFyZ2V0Lm91dHNpZGUpIHsgYnJlYWsgfVxuICAgICAgaWYgKGRpciA8IDAgPyB5IDw9IDAgOiB5ID49IGRvYy5oZWlnaHQpIHsgdGFyZ2V0LmhpdFNpZGUgPSB0cnVlOyBicmVhayB9XG4gICAgICB5ICs9IGRpciAqIDU7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8vIENPTlRFTlRFRElUQUJMRSBJTlBVVCBTVFlMRVxuXG4gIHZhciBDb250ZW50RWRpdGFibGVJbnB1dCA9IGZ1bmN0aW9uKGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHRoaXMubGFzdEFuY2hvck5vZGUgPSB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSB0aGlzLmxhc3RGb2N1c05vZGUgPSB0aGlzLmxhc3RGb2N1c09mZnNldCA9IG51bGw7XG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcbiAgICB0aGlzLmNvbXBvc2luZyA9IG51bGw7XG4gICAgdGhpcy5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSBpbnB1dC5jbTtcbiAgICB2YXIgZGl2ID0gaW5wdXQuZGl2ID0gZGlzcGxheS5saW5lRGl2O1xuICAgIGRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGRpc2FibGVCcm93c2VyTWFnaWMoZGl2LCBjbS5vcHRpb25zLnNwZWxsY2hlY2ssIGNtLm9wdGlvbnMuYXV0b2NvcnJlY3QsIGNtLm9wdGlvbnMuYXV0b2NhcGl0YWxpemUpO1xuXG4gICAgZnVuY3Rpb24gYmVsb25nc1RvSW5wdXQoZSkge1xuICAgICAgZm9yICh2YXIgdCA9IGUudGFyZ2V0OyB0OyB0ID0gdC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICh0ID09IGRpdikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICAgIGlmICgvXFxiQ29kZU1pcnJvci0oPzpsaW5lKT93aWRnZXRcXGIvLnRlc3QodC5jbGFzc05hbWUpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIG9uKGRpdiwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFiZWxvbmdzVG9JbnB1dChlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkgfHwgaGFuZGxlUGFzdGUoZSwgY20pKSB7IHJldHVybiB9XG4gICAgICAvLyBJRSBkb2Vzbid0IGZpcmUgaW5wdXQgZXZlbnRzLCBzbyB3ZSBzY2hlZHVsZSBhIHJlYWQgZm9yIHRoZSBwYXN0ZWQgY29udGVudCBpbiB0aGlzIHdheVxuICAgICAgaWYgKGllX3ZlcnNpb24gPD0gMTEpIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS51cGRhdGVGcm9tRE9NKCk7IH0pLCAyMCk7IH1cbiAgICB9KTtcblxuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzJDEuY29tcG9zaW5nID0ge2RhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2V9O1xuICAgIH0pO1xuICAgIG9uKGRpdiwgXCJjb21wb3NpdGlvbnVwZGF0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5jb21wb3NpbmcgPSB7ZGF0YTogZS5kYXRhLCBkb25lOiBmYWxzZX07IH1cbiAgICB9KTtcbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIGlmIChlLmRhdGEgIT0gdGhpcyQxLmNvbXBvc2luZy5kYXRhKSB7IHRoaXMkMS5yZWFkRnJvbURPTVNvb24oKTsgfVxuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgb24oZGl2LCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5wdXQuZm9yY2VDb21wb3NpdGlvbkVuZCgpOyB9KTtcblxuICAgIG9uKGRpdiwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMkMS5jb21wb3NpbmcpIHsgdGhpcyQxLnJlYWRGcm9tRE9NU29vbigpOyB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBvbkNvcHlDdXQoZSkge1xuICAgICAgaWYgKCFiZWxvbmdzVG9JbnB1dChlKSB8fCBzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgeyBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpOyB9XG4gICAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5vcGVyYXRpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCAwLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKFwiXCIsIG51bGwsIFwiY3V0XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgIGUuY2xpcGJvYXJkRGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBsYXN0Q29waWVkLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgLy8gaU9TIGV4cG9zZXMgdGhlIGNsaXBib2FyZCBBUEksIGJ1dCBzZWVtcyB0byBkaXNjYXJkIGNvbnRlbnQgaW5zZXJ0ZWQgaW50byBpdFxuICAgICAgICBlLmNsaXBib2FyZERhdGEuc2V0RGF0YShcIlRleHRcIiwgY29udGVudCk7XG4gICAgICAgIGlmIChlLmNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIikgPT0gY29udGVudCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gT2xkLWZhc2hpb25lZCBicmllZmx5LWZvY3VzLWEtdGV4dGFyZWEgaGFja1xuICAgICAgdmFyIGtsdWRnZSA9IGhpZGRlblRleHRhcmVhKCksIHRlID0ga2x1ZGdlLmZpcnN0Q2hpbGQ7XG4gICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5pbnNlcnRCZWZvcmUoa2x1ZGdlLCBjbS5kaXNwbGF5LmxpbmVTcGFjZS5maXJzdENoaWxkKTtcbiAgICAgIHRlLnZhbHVlID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICB2YXIgaGFkRm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpO1xuICAgICAgICBoYWRGb2N1cy5mb2N1cygpO1xuICAgICAgICBpZiAoaGFkRm9jdXMgPT0gZGl2KSB7IGlucHV0LnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cbiAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb24oZGl2LCBcImNvcHlcIiwgb25Db3B5Q3V0KTtcbiAgICBvbihkaXYsIFwiY3V0XCIsIG9uQ29weUN1dCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIC8vIExhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYobGFiZWwpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sIGZhbHNlKTtcbiAgICByZXN1bHQuZm9jdXMgPSBhY3RpdmVFbHQoKSA9PSB0aGlzLmRpdjtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaW5mbywgdGFrZUZvY3VzKSB7XG4gICAgaWYgKCFpbmZvIHx8ICF0aGlzLmNtLmRpc3BsYXkudmlldy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBpZiAoaW5mby5mb2N1cyB8fCB0YWtlRm9jdXMpIHsgdGhpcy5zaG93UHJpbWFyeVNlbGVjdGlvbigpOyB9XG4gICAgdGhpcy5zaG93TXVsdGlwbGVTZWxlY3Rpb25zKGluZm8pO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY20uZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKClcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1ByaW1hcnlTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbSwgcHJpbSA9IGNtLmRvYy5zZWwucHJpbWFyeSgpO1xuICAgIHZhciBmcm9tID0gcHJpbS5mcm9tKCksIHRvID0gcHJpbS50bygpO1xuXG4gICAgaWYgKGNtLmRpc3BsYXkudmlld1RvID09IGNtLmRpc3BsYXkudmlld0Zyb20gfHwgZnJvbS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdGcm9tKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyQW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgY3VyRm9jdXMgPSBkb21Ub1BvcyhjbSwgc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBpZiAoY3VyQW5jaG9yICYmICFjdXJBbmNob3IuYmFkICYmIGN1ckZvY3VzICYmICFjdXJGb2N1cy5iYWQgJiZcbiAgICAgICAgY21wKG1pblBvcyhjdXJBbmNob3IsIGN1ckZvY3VzKSwgZnJvbSkgPT0gMCAmJlxuICAgICAgICBjbXAobWF4UG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCB0bykgPT0gMClcbiAgICAgIHsgcmV0dXJuIH1cblxuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS52aWV3O1xuICAgIHZhciBzdGFydCA9IChmcm9tLmxpbmUgPj0gY20uZGlzcGxheS52aWV3RnJvbSAmJiBwb3NUb0RPTShjbSwgZnJvbSkpIHx8XG4gICAgICAgIHtub2RlOiB2aWV3WzBdLm1lYXN1cmUubWFwWzJdLCBvZmZzZXQ6IDB9O1xuICAgIHZhciBlbmQgPSB0by5saW5lIDwgY20uZGlzcGxheS52aWV3VG8gJiYgcG9zVG9ET00oY20sIHRvKTtcbiAgICBpZiAoIWVuZCkge1xuICAgICAgdmFyIG1lYXN1cmUgPSB2aWV3W3ZpZXcubGVuZ3RoIC0gMV0ubWVhc3VyZTtcbiAgICAgIHZhciBtYXAgPSBtZWFzdXJlLm1hcHMgPyBtZWFzdXJlLm1hcHNbbWVhc3VyZS5tYXBzLmxlbmd0aCAtIDFdIDogbWVhc3VyZS5tYXA7XG4gICAgICBlbmQgPSB7bm9kZTogbWFwW21hcC5sZW5ndGggLSAxXSwgb2Zmc2V0OiBtYXBbbWFwLmxlbmd0aCAtIDJdIC0gbWFwW21hcC5sZW5ndGggLSAzXX07XG4gICAgfVxuXG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgb2xkID0gc2VsLnJhbmdlQ291bnQgJiYgc2VsLmdldFJhbmdlQXQoMCksIHJuZztcbiAgICB0cnkgeyBybmcgPSByYW5nZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQsIGVuZC5vZmZzZXQsIGVuZC5ub2RlKTsgfVxuICAgIGNhdGNoKGUpIHt9IC8vIE91ciBtb2RlbCBvZiB0aGUgRE9NIG1pZ2h0IGJlIG91dGRhdGVkLCBpbiB3aGljaCBjYXNlIHRoZSByYW5nZSB3ZSB0cnkgdG8gc2V0IGNhbiBiZSBpbXBvc3NpYmxlXG4gICAgaWYgKHJuZykge1xuICAgICAgaWYgKCFnZWNrbyAmJiBjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIHNlbC5jb2xsYXBzZShzdGFydC5ub2RlLCBzdGFydC5vZmZzZXQpO1xuICAgICAgICBpZiAoIXJuZy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJuZyk7XG4gICAgICB9XG4gICAgICBpZiAob2xkICYmIHNlbC5hbmNob3JOb2RlID09IG51bGwpIHsgc2VsLmFkZFJhbmdlKG9sZCk7IH1cbiAgICAgIGVsc2UgaWYgKGdlY2tvKSB7IHRoaXMuc3RhcnRHcmFjZVBlcmlvZCgpOyB9XG4gICAgfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3RhcnRHcmFjZVBlcmlvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZ3JhY2VQZXJpb2QpO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5ncmFjZVBlcmlvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMkMS5zZWxlY3Rpb25DaGFuZ2VkKCkpXG4gICAgICAgIHsgdGhpcyQxLmNtLm9wZXJhdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH0pOyB9XG4gICAgfSwgMjApO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93TXVsdGlwbGVTZWxlY3Rpb25zID0gZnVuY3Rpb24gKGluZm8pIHtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZCh0aGlzLmNtLmRpc3BsYXkuY3Vyc29yRGl2LCBpbmZvLmN1cnNvcnMpO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5zZWxlY3Rpb25EaXYsIGluZm8uc2VsZWN0aW9uKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVtZW1iZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy5sYXN0QW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlOyB0aGlzLmxhc3RBbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgIHRoaXMubGFzdEZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7IHRoaXMubGFzdEZvY3VzT2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25JbkVkaXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbC5yYW5nZUNvdW50KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIG5vZGUgPSBzZWwuZ2V0UmFuZ2VBdCgwKS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICByZXR1cm4gY29udGFpbnModGhpcy5kaXYsIG5vZGUpXG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiKSB7XG4gICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uSW5FZGl0b3IoKSB8fCBhY3RpdmVFbHQoKSAhPSB0aGlzLmRpdilcbiAgICAgICAgeyB0aGlzLnNob3dTZWxlY3Rpb24odGhpcy5wcmVwYXJlU2VsZWN0aW9uKCksIHRydWUpOyB9XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuZGl2LmJsdXIoKTsgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXYgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc3VwcG9ydHNUb3VjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzO1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbkluRWRpdG9yKCkpXG4gICAgICB7IHRoaXMucG9sbFNlbGVjdGlvbigpOyB9XG4gICAgZWxzZVxuICAgICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlOyB9KTsgfVxuXG4gICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgIGlmIChpbnB1dC5jbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICAgIGlucHV0LnBvbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgaW5wdXQucG9sbGluZy5zZXQoaW5wdXQuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBvbGxpbmcuc2V0KHRoaXMuY20ub3B0aW9ucy5wb2xsSW50ZXJ2YWwsIHBvbGwpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZWxlY3Rpb25DaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiBzZWwuYW5jaG9yTm9kZSAhPSB0aGlzLmxhc3RBbmNob3JOb2RlIHx8IHNlbC5hbmNob3JPZmZzZXQgIT0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0IHx8XG4gICAgICBzZWwuZm9jdXNOb2RlICE9IHRoaXMubGFzdEZvY3VzTm9kZSB8fCBzZWwuZm9jdXNPZmZzZXQgIT0gdGhpcy5sYXN0Rm9jdXNPZmZzZXRcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucG9sbFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsIHx8IHRoaXMuZ3JhY2VQZXJpb2QgfHwgIXRoaXMuc2VsZWN0aW9uQ2hhbmdlZCgpKSB7IHJldHVybiB9XG4gICAgdmFyIHNlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCksIGNtID0gdGhpcy5jbTtcbiAgICAvLyBPbiBBbmRyb2lkIENocm9tZSAodmVyc2lvbiA1NiwgYXQgbGVhc3QpLCBiYWNrc3BhY2luZyBpbnRvIGFuXG4gICAgLy8gdW5lZGl0YWJsZSBibG9jayBlbGVtZW50IHdpbGwgcHV0IHRoZSBjdXJzb3IgaW4gdGhhdCBlbGVtZW50LFxuICAgIC8vIGFuZCB0aGVuLCBiZWNhdXNlIGl0J3Mgbm90IGVkaXRhYmxlLCBoaWRlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLlxuICAgIC8vIEJlY2F1c2UgQW5kcm9pZCBkb2Vzbid0IGFsbG93IHVzIHRvIGFjdHVhbGx5IGRldGVjdCBiYWNrc3BhY2VcbiAgICAvLyBwcmVzc2VzIGluIGEgc2FuZSB3YXksIHRoaXMgY29kZSBjaGVja3MgZm9yIHdoZW4gdGhhdCBoYXBwZW5zXG4gICAgLy8gYW5kIHNpbXVsYXRlcyBhIGJhY2tzcGFjZSBwcmVzcyBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIHRoaXMuY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGggJiYgaXNJbkd1dHRlcihzZWwuYW5jaG9yTm9kZSkpIHtcbiAgICAgIHRoaXMuY20udHJpZ2dlck9uS2V5RG93bih7dHlwZTogXCJrZXlkb3duXCIsIGtleUNvZGU6IDgsIHByZXZlbnREZWZhdWx0OiBNYXRoLmFic30pO1xuICAgICAgdGhpcy5ibHVyKCk7XG4gICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xuICAgIHZhciBhbmNob3IgPSBkb21Ub1BvcyhjbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgIHZhciBoZWFkID0gZG9tVG9Qb3MoY20sIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKGFuY2hvciAmJiBoZWFkKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFNlbGVjdGlvbihjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICBpZiAoYW5jaG9yLmJhZCB8fCBoZWFkLmJhZCkgeyBjbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfVxuICAgIH0pOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnBvbGxDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnJlYWRET01UaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlYWRET01UaW1lb3V0KTtcbiAgICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBzZWwgPSBjbS5kb2Muc2VsLnByaW1hcnkoKTtcbiAgICB2YXIgZnJvbSA9IHNlbC5mcm9tKCksIHRvID0gc2VsLnRvKCk7XG4gICAgaWYgKGZyb20uY2ggPT0gMCAmJiBmcm9tLmxpbmUgPiBjbS5maXJzdExpbmUoKSlcbiAgICAgIHsgZnJvbSA9IFBvcyhmcm9tLmxpbmUgLSAxLCBnZXRMaW5lKGNtLmRvYywgZnJvbS5saW5lIC0gMSkubGVuZ3RoKTsgfVxuICAgIGlmICh0by5jaCA9PSBnZXRMaW5lKGNtLmRvYywgdG8ubGluZSkudGV4dC5sZW5ndGggJiYgdG8ubGluZSA8IGNtLmxhc3RMaW5lKCkpXG4gICAgICB7IHRvID0gUG9zKHRvLmxpbmUgKyAxLCAwKTsgfVxuICAgIGlmIChmcm9tLmxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IHRvLmxpbmUgPiBkaXNwbGF5LnZpZXdUbyAtIDEpIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHZhciBmcm9tSW5kZXgsIGZyb21MaW5lLCBmcm9tTm9kZTtcbiAgICBpZiAoZnJvbS5saW5lID09IGRpc3BsYXkudmlld0Zyb20gfHwgKGZyb21JbmRleCA9IGZpbmRWaWV3SW5kZXgoY20sIGZyb20ubGluZSkpID09IDApIHtcbiAgICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1swXS5saW5lKTtcbiAgICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3WzBdLm5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21MaW5lID0gbGluZU5vKGRpc3BsYXkudmlld1tmcm9tSW5kZXhdLmxpbmUpO1xuICAgICAgZnJvbU5vZGUgPSBkaXNwbGF5LnZpZXdbZnJvbUluZGV4IC0gMV0ubm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgdmFyIHRvSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCB0by5saW5lKTtcbiAgICB2YXIgdG9MaW5lLCB0b05vZGU7XG4gICAgaWYgKHRvSW5kZXggPT0gZGlzcGxheS52aWV3Lmxlbmd0aCAtIDEpIHtcbiAgICAgIHRvTGluZSA9IGRpc3BsYXkudmlld1RvIC0gMTtcbiAgICAgIHRvTm9kZSA9IGRpc3BsYXkubGluZURpdi5sYXN0Q2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLmxpbmUpIC0gMTtcbiAgICAgIHRvTm9kZSA9IGRpc3BsYXkudmlld1t0b0luZGV4ICsgMV0ubm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKCFmcm9tTm9kZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBuZXdUZXh0ID0gY20uZG9jLnNwbGl0TGluZXMoZG9tVGV4dEJldHdlZW4oY20sIGZyb21Ob2RlLCB0b05vZGUsIGZyb21MaW5lLCB0b0xpbmUpKTtcbiAgICB2YXIgb2xkVGV4dCA9IGdldEJldHdlZW4oY20uZG9jLCBQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lLCBnZXRMaW5lKGNtLmRvYywgdG9MaW5lKS50ZXh0Lmxlbmd0aCkpO1xuICAgIHdoaWxlIChuZXdUZXh0Lmxlbmd0aCA+IDEgJiYgb2xkVGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAobHN0KG5ld1RleHQpID09IGxzdChvbGRUZXh0KSkgeyBuZXdUZXh0LnBvcCgpOyBvbGRUZXh0LnBvcCgpOyB0b0xpbmUtLTsgfVxuICAgICAgZWxzZSBpZiAobmV3VGV4dFswXSA9PSBvbGRUZXh0WzBdKSB7IG5ld1RleHQuc2hpZnQoKTsgb2xkVGV4dC5zaGlmdCgpOyBmcm9tTGluZSsrOyB9XG4gICAgICBlbHNlIHsgYnJlYWsgfVxuICAgIH1cblxuICAgIHZhciBjdXRGcm9udCA9IDAsIGN1dEVuZCA9IDA7XG4gICAgdmFyIG5ld1RvcCA9IG5ld1RleHRbMF0sIG9sZFRvcCA9IG9sZFRleHRbMF0sIG1heEN1dEZyb250ID0gTWF0aC5taW4obmV3VG9wLmxlbmd0aCwgb2xkVG9wLmxlbmd0aCk7XG4gICAgd2hpbGUgKGN1dEZyb250IDwgbWF4Q3V0RnJvbnQgJiYgbmV3VG9wLmNoYXJDb2RlQXQoY3V0RnJvbnQpID09IG9sZFRvcC5jaGFyQ29kZUF0KGN1dEZyb250KSlcbiAgICAgIHsgKytjdXRGcm9udDsgfVxuICAgIHZhciBuZXdCb3QgPSBsc3QobmV3VGV4dCksIG9sZEJvdCA9IGxzdChvbGRUZXh0KTtcbiAgICB2YXIgbWF4Q3V0RW5kID0gTWF0aC5taW4obmV3Qm90Lmxlbmd0aCAtIChuZXdUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkQm90Lmxlbmd0aCAtIChvbGRUZXh0Lmxlbmd0aCA9PSAxID8gY3V0RnJvbnQgOiAwKSk7XG4gICAgd2hpbGUgKGN1dEVuZCA8IG1heEN1dEVuZCAmJlxuICAgICAgICAgICBuZXdCb3QuY2hhckNvZGVBdChuZXdCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkgPT0gb2xkQm90LmNoYXJDb2RlQXQob2xkQm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpKVxuICAgICAgeyArK2N1dEVuZDsgfVxuICAgIC8vIFRyeSB0byBtb3ZlIHN0YXJ0IG9mIGNoYW5nZSB0byBzdGFydCBvZiBzZWxlY3Rpb24gaWYgYW1iaWd1b3VzXG4gICAgaWYgKG5ld1RleHQubGVuZ3RoID09IDEgJiYgb2xkVGV4dC5sZW5ndGggPT0gMSAmJiBmcm9tTGluZSA9PSBmcm9tLmxpbmUpIHtcbiAgICAgIHdoaWxlIChjdXRGcm9udCAmJiBjdXRGcm9udCA+IGZyb20uY2ggJiZcbiAgICAgICAgICAgICBuZXdCb3QuY2hhckNvZGVBdChuZXdCb3QubGVuZ3RoIC0gY3V0RW5kIC0gMSkgPT0gb2xkQm90LmNoYXJDb2RlQXQob2xkQm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpKSB7XG4gICAgICAgIGN1dEZyb250LS07XG4gICAgICAgIGN1dEVuZCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1RleHRbbmV3VGV4dC5sZW5ndGggLSAxXSA9IG5ld0JvdC5zbGljZSgwLCBuZXdCb3QubGVuZ3RoIC0gY3V0RW5kKS5yZXBsYWNlKC9eXFx1MjAwYisvLCBcIlwiKTtcbiAgICBuZXdUZXh0WzBdID0gbmV3VGV4dFswXS5zbGljZShjdXRGcm9udCkucmVwbGFjZSgvXFx1MjAwYiskLywgXCJcIik7XG5cbiAgICB2YXIgY2hGcm9tID0gUG9zKGZyb21MaW5lLCBjdXRGcm9udCk7XG4gICAgdmFyIGNoVG8gPSBQb3ModG9MaW5lLCBvbGRUZXh0Lmxlbmd0aCA/IGxzdChvbGRUZXh0KS5sZW5ndGggLSBjdXRFbmQgOiAwKTtcbiAgICBpZiAobmV3VGV4dC5sZW5ndGggPiAxIHx8IG5ld1RleHRbMF0gfHwgY21wKGNoRnJvbSwgY2hUbykpIHtcbiAgICAgIHJlcGxhY2VSYW5nZShjbS5kb2MsIG5ld1RleHQsIGNoRnJvbSwgY2hUbywgXCIraW5wdXRcIik7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZW5zdXJlUG9sbGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mb3JjZUNvbXBvc2l0aW9uRW5kKCk7XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5mb3JjZUNvbXBvc2l0aW9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCk7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgIHRoaXMudXBkYXRlRnJvbURPTSgpO1xuICAgIHRoaXMuZGl2LmJsdXIoKTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZEZyb21ET01Tb29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7IHJldHVybiB9XG4gICAgdGhpcy5yZWFkRE9NVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nKSB7XG4gICAgICAgIGlmICh0aGlzJDEuY29tcG9zaW5nLmRvbmUpIHsgdGhpcyQxLmNvbXBvc2luZyA9IG51bGw7IH1cbiAgICAgICAgZWxzZSB7IHJldHVybiB9XG4gICAgICB9XG4gICAgICB0aGlzJDEudXBkYXRlRnJvbURPTSgpO1xuICAgIH0sIDgwKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUudXBkYXRlRnJvbURPTSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuY20uaXNSZWFkT25seSgpIHx8ICF0aGlzLnBvbGxDb250ZW50KCkpXG4gICAgICB7IHJ1bkluT3AodGhpcy5jbSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVnQ2hhbmdlKHRoaXMkMS5jbSk7IH0pOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNldFVuZWRpdGFibGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS5jaGFyQ29kZSA9PSAwIHx8IHRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5jbS5pc1JlYWRPbmx5KCkpXG4gICAgICB7IG9wZXJhdGlvbih0aGlzLmNtLCBhcHBseVRleHRJbnB1dCkodGhpcy5jbSwgU3RyaW5nLmZyb21DaGFyQ29kZShlLmNoYXJDb2RlID09IG51bGwgPyBlLmtleUNvZGUgOiBlLmNoYXJDb2RlKSwgMCk7IH1cbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMuZGl2LmNvbnRlbnRFZGl0YWJsZSA9IFN0cmluZyh2YWwgIT0gXCJub2N1cnNvclwiKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25Db250ZXh0TWVudSA9IGZ1bmN0aW9uICgpIHt9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUucmVzZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5uZWVkc0NvbnRlbnRBdHRyaWJ1dGUgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHBvc1RvRE9NKGNtLCBwb3MpIHtcbiAgICB2YXIgdmlldyA9IGZpbmRWaWV3Rm9yTGluZShjbSwgcG9zLmxpbmUpO1xuICAgIGlmICghdmlldyB8fCB2aWV3LmhpZGRlbikgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xuICAgIHZhciBpbmZvID0gbWFwRnJvbUxpbmVWaWV3KHZpZXcsIGxpbmUsIHBvcy5saW5lKTtcblxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pLCBzaWRlID0gXCJsZWZ0XCI7XG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIHBvcy5jaCk7XG4gICAgICBzaWRlID0gcGFydFBvcyAlIDIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAoaW5mby5tYXAsIHBvcy5jaCwgc2lkZSk7XG4gICAgcmVzdWx0Lm9mZnNldCA9IHJlc3VsdC5jb2xsYXBzZSA9PSBcInJpZ2h0XCIgPyByZXN1bHQuZW5kIDogcmVzdWx0LnN0YXJ0O1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5HdXR0ZXIobm9kZSkge1xuICAgIGZvciAodmFyIHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gc2Nhbi5wYXJlbnROb2RlKVxuICAgICAgeyBpZiAoL0NvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXIvLnRlc3Qoc2Nhbi5jbGFzc05hbWUpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYmFkUG9zKHBvcywgYmFkKSB7IGlmIChiYWQpIHsgcG9zLmJhZCA9IHRydWU7IH0gcmV0dXJuIHBvcyB9XG5cbiAgZnVuY3Rpb24gZG9tVGV4dEJldHdlZW4oY20sIGZyb20sIHRvLCBmcm9tTGluZSwgdG9MaW5lKSB7XG4gICAgdmFyIHRleHQgPSBcIlwiLCBjbG9zaW5nID0gZmFsc2UsIGxpbmVTZXAgPSBjbS5kb2MubGluZVNlcGFyYXRvcigpLCBleHRyYUxpbmVicmVhayA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHJlY29nbml6ZU1hcmtlcihpZCkgeyByZXR1cm4gZnVuY3Rpb24gKG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmlkID09IGlkOyB9IH1cbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmIChjbG9zaW5nKSB7XG4gICAgICAgIHRleHQgKz0gbGluZVNlcDtcbiAgICAgICAgaWYgKGV4dHJhTGluZWJyZWFrKSB7IHRleHQgKz0gbGluZVNlcDsgfVxuICAgICAgICBjbG9zaW5nID0gZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVGV4dChzdHIpIHtcbiAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgdGV4dCArPSBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICB2YXIgY21UZXh0ID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIpO1xuICAgICAgICBpZiAoY21UZXh0KSB7XG4gICAgICAgICAgYWRkVGV4dChjbVRleHQpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXJJRCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIpLCByYW5nZTtcbiAgICAgICAgaWYgKG1hcmtlcklEKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gY20uZmluZE1hcmtzKFBvcyhmcm9tTGluZSwgMCksIFBvcyh0b0xpbmUgKyAxLCAwKSwgcmVjb2duaXplTWFya2VyKCttYXJrZXJJRCkpO1xuICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGggJiYgKHJhbmdlID0gZm91bmRbMF0uZmluZCgwKSkpXG4gICAgICAgICAgICB7IGFkZFRleHQoZ2V0QmV0d2VlbihjbS5kb2MsIHJhbmdlLmZyb20sIHJhbmdlLnRvKS5qb2luKGxpbmVTZXApKTsgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSA9PSBcImZhbHNlXCIpIHsgcmV0dXJuIH1cbiAgICAgICAgdmFyIGlzQmxvY2sgPSAvXihwcmV8ZGl2fHB8bGl8dGFibGV8YnIpJC9pLnRlc3Qobm9kZS5ub2RlTmFtZSk7XG4gICAgICAgIGlmICghL15iciQvaS50ZXN0KG5vZGUubm9kZU5hbWUpICYmIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoID09IDApIHsgcmV0dXJuIH1cblxuICAgICAgICBpZiAoaXNCbG9jaykgeyBjbG9zZSgpOyB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHsgd2Fsayhub2RlLmNoaWxkTm9kZXNbaV0pOyB9XG5cbiAgICAgICAgaWYgKC9eKHByZXxwKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpKSB7IGV4dHJhTGluZWJyZWFrID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoaXNCbG9jaykgeyBjbG9zaW5nID0gdHJ1ZTsgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgYWRkVGV4dChub2RlLm5vZGVWYWx1ZS5yZXBsYWNlKC9cXHUyMDBiL2csIFwiXCIpLnJlcGxhY2UoL1xcdTAwYTAvZywgXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgd2Fsayhmcm9tKTtcbiAgICAgIGlmIChmcm9tID09IHRvKSB7IGJyZWFrIH1cbiAgICAgIGZyb20gPSBmcm9tLm5leHRTaWJsaW5nO1xuICAgICAgZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvbVRvUG9zKGNtLCBub2RlLCBvZmZzZXQpIHtcbiAgICB2YXIgbGluZU5vZGU7XG4gICAgaWYgKG5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7XG4gICAgICBsaW5lTm9kZSA9IGNtLmRpc3BsYXkubGluZURpdi5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICBpZiAoIWxpbmVOb2RlKSB7IHJldHVybiBiYWRQb3MoY20uY2xpcFBvcyhQb3MoY20uZGlzcGxheS52aWV3VG8gLSAxKSksIHRydWUpIH1cbiAgICAgIG5vZGUgPSBudWxsOyBvZmZzZXQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxpbmVOb2RlID0gbm9kZTs7IGxpbmVOb2RlID0gbGluZU5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoIWxpbmVOb2RlIHx8IGxpbmVOb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIGlmIChsaW5lTm9kZS5wYXJlbnROb2RlICYmIGxpbmVOb2RlLnBhcmVudE5vZGUgPT0gY20uZGlzcGxheS5saW5lRGl2KSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lVmlldyA9IGNtLmRpc3BsYXkudmlld1tpXTtcbiAgICAgIGlmIChsaW5lVmlldy5ub2RlID09IGxpbmVOb2RlKVxuICAgICAgICB7IHJldHVybiBsb2NhdGVOb2RlSW5MaW5lVmlldyhsaW5lVmlldywgbm9kZSwgb2Zmc2V0KSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIHZhciB3cmFwcGVyID0gbGluZVZpZXcudGV4dC5maXJzdENoaWxkLCBiYWQgPSBmYWxzZTtcbiAgICBpZiAoIW5vZGUgfHwgIWNvbnRhaW5zKHdyYXBwZXIsIG5vZGUpKSB7IHJldHVybiBiYWRQb3MoUG9zKGxpbmVObyhsaW5lVmlldy5saW5lKSwgMCksIHRydWUpIH1cbiAgICBpZiAobm9kZSA9PSB3cmFwcGVyKSB7XG4gICAgICBiYWQgPSB0cnVlO1xuICAgICAgbm9kZSA9IHdyYXBwZXIuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVWaWV3LnJlc3QgPyBsc3QobGluZVZpZXcucmVzdCkgOiBsaW5lVmlldy5saW5lO1xuICAgICAgICByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZSksIGxpbmUudGV4dC5sZW5ndGgpLCBiYWQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZSA6IG51bGwsIHRvcE5vZGUgPSBub2RlO1xuICAgIGlmICghdGV4dE5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxICYmIG5vZGUuZmlyc3RDaGlsZC5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChvZmZzZXQpIHsgb2Zmc2V0ID0gdGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aDsgfVxuICAgIH1cbiAgICB3aGlsZSAodG9wTm9kZS5wYXJlbnROb2RlICE9IHdyYXBwZXIpIHsgdG9wTm9kZSA9IHRvcE5vZGUucGFyZW50Tm9kZTsgfVxuICAgIHZhciBtZWFzdXJlID0gbGluZVZpZXcubWVhc3VyZSwgbWFwcyA9IG1lYXN1cmUubWFwcztcblxuICAgIGZ1bmN0aW9uIGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IC0xOyBpIDwgKG1hcHMgPyBtYXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgdmFyIG1hcCA9IGkgPCAwID8gbWVhc3VyZS5tYXAgOiBtYXBzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMykge1xuICAgICAgICAgIHZhciBjdXJOb2RlID0gbWFwW2ogKyAyXTtcbiAgICAgICAgICBpZiAoY3VyTm9kZSA9PSB0ZXh0Tm9kZSB8fCBjdXJOb2RlID09IHRvcE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gbGluZU5vKGkgPCAwID8gbGluZVZpZXcubGluZSA6IGxpbmVWaWV3LnJlc3RbaV0pO1xuICAgICAgICAgICAgdmFyIGNoID0gbWFwW2pdICsgb2Zmc2V0O1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgfHwgY3VyTm9kZSAhPSB0ZXh0Tm9kZSkgeyBjaCA9IG1hcFtqICsgKG9mZnNldCA/IDEgOiAwKV07IH1cbiAgICAgICAgICAgIHJldHVybiBQb3MobGluZSwgY2gpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBmb3VuZCA9IGZpbmQodGV4dE5vZGUsIHRvcE5vZGUsIG9mZnNldCk7XG4gICAgaWYgKGZvdW5kKSB7IHJldHVybiBiYWRQb3MoZm91bmQsIGJhZCkgfVxuXG4gICAgLy8gRklYTUUgdGhpcyBpcyBhbGwgcmVhbGx5IHNoYWt5LiBtaWdodCBoYW5kbGUgdGhlIGZldyBjYXNlcyBpdCBuZWVkcyB0byBoYW5kbGUsIGJ1dCBsaWtlbHkgdG8gY2F1c2UgcHJvYmxlbXNcbiAgICBmb3IgKHZhciBhZnRlciA9IHRvcE5vZGUubmV4dFNpYmxpbmcsIGRpc3QgPSB0ZXh0Tm9kZSA/IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSBvZmZzZXQgOiAwOyBhZnRlcjsgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZykge1xuICAgICAgZm91bmQgPSBmaW5kKGFmdGVyLCBhZnRlci5maXJzdENoaWxkLCAwKTtcbiAgICAgIGlmIChmb3VuZClcbiAgICAgICAgeyByZXR1cm4gYmFkUG9zKFBvcyhmb3VuZC5saW5lLCBmb3VuZC5jaCAtIGRpc3QpLCBiYWQpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBkaXN0ICs9IGFmdGVyLnRleHRDb250ZW50Lmxlbmd0aDsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBiZWZvcmUgPSB0b3BOb2RlLnByZXZpb3VzU2libGluZywgZGlzdCQxID0gb2Zmc2V0OyBiZWZvcmU7IGJlZm9yZSA9IGJlZm9yZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIGZvdW5kID0gZmluZChiZWZvcmUsIGJlZm9yZS5maXJzdENoaWxkLCAtMSk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIHsgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggKyBkaXN0JDEpLCBiYWQpIH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyBkaXN0JDEgKz0gYmVmb3JlLnRleHRDb250ZW50Lmxlbmd0aDsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRFWFRBUkVBIElOUFVUIFNUWUxFXG5cbiAgdmFyIFRleHRhcmVhSW5wdXQgPSBmdW5jdGlvbihjbSkge1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICAvLyBTZWUgaW5wdXQucG9sbCBhbmQgaW5wdXQucmVzZXRcbiAgICB0aGlzLnByZXZJbnB1dCA9IFwiXCI7XG5cbiAgICAvLyBGbGFnIHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgd2UgZXhwZWN0IGlucHV0IHRvIGFwcGVhciByZWFsIHNvb25cbiAgICAvLyBub3cgKGFmdGVyIHNvbWUgZXZlbnQgbGlrZSAna2V5cHJlc3MnIG9yICdpbnB1dCcpIGFuZCBhcmVcbiAgICAvLyBwb2xsaW5nIGludGVuc2l2ZWx5LlxuICAgIHRoaXMucG9sbGluZ0Zhc3QgPSBmYWxzZTtcbiAgICAvLyBTZWxmLXJlc2V0dGluZyB0aW1lb3V0IGZvciB0aGUgcG9sbGVyXG4gICAgdGhpcy5wb2xsaW5nID0gbmV3IERlbGF5ZWQoKTtcbiAgICAvLyBVc2VkIHRvIHdvcmsgYXJvdW5kIElFIGlzc3VlIHdpdGggc2VsZWN0aW9uIGJlaW5nIGZvcmdvdHRlbiB3aGVuIGZvY3VzIG1vdmVzIGF3YXkgZnJvbSB0ZXh0YXJlYVxuICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGlzcGxheSkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IHRoaXMuY207XG4gICAgdGhpcy5jcmVhdGVGaWVsZChkaXNwbGF5KTtcbiAgICB2YXIgdGUgPSB0aGlzLnRleHRhcmVhO1xuXG4gICAgZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZSh0aGlzLndyYXBwZXIsIGRpc3BsYXkud3JhcHBlci5maXJzdENoaWxkKTtcblxuICAgIC8vIE5lZWRlZCB0byBoaWRlIGJpZyBibHVlIGJsaW5raW5nIGN1cnNvciBvbiBNb2JpbGUgU2FmYXJpIChkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBpT1MgOCBhbnltb3JlKVxuICAgIGlmIChpb3MpIHsgdGUuc3R5bGUud2lkdGggPSBcIjBweFwiOyB9XG5cbiAgICBvbih0ZSwgXCJpbnB1dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMkMS5oYXNTZWxlY3Rpb24pIHsgdGhpcyQxLmhhc1NlbGVjdGlvbiA9IG51bGw7IH1cbiAgICAgIGlucHV0LnBvbGwoKTtcbiAgICB9KTtcblxuICAgIG9uKHRlLCBcInBhc3RlXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxuXG4gICAgICBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID0gK25ldyBEYXRlO1xuICAgICAgaW5wdXQuZmFzdFBvbGwoKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb3B5Q3V0KGUpIHtcbiAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiBmYWxzZSwgdGV4dDogY20uZ2V0U2VsZWN0aW9ucygpfSk7XG4gICAgICB9IGVsc2UgaWYgKCFjbS5vcHRpb25zLmxpbmVXaXNlQ29weUN1dCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBjb3B5YWJsZVJhbmdlcyhjbSk7XG4gICAgICAgIHNldExhc3RDb3BpZWQoe2xpbmVXaXNlOiB0cnVlLCB0ZXh0OiByYW5nZXMudGV4dH0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHtcbiAgICAgICAgICBjbS5zZXRTZWxlY3Rpb25zKHJhbmdlcy5yYW5nZXMsIG51bGwsIHNlbF9kb250U2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBcIlwiO1xuICAgICAgICAgIHRlLnZhbHVlID0gcmFuZ2VzLnRleHQuam9pbihcIlxcblwiKTtcbiAgICAgICAgICBzZWxlY3RJbnB1dCh0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlLnR5cGUgPT0gXCJjdXRcIikgeyBjbS5zdGF0ZS5jdXRJbmNvbWluZyA9ICtuZXcgRGF0ZTsgfVxuICAgIH1cbiAgICBvbih0ZSwgXCJjdXRcIiwgcHJlcGFyZUNvcHlDdXQpO1xuICAgIG9uKHRlLCBcImNvcHlcIiwgcHJlcGFyZUNvcHlDdXQpO1xuXG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoIXRlLmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9ICtuZXcgRGF0ZTtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhlIGBwYXN0ZWAgZXZlbnQgdG8gdGhlIHRleHRhcmVhIHNvIGl0J3MgaGFuZGxlZCBieSBpdHMgZXZlbnQgbGlzdGVuZXIuXG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoXCJwYXN0ZVwiKTtcbiAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEgPSBlLmNsaXBib2FyZERhdGE7XG4gICAgICB0ZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9KTtcblxuICAgIC8vIFByZXZlbnQgbm9ybWFsIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yICh3ZSBoYW5kbGUgb3VyIG93bilcbiAgICBvbihkaXNwbGF5LmxpbmVTcGFjZSwgXCJzZWxlY3RzdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKCFldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpKSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICB9KTtcblxuICAgIG9uKHRlLCBcImNvbXBvc2l0aW9uc3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gY20uZ2V0Q3Vyc29yKFwiZnJvbVwiKTtcbiAgICAgIGlmIChpbnB1dC5jb21wb3NpbmcpIHsgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7IH1cbiAgICAgIGlucHV0LmNvbXBvc2luZyA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICByYW5nZTogY20ubWFya1RleHQoc3RhcnQsIGNtLmdldEN1cnNvcihcInRvXCIpLCB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBvbih0ZSwgXCJjb21wb3NpdGlvbmVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7XG4gICAgICAgIGlucHV0LnBvbGwoKTtcbiAgICAgICAgaW5wdXQuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgIGlucHV0LmNvbXBvc2luZyA9IG51bGw7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuY3JlYXRlRmllbGQgPSBmdW5jdGlvbiAoX2Rpc3BsYXkpIHtcbiAgICAvLyBXcmFwcyBhbmQgaGlkZXMgaW5wdXQgdGV4dGFyZWFcbiAgICB0aGlzLndyYXBwZXIgPSBoaWRkZW5UZXh0YXJlYSgpO1xuICAgIC8vIFRoZSBzZW1paGlkZGVuIHRleHRhcmVhIHRoYXQgaXMgZm9jdXNlZCB3aGVuIHRoZSBlZGl0b3IgaXNcbiAgICAvLyBmb2N1c2VkLCBhbmQgcmVjZWl2ZXMgaW5wdXQuXG4gICAgdGhpcy50ZXh0YXJlYSA9IHRoaXMud3JhcHBlci5maXJzdENoaWxkO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIC8vIExhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYobGFiZWwpIHtcbiAgICAgIHRoaXMudGV4dGFyZWEuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgbGFiZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlZHJhdyB0aGUgc2VsZWN0aW9uIGFuZC9vciBjdXJzb3JcbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKGNtKTtcblxuICAgIC8vIE1vdmUgdGhlIGhpZGRlbiB0ZXh0YXJlYSBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCBzY3JvbGxpbmcgYXJ0aWZhY3RzXG4gICAgaWYgKGNtLm9wdGlvbnMubW92ZUlucHV0V2l0aEN1cnNvcikge1xuICAgICAgdmFyIGhlYWRQb3MgPSBjdXJzb3JDb29yZHMoY20sIGRvYy5zZWwucHJpbWFyeSgpLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgdmFyIHdyYXBPZmYgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGxpbmVPZmYgPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICByZXN1bHQudGVUb3AgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0IC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLnRvcCArIGxpbmVPZmYudG9wIC0gd3JhcE9mZi50b3ApKTtcbiAgICAgIHJlc3VsdC50ZUxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihkaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggLSAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkUG9zLmxlZnQgKyBsaW5lT2ZmLmxlZnQgLSB3cmFwT2ZmLmxlZnQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbiA9IGZ1bmN0aW9uIChkcmF3bikge1xuICAgIHZhciBjbSA9IHRoaXMuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkuY3Vyc29yRGl2LCBkcmF3bi5jdXJzb3JzKTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LnNlbGVjdGlvbkRpdiwgZHJhd24uc2VsZWN0aW9uKTtcbiAgICBpZiAoZHJhd24udGVUb3AgIT0gbnVsbCkge1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IGRyYXduLnRlVG9wICsgXCJweFwiO1xuICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLmxlZnQgPSBkcmF3bi50ZUxlZnQgKyBcInB4XCI7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlc2V0IHRoZSBpbnB1dCB0byBjb3JyZXNwb25kIHRvIHRoZSBzZWxlY3Rpb24gKG9yIHRvIGJlIGVtcHR5LFxuICAvLyB3aGVuIG5vdCB0eXBpbmcgYW5kIG5vdGhpbmcgaXMgc2VsZWN0ZWQpXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHR5cGluZykge1xuICAgIGlmICh0aGlzLmNvbnRleHRNZW51UGVuZGluZyB8fCB0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIHZhciBjbSA9IHRoaXMuY207XG4gICAgaWYgKGNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHtcbiAgICAgIHRoaXMucHJldklucHV0ID0gXCJcIjtcbiAgICAgIHZhciBjb250ZW50ID0gY20uZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLnRleHRhcmVhLnZhbHVlID0gY29udGVudDtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IHNlbGVjdElucHV0KHRoaXMudGV4dGFyZWEpOyB9XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gY29udGVudDsgfVxuICAgIH0gZWxzZSBpZiAoIXR5cGluZykge1xuICAgICAgdGhpcy5wcmV2SW5wdXQgPSB0aGlzLnRleHRhcmVhLnZhbHVlID0gXCJcIjtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmdldEZpZWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy50ZXh0YXJlYSB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnN1cHBvcnRzVG91Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZSB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNtLm9wdGlvbnMucmVhZE9ubHkgIT0gXCJub2N1cnNvclwiICYmICghbW9iaWxlIHx8IGFjdGl2ZUVsdCgpICE9IHRoaXMudGV4dGFyZWEpKSB7XG4gICAgICB0cnkgeyB0aGlzLnRleHRhcmVhLmZvY3VzKCk7IH1cbiAgICAgIGNhdGNoIChlKSB7fSAvLyBJRTggd2lsbCB0aHJvdyBpZiB0aGUgdGV4dGFyZWEgaXMgZGlzcGxheTogbm9uZSBvciBub3QgaW4gRE9NXG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMudGV4dGFyZWEuYmx1cigpOyB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy53cmFwcGVyLnN0eWxlLnRvcCA9IHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gMDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZWNlaXZlZEZvY3VzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnNsb3dQb2xsKCk7IH07XG5cbiAgLy8gUG9sbCBmb3IgaW5wdXQgY2hhbmdlcywgdXNpbmcgdGhlIG5vcm1hbCByYXRlIG9mIHBvbGxpbmcuIFRoaXNcbiAgLy8gcnVucyBhcyBsb25nIGFzIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2xvd1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLnBvbGxpbmdGYXN0KSB7IHJldHVybiB9XG4gICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEucG9sbCgpO1xuICAgICAgaWYgKHRoaXMkMS5jbS5zdGF0ZS5mb2N1c2VkKSB7IHRoaXMkMS5zbG93UG9sbCgpOyB9XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gV2hlbiBhbiBldmVudCBoYXMganVzdCBjb21lIGluIHRoYXQgaXMgbGlrZWx5IHRvIGFkZCBvciBjaGFuZ2VcbiAgLy8gc29tZXRoaW5nIGluIHRoZSBpbnB1dCB0ZXh0YXJlYSwgd2UgcG9sbCBmYXN0ZXIsIHRvIGVuc3VyZSB0aGF0XG4gIC8vIHRoZSBjaGFuZ2UgYXBwZWFycyBvbiB0aGUgc2NyZWVuIHF1aWNrbHkuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmZhc3RQb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtaXNzZWQgPSBmYWxzZSwgaW5wdXQgPSB0aGlzO1xuICAgIGlucHV0LnBvbGxpbmdGYXN0ID0gdHJ1ZTtcbiAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgdmFyIGNoYW5nZWQgPSBpbnB1dC5wb2xsKCk7XG4gICAgICBpZiAoIWNoYW5nZWQgJiYgIW1pc3NlZCkge21pc3NlZCA9IHRydWU7IGlucHV0LnBvbGxpbmcuc2V0KDYwLCBwKTt9XG4gICAgICBlbHNlIHtpbnB1dC5wb2xsaW5nRmFzdCA9IGZhbHNlOyBpbnB1dC5zbG93UG9sbCgpO31cbiAgICB9XG4gICAgaW5wdXQucG9sbGluZy5zZXQoMjAsIHApO1xuICB9O1xuXG4gIC8vIFJlYWQgaW5wdXQgZnJvbSB0aGUgdGV4dGFyZWEsIGFuZCB1cGRhdGUgdGhlIGRvY3VtZW50IHRvIG1hdGNoLlxuICAvLyBXaGVuIHNvbWV0aGluZyBpcyBzZWxlY3RlZCwgaXQgaXMgcHJlc2VudCBpbiB0aGUgdGV4dGFyZWEsIGFuZFxuICAvLyBzZWxlY3RlZCAodW5sZXNzIGl0IGlzIGh1Z2UsIGluIHdoaWNoIGNhc2UgYSBwbGFjZWhvbGRlciBpc1xuICAvLyB1c2VkKS4gV2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGUgY3Vyc29yIHNpdHMgYWZ0ZXIgcHJldmlvdXNseVxuICAvLyBzZWVuIHRleHQgKGNhbiBiZSBlbXB0eSksIHdoaWNoIGlzIHN0b3JlZCBpbiBwcmV2SW5wdXQgKHdlIG11c3RcbiAgLy8gbm90IHJlc2V0IHRoZSB0ZXh0YXJlYSB3aGVuIHR5cGluZywgYmVjYXVzZSB0aGF0IGJyZWFrcyBJTUUpLlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY20gPSB0aGlzLmNtLCBpbnB1dCA9IHRoaXMudGV4dGFyZWEsIHByZXZJbnB1dCA9IHRoaXMucHJldklucHV0O1xuICAgIC8vIFNpbmNlIHRoaXMgaXMgY2FsbGVkIGEgKmxvdCosIHRyeSB0byBiYWlsIG91dCBhcyBjaGVhcGx5IGFzXG4gICAgLy8gcG9zc2libGUgd2hlbiBpdCBpcyBjbGVhciB0aGF0IG5vdGhpbmcgaGFwcGVuZWQuIGhhc1NlbGVjdGlvblxuICAgIC8vIHdpbGwgYmUgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBhIGxvdCBvZiB0ZXh0IGluIHRoZSB0ZXh0YXJlYSxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHJlYWRpbmcgaXRzIHZhbHVlIHdvdWxkIGJlIGV4cGVuc2l2ZS5cbiAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgIWNtLnN0YXRlLmZvY3VzZWQgfHxcbiAgICAgICAgKGhhc1NlbGVjdGlvbihpbnB1dCkgJiYgIXByZXZJbnB1dCAmJiAhdGhpcy5jb21wb3NpbmcpIHx8XG4gICAgICAgIGNtLmlzUmVhZE9ubHkoKSB8fCBjbS5vcHRpb25zLmRpc2FibGVJbnB1dCB8fCBjbS5zdGF0ZS5rZXlTZXEpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG5cbiAgICB2YXIgdGV4dCA9IGlucHV0LnZhbHVlO1xuICAgIC8vIElmIG5vdGhpbmcgY2hhbmdlZCwgYmFpbC5cbiAgICBpZiAodGV4dCA9PSBwcmV2SW5wdXQgJiYgIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBXb3JrIGFyb3VuZCBub25zZW5zaWNhbCBzZWxlY3Rpb24gcmVzZXR0aW5nIGluIElFOS8xMCwgYW5kXG4gICAgLy8gaW5leHBsaWNhYmxlIGFwcGVhcmFuY2Ugb2YgcHJpdmF0ZSBhcmVhIHVuaWNvZGUgY2hhcmFjdGVycyBvblxuICAgIC8vIHNvbWUga2V5IGNvbWJvcyBpbiBNYWMgKCMyNjg5KS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5ICYmIHRoaXMuaGFzU2VsZWN0aW9uID09PSB0ZXh0IHx8XG4gICAgICAgIG1hYyAmJiAvW1xcdWY3MDAtXFx1ZjdmZl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChjbS5kb2Muc2VsID09IGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUpIHtcbiAgICAgIHZhciBmaXJzdCA9IHRleHQuY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChmaXJzdCA9PSAweDIwMGIgJiYgIXByZXZJbnB1dCkgeyBwcmV2SW5wdXQgPSBcIlxcdTIwMGJcIjsgfVxuICAgICAgaWYgKGZpcnN0ID09IDB4MjFkYSkgeyB0aGlzLnJlc2V0KCk7IHJldHVybiB0aGlzLmNtLmV4ZWNDb21tYW5kKFwidW5kb1wiKSB9XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIHBhcnQgb2YgdGhlIGlucHV0IHRoYXQgaXMgYWN0dWFsbHkgbmV3XG4gICAgdmFyIHNhbWUgPSAwLCBsID0gTWF0aC5taW4ocHJldklucHV0Lmxlbmd0aCwgdGV4dC5sZW5ndGgpO1xuICAgIHdoaWxlIChzYW1lIDwgbCAmJiBwcmV2SW5wdXQuY2hhckNvZGVBdChzYW1lKSA9PSB0ZXh0LmNoYXJDb2RlQXQoc2FtZSkpIHsgKytzYW1lOyB9XG5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseVRleHRJbnB1dChjbSwgdGV4dC5zbGljZShzYW1lKSwgcHJldklucHV0Lmxlbmd0aCAtIHNhbWUsXG4gICAgICAgICAgICAgICAgICAgICBudWxsLCB0aGlzJDEuY29tcG9zaW5nID8gXCIqY29tcG9zZVwiIDogbnVsbCk7XG5cbiAgICAgIC8vIERvbid0IGxlYXZlIGxvbmcgdGV4dCBpbiB0aGUgdGV4dGFyZWEsIHNpbmNlIGl0IG1ha2VzIGZ1cnRoZXIgcG9sbGluZyBzbG93XG4gICAgICBpZiAodGV4dC5sZW5ndGggPiAxMDAwIHx8IHRleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xKSB7IGlucHV0LnZhbHVlID0gdGhpcyQxLnByZXZJbnB1dCA9IFwiXCI7IH1cbiAgICAgIGVsc2UgeyB0aGlzJDEucHJldklucHV0ID0gdGV4dDsgfVxuXG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMkMS5jb21wb3NpbmcucmFuZ2UgPSBjbS5tYXJrVGV4dCh0aGlzJDEuY29tcG9zaW5nLnN0YXJ0LCBjbS5nZXRDdXJzb3IoXCJ0b1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItY29tcG9zaW5nXCJ9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCAmJiB0aGlzLnBvbGwoKSkgeyB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7IH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbktleVByZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgdGhpcy5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgdGhpcy5mYXN0UG9sbCgpO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB0ZSA9IGlucHV0LnRleHRhcmVhO1xuICAgIGlmIChpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcpIHsgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nKCk7IH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKSwgc2Nyb2xsUG9zID0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgaWYgKCFwb3MgfHwgcHJlc3RvKSB7IHJldHVybiB9IC8vIE9wZXJhIGlzIGRpZmZpY3VsdC5cblxuICAgIC8vIFJlc2V0IHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIG9ubHkgaWYgdGhlIGNsaWNrIGlzIGRvbmUgb3V0c2lkZSBvZiB0aGUgc2VsZWN0aW9uXG4gICAgLy8gYW5kICdyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnUnIG9wdGlvbiBpcyB0cnVlLlxuICAgIHZhciByZXNldCA9IGNtLm9wdGlvbnMucmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51O1xuICAgIGlmIChyZXNldCAmJiBjbS5kb2Muc2VsLmNvbnRhaW5zKHBvcykgPT0gLTEpXG4gICAgICB7IG9wZXJhdGlvbihjbSwgc2V0U2VsZWN0aW9uKShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihwb3MpLCBzZWxfZG9udFNjcm9sbCk7IH1cblxuICAgIHZhciBvbGRDU1MgPSB0ZS5zdHlsZS5jc3NUZXh0LCBvbGRXcmFwcGVyQ1NTID0gaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0O1xuICAgIHZhciB3cmFwcGVyQm94ID0gaW5wdXQud3JhcHBlci5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogc3RhdGljXCI7XG4gICAgdGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMzBweDsgaGVpZ2h0OiAzMHB4O1xcbiAgICAgIHRvcDogXCIgKyAoZS5jbGllbnRZIC0gd3JhcHBlckJveC50b3AgLSA1KSArIFwicHg7IGxlZnQ6IFwiICsgKGUuY2xpZW50WCAtIHdyYXBwZXJCb3gubGVmdCAtIDUpICsgXCJweDtcXG4gICAgICB6LWluZGV4OiAxMDAwOyBiYWNrZ3JvdW5kOiBcIiArIChpZSA/IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAuMDUpXCIgOiBcInRyYW5zcGFyZW50XCIpICsgXCI7XFxuICAgICAgb3V0bGluZTogbm9uZTsgYm9yZGVyLXdpZHRoOiAwOyBvdXRsaW5lOiBub25lOyBvdmVyZmxvdzogaGlkZGVuOyBvcGFjaXR5OiAuMDU7IGZpbHRlcjogYWxwaGEob3BhY2l0eT01KTtcIjtcbiAgICB2YXIgb2xkU2Nyb2xsWTtcbiAgICBpZiAod2Via2l0KSB7IG9sZFNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTsgfSAvLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgKCMyNzEyKVxuICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICBpZiAod2Via2l0KSB7IHdpbmRvdy5zY3JvbGxUbyhudWxsLCBvbGRTY3JvbGxZKTsgfVxuICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAvLyBBZGRzIFwiU2VsZWN0IGFsbFwiIHRvIGNvbnRleHQgbWVudSBpbiBGRlxuICAgIGlmICghY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyB0ZS52YWx1ZSA9IGlucHV0LnByZXZJbnB1dCA9IFwiIFwiOyB9XG4gICAgaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nID0gcmVoaWRlO1xuICAgIGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPSBjbS5kb2Muc2VsO1xuICAgIGNsZWFyVGltZW91dChkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCk7XG5cbiAgICAvLyBTZWxlY3QtYWxsIHdpbGwgYmUgZ3JleWVkIG91dCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2VsZWN0LCBzb1xuICAgIC8vIHRoaXMgYWRkcyBhIHplcm8td2lkdGggc3BhY2Ugc28gdGhhdCB3ZSBjYW4gbGF0ZXIgY2hlY2sgd2hldGhlclxuICAgIC8vIGl0IGdvdCBzZWxlY3RlZC5cbiAgICBmdW5jdGlvbiBwcmVwYXJlU2VsZWN0QWxsSGFjaygpIHtcbiAgICAgIGlmICh0ZS5zZWxlY3Rpb25TdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGNtLnNvbWV0aGluZ1NlbGVjdGVkKCk7XG4gICAgICAgIHZhciBleHR2YWwgPSBcIlxcdTIwMGJcIiArIChzZWxlY3RlZCA/IHRlLnZhbHVlIDogXCJcIik7XG4gICAgICAgIHRlLnZhbHVlID0gXCJcXHUyMWRhXCI7IC8vIFVzZWQgdG8gY2F0Y2ggY29udGV4dC1tZW51IHVuZG9cbiAgICAgICAgdGUudmFsdWUgPSBleHR2YWw7XG4gICAgICAgIGlucHV0LnByZXZJbnB1dCA9IHNlbGVjdGVkID8gXCJcIiA6IFwiXFx1MjAwYlwiO1xuICAgICAgICB0ZS5zZWxlY3Rpb25TdGFydCA9IDE7IHRlLnNlbGVjdGlvbkVuZCA9IGV4dHZhbC5sZW5ndGg7XG4gICAgICAgIC8vIFJlLXNldCB0aGlzLCBpbiBjYXNlIHNvbWUgb3RoZXIgaGFuZGxlciB0b3VjaGVkIHRoZVxuICAgICAgICAvLyBzZWxlY3Rpb24gaW4gdGhlIG1lYW50aW1lLlxuICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVoaWRlKCkge1xuICAgICAgaWYgKGlucHV0LmNvbnRleHRNZW51UGVuZGluZyAhPSByZWhpZGUpIHsgcmV0dXJuIH1cbiAgICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IGZhbHNlO1xuICAgICAgaW5wdXQud3JhcHBlci5zdHlsZS5jc3NUZXh0ID0gb2xkV3JhcHBlckNTUztcbiAgICAgIHRlLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcChkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCA9IHNjcm9sbFBvcyk7IH1cblxuICAgICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgdXNlciBjaG9vc2luZyBzZWxlY3QtYWxsXG4gICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWllIHx8IChpZSAmJiBpZV92ZXJzaW9uIDwgOSkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTsgfVxuICAgICAgICB2YXIgaSA9IDAsIHBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgPT0gY20uZG9jLnNlbCAmJiB0ZS5zZWxlY3Rpb25TdGFydCA9PSAwICYmXG4gICAgICAgICAgICAgIHRlLnNlbGVjdGlvbkVuZCA+IDAgJiYgaW5wdXQucHJldklucHV0ID09IFwiXFx1MjAwYlwiKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24oY20sIHNlbGVjdEFsbCkoY20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSsrIDwgMTApIHtcbiAgICAgICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCA1MDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRpc3BsYXkuZGV0ZWN0aW5nU2VsZWN0QWxsID0gc2V0VGltZW91dChwb2xsLCAyMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uID49IDkpIHsgcHJlcGFyZVNlbGVjdEFsbEhhY2soKTsgfVxuICAgIGlmIChjYXB0dXJlUmlnaHRDbGljaykge1xuICAgICAgZV9zdG9wKGUpO1xuICAgICAgdmFyIG1vdXNldXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9mZih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICAgICAgc2V0VGltZW91dChyZWhpZGUsIDIwKTtcbiAgICAgIH07XG4gICAgICBvbih3aW5kb3csIFwibW91c2V1cFwiLCBtb3VzZXVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dChyZWhpZGUsIDUwKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVhZE9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGlmICghdmFsKSB7IHRoaXMucmVzZXQoKTsgfVxuICAgIHRoaXMudGV4dGFyZWEuZGlzYWJsZWQgPSB2YWwgPT0gXCJub2N1cnNvclwiO1xuICAgIHRoaXMudGV4dGFyZWEucmVhZE9ubHkgPSAhIXZhbDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKCkge307XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZnJvbVRleHRBcmVhKHRleHRhcmVhLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XG4gICAgb3B0aW9ucy52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xuICAgIGlmICghb3B0aW9ucy50YWJpbmRleCAmJiB0ZXh0YXJlYS50YWJJbmRleClcbiAgICAgIHsgb3B0aW9ucy50YWJpbmRleCA9IHRleHRhcmVhLnRhYkluZGV4OyB9XG4gICAgaWYgKCFvcHRpb25zLnBsYWNlaG9sZGVyICYmIHRleHRhcmVhLnBsYWNlaG9sZGVyKVxuICAgICAgeyBvcHRpb25zLnBsYWNlaG9sZGVyID0gdGV4dGFyZWEucGxhY2Vob2xkZXI7IH1cbiAgICAvLyBTZXQgYXV0b2ZvY3VzIHRvIHRydWUgaWYgdGhpcyB0ZXh0YXJlYSBpcyBmb2N1c2VkLCBvciBpZiBpdCBoYXNcbiAgICAvLyBhdXRvZm9jdXMgYW5kIG5vIG90aGVyIGVsZW1lbnQgaXMgZm9jdXNlZC5cbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgPT0gbnVsbCkge1xuICAgICAgdmFyIGhhc0ZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICBvcHRpb25zLmF1dG9mb2N1cyA9IGhhc0ZvY3VzID09IHRleHRhcmVhIHx8XG4gICAgICAgIHRleHRhcmVhLmdldEF0dHJpYnV0ZShcImF1dG9mb2N1c1wiKSAhPSBudWxsICYmIGhhc0ZvY3VzID09IGRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2F2ZSgpIHt0ZXh0YXJlYS52YWx1ZSA9IGNtLmdldFZhbHVlKCk7fVxuXG4gICAgdmFyIHJlYWxTdWJtaXQ7XG4gICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgIG9uKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgLy8gRGVwbG9yYWJsZSBoYWNrIHRvIG1ha2UgdGhlIHN1Ym1pdCBtZXRob2QgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUpIHtcbiAgICAgICAgdmFyIGZvcm0gPSB0ZXh0YXJlYS5mb3JtO1xuICAgICAgICByZWFsU3VibWl0ID0gZm9ybS5zdWJtaXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHdyYXBwZWRTdWJtaXQgPSBmb3JtLnN1Ym1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNhdmUoKTtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDtcbiAgICAgICAgICAgIGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHdyYXBwZWRTdWJtaXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaChlKSB7fVxuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbnMuZmluaXNoSW5pdCA9IGZ1bmN0aW9uIChjbSkge1xuICAgICAgY20uc2F2ZSA9IHNhdmU7XG4gICAgICBjbS5nZXRUZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRleHRhcmVhOyB9O1xuICAgICAgY20udG9UZXh0QXJlYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY20udG9UZXh0QXJlYSA9IGlzTmFOOyAvLyBQcmV2ZW50IHRoaXMgZnJvbSBiZWluZyByYW4gdHdpY2VcbiAgICAgICAgc2F2ZSgpO1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNtLmdldFdyYXBwZXJFbGVtZW50KCkpO1xuICAgICAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgaWYgKHRleHRhcmVhLmZvcm0pIHtcbiAgICAgICAgICBvZmYodGV4dGFyZWEuZm9ybSwgXCJzdWJtaXRcIiwgc2F2ZSk7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmxlYXZlU3VibWl0TWV0aG9kQWxvbmUgJiYgdHlwZW9mIHRleHRhcmVhLmZvcm0uc3VibWl0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHsgdGV4dGFyZWEuZm9ybS5zdWJtaXQgPSByZWFsU3VibWl0OyB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIHRleHRhcmVhLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB2YXIgY20gPSBDb2RlTWlycm9yKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0ZXh0YXJlYS5uZXh0U2libGluZyk7IH0sXG4gICAgICBvcHRpb25zKTtcbiAgICByZXR1cm4gY21cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpIHtcbiAgICBDb2RlTWlycm9yLm9mZiA9IG9mZjtcbiAgICBDb2RlTWlycm9yLm9uID0gb247XG4gICAgQ29kZU1pcnJvci53aGVlbEV2ZW50UGl4ZWxzID0gd2hlZWxFdmVudFBpeGVscztcbiAgICBDb2RlTWlycm9yLkRvYyA9IERvYztcbiAgICBDb2RlTWlycm9yLnNwbGl0TGluZXMgPSBzcGxpdExpbmVzQXV0bztcbiAgICBDb2RlTWlycm9yLmNvdW50Q29sdW1uID0gY291bnRDb2x1bW47XG4gICAgQ29kZU1pcnJvci5maW5kQ29sdW1uID0gZmluZENvbHVtbjtcbiAgICBDb2RlTWlycm9yLmlzV29yZENoYXIgPSBpc1dvcmRDaGFyQmFzaWM7XG4gICAgQ29kZU1pcnJvci5QYXNzID0gUGFzcztcbiAgICBDb2RlTWlycm9yLnNpZ25hbCA9IHNpZ25hbDtcbiAgICBDb2RlTWlycm9yLkxpbmUgPSBMaW5lO1xuICAgIENvZGVNaXJyb3IuY2hhbmdlRW5kID0gY2hhbmdlRW5kO1xuICAgIENvZGVNaXJyb3Iuc2Nyb2xsYmFyTW9kZWwgPSBzY3JvbGxiYXJNb2RlbDtcbiAgICBDb2RlTWlycm9yLlBvcyA9IFBvcztcbiAgICBDb2RlTWlycm9yLmNtcFBvcyA9IGNtcDtcbiAgICBDb2RlTWlycm9yLm1vZGVzID0gbW9kZXM7XG4gICAgQ29kZU1pcnJvci5taW1lTW9kZXMgPSBtaW1lTW9kZXM7XG4gICAgQ29kZU1pcnJvci5yZXNvbHZlTW9kZSA9IHJlc29sdmVNb2RlO1xuICAgIENvZGVNaXJyb3IuZ2V0TW9kZSA9IGdldE1vZGU7XG4gICAgQ29kZU1pcnJvci5tb2RlRXh0ZW5zaW9ucyA9IG1vZGVFeHRlbnNpb25zO1xuICAgIENvZGVNaXJyb3IuZXh0ZW5kTW9kZSA9IGV4dGVuZE1vZGU7XG4gICAgQ29kZU1pcnJvci5jb3B5U3RhdGUgPSBjb3B5U3RhdGU7XG4gICAgQ29kZU1pcnJvci5zdGFydFN0YXRlID0gc3RhcnRTdGF0ZTtcbiAgICBDb2RlTWlycm9yLmlubmVyTW9kZSA9IGlubmVyTW9kZTtcbiAgICBDb2RlTWlycm9yLmNvbW1hbmRzID0gY29tbWFuZHM7XG4gICAgQ29kZU1pcnJvci5rZXlNYXAgPSBrZXlNYXA7XG4gICAgQ29kZU1pcnJvci5rZXlOYW1lID0ga2V5TmFtZTtcbiAgICBDb2RlTWlycm9yLmlzTW9kaWZpZXJLZXkgPSBpc01vZGlmaWVyS2V5O1xuICAgIENvZGVNaXJyb3IubG9va3VwS2V5ID0gbG9va3VwS2V5O1xuICAgIENvZGVNaXJyb3Iubm9ybWFsaXplS2V5TWFwID0gbm9ybWFsaXplS2V5TWFwO1xuICAgIENvZGVNaXJyb3IuU3RyaW5nU3RyZWFtID0gU3RyaW5nU3RyZWFtO1xuICAgIENvZGVNaXJyb3IuU2hhcmVkVGV4dE1hcmtlciA9IFNoYXJlZFRleHRNYXJrZXI7XG4gICAgQ29kZU1pcnJvci5UZXh0TWFya2VyID0gVGV4dE1hcmtlcjtcbiAgICBDb2RlTWlycm9yLkxpbmVXaWRnZXQgPSBMaW5lV2lkZ2V0O1xuICAgIENvZGVNaXJyb3IuZV9wcmV2ZW50RGVmYXVsdCA9IGVfcHJldmVudERlZmF1bHQ7XG4gICAgQ29kZU1pcnJvci5lX3N0b3BQcm9wYWdhdGlvbiA9IGVfc3RvcFByb3BhZ2F0aW9uO1xuICAgIENvZGVNaXJyb3IuZV9zdG9wID0gZV9zdG9wO1xuICAgIENvZGVNaXJyb3IuYWRkQ2xhc3MgPSBhZGRDbGFzcztcbiAgICBDb2RlTWlycm9yLmNvbnRhaW5zID0gY29udGFpbnM7XG4gICAgQ29kZU1pcnJvci5ybUNsYXNzID0gcm1DbGFzcztcbiAgICBDb2RlTWlycm9yLmtleU5hbWVzID0ga2V5TmFtZXM7XG4gIH1cblxuICAvLyBFRElUT1IgQ09OU1RSVUNUT1JcblxuICBkZWZpbmVPcHRpb25zKENvZGVNaXJyb3IpO1xuXG4gIGFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcik7XG5cbiAgLy8gU2V0IHVwIG1ldGhvZHMgb24gQ29kZU1pcnJvcidzIHByb3RvdHlwZSB0byByZWRpcmVjdCB0byB0aGUgZWRpdG9yJ3MgZG9jdW1lbnQuXG4gIHZhciBkb250RGVsZWdhdGUgPSBcIml0ZXIgaW5zZXJ0IHJlbW92ZSBjb3B5IGdldEVkaXRvciBjb25zdHJ1Y3RvclwiLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgcHJvcCBpbiBEb2MucHJvdG90eXBlKSB7IGlmIChEb2MucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3ApICYmIGluZGV4T2YoZG9udERlbGVnYXRlLCBwcm9wKSA8IDApXG4gICAgeyBDb2RlTWlycm9yLnByb3RvdHlwZVtwcm9wXSA9IChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtyZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMuZG9jLCBhcmd1bWVudHMpfVxuICAgIH0pKERvYy5wcm90b3R5cGVbcHJvcF0pOyB9IH1cblxuICBldmVudE1peGluKERvYyk7XG4gIENvZGVNaXJyb3IuaW5wdXRTdHlsZXMgPSB7XCJ0ZXh0YXJlYVwiOiBUZXh0YXJlYUlucHV0LCBcImNvbnRlbnRlZGl0YWJsZVwiOiBDb250ZW50RWRpdGFibGVJbnB1dH07XG5cbiAgLy8gRXh0cmEgYXJndW1lbnRzIGFyZSBzdG9yZWQgYXMgdGhlIG1vZGUncyBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzXG4gIC8vIHVzZWQgYnkgKGxlZ2FjeSkgbWVjaGFuaXNtcyBsaWtlIGxvYWRtb2RlLmpzIHRvIGF1dG9tYXRpY2FsbHlcbiAgLy8gbG9hZCBhIG1vZGUuIChQcmVmZXJyZWQgbWVjaGFuaXNtIGlzIHRoZSByZXF1aXJlL2RlZmluZSBjYWxscy4pXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZSA9IGZ1bmN0aW9uKG5hbWUvKiwgbW9kZSwg4oCmKi8pIHtcbiAgICBpZiAoIUNvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSAmJiBuYW1lICE9IFwibnVsbFwiKSB7IENvZGVNaXJyb3IuZGVmYXVsdHMubW9kZSA9IG5hbWU7IH1cbiAgICBkZWZpbmVNb2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FID0gZGVmaW5lTUlNRTtcblxuICAvLyBNaW5pbWFsIGRlZmF1bHQgbW9kZS5cbiAgQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwibnVsbFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiAoe3Rva2VuOiBmdW5jdGlvbiAoc3RyZWFtKSB7IHJldHVybiBzdHJlYW0uc2tpcFRvRW5kKCk7IH19KTsgfSk7XG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvcGxhaW5cIiwgXCJudWxsXCIpO1xuXG4gIC8vIEVYVEVOU0lPTlNcblxuICBDb2RlTWlycm9yLmRlZmluZUV4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICB9O1xuICBDb2RlTWlycm9yLmRlZmluZURvY0V4dGVuc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgRG9jLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmM7XG4gIH07XG5cbiAgQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEgPSBmcm9tVGV4dEFyZWE7XG5cbiAgYWRkTGVnYWN5UHJvcHMoQ29kZU1pcnJvcik7XG5cbiAgQ29kZU1pcnJvci52ZXJzaW9uID0gXCI1LjYxLjBcIjtcblxuICByZXR1cm4gQ29kZU1pcnJvcjtcblxufSkpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/codemirror/lib/codemirror.js\n')},"./node_modules/codemirror/mode/css/css.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nCodeMirror.defineMode("css", function(config, parserConfig) {\n  var inline = parserConfig.inline\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      lineComment = parserConfig.lineComment,\n      supportsAtComponent = parserConfig.supportsAtComponent === true,\n      highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == "@") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("def", stream.current());\n    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n      return ret(null, "compare");\n    } else if (ch == "\\"" || ch == "\'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "#") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("atom", "hash");\n    } else if (ch == "!") {\n      stream.match(/^\\s*\\w*/);\n      return ret("keyword", "important");\n    } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret("number", "unit");\n    } else if (ch === "-") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret("number", "unit");\n      } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret("variable-2", "variable-definition");\n        return ret("variable-2", "variable");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret("meta", "meta");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, "select-op");\n    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret("qualifier", "qualifier");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (stream.match(/^[\\w-.]+(?=\\()/)) {\n      if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {\n        state.tokenize = tokenParenthesized;\n      }\n      return ret("variable callee", "variable");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("property", "word");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == ")") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      if (ch == quote || !escaped && quote != ")") state.tokenize = null;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be \'(\'\n    if (!stream.match(/^\\s*[\\"\\\')]/, false))\n      state.tokenize = tokenString(")");\n    else\n      state.tokenize = null;\n    return ret(null, "(");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = "atom";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = "keyword";\n    else\n      override = "variable";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == "{") {\n      return pushContext(state, stream, "block");\n    } else if (type == "}" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/i.test(type)) {\n      return pushContext(state, stream, "atComponentBlock");\n    } else if (/^@(-moz-)?document$/i.test(type)) {\n      return pushContext(state, stream, "documentTypes");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\n      return pushContext(state, stream, "atBlock");\n    } else if (/^@(font-face|counter-style)/i.test(type)) {\n      state.stateArg = type;\n      return "restricted_atBlock_before";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\n      return "keyframes";\n    } else if (type && type.charAt(0) == "@") {\n      return pushContext(state, stream, "at");\n    } else if (type == "hash") {\n      override = "builtin";\n    } else if (type == "word") {\n      override = "tag";\n    } else if (type == "variable-definition") {\n      return "maybeprop";\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    } else if (type == ":") {\n      return "pseudo";\n    } else if (allowNested && type == "(") {\n      return pushContext(state, stream, "parens");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == "word") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = "property";\n        return "maybeprop";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = highlightNonStandardPropertyKeywords ? "string-2" : "property";\n        return "maybeprop";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? "property" : "tag";\n        return "block";\n      } else {\n        override += " error";\n        return "maybeprop";\n      }\n    } else if (type == "meta") {\n      return "block";\n    } else if (!allowNested && (type == "hash" || type == "qualifier")) {\n      override = "error";\n      return "block";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == ":") return pushContext(state, stream, "prop");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");\n    if (type == "}" || type == "{") return popAndPass(type, stream, state);\n    if (type == "(") return pushContext(state, stream, "parens");\n\n    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {\n      override += " error";\n    } else if (type == "word") {\n      wordAsValue(stream);\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    }\n    return "prop";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") { override = "property"; return "maybeprop"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == ")") return popContext(state);\n    if (type == "(") return pushContext(state, stream, "parens");\n    if (type == "interpolation") return pushContext(state, stream, "interpolation");\n    if (type == "word") wordAsValue(stream);\n    return "parens";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == "meta") return "pseudo";\n\n    if (type == "word") {\n      override = "variable-3";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {\n      override = "tag";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == "(") return pushContext(state, stream, "atBlock_parens");\n    if (type == "}" || type == ";") return popAndPass(type, stream, state);\n    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n\n    if (type == "interpolation") return pushContext(state, stream, "interpolation");\n\n    if (type == "word") {\n      var word = stream.current().toLowerCase();\n      if (word == "only" || word == "not" || word == "and" || word == "or")\n        override = "keyword";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = "attribute";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = "property";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = "keyword";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = "property";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = highlightNonStandardPropertyKeywords ? "string-2" : "property";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = "atom";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = "keyword";\n      else\n        override = "error";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == "}")\n      return popAndPass(type, stream, state);\n    if (type == "{")\n      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);\n    if (type == "word")\n      override = "error";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == "{")\n      return pushContext(state, stream, "restricted_atBlock");\n    if (type == "word" && state.stateArg == "@counter-style") {\n      override = "variable";\n      return "restricted_atBlock_before";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == "}") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == "word") {\n      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = "error";\n      else\n        override = "property";\n      return "maybeprop";\n    }\n    return "restricted_atBlock";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == "word") { override = "variable"; return "keyframes"; }\n    if (type == "{") return pushContext(state, stream, "top");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") override = "tag";\n    else if (type == "hash") override = "builtin";\n    return "at";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "{" || type == ";") return popAndPass(type, stream, state);\n    if (type == "word") override = "variable";\n    else if (type != "variable" && type != "(" && type != ")") override = "error";\n    return "interpolation";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: inline ? "block" : "top",\n              stateArg: null,\n              context: new Context(inline ? "block" : "top", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == "object") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      if (type != "comment")\n        state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||\n                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||\n            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n        }\n      }\n      return indent;\n    },\n\n    electricChars: "}",\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    blockCommentContinue: " * ",\n    lineComment: lineComment,\n    fold: "brace"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    "domain", "regexp", "url", "url-prefix"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    "all", "aural", "braille", "handheld", "print", "projection", "screen",\n    "tty", "tv", "embossed"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    "width", "min-width", "max-width", "height", "min-height", "max-height",\n    "device-width", "min-device-width", "max-device-width", "device-height",\n    "min-device-height", "max-device-height", "aspect-ratio",\n    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",\n    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",\n    "max-color", "color-index", "min-color-index", "max-color-index",\n    "monochrome", "min-monochrome", "max-monochrome", "resolution",\n    "min-resolution", "max-resolution", "scan", "grid", "orientation",\n    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",\n    "pointer", "any-pointer", "hover", "any-hover", "prefers-color-scheme"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",\n    "interlace", "progressive",\n    "dark", "light"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    "align-content", "align-items", "align-self", "alignment-adjust",\n    "alignment-baseline", "all", "anchor-point", "animation", "animation-delay",\n    "animation-direction", "animation-duration", "animation-fill-mode",\n    "animation-iteration-count", "animation-name", "animation-play-state",\n    "animation-timing-function", "appearance", "azimuth", "backdrop-filter",\n    "backface-visibility", "background", "background-attachment",\n    "background-blend-mode", "background-clip", "background-color",\n    "background-image", "background-origin", "background-position",\n    "background-position-x", "background-position-y", "background-repeat",\n    "background-size", "baseline-shift", "binding", "bleed", "block-size",\n    "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target",\n    "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius",\n    "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",\n    "border-collapse", "border-color", "border-image", "border-image-outset",\n    "border-image-repeat", "border-image-slice", "border-image-source",\n    "border-image-width", "border-left", "border-left-color", "border-left-style",\n    "border-left-width", "border-radius", "border-right", "border-right-color",\n    "border-right-style", "border-right-width", "border-spacing", "border-style",\n    "border-top", "border-top-color", "border-top-left-radius",\n    "border-top-right-radius", "border-top-style", "border-top-width",\n    "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing",\n    "break-after", "break-before", "break-inside", "caption-side", "caret-color",\n    "clear", "clip", "color", "color-profile", "column-count", "column-fill",\n    "column-gap", "column-rule", "column-rule-color", "column-rule-style",\n    "column-rule-width", "column-span", "column-width", "columns", "contain",\n    "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after",\n    "cue-before", "cursor", "direction", "display", "dominant-baseline",\n    "drop-initial-after-adjust", "drop-initial-after-align",\n    "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",\n    "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position",\n    "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow",\n    "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into",\n    "font", "font-family", "font-feature-settings", "font-kerning",\n    "font-language-override", "font-optical-sizing", "font-size",\n    "font-size-adjust", "font-stretch", "font-style", "font-synthesis",\n    "font-variant", "font-variant-alternates", "font-variant-caps",\n    "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric",\n    "font-variant-position", "font-variation-settings", "font-weight", "gap",\n    "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows",\n    "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start",\n    "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start",\n    "grid-template", "grid-template-areas", "grid-template-columns",\n    "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon",\n    "image-orientation", "image-rendering", "image-resolution", "inline-box-align",\n    "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline",\n    "inset-inline-end", "inset-inline-start", "isolation", "justify-content",\n    "justify-items", "justify-self", "left", "letter-spacing", "line-break",\n    "line-height", "line-height-step", "line-stacking", "line-stacking-ruby",\n    "line-stacking-shift", "line-stacking-strategy", "list-style",\n    "list-style-image", "list-style-position", "list-style-type", "margin",\n    "margin-bottom", "margin-left", "margin-right", "margin-top", "marks",\n    "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed",\n    "marquee-style", "mask-clip", "mask-composite", "mask-image", "mask-mode",\n    "mask-origin", "mask-position", "mask-repeat", "mask-size","mask-type",\n    "max-block-size", "max-height", "max-inline-size",\n    "max-width", "min-block-size", "min-height", "min-inline-size", "min-width",\n    "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right",\n    "nav-up", "object-fit", "object-position", "offset", "offset-anchor",\n    "offset-distance", "offset-path", "offset-position", "offset-rotate",\n    "opacity", "order", "orphans", "outline", "outline-color", "outline-offset",\n    "outline-style", "outline-width", "overflow", "overflow-style",\n    "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom",\n    "padding-left", "padding-right", "padding-top", "page", "page-break-after",\n    "page-break-before", "page-break-inside", "page-policy", "pause",\n    "pause-after", "pause-before", "perspective", "perspective-origin", "pitch",\n    "pitch-range", "place-content", "place-items", "place-self", "play-during",\n    "position", "presentation-level", "punctuation-trim", "quotes",\n    "region-break-after", "region-break-before", "region-break-inside",\n    "region-fragment", "rendering-intent", "resize", "rest", "rest-after",\n    "rest-before", "richness", "right", "rotate", "rotation", "rotation-point",\n    "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span",\n    "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block",\n    "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom",\n    "scroll-margin-inline", "scroll-margin-inline-end",\n    "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right",\n    "scroll-margin-top", "scroll-padding", "scroll-padding-block",\n    "scroll-padding-block-end", "scroll-padding-block-start",\n    "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end",\n    "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right",\n    "scroll-padding-top", "scroll-snap-align", "scroll-snap-type",\n    "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside",\n    "size", "speak", "speak-as", "speak-header", "speak-numeral",\n    "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size",\n    "table-layout", "target", "target-name", "target-new", "target-position",\n    "text-align", "text-align-last", "text-combine-upright", "text-decoration",\n    "text-decoration-color", "text-decoration-line", "text-decoration-skip",\n    "text-decoration-skip-ink", "text-decoration-style", "text-emphasis",\n    "text-emphasis-color", "text-emphasis-position", "text-emphasis-style",\n    "text-height", "text-indent", "text-justify", "text-orientation",\n    "text-outline", "text-overflow", "text-rendering", "text-shadow",\n    "text-size-adjust", "text-space-collapse", "text-transform",\n    "text-underline-position", "text-wrap", "top", "touch-action", "transform", "transform-origin",\n    "transform-style", "transition", "transition-delay", "transition-duration",\n    "transition-property", "transition-timing-function", "translate",\n    "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance",\n    "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate",\n    "voice-stress", "voice-volume", "volume", "white-space", "widows", "width",\n    "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index",\n    // SVG-specific\n    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",\n    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",\n    "color-interpolation", "color-interpolation-filters",\n    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",\n    "marker", "marker-end", "marker-mid", "marker-start", "paint-order", "shape-rendering", "stroke",\n    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",\n    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",\n    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",\n    "glyph-orientation-vertical", "text-anchor", "writing-mode",\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    "border-block", "border-block-color", "border-block-end",\n    "border-block-end-color", "border-block-end-style", "border-block-end-width",\n    "border-block-start", "border-block-start-color", "border-block-start-style",\n    "border-block-start-width", "border-block-style", "border-block-width",\n    "border-inline", "border-inline-color", "border-inline-end",\n    "border-inline-end-color", "border-inline-end-style",\n    "border-inline-end-width", "border-inline-start", "border-inline-start-color",\n    "border-inline-start-style", "border-inline-start-width",\n    "border-inline-style", "border-inline-width", "margin-block",\n    "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end",\n    "margin-inline-start", "padding-block", "padding-block-end",\n    "padding-block-start", "padding-inline", "padding-inline-end",\n    "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color",\n    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",\n    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",\n    "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration",\n    "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    "font-display", "font-family", "src", "unicode-range", "font-variant",\n     "font-feature-settings", "font-stretch", "font-weight", "font-style"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",\n    "speak-as", "suffix", "symbols", "system"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",\n    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",\n    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",\n    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",\n    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",\n    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",\n    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",\n    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",\n    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",\n    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",\n    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",\n    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",\n    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",\n    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",\n    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",\n    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",\n    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",\n    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",\n    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",\n    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",\n    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",\n    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",\n    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",\n    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",\n    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",\n    "whitesmoke", "yellow", "yellowgreen"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    "above", "absolute", "activeborder", "additive", "activecaption", "afar",\n    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",\n    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",\n    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",\n    "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "binary",\n    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",\n    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",\n    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",\n    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",\n    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",\n    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",\n    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",\n    "compact", "condensed", "contain", "content", "contents",\n    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",\n    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",\n    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",\n    "destination-in", "destination-out", "destination-over", "devanagari", "difference",\n    "disc", "discard", "disclosure-closed", "disclosure-open", "document",\n    "dot-dash", "dot-dot-dash",\n    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",\n    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",\n    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",\n    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",\n    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",\n    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",\n    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",\n    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",\n    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",\n    "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",\n    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",\n    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",\n    "help", "hidden", "hide", "higher", "highlight", "highlighttext",\n    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",\n    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",\n    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",\n    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",\n    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",\n    "katakana", "katakana-iroha", "keep-all", "khmer",\n    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",\n    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",\n    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",\n    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",\n    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",\n    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "manipulation", "match", "matrix", "matrix3d",\n    "media-controls-background", "media-current-time-display",\n    "media-fullscreen-button", "media-mute-button", "media-play-button",\n    "media-return-to-realtime-button", "media-rewind-button",\n    "media-seek-back-button", "media-seek-forward-button", "media-slider",\n    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",\n    "media-volume-slider-container", "media-volume-sliderthumb", "medium",\n    "menu", "menulist", "menulist-button", "menulist-text",\n    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",\n    "mix", "mongolian", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "myanmar", "n-resize",\n    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",\n    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",\n    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",\n    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",\n    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",\n    "painted", "page", "paused", "persian", "perspective", "pinch-zoom", "plus-darker", "plus-lighter",\n    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",\n    "progress", "push-button", "radial-gradient", "radio", "read-only",\n    "read-write", "read-write-plaintext-only", "rectangle", "region",\n    "relative", "repeat", "repeating-linear-gradient",\n    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",\n    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",\n    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",\n    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",\n    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",\n    "searchfield-cancel-button", "searchfield-decoration",\n    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",\n    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",\n    "simp-chinese-formal", "simp-chinese-informal", "single",\n    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",\n    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",\n    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",\n    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",\n    "square-button", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub",\n    "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",\n    "table-caption", "table-cell", "table-column", "table-column-group",\n    "table-footer-group", "table-header-group", "table-row", "table-row-group",\n    "tamil",\n    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",\n    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",\n    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",\n    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",\n    "trad-chinese-formal", "trad-chinese-informal", "transform",\n    "translate", "translate3d", "translateX", "translateY", "translateZ",\n    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up",\n    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",\n    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",\n    "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted",\n    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",\n    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",\n    "xx-large", "xx-small"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper("hintWords", "css", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == "/") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ["comment", "comment"];\n  }\n\n  CodeMirror.defineMIME("text/css", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css"\n  });\n\n  CodeMirror.defineMIME("text/x-scss", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: "//",\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      ":": function(stream) {\n        if (stream.match(/^\\s*\\{/, false))\n          return [null, null]\n        return false;\n      },\n      "$": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "#": function(stream) {\n        if (!stream.eat("{")) return false;\n        return [null, "interpolation"];\n      }\n    },\n    name: "css",\n    helperType: "scss"\n  });\n\n  CodeMirror.defineMIME("text/x-less", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: "//",\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      "@": function(stream) {\n        if (stream.eat("{")) return [null, "interpolation"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "&": function() {\n        return ["atom", "atom"];\n      }\n    },\n    name: "css",\n    helperType: "less"\n  });\n\n  CodeMirror.defineMIME("text/x-gss", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css",\n    helperType: "gss"\n  });\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9jc3MvY3NzLmpzPzdiMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELGdEQUFnRDtBQUNoRCxzREFBc0Q7QUFDdEQsZ0VBQWdFO0FBQ2hFLDREQUE0RDtBQUM1RCxrRkFBa0Y7QUFDbEYsd0RBQXdEO0FBQ3hELGdFQUFnRTtBQUNoRSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFdBQVcsY0FBYzs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLLGdCQUFnQjtBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUgsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvY3NzL2Nzcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIikpO1xuICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSAvLyBBTURcbiAgICBkZWZpbmUoW1wiLi4vLi4vbGliL2NvZGVtaXJyb3JcIl0sIG1vZCk7XG4gIGVsc2UgLy8gUGxhaW4gYnJvd3NlciBlbnZcbiAgICBtb2QoQ29kZU1pcnJvcik7XG59KShmdW5jdGlvbihDb2RlTWlycm9yKSB7XG5cInVzZSBzdHJpY3RcIjtcblxuQ29kZU1pcnJvci5kZWZpbmVNb2RlKFwiY3NzXCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBpbmxpbmUgPSBwYXJzZXJDb25maWcuaW5saW5lXG4gIGlmICghcGFyc2VyQ29uZmlnLnByb3BlcnR5S2V5d29yZHMpIHBhcnNlckNvbmZpZyA9IENvZGVNaXJyb3IucmVzb2x2ZU1vZGUoXCJ0ZXh0L2Nzc1wiKTtcblxuICB2YXIgaW5kZW50VW5pdCA9IGNvbmZpZy5pbmRlbnRVbml0LFxuICAgICAgdG9rZW5Ib29rcyA9IHBhcnNlckNvbmZpZy50b2tlbkhvb2tzLFxuICAgICAgZG9jdW1lbnRUeXBlcyA9IHBhcnNlckNvbmZpZy5kb2N1bWVudFR5cGVzIHx8IHt9LFxuICAgICAgbWVkaWFUeXBlcyA9IHBhcnNlckNvbmZpZy5tZWRpYVR5cGVzIHx8IHt9LFxuICAgICAgbWVkaWFGZWF0dXJlcyA9IHBhcnNlckNvbmZpZy5tZWRpYUZlYXR1cmVzIHx8IHt9LFxuICAgICAgbWVkaWFWYWx1ZUtleXdvcmRzID0gcGFyc2VyQ29uZmlnLm1lZGlhVmFsdWVLZXl3b3JkcyB8fCB7fSxcbiAgICAgIHByb3BlcnR5S2V5d29yZHMgPSBwYXJzZXJDb25maWcucHJvcGVydHlLZXl3b3JkcyB8fCB7fSxcbiAgICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyA9IHBhcnNlckNvbmZpZy5ub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMgfHwge30sXG4gICAgICBmb250UHJvcGVydGllcyA9IHBhcnNlckNvbmZpZy5mb250UHJvcGVydGllcyB8fCB7fSxcbiAgICAgIGNvdW50ZXJEZXNjcmlwdG9ycyA9IHBhcnNlckNvbmZpZy5jb3VudGVyRGVzY3JpcHRvcnMgfHwge30sXG4gICAgICBjb2xvcktleXdvcmRzID0gcGFyc2VyQ29uZmlnLmNvbG9yS2V5d29yZHMgfHwge30sXG4gICAgICB2YWx1ZUtleXdvcmRzID0gcGFyc2VyQ29uZmlnLnZhbHVlS2V5d29yZHMgfHwge30sXG4gICAgICBhbGxvd05lc3RlZCA9IHBhcnNlckNvbmZpZy5hbGxvd05lc3RlZCxcbiAgICAgIGxpbmVDb21tZW50ID0gcGFyc2VyQ29uZmlnLmxpbmVDb21tZW50LFxuICAgICAgc3VwcG9ydHNBdENvbXBvbmVudCA9IHBhcnNlckNvbmZpZy5zdXBwb3J0c0F0Q29tcG9uZW50ID09PSB0cnVlLFxuICAgICAgaGlnaGxpZ2h0Tm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzID0gY29uZmlnLmhpZ2hsaWdodE5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyAhPT0gZmFsc2U7XG5cbiAgdmFyIHR5cGUsIG92ZXJyaWRlO1xuICBmdW5jdGlvbiByZXQoc3R5bGUsIHRwKSB7IHR5cGUgPSB0cDsgcmV0dXJuIHN0eWxlOyB9XG5cbiAgLy8gVG9rZW5pemVyc1xuXG4gIGZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgICBpZiAodG9rZW5Ib29rc1tjaF0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b2tlbkhvb2tzW2NoXShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoY2ggPT0gXCJAXCIpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICByZXR1cm4gcmV0KFwiZGVmXCIsIHN0cmVhbS5jdXJyZW50KCkpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIgfHwgKGNoID09IFwiflwiIHx8IGNoID09IFwifFwiKSAmJiBzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgICAgcmV0dXJuIHJldChudWxsLCBcImNvbXBhcmVcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIlxcXCJcIiB8fCBjaCA9PSBcIidcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgIHJldHVybiByZXQoXCJhdG9tXCIsIFwiaGFzaFwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiIVwiKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL15cXHMqXFx3Ki8pO1xuICAgICAgcmV0dXJuIHJldChcImtleXdvcmRcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSB8fCBjaCA9PSBcIi5cIiAmJiBzdHJlYW0uZWF0KC9cXGQvKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LiVdLyk7XG4gICAgICByZXR1cm4gcmV0KFwibnVtYmVyXCIsIFwidW5pdFwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09PSBcIi1cIikge1xuICAgICAgaWYgKC9bXFxkLl0vLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3LiVdLyk7XG4gICAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJ1bml0XCIpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goL14tW1xcd1xcXFxcXC1dKi8pKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqOi8sIGZhbHNlKSlcbiAgICAgICAgICByZXR1cm4gcmV0KFwidmFyaWFibGUtMlwiLCBcInZhcmlhYmxlLWRlZmluaXRpb25cIik7XG4gICAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVcIik7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvXlxcdystLykpIHtcbiAgICAgICAgcmV0dXJuIHJldChcIm1ldGFcIiwgXCJtZXRhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoL1ssKz4qXFwvXS8udGVzdChjaCkpIHtcbiAgICAgIHJldHVybiByZXQobnVsbCwgXCJzZWxlY3Qtb3BcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goL14tP1tfYS16XVtfYS16MC05LV0qL2kpKSB7XG4gICAgICByZXR1cm4gcmV0KFwicXVhbGlmaWVyXCIsIFwicXVhbGlmaWVyXCIpO1xuICAgIH0gZWxzZSBpZiAoL1s6O3t9XFxbXFxdXFwoXFwpXS8udGVzdChjaCkpIHtcbiAgICAgIHJldHVybiByZXQobnVsbCwgY2gpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW1xcdy0uXSsoPz1cXCgpLykpIHtcbiAgICAgIGlmICgvXih1cmwoLXByZWZpeCk/fGRvbWFpbnxyZWdleHApJC9pLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblBhcmVudGhlc2l6ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0KFwidmFyaWFibGUgY2FsbGVlXCIsIFwidmFyaWFibGVcIik7XG4gICAgfSBlbHNlIGlmICgvW1xcd1xcXFxcXC1dLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxcXFxcLV0vKTtcbiAgICAgIHJldHVybiByZXQoXCJwcm9wZXJ0eVwiLCBcIndvcmRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXQobnVsbCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgICBpZiAocXVvdGUgPT0gXCIpXCIpIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgICAgfVxuICAgICAgaWYgKGNoID09IHF1b3RlIHx8ICFlc2NhcGVkICYmIHF1b3RlICE9IFwiKVwiKSBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblBhcmVudGhlc2l6ZWQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5uZXh0KCk7IC8vIE11c3QgYmUgJygnXG4gICAgaWYgKCFzdHJlYW0ubWF0Y2goL15cXHMqW1xcXCJcXCcpXS8sIGZhbHNlKSlcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoXCIpXCIpO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICByZXR1cm4gcmV0KG51bGwsIFwiKFwiKTtcbiAgfVxuXG4gIC8vIENvbnRleHQgbWFuYWdlbWVudFxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHlwZSwgaW5kZW50LCBwcmV2KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmluZGVudCA9IGluZGVudDtcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgdHlwZSwgaW5kZW50KSB7XG4gICAgc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KHR5cGUsIHN0cmVhbS5pbmRlbnRhdGlvbigpICsgKGluZGVudCA9PT0gZmFsc2UgPyAwIDogaW5kZW50VW5pdCksIHN0YXRlLmNvbnRleHQpO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb250ZXh0LnByZXYpXG4gICAgICBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICAgIHJldHVybiBzdGF0ZS5jb250ZXh0LnR5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBwYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGVzW3N0YXRlLmNvbnRleHQudHlwZV0odHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlLCBuKSB7XG4gICAgZm9yICh2YXIgaSA9IG4gfHwgMTsgaSA+IDA7IGktLSlcbiAgICAgIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cblxuICAvLyBQYXJzZXJcblxuICBmdW5jdGlvbiB3b3JkQXNWYWx1ZShzdHJlYW0pIHtcbiAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodmFsdWVLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgIG92ZXJyaWRlID0gXCJhdG9tXCI7XG4gICAgZWxzZSBpZiAoY29sb3JLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgIG92ZXJyaWRlID0gXCJrZXl3b3JkXCI7XG4gICAgZWxzZVxuICAgICAgb3ZlcnJpZGUgPSBcInZhcmlhYmxlXCI7XG4gIH1cblxuICB2YXIgc3RhdGVzID0ge307XG5cbiAgc3RhdGVzLnRvcCA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIntcIikge1xuICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiYmxvY2tcIik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwifVwiICYmIHN0YXRlLmNvbnRleHQucHJldikge1xuICAgICAgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNBdENvbXBvbmVudCAmJiAvQGNvbXBvbmVudC9pLnRlc3QodHlwZSkpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImF0Q29tcG9uZW50QmxvY2tcIik7XG4gICAgfSBlbHNlIGlmICgvXkAoLW1vei0pP2RvY3VtZW50JC9pLnRlc3QodHlwZSkpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImRvY3VtZW50VHlwZXNcIik7XG4gICAgfSBlbHNlIGlmICgvXkAobWVkaWF8c3VwcG9ydHN8KC1tb3otKT9kb2N1bWVudHxpbXBvcnQpJC9pLnRlc3QodHlwZSkpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImF0QmxvY2tcIik7XG4gICAgfSBlbHNlIGlmICgvXkAoZm9udC1mYWNlfGNvdW50ZXItc3R5bGUpL2kudGVzdCh0eXBlKSkge1xuICAgICAgc3RhdGUuc3RhdGVBcmcgPSB0eXBlO1xuICAgICAgcmV0dXJuIFwicmVzdHJpY3RlZF9hdEJsb2NrX2JlZm9yZVwiO1xuICAgIH0gZWxzZSBpZiAoL15AKC0obW96fG1zfG98d2Via2l0KS0pP2tleWZyYW1lcyQvaS50ZXN0KHR5cGUpKSB7XG4gICAgICByZXR1cm4gXCJrZXlmcmFtZXNcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgJiYgdHlwZS5jaGFyQXQoMCkgPT0gXCJAXCIpIHtcbiAgICAgIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcImF0XCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImhhc2hcIikge1xuICAgICAgb3ZlcnJpZGUgPSBcImJ1aWx0aW5cIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIG92ZXJyaWRlID0gXCJ0YWdcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZS1kZWZpbml0aW9uXCIpIHtcbiAgICAgIHJldHVybiBcIm1heWJlcHJvcFwiO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikge1xuICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiaW50ZXJwb2xhdGlvblwiKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBcInBzZXVkb1wiO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dOZXN0ZWQgJiYgdHlwZSA9PSBcIihcIikge1xuICAgICAgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwicGFyZW5zXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICB9O1xuXG4gIHN0YXRlcy5ibG9jayA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAocHJvcGVydHlLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkge1xuICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgICAgcmV0dXJuIFwibWF5YmVwcm9wXCI7XG4gICAgICB9IGVsc2UgaWYgKG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSkge1xuICAgICAgICBvdmVycmlkZSA9IGhpZ2hsaWdodE5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyA/IFwic3RyaW5nLTJcIiA6IFwicHJvcGVydHlcIjtcbiAgICAgICAgcmV0dXJuIFwibWF5YmVwcm9wXCI7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93TmVzdGVkKSB7XG4gICAgICAgIG92ZXJyaWRlID0gc3RyZWFtLm1hdGNoKC9eXFxzKjooPzpcXHN8JCkvLCBmYWxzZSkgPyBcInByb3BlcnR5XCIgOiBcInRhZ1wiO1xuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3ZlcnJpZGUgKz0gXCIgZXJyb3JcIjtcbiAgICAgICAgcmV0dXJuIFwibWF5YmVwcm9wXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwibWV0YVwiKSB7XG4gICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93TmVzdGVkICYmICh0eXBlID09IFwiaGFzaFwiIHx8IHR5cGUgPT0gXCJxdWFsaWZpZXJcIikpIHtcbiAgICAgIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRlcy50b3AodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHN0YXRlcy5tYXliZXByb3AgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBwdXNoQ29udGV4dChzdGF0ZSwgc3RyZWFtLCBcInByb3BcIik7XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLnByb3AgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIiAmJiBhbGxvd05lc3RlZCkgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwicHJvcEJsb2NrXCIpO1xuICAgIGlmICh0eXBlID09IFwifVwiIHx8IHR5cGUgPT0gXCJ7XCIpIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJwYXJlbnNcIik7XG5cbiAgICBpZiAodHlwZSA9PSBcImhhc2hcIiAmJiAhL14jKFswLTlhLWZBLWZdezMsNH18WzAtOWEtZkEtZl17Nn18WzAtOWEtZkEtZl17OH0pJC8udGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgb3ZlcnJpZGUgKz0gXCIgZXJyb3JcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIHdvcmRBc1ZhbHVlKHN0cmVhbSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiaW50ZXJwb2xhdGlvblwiKSB7XG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJwcm9wXCI7XG4gIH07XG5cbiAgc3RhdGVzLnByb3BCbG9jayA9IGZ1bmN0aW9uKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikgeyBvdmVycmlkZSA9IFwicHJvcGVydHlcIjsgcmV0dXJuIFwibWF5YmVwcm9wXCI7IH1cbiAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICB9O1xuXG4gIHN0YXRlcy5wYXJlbnMgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIpXCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwicGFyZW5zXCIpO1xuICAgIGlmICh0eXBlID09IFwiaW50ZXJwb2xhdGlvblwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJpbnRlcnBvbGF0aW9uXCIpO1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB3b3JkQXNWYWx1ZShzdHJlYW0pO1xuICAgIHJldHVybiBcInBhcmVuc1wiO1xuICB9O1xuXG4gIHN0YXRlcy5wc2V1ZG8gPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJtZXRhXCIpIHJldHVybiBcInBzZXVkb1wiO1xuXG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIHtcbiAgICAgIG92ZXJyaWRlID0gXCJ2YXJpYWJsZS0zXCI7XG4gICAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIH1cbiAgICByZXR1cm4gcGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfTtcblxuICBzdGF0ZXMuZG9jdW1lbnRUeXBlcyA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIiAmJiBkb2N1bWVudFR5cGVzLmhhc093blByb3BlcnR5KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgICBvdmVycmlkZSA9IFwidGFnXCI7XG4gICAgICByZXR1cm4gc3RhdGUuY29udGV4dC50eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RhdGVzLmF0QmxvY2sodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIHN0YXRlcy5hdEJsb2NrID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJhdEJsb2NrX3BhcmVuc1wiKTtcbiAgICBpZiAodHlwZSA9PSBcIn1cIiB8fCB0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpICYmIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIGFsbG93TmVzdGVkID8gXCJibG9ja1wiIDogXCJ0b3BcIik7XG5cbiAgICBpZiAodHlwZSA9PSBcImludGVycG9sYXRpb25cIikgcmV0dXJuIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIFwiaW50ZXJwb2xhdGlvblwiKTtcblxuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh3b3JkID09IFwib25seVwiIHx8IHdvcmQgPT0gXCJub3RcIiB8fCB3b3JkID09IFwiYW5kXCIgfHwgd29yZCA9PSBcIm9yXCIpXG4gICAgICAgIG92ZXJyaWRlID0gXCJrZXl3b3JkXCI7XG4gICAgICBlbHNlIGlmIChtZWRpYVR5cGVzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwiYXR0cmlidXRlXCI7XG4gICAgICBlbHNlIGlmIChtZWRpYUZlYXR1cmVzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgIGVsc2UgaWYgKG1lZGlhVmFsdWVLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eSh3b3JkKSlcbiAgICAgICAgb3ZlcnJpZGUgPSBcImtleXdvcmRcIjtcbiAgICAgIGVsc2UgaWYgKHByb3BlcnR5S2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICAgIG92ZXJyaWRlID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgZWxzZSBpZiAobm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IGhpZ2hsaWdodE5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyA/IFwic3RyaW5nLTJcIiA6IFwicHJvcGVydHlcIjtcbiAgICAgIGVsc2UgaWYgKHZhbHVlS2V5d29yZHMuaGFzT3duUHJvcGVydHkod29yZCkpXG4gICAgICAgIG92ZXJyaWRlID0gXCJhdG9tXCI7XG4gICAgICBlbHNlIGlmIChjb2xvcktleXdvcmRzLmhhc093blByb3BlcnR5KHdvcmQpKVxuICAgICAgICBvdmVycmlkZSA9IFwia2V5d29yZFwiO1xuICAgICAgZWxzZVxuICAgICAgICBvdmVycmlkZSA9IFwiZXJyb3JcIjtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgfTtcblxuICBzdGF0ZXMuYXRDb21wb25lbnRCbG9jayA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIilcbiAgICAgIHJldHVybiBwb3BBbmRQYXNzKHR5cGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmICh0eXBlID09IFwie1wiKVxuICAgICAgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpICYmIHB1c2hDb250ZXh0KHN0YXRlLCBzdHJlYW0sIGFsbG93TmVzdGVkID8gXCJibG9ja1wiIDogXCJ0b3BcIiwgZmFsc2UpO1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKVxuICAgICAgb3ZlcnJpZGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIHN0YXRlLmNvbnRleHQudHlwZTtcbiAgfTtcblxuICBzdGF0ZXMuYXRCbG9ja19wYXJlbnMgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIpXCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIiB8fCB0eXBlID09IFwifVwiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlLCAyKTtcbiAgICByZXR1cm4gc3RhdGVzLmF0QmxvY2sodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLnJlc3RyaWN0ZWRfYXRCbG9ja19iZWZvcmUgPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpXG4gICAgICByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJyZXN0cmljdGVkX2F0QmxvY2tcIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIgJiYgc3RhdGUuc3RhdGVBcmcgPT0gXCJAY291bnRlci1zdHlsZVwiKSB7XG4gICAgICBvdmVycmlkZSA9IFwidmFyaWFibGVcIjtcbiAgICAgIHJldHVybiBcInJlc3RyaWN0ZWRfYXRCbG9ja19iZWZvcmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLnJlc3RyaWN0ZWRfYXRCbG9jayA9IGZ1bmN0aW9uKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIn1cIikge1xuICAgICAgc3RhdGUuc3RhdGVBcmcgPSBudWxsO1xuICAgICAgcmV0dXJuIHBvcENvbnRleHQoc3RhdGUpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgaWYgKChzdGF0ZS5zdGF0ZUFyZyA9PSBcIkBmb250LWZhY2VcIiAmJiAhZm9udFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpKSkgfHxcbiAgICAgICAgICAoc3RhdGUuc3RhdGVBcmcgPT0gXCJAY291bnRlci1zdHlsZVwiICYmICFjb3VudGVyRGVzY3JpcHRvcnMuaGFzT3duUHJvcGVydHkoc3RyZWFtLmN1cnJlbnQoKS50b0xvd2VyQ2FzZSgpKSkpXG4gICAgICAgIG92ZXJyaWRlID0gXCJlcnJvclwiO1xuICAgICAgZWxzZVxuICAgICAgICBvdmVycmlkZSA9IFwicHJvcGVydHlcIjtcbiAgICAgIHJldHVybiBcIm1heWJlcHJvcFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJyZXN0cmljdGVkX2F0QmxvY2tcIjtcbiAgfTtcblxuICBzdGF0ZXMua2V5ZnJhbWVzID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7IG92ZXJyaWRlID0gXCJ2YXJpYWJsZVwiOyByZXR1cm4gXCJrZXlmcmFtZXNcIjsgfVxuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gcHVzaENvbnRleHQoc3RhdGUsIHN0cmVhbSwgXCJ0b3BcIik7XG4gICAgcmV0dXJuIHBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gIH07XG5cbiAgc3RhdGVzLmF0ID0gZnVuY3Rpb24odHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIgfHwgdHlwZSA9PSBcIn1cIikgcmV0dXJuIHBvcEFuZFBhc3ModHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ3b3JkXCIpIG92ZXJyaWRlID0gXCJ0YWdcIjtcbiAgICBlbHNlIGlmICh0eXBlID09IFwiaGFzaFwiKSBvdmVycmlkZSA9IFwiYnVpbHRpblwiO1xuICAgIHJldHVybiBcImF0XCI7XG4gIH07XG5cbiAgc3RhdGVzLmludGVycG9sYXRpb24gPSBmdW5jdGlvbih0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIiB8fCB0eXBlID09IFwiO1wiKSByZXR1cm4gcG9wQW5kUGFzcyh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikgb3ZlcnJpZGUgPSBcInZhcmlhYmxlXCI7XG4gICAgZWxzZSBpZiAodHlwZSAhPSBcInZhcmlhYmxlXCIgJiYgdHlwZSAhPSBcIihcIiAmJiB0eXBlICE9IFwiKVwiKSBvdmVycmlkZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gXCJpbnRlcnBvbGF0aW9uXCI7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydFN0YXRlOiBmdW5jdGlvbihiYXNlKSB7XG4gICAgICByZXR1cm4ge3Rva2VuaXplOiBudWxsLFxuICAgICAgICAgICAgICBzdGF0ZTogaW5saW5lID8gXCJibG9ja1wiIDogXCJ0b3BcIixcbiAgICAgICAgICAgICAgc3RhdGVBcmc6IG51bGwsXG4gICAgICAgICAgICAgIGNvbnRleHQ6IG5ldyBDb250ZXh0KGlubGluZSA/IFwiYmxvY2tcIiA6IFwidG9wXCIsIGJhc2UgfHwgMCwgbnVsbCl9O1xuICAgIH0sXG5cbiAgICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgaWYgKCFzdGF0ZS50b2tlbml6ZSAmJiBzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0eXBlID0gc3R5bGVbMV07XG4gICAgICAgIHN0eWxlID0gc3R5bGVbMF07XG4gICAgICB9XG4gICAgICBvdmVycmlkZSA9IHN0eWxlO1xuICAgICAgaWYgKHR5cGUgIT0gXCJjb21tZW50XCIpXG4gICAgICAgIHN0YXRlLnN0YXRlID0gc3RhdGVzW3N0YXRlLnN0YXRlXSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyKSB7XG4gICAgICB2YXIgY3ggPSBzdGF0ZS5jb250ZXh0LCBjaCA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApO1xuICAgICAgdmFyIGluZGVudCA9IGN4LmluZGVudDtcbiAgICAgIGlmIChjeC50eXBlID09IFwicHJvcFwiICYmIChjaCA9PSBcIn1cIiB8fCBjaCA9PSBcIilcIikpIGN4ID0gY3gucHJldjtcbiAgICAgIGlmIChjeC5wcmV2KSB7XG4gICAgICAgIGlmIChjaCA9PSBcIn1cIiAmJiAoY3gudHlwZSA9PSBcImJsb2NrXCIgfHwgY3gudHlwZSA9PSBcInRvcFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnR5cGUgPT0gXCJpbnRlcnBvbGF0aW9uXCIgfHwgY3gudHlwZSA9PSBcInJlc3RyaWN0ZWRfYXRCbG9ja1wiKSkge1xuICAgICAgICAgIC8vIFJlc3VtZSBpbmRlbnRhdGlvbiBmcm9tIHBhcmVudCBjb250ZXh0LlxuICAgICAgICAgIGN4ID0gY3gucHJldjtcbiAgICAgICAgICBpbmRlbnQgPSBjeC5pbmRlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIpXCIgJiYgKGN4LnR5cGUgPT0gXCJwYXJlbnNcIiB8fCBjeC50eXBlID09IFwiYXRCbG9ja19wYXJlbnNcIikgfHxcbiAgICAgICAgICAgIGNoID09IFwie1wiICYmIChjeC50eXBlID09IFwiYXRcIiB8fCBjeC50eXBlID09IFwiYXRCbG9ja1wiKSkge1xuICAgICAgICAgIC8vIERlZGVudCByZWxhdGl2ZSB0byBjdXJyZW50IGNvbnRleHQuXG4gICAgICAgICAgaW5kZW50ID0gTWF0aC5tYXgoMCwgY3guaW5kZW50IC0gaW5kZW50VW5pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbmRlbnQ7XG4gICAgfSxcblxuICAgIGVsZWN0cmljQ2hhcnM6IFwifVwiLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIi8qXCIsXG4gICAgYmxvY2tDb21tZW50RW5kOiBcIiovXCIsXG4gICAgYmxvY2tDb21tZW50Q29udGludWU6IFwiICogXCIsXG4gICAgbGluZUNvbW1lbnQ6IGxpbmVDb21tZW50LFxuICAgIGZvbGQ6IFwiYnJhY2VcIlxuICB9O1xufSk7XG5cbiAgZnVuY3Rpb24ga2V5U2V0KGFycmF5KSB7XG4gICAgdmFyIGtleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBrZXlzW2FycmF5W2ldLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRUeXBlc18gPSBbXG4gICAgXCJkb21haW5cIiwgXCJyZWdleHBcIiwgXCJ1cmxcIiwgXCJ1cmwtcHJlZml4XCJcbiAgXSwgZG9jdW1lbnRUeXBlcyA9IGtleVNldChkb2N1bWVudFR5cGVzXyk7XG5cbiAgdmFyIG1lZGlhVHlwZXNfID0gW1xuICAgIFwiYWxsXCIsIFwiYXVyYWxcIiwgXCJicmFpbGxlXCIsIFwiaGFuZGhlbGRcIiwgXCJwcmludFwiLCBcInByb2plY3Rpb25cIiwgXCJzY3JlZW5cIixcbiAgICBcInR0eVwiLCBcInR2XCIsIFwiZW1ib3NzZWRcIlxuICBdLCBtZWRpYVR5cGVzID0ga2V5U2V0KG1lZGlhVHlwZXNfKTtcblxuICB2YXIgbWVkaWFGZWF0dXJlc18gPSBbXG4gICAgXCJ3aWR0aFwiLCBcIm1pbi13aWR0aFwiLCBcIm1heC13aWR0aFwiLCBcImhlaWdodFwiLCBcIm1pbi1oZWlnaHRcIiwgXCJtYXgtaGVpZ2h0XCIsXG4gICAgXCJkZXZpY2Utd2lkdGhcIiwgXCJtaW4tZGV2aWNlLXdpZHRoXCIsIFwibWF4LWRldmljZS13aWR0aFwiLCBcImRldmljZS1oZWlnaHRcIixcbiAgICBcIm1pbi1kZXZpY2UtaGVpZ2h0XCIsIFwibWF4LWRldmljZS1oZWlnaHRcIiwgXCJhc3BlY3QtcmF0aW9cIixcbiAgICBcIm1pbi1hc3BlY3QtcmF0aW9cIiwgXCJtYXgtYXNwZWN0LXJhdGlvXCIsIFwiZGV2aWNlLWFzcGVjdC1yYXRpb1wiLFxuICAgIFwibWluLWRldmljZS1hc3BlY3QtcmF0aW9cIiwgXCJtYXgtZGV2aWNlLWFzcGVjdC1yYXRpb1wiLCBcImNvbG9yXCIsIFwibWluLWNvbG9yXCIsXG4gICAgXCJtYXgtY29sb3JcIiwgXCJjb2xvci1pbmRleFwiLCBcIm1pbi1jb2xvci1pbmRleFwiLCBcIm1heC1jb2xvci1pbmRleFwiLFxuICAgIFwibW9ub2Nocm9tZVwiLCBcIm1pbi1tb25vY2hyb21lXCIsIFwibWF4LW1vbm9jaHJvbWVcIiwgXCJyZXNvbHV0aW9uXCIsXG4gICAgXCJtaW4tcmVzb2x1dGlvblwiLCBcIm1heC1yZXNvbHV0aW9uXCIsIFwic2NhblwiLCBcImdyaWRcIiwgXCJvcmllbnRhdGlvblwiLFxuICAgIFwiZGV2aWNlLXBpeGVsLXJhdGlvXCIsIFwibWluLWRldmljZS1waXhlbC1yYXRpb1wiLCBcIm1heC1kZXZpY2UtcGl4ZWwtcmF0aW9cIixcbiAgICBcInBvaW50ZXJcIiwgXCJhbnktcG9pbnRlclwiLCBcImhvdmVyXCIsIFwiYW55LWhvdmVyXCIsIFwicHJlZmVycy1jb2xvci1zY2hlbWVcIlxuICBdLCBtZWRpYUZlYXR1cmVzID0ga2V5U2V0KG1lZGlhRmVhdHVyZXNfKTtcblxuICB2YXIgbWVkaWFWYWx1ZUtleXdvcmRzXyA9IFtcbiAgICBcImxhbmRzY2FwZVwiLCBcInBvcnRyYWl0XCIsIFwibm9uZVwiLCBcImNvYXJzZVwiLCBcImZpbmVcIiwgXCJvbi1kZW1hbmRcIiwgXCJob3ZlclwiLFxuICAgIFwiaW50ZXJsYWNlXCIsIFwicHJvZ3Jlc3NpdmVcIixcbiAgICBcImRhcmtcIiwgXCJsaWdodFwiXG4gIF0sIG1lZGlhVmFsdWVLZXl3b3JkcyA9IGtleVNldChtZWRpYVZhbHVlS2V5d29yZHNfKTtcblxuICB2YXIgcHJvcGVydHlLZXl3b3Jkc18gPSBbXG4gICAgXCJhbGlnbi1jb250ZW50XCIsIFwiYWxpZ24taXRlbXNcIiwgXCJhbGlnbi1zZWxmXCIsIFwiYWxpZ25tZW50LWFkanVzdFwiLFxuICAgIFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwiYWxsXCIsIFwiYW5jaG9yLXBvaW50XCIsIFwiYW5pbWF0aW9uXCIsIFwiYW5pbWF0aW9uLWRlbGF5XCIsXG4gICAgXCJhbmltYXRpb24tZGlyZWN0aW9uXCIsIFwiYW5pbWF0aW9uLWR1cmF0aW9uXCIsIFwiYW5pbWF0aW9uLWZpbGwtbW9kZVwiLFxuICAgIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiLCBcImFuaW1hdGlvbi1uYW1lXCIsIFwiYW5pbWF0aW9uLXBsYXktc3RhdGVcIixcbiAgICBcImFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb25cIiwgXCJhcHBlYXJhbmNlXCIsIFwiYXppbXV0aFwiLCBcImJhY2tkcm9wLWZpbHRlclwiLFxuICAgIFwiYmFja2ZhY2UtdmlzaWJpbGl0eVwiLCBcImJhY2tncm91bmRcIiwgXCJiYWNrZ3JvdW5kLWF0dGFjaG1lbnRcIixcbiAgICBcImJhY2tncm91bmQtYmxlbmQtbW9kZVwiLCBcImJhY2tncm91bmQtY2xpcFwiLCBcImJhY2tncm91bmQtY29sb3JcIixcbiAgICBcImJhY2tncm91bmQtaW1hZ2VcIiwgXCJiYWNrZ3JvdW5kLW9yaWdpblwiLCBcImJhY2tncm91bmQtcG9zaXRpb25cIixcbiAgICBcImJhY2tncm91bmQtcG9zaXRpb24teFwiLCBcImJhY2tncm91bmQtcG9zaXRpb24teVwiLCBcImJhY2tncm91bmQtcmVwZWF0XCIsXG4gICAgXCJiYWNrZ3JvdW5kLXNpemVcIiwgXCJiYXNlbGluZS1zaGlmdFwiLCBcImJpbmRpbmdcIiwgXCJibGVlZFwiLCBcImJsb2NrLXNpemVcIixcbiAgICBcImJvb2ttYXJrLWxhYmVsXCIsIFwiYm9va21hcmstbGV2ZWxcIiwgXCJib29rbWFyay1zdGF0ZVwiLCBcImJvb2ttYXJrLXRhcmdldFwiLFxuICAgIFwiYm9yZGVyXCIsIFwiYm9yZGVyLWJvdHRvbVwiLCBcImJvcmRlci1ib3R0b20tY29sb3JcIiwgXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXG4gICAgXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLCBcImJvcmRlci1ib3R0b20tc3R5bGVcIiwgXCJib3JkZXItYm90dG9tLXdpZHRoXCIsXG4gICAgXCJib3JkZXItY29sbGFwc2VcIiwgXCJib3JkZXItY29sb3JcIiwgXCJib3JkZXItaW1hZ2VcIiwgXCJib3JkZXItaW1hZ2Utb3V0c2V0XCIsXG4gICAgXCJib3JkZXItaW1hZ2UtcmVwZWF0XCIsIFwiYm9yZGVyLWltYWdlLXNsaWNlXCIsIFwiYm9yZGVyLWltYWdlLXNvdXJjZVwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXdpZHRoXCIsIFwiYm9yZGVyLWxlZnRcIiwgXCJib3JkZXItbGVmdC1jb2xvclwiLCBcImJvcmRlci1sZWZ0LXN0eWxlXCIsXG4gICAgXCJib3JkZXItbGVmdC13aWR0aFwiLCBcImJvcmRlci1yYWRpdXNcIiwgXCJib3JkZXItcmlnaHRcIiwgXCJib3JkZXItcmlnaHQtY29sb3JcIixcbiAgICBcImJvcmRlci1yaWdodC1zdHlsZVwiLCBcImJvcmRlci1yaWdodC13aWR0aFwiLCBcImJvcmRlci1zcGFjaW5nXCIsIFwiYm9yZGVyLXN0eWxlXCIsXG4gICAgXCJib3JkZXItdG9wXCIsIFwiYm9yZGVyLXRvcC1jb2xvclwiLCBcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIixcbiAgICBcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsIFwiYm9yZGVyLXRvcC1zdHlsZVwiLCBcImJvcmRlci10b3Atd2lkdGhcIixcbiAgICBcImJvcmRlci13aWR0aFwiLCBcImJvdHRvbVwiLCBcImJveC1kZWNvcmF0aW9uLWJyZWFrXCIsIFwiYm94LXNoYWRvd1wiLCBcImJveC1zaXppbmdcIixcbiAgICBcImJyZWFrLWFmdGVyXCIsIFwiYnJlYWstYmVmb3JlXCIsIFwiYnJlYWstaW5zaWRlXCIsIFwiY2FwdGlvbi1zaWRlXCIsIFwiY2FyZXQtY29sb3JcIixcbiAgICBcImNsZWFyXCIsIFwiY2xpcFwiLCBcImNvbG9yXCIsIFwiY29sb3ItcHJvZmlsZVwiLCBcImNvbHVtbi1jb3VudFwiLCBcImNvbHVtbi1maWxsXCIsXG4gICAgXCJjb2x1bW4tZ2FwXCIsIFwiY29sdW1uLXJ1bGVcIiwgXCJjb2x1bW4tcnVsZS1jb2xvclwiLCBcImNvbHVtbi1ydWxlLXN0eWxlXCIsXG4gICAgXCJjb2x1bW4tcnVsZS13aWR0aFwiLCBcImNvbHVtbi1zcGFuXCIsIFwiY29sdW1uLXdpZHRoXCIsIFwiY29sdW1uc1wiLCBcImNvbnRhaW5cIixcbiAgICBcImNvbnRlbnRcIiwgXCJjb3VudGVyLWluY3JlbWVudFwiLCBcImNvdW50ZXItcmVzZXRcIiwgXCJjcm9wXCIsIFwiY3VlXCIsIFwiY3VlLWFmdGVyXCIsXG4gICAgXCJjdWUtYmVmb3JlXCIsIFwiY3Vyc29yXCIsIFwiZGlyZWN0aW9uXCIsIFwiZGlzcGxheVwiLCBcImRvbWluYW50LWJhc2VsaW5lXCIsXG4gICAgXCJkcm9wLWluaXRpYWwtYWZ0ZXItYWRqdXN0XCIsIFwiZHJvcC1pbml0aWFsLWFmdGVyLWFsaWduXCIsXG4gICAgXCJkcm9wLWluaXRpYWwtYmVmb3JlLWFkanVzdFwiLCBcImRyb3AtaW5pdGlhbC1iZWZvcmUtYWxpZ25cIiwgXCJkcm9wLWluaXRpYWwtc2l6ZVwiLFxuICAgIFwiZHJvcC1pbml0aWFsLXZhbHVlXCIsIFwiZWxldmF0aW9uXCIsIFwiZW1wdHktY2VsbHNcIiwgXCJmaXRcIiwgXCJmaXQtcG9zaXRpb25cIixcbiAgICBcImZsZXhcIiwgXCJmbGV4LWJhc2lzXCIsIFwiZmxleC1kaXJlY3Rpb25cIiwgXCJmbGV4LWZsb3dcIiwgXCJmbGV4LWdyb3dcIixcbiAgICBcImZsZXgtc2hyaW5rXCIsIFwiZmxleC13cmFwXCIsIFwiZmxvYXRcIiwgXCJmbG9hdC1vZmZzZXRcIiwgXCJmbG93LWZyb21cIiwgXCJmbG93LWludG9cIixcbiAgICBcImZvbnRcIiwgXCJmb250LWZhbWlseVwiLCBcImZvbnQtZmVhdHVyZS1zZXR0aW5nc1wiLCBcImZvbnQta2VybmluZ1wiLFxuICAgIFwiZm9udC1sYW5ndWFnZS1vdmVycmlkZVwiLCBcImZvbnQtb3B0aWNhbC1zaXppbmdcIiwgXCJmb250LXNpemVcIixcbiAgICBcImZvbnQtc2l6ZS1hZGp1c3RcIiwgXCJmb250LXN0cmV0Y2hcIiwgXCJmb250LXN0eWxlXCIsIFwiZm9udC1zeW50aGVzaXNcIixcbiAgICBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtdmFyaWFudC1hbHRlcm5hdGVzXCIsIFwiZm9udC12YXJpYW50LWNhcHNcIixcbiAgICBcImZvbnQtdmFyaWFudC1lYXN0LWFzaWFuXCIsIFwiZm9udC12YXJpYW50LWxpZ2F0dXJlc1wiLCBcImZvbnQtdmFyaWFudC1udW1lcmljXCIsXG4gICAgXCJmb250LXZhcmlhbnQtcG9zaXRpb25cIiwgXCJmb250LXZhcmlhdGlvbi1zZXR0aW5nc1wiLCBcImZvbnQtd2VpZ2h0XCIsIFwiZ2FwXCIsXG4gICAgXCJncmlkXCIsIFwiZ3JpZC1hcmVhXCIsIFwiZ3JpZC1hdXRvLWNvbHVtbnNcIiwgXCJncmlkLWF1dG8tZmxvd1wiLCBcImdyaWQtYXV0by1yb3dzXCIsXG4gICAgXCJncmlkLWNvbHVtblwiLCBcImdyaWQtY29sdW1uLWVuZFwiLCBcImdyaWQtY29sdW1uLWdhcFwiLCBcImdyaWQtY29sdW1uLXN0YXJ0XCIsXG4gICAgXCJncmlkLWdhcFwiLCBcImdyaWQtcm93XCIsIFwiZ3JpZC1yb3ctZW5kXCIsIFwiZ3JpZC1yb3ctZ2FwXCIsIFwiZ3JpZC1yb3ctc3RhcnRcIixcbiAgICBcImdyaWQtdGVtcGxhdGVcIiwgXCJncmlkLXRlbXBsYXRlLWFyZWFzXCIsIFwiZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zXCIsXG4gICAgXCJncmlkLXRlbXBsYXRlLXJvd3NcIiwgXCJoYW5naW5nLXB1bmN0dWF0aW9uXCIsIFwiaGVpZ2h0XCIsIFwiaHlwaGVuc1wiLCBcImljb25cIixcbiAgICBcImltYWdlLW9yaWVudGF0aW9uXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsIFwiaW1hZ2UtcmVzb2x1dGlvblwiLCBcImlubGluZS1ib3gtYWxpZ25cIixcbiAgICBcImluc2V0XCIsIFwiaW5zZXQtYmxvY2tcIiwgXCJpbnNldC1ibG9jay1lbmRcIiwgXCJpbnNldC1ibG9jay1zdGFydFwiLCBcImluc2V0LWlubGluZVwiLFxuICAgIFwiaW5zZXQtaW5saW5lLWVuZFwiLCBcImluc2V0LWlubGluZS1zdGFydFwiLCBcImlzb2xhdGlvblwiLCBcImp1c3RpZnktY29udGVudFwiLFxuICAgIFwianVzdGlmeS1pdGVtc1wiLCBcImp1c3RpZnktc2VsZlwiLCBcImxlZnRcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLCBcImxpbmUtYnJlYWtcIixcbiAgICBcImxpbmUtaGVpZ2h0XCIsIFwibGluZS1oZWlnaHQtc3RlcFwiLCBcImxpbmUtc3RhY2tpbmdcIiwgXCJsaW5lLXN0YWNraW5nLXJ1YnlcIixcbiAgICBcImxpbmUtc3RhY2tpbmctc2hpZnRcIiwgXCJsaW5lLXN0YWNraW5nLXN0cmF0ZWd5XCIsIFwibGlzdC1zdHlsZVwiLFxuICAgIFwibGlzdC1zdHlsZS1pbWFnZVwiLCBcImxpc3Qtc3R5bGUtcG9zaXRpb25cIiwgXCJsaXN0LXN0eWxlLXR5cGVcIiwgXCJtYXJnaW5cIixcbiAgICBcIm1hcmdpbi1ib3R0b21cIiwgXCJtYXJnaW4tbGVmdFwiLCBcIm1hcmdpbi1yaWdodFwiLCBcIm1hcmdpbi10b3BcIiwgXCJtYXJrc1wiLFxuICAgIFwibWFycXVlZS1kaXJlY3Rpb25cIiwgXCJtYXJxdWVlLWxvb3BcIiwgXCJtYXJxdWVlLXBsYXktY291bnRcIiwgXCJtYXJxdWVlLXNwZWVkXCIsXG4gICAgXCJtYXJxdWVlLXN0eWxlXCIsIFwibWFzay1jbGlwXCIsIFwibWFzay1jb21wb3NpdGVcIiwgXCJtYXNrLWltYWdlXCIsIFwibWFzay1tb2RlXCIsXG4gICAgXCJtYXNrLW9yaWdpblwiLCBcIm1hc2stcG9zaXRpb25cIiwgXCJtYXNrLXJlcGVhdFwiLCBcIm1hc2stc2l6ZVwiLFwibWFzay10eXBlXCIsXG4gICAgXCJtYXgtYmxvY2stc2l6ZVwiLCBcIm1heC1oZWlnaHRcIiwgXCJtYXgtaW5saW5lLXNpemVcIixcbiAgICBcIm1heC13aWR0aFwiLCBcIm1pbi1ibG9jay1zaXplXCIsIFwibWluLWhlaWdodFwiLCBcIm1pbi1pbmxpbmUtc2l6ZVwiLCBcIm1pbi13aWR0aFwiLFxuICAgIFwibWl4LWJsZW5kLW1vZGVcIiwgXCJtb3ZlLXRvXCIsIFwibmF2LWRvd25cIiwgXCJuYXYtaW5kZXhcIiwgXCJuYXYtbGVmdFwiLCBcIm5hdi1yaWdodFwiLFxuICAgIFwibmF2LXVwXCIsIFwib2JqZWN0LWZpdFwiLCBcIm9iamVjdC1wb3NpdGlvblwiLCBcIm9mZnNldFwiLCBcIm9mZnNldC1hbmNob3JcIixcbiAgICBcIm9mZnNldC1kaXN0YW5jZVwiLCBcIm9mZnNldC1wYXRoXCIsIFwib2Zmc2V0LXBvc2l0aW9uXCIsIFwib2Zmc2V0LXJvdGF0ZVwiLFxuICAgIFwib3BhY2l0eVwiLCBcIm9yZGVyXCIsIFwib3JwaGFuc1wiLCBcIm91dGxpbmVcIiwgXCJvdXRsaW5lLWNvbG9yXCIsIFwib3V0bGluZS1vZmZzZXRcIixcbiAgICBcIm91dGxpbmUtc3R5bGVcIiwgXCJvdXRsaW5lLXdpZHRoXCIsIFwib3ZlcmZsb3dcIiwgXCJvdmVyZmxvdy1zdHlsZVwiLFxuICAgIFwib3ZlcmZsb3ctd3JhcFwiLCBcIm92ZXJmbG93LXhcIiwgXCJvdmVyZmxvdy15XCIsIFwicGFkZGluZ1wiLCBcInBhZGRpbmctYm90dG9tXCIsXG4gICAgXCJwYWRkaW5nLWxlZnRcIiwgXCJwYWRkaW5nLXJpZ2h0XCIsIFwicGFkZGluZy10b3BcIiwgXCJwYWdlXCIsIFwicGFnZS1icmVhay1hZnRlclwiLFxuICAgIFwicGFnZS1icmVhay1iZWZvcmVcIiwgXCJwYWdlLWJyZWFrLWluc2lkZVwiLCBcInBhZ2UtcG9saWN5XCIsIFwicGF1c2VcIixcbiAgICBcInBhdXNlLWFmdGVyXCIsIFwicGF1c2UtYmVmb3JlXCIsIFwicGVyc3BlY3RpdmVcIiwgXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIiwgXCJwaXRjaFwiLFxuICAgIFwicGl0Y2gtcmFuZ2VcIiwgXCJwbGFjZS1jb250ZW50XCIsIFwicGxhY2UtaXRlbXNcIiwgXCJwbGFjZS1zZWxmXCIsIFwicGxheS1kdXJpbmdcIixcbiAgICBcInBvc2l0aW9uXCIsIFwicHJlc2VudGF0aW9uLWxldmVsXCIsIFwicHVuY3R1YXRpb24tdHJpbVwiLCBcInF1b3Rlc1wiLFxuICAgIFwicmVnaW9uLWJyZWFrLWFmdGVyXCIsIFwicmVnaW9uLWJyZWFrLWJlZm9yZVwiLCBcInJlZ2lvbi1icmVhay1pbnNpZGVcIixcbiAgICBcInJlZ2lvbi1mcmFnbWVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIiwgXCJyZXNpemVcIiwgXCJyZXN0XCIsIFwicmVzdC1hZnRlclwiLFxuICAgIFwicmVzdC1iZWZvcmVcIiwgXCJyaWNobmVzc1wiLCBcInJpZ2h0XCIsIFwicm90YXRlXCIsIFwicm90YXRpb25cIiwgXCJyb3RhdGlvbi1wb2ludFwiLFxuICAgIFwicm93LWdhcFwiLCBcInJ1YnktYWxpZ25cIiwgXCJydWJ5LW92ZXJoYW5nXCIsIFwicnVieS1wb3NpdGlvblwiLCBcInJ1Ynktc3BhblwiLFxuICAgIFwic2NhbGVcIiwgXCJzY3JvbGwtYmVoYXZpb3JcIiwgXCJzY3JvbGwtbWFyZ2luXCIsIFwic2Nyb2xsLW1hcmdpbi1ibG9ja1wiLFxuICAgIFwic2Nyb2xsLW1hcmdpbi1ibG9jay1lbmRcIiwgXCJzY3JvbGwtbWFyZ2luLWJsb2NrLXN0YXJ0XCIsIFwic2Nyb2xsLW1hcmdpbi1ib3R0b21cIixcbiAgICBcInNjcm9sbC1tYXJnaW4taW5saW5lXCIsIFwic2Nyb2xsLW1hcmdpbi1pbmxpbmUtZW5kXCIsXG4gICAgXCJzY3JvbGwtbWFyZ2luLWlubGluZS1zdGFydFwiLCBcInNjcm9sbC1tYXJnaW4tbGVmdFwiLCBcInNjcm9sbC1tYXJnaW4tcmlnaHRcIixcbiAgICBcInNjcm9sbC1tYXJnaW4tdG9wXCIsIFwic2Nyb2xsLXBhZGRpbmdcIiwgXCJzY3JvbGwtcGFkZGluZy1ibG9ja1wiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctYmxvY2stZW5kXCIsIFwic2Nyb2xsLXBhZGRpbmctYmxvY2stc3RhcnRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWJvdHRvbVwiLCBcInNjcm9sbC1wYWRkaW5nLWlubGluZVwiLCBcInNjcm9sbC1wYWRkaW5nLWlubGluZS1lbmRcIixcbiAgICBcInNjcm9sbC1wYWRkaW5nLWlubGluZS1zdGFydFwiLCBcInNjcm9sbC1wYWRkaW5nLWxlZnRcIiwgXCJzY3JvbGwtcGFkZGluZy1yaWdodFwiLFxuICAgIFwic2Nyb2xsLXBhZGRpbmctdG9wXCIsIFwic2Nyb2xsLXNuYXAtYWxpZ25cIiwgXCJzY3JvbGwtc25hcC10eXBlXCIsXG4gICAgXCJzaGFwZS1pbWFnZS10aHJlc2hvbGRcIiwgXCJzaGFwZS1pbnNpZGVcIiwgXCJzaGFwZS1tYXJnaW5cIiwgXCJzaGFwZS1vdXRzaWRlXCIsXG4gICAgXCJzaXplXCIsIFwic3BlYWtcIiwgXCJzcGVhay1hc1wiLCBcInNwZWFrLWhlYWRlclwiLCBcInNwZWFrLW51bWVyYWxcIixcbiAgICBcInNwZWFrLXB1bmN0dWF0aW9uXCIsIFwic3BlZWNoLXJhdGVcIiwgXCJzdHJlc3NcIiwgXCJzdHJpbmctc2V0XCIsIFwidGFiLXNpemVcIixcbiAgICBcInRhYmxlLWxheW91dFwiLCBcInRhcmdldFwiLCBcInRhcmdldC1uYW1lXCIsIFwidGFyZ2V0LW5ld1wiLCBcInRhcmdldC1wb3NpdGlvblwiLFxuICAgIFwidGV4dC1hbGlnblwiLCBcInRleHQtYWxpZ24tbGFzdFwiLCBcInRleHQtY29tYmluZS11cHJpZ2h0XCIsIFwidGV4dC1kZWNvcmF0aW9uXCIsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb24tY29sb3JcIiwgXCJ0ZXh0LWRlY29yYXRpb24tbGluZVwiLCBcInRleHQtZGVjb3JhdGlvbi1za2lwXCIsXG4gICAgXCJ0ZXh0LWRlY29yYXRpb24tc2tpcC1pbmtcIiwgXCJ0ZXh0LWRlY29yYXRpb24tc3R5bGVcIiwgXCJ0ZXh0LWVtcGhhc2lzXCIsXG4gICAgXCJ0ZXh0LWVtcGhhc2lzLWNvbG9yXCIsIFwidGV4dC1lbXBoYXNpcy1wb3NpdGlvblwiLCBcInRleHQtZW1waGFzaXMtc3R5bGVcIixcbiAgICBcInRleHQtaGVpZ2h0XCIsIFwidGV4dC1pbmRlbnRcIiwgXCJ0ZXh0LWp1c3RpZnlcIiwgXCJ0ZXh0LW9yaWVudGF0aW9uXCIsXG4gICAgXCJ0ZXh0LW91dGxpbmVcIiwgXCJ0ZXh0LW92ZXJmbG93XCIsIFwidGV4dC1yZW5kZXJpbmdcIiwgXCJ0ZXh0LXNoYWRvd1wiLFxuICAgIFwidGV4dC1zaXplLWFkanVzdFwiLCBcInRleHQtc3BhY2UtY29sbGFwc2VcIiwgXCJ0ZXh0LXRyYW5zZm9ybVwiLFxuICAgIFwidGV4dC11bmRlcmxpbmUtcG9zaXRpb25cIiwgXCJ0ZXh0LXdyYXBcIiwgXCJ0b3BcIiwgXCJ0b3VjaC1hY3Rpb25cIiwgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm0tb3JpZ2luXCIsXG4gICAgXCJ0cmFuc2Zvcm0tc3R5bGVcIiwgXCJ0cmFuc2l0aW9uXCIsIFwidHJhbnNpdGlvbi1kZWxheVwiLCBcInRyYW5zaXRpb24tZHVyYXRpb25cIixcbiAgICBcInRyYW5zaXRpb24tcHJvcGVydHlcIiwgXCJ0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblwiLCBcInRyYW5zbGF0ZVwiLFxuICAgIFwidW5pY29kZS1iaWRpXCIsIFwidXNlci1zZWxlY3RcIiwgXCJ2ZXJ0aWNhbC1hbGlnblwiLCBcInZpc2liaWxpdHlcIiwgXCJ2b2ljZS1iYWxhbmNlXCIsXG4gICAgXCJ2b2ljZS1kdXJhdGlvblwiLCBcInZvaWNlLWZhbWlseVwiLCBcInZvaWNlLXBpdGNoXCIsIFwidm9pY2UtcmFuZ2VcIiwgXCJ2b2ljZS1yYXRlXCIsXG4gICAgXCJ2b2ljZS1zdHJlc3NcIiwgXCJ2b2ljZS12b2x1bWVcIiwgXCJ2b2x1bWVcIiwgXCJ3aGl0ZS1zcGFjZVwiLCBcIndpZG93c1wiLCBcIndpZHRoXCIsXG4gICAgXCJ3aWxsLWNoYW5nZVwiLCBcIndvcmQtYnJlYWtcIiwgXCJ3b3JkLXNwYWNpbmdcIiwgXCJ3b3JkLXdyYXBcIiwgXCJ3cml0aW5nLW1vZGVcIiwgXCJ6LWluZGV4XCIsXG4gICAgLy8gU1ZHLXNwZWNpZmljXG4gICAgXCJjbGlwLXBhdGhcIiwgXCJjbGlwLXJ1bGVcIiwgXCJtYXNrXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIiwgXCJmaWx0ZXJcIiwgXCJmbG9vZC1jb2xvclwiLFxuICAgIFwiZmxvb2Qtb3BhY2l0eVwiLCBcImxpZ2h0aW5nLWNvbG9yXCIsIFwic3RvcC1jb2xvclwiLCBcInN0b3Atb3BhY2l0eVwiLCBcInBvaW50ZXItZXZlbnRzXCIsXG4gICAgXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsIFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsXG4gICAgXCJjb2xvci1yZW5kZXJpbmdcIiwgXCJmaWxsXCIsIFwiZmlsbC1vcGFjaXR5XCIsIFwiZmlsbC1ydWxlXCIsIFwiaW1hZ2UtcmVuZGVyaW5nXCIsXG4gICAgXCJtYXJrZXJcIiwgXCJtYXJrZXItZW5kXCIsIFwibWFya2VyLW1pZFwiLCBcIm1hcmtlci1zdGFydFwiLCBcInBhaW50LW9yZGVyXCIsIFwic2hhcGUtcmVuZGVyaW5nXCIsIFwic3Ryb2tlXCIsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgXCJzdHJva2UtbGluZWNhcFwiLCBcInN0cm9rZS1saW5lam9pblwiLFxuICAgIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgXCJzdHJva2Utb3BhY2l0eVwiLCBcInN0cm9rZS13aWR0aFwiLCBcInRleHQtcmVuZGVyaW5nXCIsXG4gICAgXCJiYXNlbGluZS1zaGlmdFwiLCBcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLFxuICAgIFwiZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWxcIiwgXCJ0ZXh0LWFuY2hvclwiLCBcIndyaXRpbmctbW9kZVwiLFxuICBdLCBwcm9wZXJ0eUtleXdvcmRzID0ga2V5U2V0KHByb3BlcnR5S2V5d29yZHNfKTtcblxuICB2YXIgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzXyA9IFtcbiAgICBcImJvcmRlci1ibG9ja1wiLCBcImJvcmRlci1ibG9jay1jb2xvclwiLCBcImJvcmRlci1ibG9jay1lbmRcIixcbiAgICBcImJvcmRlci1ibG9jay1lbmQtY29sb3JcIiwgXCJib3JkZXItYmxvY2stZW5kLXN0eWxlXCIsIFwiYm9yZGVyLWJsb2NrLWVuZC13aWR0aFwiLFxuICAgIFwiYm9yZGVyLWJsb2NrLXN0YXJ0XCIsIFwiYm9yZGVyLWJsb2NrLXN0YXJ0LWNvbG9yXCIsIFwiYm9yZGVyLWJsb2NrLXN0YXJ0LXN0eWxlXCIsXG4gICAgXCJib3JkZXItYmxvY2stc3RhcnQtd2lkdGhcIiwgXCJib3JkZXItYmxvY2stc3R5bGVcIiwgXCJib3JkZXItYmxvY2std2lkdGhcIixcbiAgICBcImJvcmRlci1pbmxpbmVcIiwgXCJib3JkZXItaW5saW5lLWNvbG9yXCIsIFwiYm9yZGVyLWlubGluZS1lbmRcIixcbiAgICBcImJvcmRlci1pbmxpbmUtZW5kLWNvbG9yXCIsIFwiYm9yZGVyLWlubGluZS1lbmQtc3R5bGVcIixcbiAgICBcImJvcmRlci1pbmxpbmUtZW5kLXdpZHRoXCIsIFwiYm9yZGVyLWlubGluZS1zdGFydFwiLCBcImJvcmRlci1pbmxpbmUtc3RhcnQtY29sb3JcIixcbiAgICBcImJvcmRlci1pbmxpbmUtc3RhcnQtc3R5bGVcIiwgXCJib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoXCIsXG4gICAgXCJib3JkZXItaW5saW5lLXN0eWxlXCIsIFwiYm9yZGVyLWlubGluZS13aWR0aFwiLCBcIm1hcmdpbi1ibG9ja1wiLFxuICAgIFwibWFyZ2luLWJsb2NrLWVuZFwiLCBcIm1hcmdpbi1ibG9jay1zdGFydFwiLCBcIm1hcmdpbi1pbmxpbmVcIiwgXCJtYXJnaW4taW5saW5lLWVuZFwiLFxuICAgIFwibWFyZ2luLWlubGluZS1zdGFydFwiLCBcInBhZGRpbmctYmxvY2tcIiwgXCJwYWRkaW5nLWJsb2NrLWVuZFwiLFxuICAgIFwicGFkZGluZy1ibG9jay1zdGFydFwiLCBcInBhZGRpbmctaW5saW5lXCIsIFwicGFkZGluZy1pbmxpbmUtZW5kXCIsXG4gICAgXCJwYWRkaW5nLWlubGluZS1zdGFydFwiLCBcInNjcm9sbC1zbmFwLXN0b3BcIiwgXCJzY3JvbGxiYXItM2QtbGlnaHQtY29sb3JcIixcbiAgICBcInNjcm9sbGJhci1hcnJvdy1jb2xvclwiLCBcInNjcm9sbGJhci1iYXNlLWNvbG9yXCIsIFwic2Nyb2xsYmFyLWRhcmstc2hhZG93LWNvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXItZmFjZS1jb2xvclwiLCBcInNjcm9sbGJhci1oaWdobGlnaHQtY29sb3JcIiwgXCJzY3JvbGxiYXItc2hhZG93LWNvbG9yXCIsXG4gICAgXCJzY3JvbGxiYXItdHJhY2stY29sb3JcIiwgXCJzZWFyY2hmaWVsZC1jYW5jZWwtYnV0dG9uXCIsIFwic2VhcmNoZmllbGQtZGVjb3JhdGlvblwiLFxuICAgIFwic2VhcmNoZmllbGQtcmVzdWx0cy1idXR0b25cIiwgXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWRlY29yYXRpb25cIiwgXCJzaGFwZS1pbnNpZGVcIiwgXCJ6b29tXCJcbiAgXSwgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzID0ga2V5U2V0KG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkc18pO1xuXG4gIHZhciBmb250UHJvcGVydGllc18gPSBbXG4gICAgXCJmb250LWRpc3BsYXlcIiwgXCJmb250LWZhbWlseVwiLCBcInNyY1wiLCBcInVuaWNvZGUtcmFuZ2VcIiwgXCJmb250LXZhcmlhbnRcIixcbiAgICAgXCJmb250LWZlYXR1cmUtc2V0dGluZ3NcIiwgXCJmb250LXN0cmV0Y2hcIiwgXCJmb250LXdlaWdodFwiLCBcImZvbnQtc3R5bGVcIlxuICBdLCBmb250UHJvcGVydGllcyA9IGtleVNldChmb250UHJvcGVydGllc18pO1xuXG4gIHZhciBjb3VudGVyRGVzY3JpcHRvcnNfID0gW1xuICAgIFwiYWRkaXRpdmUtc3ltYm9sc1wiLCBcImZhbGxiYWNrXCIsIFwibmVnYXRpdmVcIiwgXCJwYWRcIiwgXCJwcmVmaXhcIiwgXCJyYW5nZVwiLFxuICAgIFwic3BlYWstYXNcIiwgXCJzdWZmaXhcIiwgXCJzeW1ib2xzXCIsIFwic3lzdGVtXCJcbiAgXSwgY291bnRlckRlc2NyaXB0b3JzID0ga2V5U2V0KGNvdW50ZXJEZXNjcmlwdG9yc18pO1xuXG4gIHZhciBjb2xvcktleXdvcmRzXyA9IFtcbiAgICBcImFsaWNlYmx1ZVwiLCBcImFudGlxdWV3aGl0ZVwiLCBcImFxdWFcIiwgXCJhcXVhbWFyaW5lXCIsIFwiYXp1cmVcIiwgXCJiZWlnZVwiLFxuICAgIFwiYmlzcXVlXCIsIFwiYmxhY2tcIiwgXCJibGFuY2hlZGFsbW9uZFwiLCBcImJsdWVcIiwgXCJibHVldmlvbGV0XCIsIFwiYnJvd25cIixcbiAgICBcImJ1cmx5d29vZFwiLCBcImNhZGV0Ymx1ZVwiLCBcImNoYXJ0cmV1c2VcIiwgXCJjaG9jb2xhdGVcIiwgXCJjb3JhbFwiLCBcImNvcm5mbG93ZXJibHVlXCIsXG4gICAgXCJjb3Juc2lsa1wiLCBcImNyaW1zb25cIiwgXCJjeWFuXCIsIFwiZGFya2JsdWVcIiwgXCJkYXJrY3lhblwiLCBcImRhcmtnb2xkZW5yb2RcIixcbiAgICBcImRhcmtncmF5XCIsIFwiZGFya2dyZWVuXCIsIFwiZGFya2toYWtpXCIsIFwiZGFya21hZ2VudGFcIiwgXCJkYXJrb2xpdmVncmVlblwiLFxuICAgIFwiZGFya29yYW5nZVwiLCBcImRhcmtvcmNoaWRcIiwgXCJkYXJrcmVkXCIsIFwiZGFya3NhbG1vblwiLCBcImRhcmtzZWFncmVlblwiLFxuICAgIFwiZGFya3NsYXRlYmx1ZVwiLCBcImRhcmtzbGF0ZWdyYXlcIiwgXCJkYXJrdHVycXVvaXNlXCIsIFwiZGFya3Zpb2xldFwiLFxuICAgIFwiZGVlcHBpbmtcIiwgXCJkZWVwc2t5Ymx1ZVwiLCBcImRpbWdyYXlcIiwgXCJkb2RnZXJibHVlXCIsIFwiZmlyZWJyaWNrXCIsXG4gICAgXCJmbG9yYWx3aGl0ZVwiLCBcImZvcmVzdGdyZWVuXCIsIFwiZnVjaHNpYVwiLCBcImdhaW5zYm9yb1wiLCBcImdob3N0d2hpdGVcIixcbiAgICBcImdvbGRcIiwgXCJnb2xkZW5yb2RcIiwgXCJncmF5XCIsIFwiZ3JleVwiLCBcImdyZWVuXCIsIFwiZ3JlZW55ZWxsb3dcIiwgXCJob25leWRld1wiLFxuICAgIFwiaG90cGlua1wiLCBcImluZGlhbnJlZFwiLCBcImluZGlnb1wiLCBcIml2b3J5XCIsIFwia2hha2lcIiwgXCJsYXZlbmRlclwiLFxuICAgIFwibGF2ZW5kZXJibHVzaFwiLCBcImxhd25ncmVlblwiLCBcImxlbW9uY2hpZmZvblwiLCBcImxpZ2h0Ymx1ZVwiLCBcImxpZ2h0Y29yYWxcIixcbiAgICBcImxpZ2h0Y3lhblwiLCBcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIFwibGlnaHRncmF5XCIsIFwibGlnaHRncmVlblwiLCBcImxpZ2h0cGlua1wiLFxuICAgIFwibGlnaHRzYWxtb25cIiwgXCJsaWdodHNlYWdyZWVuXCIsIFwibGlnaHRza3libHVlXCIsIFwibGlnaHRzbGF0ZWdyYXlcIixcbiAgICBcImxpZ2h0c3RlZWxibHVlXCIsIFwibGlnaHR5ZWxsb3dcIiwgXCJsaW1lXCIsIFwibGltZWdyZWVuXCIsIFwibGluZW5cIiwgXCJtYWdlbnRhXCIsXG4gICAgXCJtYXJvb25cIiwgXCJtZWRpdW1hcXVhbWFyaW5lXCIsIFwibWVkaXVtYmx1ZVwiLCBcIm1lZGl1bW9yY2hpZFwiLCBcIm1lZGl1bXB1cnBsZVwiLFxuICAgIFwibWVkaXVtc2VhZ3JlZW5cIiwgXCJtZWRpdW1zbGF0ZWJsdWVcIiwgXCJtZWRpdW1zcHJpbmdncmVlblwiLCBcIm1lZGl1bXR1cnF1b2lzZVwiLFxuICAgIFwibWVkaXVtdmlvbGV0cmVkXCIsIFwibWlkbmlnaHRibHVlXCIsIFwibWludGNyZWFtXCIsIFwibWlzdHlyb3NlXCIsIFwibW9jY2FzaW5cIixcbiAgICBcIm5hdmFqb3doaXRlXCIsIFwibmF2eVwiLCBcIm9sZGxhY2VcIiwgXCJvbGl2ZVwiLCBcIm9saXZlZHJhYlwiLCBcIm9yYW5nZVwiLCBcIm9yYW5nZXJlZFwiLFxuICAgIFwib3JjaGlkXCIsIFwicGFsZWdvbGRlbnJvZFwiLCBcInBhbGVncmVlblwiLCBcInBhbGV0dXJxdW9pc2VcIiwgXCJwYWxldmlvbGV0cmVkXCIsXG4gICAgXCJwYXBheWF3aGlwXCIsIFwicGVhY2hwdWZmXCIsIFwicGVydVwiLCBcInBpbmtcIiwgXCJwbHVtXCIsIFwicG93ZGVyYmx1ZVwiLFxuICAgIFwicHVycGxlXCIsIFwicmViZWNjYXB1cnBsZVwiLCBcInJlZFwiLCBcInJvc3licm93blwiLCBcInJveWFsYmx1ZVwiLCBcInNhZGRsZWJyb3duXCIsXG4gICAgXCJzYWxtb25cIiwgXCJzYW5keWJyb3duXCIsIFwic2VhZ3JlZW5cIiwgXCJzZWFzaGVsbFwiLCBcInNpZW5uYVwiLCBcInNpbHZlclwiLCBcInNreWJsdWVcIixcbiAgICBcInNsYXRlYmx1ZVwiLCBcInNsYXRlZ3JheVwiLCBcInNub3dcIiwgXCJzcHJpbmdncmVlblwiLCBcInN0ZWVsYmx1ZVwiLCBcInRhblwiLFxuICAgIFwidGVhbFwiLCBcInRoaXN0bGVcIiwgXCJ0b21hdG9cIiwgXCJ0dXJxdW9pc2VcIiwgXCJ2aW9sZXRcIiwgXCJ3aGVhdFwiLCBcIndoaXRlXCIsXG4gICAgXCJ3aGl0ZXNtb2tlXCIsIFwieWVsbG93XCIsIFwieWVsbG93Z3JlZW5cIlxuICBdLCBjb2xvcktleXdvcmRzID0ga2V5U2V0KGNvbG9yS2V5d29yZHNfKTtcblxuICB2YXIgdmFsdWVLZXl3b3Jkc18gPSBbXG4gICAgXCJhYm92ZVwiLCBcImFic29sdXRlXCIsIFwiYWN0aXZlYm9yZGVyXCIsIFwiYWRkaXRpdmVcIiwgXCJhY3RpdmVjYXB0aW9uXCIsIFwiYWZhclwiLFxuICAgIFwiYWZ0ZXItd2hpdGUtc3BhY2VcIiwgXCJhaGVhZFwiLCBcImFsaWFzXCIsIFwiYWxsXCIsIFwiYWxsLXNjcm9sbFwiLCBcImFscGhhYmV0aWNcIiwgXCJhbHRlcm5hdGVcIixcbiAgICBcImFsd2F5c1wiLCBcImFtaGFyaWNcIiwgXCJhbWhhcmljLWFiZWdlZGVcIiwgXCJhbnRpYWxpYXNlZFwiLCBcImFwcHdvcmtzcGFjZVwiLFxuICAgIFwiYXJhYmljLWluZGljXCIsIFwiYXJtZW5pYW5cIiwgXCJhc3Rlcmlza3NcIiwgXCJhdHRyXCIsIFwiYXV0b1wiLCBcImF1dG8tZmxvd1wiLCBcImF2b2lkXCIsIFwiYXZvaWQtY29sdW1uXCIsIFwiYXZvaWQtcGFnZVwiLFxuICAgIFwiYXZvaWQtcmVnaW9uXCIsIFwiYXhpcy1wYW5cIiwgXCJiYWNrZ3JvdW5kXCIsIFwiYmFja3dhcmRzXCIsIFwiYmFzZWxpbmVcIiwgXCJiZWxvd1wiLCBcImJpZGktb3ZlcnJpZGVcIiwgXCJiaW5hcnlcIixcbiAgICBcImJlbmdhbGlcIiwgXCJibGlua1wiLCBcImJsb2NrXCIsIFwiYmxvY2stYXhpc1wiLCBcImJvbGRcIiwgXCJib2xkZXJcIiwgXCJib3JkZXJcIiwgXCJib3JkZXItYm94XCIsXG4gICAgXCJib3RoXCIsIFwiYm90dG9tXCIsIFwiYnJlYWtcIiwgXCJicmVhay1hbGxcIiwgXCJicmVhay13b3JkXCIsIFwiYnVsbGV0c1wiLCBcImJ1dHRvblwiLCBcImJ1dHRvbi1iZXZlbFwiLFxuICAgIFwiYnV0dG9uZmFjZVwiLCBcImJ1dHRvbmhpZ2hsaWdodFwiLCBcImJ1dHRvbnNoYWRvd1wiLCBcImJ1dHRvbnRleHRcIiwgXCJjYWxjXCIsIFwiY2FtYm9kaWFuXCIsXG4gICAgXCJjYXBpdGFsaXplXCIsIFwiY2Fwcy1sb2NrLWluZGljYXRvclwiLCBcImNhcHRpb25cIiwgXCJjYXB0aW9udGV4dFwiLCBcImNhcmV0XCIsXG4gICAgXCJjZWxsXCIsIFwiY2VudGVyXCIsIFwiY2hlY2tib3hcIiwgXCJjaXJjbGVcIiwgXCJjamstZGVjaW1hbFwiLCBcImNqay1lYXJ0aGx5LWJyYW5jaFwiLFxuICAgIFwiY2prLWhlYXZlbmx5LXN0ZW1cIiwgXCJjamstaWRlb2dyYXBoaWNcIiwgXCJjbGVhclwiLCBcImNsaXBcIiwgXCJjbG9zZS1xdW90ZVwiLFxuICAgIFwiY29sLXJlc2l6ZVwiLCBcImNvbGxhcHNlXCIsIFwiY29sb3JcIiwgXCJjb2xvci1idXJuXCIsIFwiY29sb3ItZG9kZ2VcIiwgXCJjb2x1bW5cIiwgXCJjb2x1bW4tcmV2ZXJzZVwiLFxuICAgIFwiY29tcGFjdFwiLCBcImNvbmRlbnNlZFwiLCBcImNvbnRhaW5cIiwgXCJjb250ZW50XCIsIFwiY29udGVudHNcIixcbiAgICBcImNvbnRlbnQtYm94XCIsIFwiY29udGV4dC1tZW51XCIsIFwiY29udGludW91c1wiLCBcImNvcHlcIiwgXCJjb3VudGVyXCIsIFwiY291bnRlcnNcIiwgXCJjb3ZlclwiLCBcImNyb3BcIixcbiAgICBcImNyb3NzXCIsIFwiY3Jvc3NoYWlyXCIsIFwiY3VycmVudGNvbG9yXCIsIFwiY3Vyc2l2ZVwiLCBcImN5Y2xpY1wiLCBcImRhcmtlblwiLCBcImRhc2hlZFwiLCBcImRlY2ltYWxcIixcbiAgICBcImRlY2ltYWwtbGVhZGluZy16ZXJvXCIsIFwiZGVmYXVsdFwiLCBcImRlZmF1bHQtYnV0dG9uXCIsIFwiZGVuc2VcIiwgXCJkZXN0aW5hdGlvbi1hdG9wXCIsXG4gICAgXCJkZXN0aW5hdGlvbi1pblwiLCBcImRlc3RpbmF0aW9uLW91dFwiLCBcImRlc3RpbmF0aW9uLW92ZXJcIiwgXCJkZXZhbmFnYXJpXCIsIFwiZGlmZmVyZW5jZVwiLFxuICAgIFwiZGlzY1wiLCBcImRpc2NhcmRcIiwgXCJkaXNjbG9zdXJlLWNsb3NlZFwiLCBcImRpc2Nsb3N1cmUtb3BlblwiLCBcImRvY3VtZW50XCIsXG4gICAgXCJkb3QtZGFzaFwiLCBcImRvdC1kb3QtZGFzaFwiLFxuICAgIFwiZG90dGVkXCIsIFwiZG91YmxlXCIsIFwiZG93blwiLCBcImUtcmVzaXplXCIsIFwiZWFzZVwiLCBcImVhc2UtaW5cIiwgXCJlYXNlLWluLW91dFwiLCBcImVhc2Utb3V0XCIsXG4gICAgXCJlbGVtZW50XCIsIFwiZWxsaXBzZVwiLCBcImVsbGlwc2lzXCIsIFwiZW1iZWRcIiwgXCJlbmRcIiwgXCJldGhpb3BpY1wiLCBcImV0aGlvcGljLWFiZWdlZGVcIixcbiAgICBcImV0aGlvcGljLWFiZWdlZGUtYW0tZXRcIiwgXCJldGhpb3BpYy1hYmVnZWRlLWdlelwiLCBcImV0aGlvcGljLWFiZWdlZGUtdGktZXJcIixcbiAgICBcImV0aGlvcGljLWFiZWdlZGUtdGktZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1hYS1lclwiLFxuICAgIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXRcIiwgXCJldGhpb3BpYy1oYWxlaGFtZS1hbS1ldFwiLFxuICAgIFwiZXRoaW9waWMtaGFsZWhhbWUtZ2V6XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtb20tZXRcIixcbiAgICBcImV0aGlvcGljLWhhbGVoYW1lLXNpZC1ldFwiLCBcImV0aGlvcGljLWhhbGVoYW1lLXNvLWV0XCIsXG4gICAgXCJldGhpb3BpYy1oYWxlaGFtZS10aS1lclwiLCBcImV0aGlvcGljLWhhbGVoYW1lLXRpLWV0XCIsIFwiZXRoaW9waWMtaGFsZWhhbWUtdGlnXCIsXG4gICAgXCJldGhpb3BpYy1udW1lcmljXCIsIFwiZXctcmVzaXplXCIsIFwiZXhjbHVzaW9uXCIsIFwiZXhwYW5kZWRcIiwgXCJleHRlbmRzXCIsIFwiZXh0cmEtY29uZGVuc2VkXCIsXG4gICAgXCJleHRyYS1leHBhbmRlZFwiLCBcImZhbnRhc3lcIiwgXCJmYXN0XCIsIFwiZmlsbFwiLCBcImZpbGwtYm94XCIsIFwiZml4ZWRcIiwgXCJmbGF0XCIsIFwiZmxleFwiLCBcImZsZXgtZW5kXCIsIFwiZmxleC1zdGFydFwiLCBcImZvb3Rub3Rlc1wiLFxuICAgIFwiZm9yd2FyZHNcIiwgXCJmcm9tXCIsIFwiZ2VvbWV0cmljUHJlY2lzaW9uXCIsIFwiZ2VvcmdpYW5cIiwgXCJncmF5dGV4dFwiLCBcImdyaWRcIiwgXCJncm9vdmVcIixcbiAgICBcImd1amFyYXRpXCIsIFwiZ3VybXVraGlcIiwgXCJoYW5kXCIsIFwiaGFuZ3VsXCIsIFwiaGFuZ3VsLWNvbnNvbmFudFwiLCBcImhhcmQtbGlnaHRcIiwgXCJoZWJyZXdcIixcbiAgICBcImhlbHBcIiwgXCJoaWRkZW5cIiwgXCJoaWRlXCIsIFwiaGlnaGVyXCIsIFwiaGlnaGxpZ2h0XCIsIFwiaGlnaGxpZ2h0dGV4dFwiLFxuICAgIFwiaGlyYWdhbmFcIiwgXCJoaXJhZ2FuYS1pcm9oYVwiLCBcImhvcml6b250YWxcIiwgXCJoc2xcIiwgXCJoc2xhXCIsIFwiaHVlXCIsIFwiaWNvblwiLCBcImlnbm9yZVwiLFxuICAgIFwiaW5hY3RpdmVib3JkZXJcIiwgXCJpbmFjdGl2ZWNhcHRpb25cIiwgXCJpbmFjdGl2ZWNhcHRpb250ZXh0XCIsIFwiaW5maW5pdGVcIixcbiAgICBcImluZm9iYWNrZ3JvdW5kXCIsIFwiaW5mb3RleHRcIiwgXCJpbmhlcml0XCIsIFwiaW5pdGlhbFwiLCBcImlubGluZVwiLCBcImlubGluZS1heGlzXCIsXG4gICAgXCJpbmxpbmUtYmxvY2tcIiwgXCJpbmxpbmUtZmxleFwiLCBcImlubGluZS1ncmlkXCIsIFwiaW5saW5lLXRhYmxlXCIsIFwiaW5zZXRcIiwgXCJpbnNpZGVcIiwgXCJpbnRyaW5zaWNcIiwgXCJpbnZlcnRcIixcbiAgICBcIml0YWxpY1wiLCBcImphcGFuZXNlLWZvcm1hbFwiLCBcImphcGFuZXNlLWluZm9ybWFsXCIsIFwianVzdGlmeVwiLCBcImthbm5hZGFcIixcbiAgICBcImthdGFrYW5hXCIsIFwia2F0YWthbmEtaXJvaGFcIiwgXCJrZWVwLWFsbFwiLCBcImtobWVyXCIsXG4gICAgXCJrb3JlYW4taGFuZ3VsLWZvcm1hbFwiLCBcImtvcmVhbi1oYW5qYS1mb3JtYWxcIiwgXCJrb3JlYW4taGFuamEtaW5mb3JtYWxcIixcbiAgICBcImxhbmRzY2FwZVwiLCBcImxhb1wiLCBcImxhcmdlXCIsIFwibGFyZ2VyXCIsIFwibGVmdFwiLCBcImxldmVsXCIsIFwibGlnaHRlclwiLCBcImxpZ2h0ZW5cIixcbiAgICBcImxpbmUtdGhyb3VnaFwiLCBcImxpbmVhclwiLCBcImxpbmVhci1ncmFkaWVudFwiLCBcImxpbmVzXCIsIFwibGlzdC1pdGVtXCIsIFwibGlzdGJveFwiLCBcImxpc3RpdGVtXCIsXG4gICAgXCJsb2NhbFwiLCBcImxvZ2ljYWxcIiwgXCJsb3VkXCIsIFwibG93ZXJcIiwgXCJsb3dlci1hbHBoYVwiLCBcImxvd2VyLWFybWVuaWFuXCIsXG4gICAgXCJsb3dlci1ncmVla1wiLCBcImxvd2VyLWhleGFkZWNpbWFsXCIsIFwibG93ZXItbGF0aW5cIiwgXCJsb3dlci1ub3J3ZWdpYW5cIixcbiAgICBcImxvd2VyLXJvbWFuXCIsIFwibG93ZXJjYXNlXCIsIFwibHRyXCIsIFwibHVtaW5vc2l0eVwiLCBcIm1hbGF5YWxhbVwiLCBcIm1hbmlwdWxhdGlvblwiLCBcIm1hdGNoXCIsIFwibWF0cml4XCIsIFwibWF0cml4M2RcIixcbiAgICBcIm1lZGlhLWNvbnRyb2xzLWJhY2tncm91bmRcIiwgXCJtZWRpYS1jdXJyZW50LXRpbWUtZGlzcGxheVwiLFxuICAgIFwibWVkaWEtZnVsbHNjcmVlbi1idXR0b25cIiwgXCJtZWRpYS1tdXRlLWJ1dHRvblwiLCBcIm1lZGlhLXBsYXktYnV0dG9uXCIsXG4gICAgXCJtZWRpYS1yZXR1cm4tdG8tcmVhbHRpbWUtYnV0dG9uXCIsIFwibWVkaWEtcmV3aW5kLWJ1dHRvblwiLFxuICAgIFwibWVkaWEtc2Vlay1iYWNrLWJ1dHRvblwiLCBcIm1lZGlhLXNlZWstZm9yd2FyZC1idXR0b25cIiwgXCJtZWRpYS1zbGlkZXJcIixcbiAgICBcIm1lZGlhLXNsaWRlcnRodW1iXCIsIFwibWVkaWEtdGltZS1yZW1haW5pbmctZGlzcGxheVwiLCBcIm1lZGlhLXZvbHVtZS1zbGlkZXJcIixcbiAgICBcIm1lZGlhLXZvbHVtZS1zbGlkZXItY29udGFpbmVyXCIsIFwibWVkaWEtdm9sdW1lLXNsaWRlcnRodW1iXCIsIFwibWVkaXVtXCIsXG4gICAgXCJtZW51XCIsIFwibWVudWxpc3RcIiwgXCJtZW51bGlzdC1idXR0b25cIiwgXCJtZW51bGlzdC10ZXh0XCIsXG4gICAgXCJtZW51bGlzdC10ZXh0ZmllbGRcIiwgXCJtZW51dGV4dFwiLCBcIm1lc3NhZ2UtYm94XCIsIFwibWlkZGxlXCIsIFwibWluLWludHJpbnNpY1wiLFxuICAgIFwibWl4XCIsIFwibW9uZ29saWFuXCIsIFwibW9ub3NwYWNlXCIsIFwibW92ZVwiLCBcIm11bHRpcGxlXCIsIFwibXVsdGlwbGVfbWFza19pbWFnZXNcIiwgXCJtdWx0aXBseVwiLCBcIm15YW5tYXJcIiwgXCJuLXJlc2l6ZVwiLFxuICAgIFwibmFycm93ZXJcIiwgXCJuZS1yZXNpemVcIiwgXCJuZXN3LXJlc2l6ZVwiLCBcIm5vLWNsb3NlLXF1b3RlXCIsIFwibm8tZHJvcFwiLFxuICAgIFwibm8tb3Blbi1xdW90ZVwiLCBcIm5vLXJlcGVhdFwiLCBcIm5vbmVcIiwgXCJub3JtYWxcIiwgXCJub3QtYWxsb3dlZFwiLCBcIm5vd3JhcFwiLFxuICAgIFwibnMtcmVzaXplXCIsIFwibnVtYmVyc1wiLCBcIm51bWVyaWNcIiwgXCJudy1yZXNpemVcIiwgXCJud3NlLXJlc2l6ZVwiLCBcIm9ibGlxdWVcIiwgXCJvY3RhbFwiLCBcIm9wYWNpdHlcIiwgXCJvcGVuLXF1b3RlXCIsXG4gICAgXCJvcHRpbWl6ZUxlZ2liaWxpdHlcIiwgXCJvcHRpbWl6ZVNwZWVkXCIsIFwib3JpeWFcIiwgXCJvcm9tb1wiLCBcIm91dHNldFwiLFxuICAgIFwib3V0c2lkZVwiLCBcIm91dHNpZGUtc2hhcGVcIiwgXCJvdmVybGF5XCIsIFwib3ZlcmxpbmVcIiwgXCJwYWRkaW5nXCIsIFwicGFkZGluZy1ib3hcIixcbiAgICBcInBhaW50ZWRcIiwgXCJwYWdlXCIsIFwicGF1c2VkXCIsIFwicGVyc2lhblwiLCBcInBlcnNwZWN0aXZlXCIsIFwicGluY2gtem9vbVwiLCBcInBsdXMtZGFya2VyXCIsIFwicGx1cy1saWdodGVyXCIsXG4gICAgXCJwb2ludGVyXCIsIFwicG9seWdvblwiLCBcInBvcnRyYWl0XCIsIFwicHJlXCIsIFwicHJlLWxpbmVcIiwgXCJwcmUtd3JhcFwiLCBcInByZXNlcnZlLTNkXCIsXG4gICAgXCJwcm9ncmVzc1wiLCBcInB1c2gtYnV0dG9uXCIsIFwicmFkaWFsLWdyYWRpZW50XCIsIFwicmFkaW9cIiwgXCJyZWFkLW9ubHlcIixcbiAgICBcInJlYWQtd3JpdGVcIiwgXCJyZWFkLXdyaXRlLXBsYWludGV4dC1vbmx5XCIsIFwicmVjdGFuZ2xlXCIsIFwicmVnaW9uXCIsXG4gICAgXCJyZWxhdGl2ZVwiLCBcInJlcGVhdFwiLCBcInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnRcIixcbiAgICBcInJlcGVhdGluZy1yYWRpYWwtZ3JhZGllbnRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIFwicmVzZXRcIiwgXCJyZXZlcnNlXCIsXG4gICAgXCJyZ2JcIiwgXCJyZ2JhXCIsIFwicmlkZ2VcIiwgXCJyaWdodFwiLCBcInJvdGF0ZVwiLCBcInJvdGF0ZTNkXCIsIFwicm90YXRlWFwiLCBcInJvdGF0ZVlcIixcbiAgICBcInJvdGF0ZVpcIiwgXCJyb3VuZFwiLCBcInJvd1wiLCBcInJvdy1yZXNpemVcIiwgXCJyb3ctcmV2ZXJzZVwiLCBcInJ0bFwiLCBcInJ1bi1pblwiLCBcInJ1bm5pbmdcIixcbiAgICBcInMtcmVzaXplXCIsIFwic2Fucy1zZXJpZlwiLCBcInNhdHVyYXRpb25cIiwgXCJzY2FsZVwiLCBcInNjYWxlM2RcIiwgXCJzY2FsZVhcIiwgXCJzY2FsZVlcIiwgXCJzY2FsZVpcIiwgXCJzY3JlZW5cIixcbiAgICBcInNjcm9sbFwiLCBcInNjcm9sbGJhclwiLCBcInNjcm9sbC1wb3NpdGlvblwiLCBcInNlLXJlc2l6ZVwiLCBcInNlYXJjaGZpZWxkXCIsXG4gICAgXCJzZWFyY2hmaWVsZC1jYW5jZWwtYnV0dG9uXCIsIFwic2VhcmNoZmllbGQtZGVjb3JhdGlvblwiLFxuICAgIFwic2VhcmNoZmllbGQtcmVzdWx0cy1idXR0b25cIiwgXCJzZWFyY2hmaWVsZC1yZXN1bHRzLWRlY29yYXRpb25cIiwgXCJzZWxmLXN0YXJ0XCIsIFwic2VsZi1lbmRcIixcbiAgICBcInNlbWktY29uZGVuc2VkXCIsIFwic2VtaS1leHBhbmRlZFwiLCBcInNlcGFyYXRlXCIsIFwic2VyaWZcIiwgXCJzaG93XCIsIFwic2lkYW1hXCIsXG4gICAgXCJzaW1wLWNoaW5lc2UtZm9ybWFsXCIsIFwic2ltcC1jaGluZXNlLWluZm9ybWFsXCIsIFwic2luZ2xlXCIsXG4gICAgXCJza2V3XCIsIFwic2tld1hcIiwgXCJza2V3WVwiLCBcInNraXAtd2hpdGUtc3BhY2VcIiwgXCJzbGlkZVwiLCBcInNsaWRlci1ob3Jpem9udGFsXCIsXG4gICAgXCJzbGlkZXItdmVydGljYWxcIiwgXCJzbGlkZXJ0aHVtYi1ob3Jpem9udGFsXCIsIFwic2xpZGVydGh1bWItdmVydGljYWxcIiwgXCJzbG93XCIsXG4gICAgXCJzbWFsbFwiLCBcInNtYWxsLWNhcHNcIiwgXCJzbWFsbC1jYXB0aW9uXCIsIFwic21hbGxlclwiLCBcInNvZnQtbGlnaHRcIiwgXCJzb2xpZFwiLCBcInNvbWFsaVwiLFxuICAgIFwic291cmNlLWF0b3BcIiwgXCJzb3VyY2UtaW5cIiwgXCJzb3VyY2Utb3V0XCIsIFwic291cmNlLW92ZXJcIiwgXCJzcGFjZVwiLCBcInNwYWNlLWFyb3VuZFwiLCBcInNwYWNlLWJldHdlZW5cIiwgXCJzcGFjZS1ldmVubHlcIiwgXCJzcGVsbC1vdXRcIiwgXCJzcXVhcmVcIixcbiAgICBcInNxdWFyZS1idXR0b25cIiwgXCJzdGFydFwiLCBcInN0YXRpY1wiLCBcInN0YXR1cy1iYXJcIiwgXCJzdHJldGNoXCIsIFwic3Ryb2tlXCIsIFwic3Ryb2tlLWJveFwiLCBcInN1YlwiLFxuICAgIFwic3VicGl4ZWwtYW50aWFsaWFzZWRcIiwgXCJzdmdfbWFza3NcIiwgXCJzdXBlclwiLCBcInN3LXJlc2l6ZVwiLCBcInN5bWJvbGljXCIsIFwic3ltYm9sc1wiLCBcInN5c3RlbS11aVwiLCBcInRhYmxlXCIsXG4gICAgXCJ0YWJsZS1jYXB0aW9uXCIsIFwidGFibGUtY2VsbFwiLCBcInRhYmxlLWNvbHVtblwiLCBcInRhYmxlLWNvbHVtbi1ncm91cFwiLFxuICAgIFwidGFibGUtZm9vdGVyLWdyb3VwXCIsIFwidGFibGUtaGVhZGVyLWdyb3VwXCIsIFwidGFibGUtcm93XCIsIFwidGFibGUtcm93LWdyb3VwXCIsXG4gICAgXCJ0YW1pbFwiLFxuICAgIFwidGVsdWd1XCIsIFwidGV4dFwiLCBcInRleHQtYm90dG9tXCIsIFwidGV4dC10b3BcIiwgXCJ0ZXh0YXJlYVwiLCBcInRleHRmaWVsZFwiLCBcInRoYWlcIixcbiAgICBcInRoaWNrXCIsIFwidGhpblwiLCBcInRocmVlZGRhcmtzaGFkb3dcIiwgXCJ0aHJlZWRmYWNlXCIsIFwidGhyZWVkaGlnaGxpZ2h0XCIsXG4gICAgXCJ0aHJlZWRsaWdodHNoYWRvd1wiLCBcInRocmVlZHNoYWRvd1wiLCBcInRpYmV0YW5cIiwgXCJ0aWdyZVwiLCBcInRpZ3JpbnlhLWVyXCIsXG4gICAgXCJ0aWdyaW55YS1lci1hYmVnZWRlXCIsIFwidGlncmlueWEtZXRcIiwgXCJ0aWdyaW55YS1ldC1hYmVnZWRlXCIsIFwidG9cIiwgXCJ0b3BcIixcbiAgICBcInRyYWQtY2hpbmVzZS1mb3JtYWxcIiwgXCJ0cmFkLWNoaW5lc2UtaW5mb3JtYWxcIiwgXCJ0cmFuc2Zvcm1cIixcbiAgICBcInRyYW5zbGF0ZVwiLCBcInRyYW5zbGF0ZTNkXCIsIFwidHJhbnNsYXRlWFwiLCBcInRyYW5zbGF0ZVlcIiwgXCJ0cmFuc2xhdGVaXCIsXG4gICAgXCJ0cmFuc3BhcmVudFwiLCBcInVsdHJhLWNvbmRlbnNlZFwiLCBcInVsdHJhLWV4cGFuZGVkXCIsIFwidW5kZXJsaW5lXCIsIFwidW5pZGlyZWN0aW9uYWwtcGFuXCIsIFwidW5zZXRcIiwgXCJ1cFwiLFxuICAgIFwidXBwZXItYWxwaGFcIiwgXCJ1cHBlci1hcm1lbmlhblwiLCBcInVwcGVyLWdyZWVrXCIsIFwidXBwZXItaGV4YWRlY2ltYWxcIixcbiAgICBcInVwcGVyLWxhdGluXCIsIFwidXBwZXItbm9yd2VnaWFuXCIsIFwidXBwZXItcm9tYW5cIiwgXCJ1cHBlcmNhc2VcIiwgXCJ1cmR1XCIsIFwidXJsXCIsXG4gICAgXCJ2YXJcIiwgXCJ2ZXJ0aWNhbFwiLCBcInZlcnRpY2FsLXRleHRcIiwgXCJ2aWV3LWJveFwiLCBcInZpc2libGVcIiwgXCJ2aXNpYmxlRmlsbFwiLCBcInZpc2libGVQYWludGVkXCIsXG4gICAgXCJ2aXNpYmxlU3Ryb2tlXCIsIFwidmlzdWFsXCIsIFwidy1yZXNpemVcIiwgXCJ3YWl0XCIsIFwid2F2ZVwiLCBcIndpZGVyXCIsXG4gICAgXCJ3aW5kb3dcIiwgXCJ3aW5kb3dmcmFtZVwiLCBcIndpbmRvd3RleHRcIiwgXCJ3b3Jkc1wiLCBcIndyYXBcIiwgXCJ3cmFwLXJldmVyc2VcIiwgXCJ4LWxhcmdlXCIsIFwieC1zbWFsbFwiLCBcInhvclwiLFxuICAgIFwieHgtbGFyZ2VcIiwgXCJ4eC1zbWFsbFwiXG4gIF0sIHZhbHVlS2V5d29yZHMgPSBrZXlTZXQodmFsdWVLZXl3b3Jkc18pO1xuXG4gIHZhciBhbGxXb3JkcyA9IGRvY3VtZW50VHlwZXNfLmNvbmNhdChtZWRpYVR5cGVzXykuY29uY2F0KG1lZGlhRmVhdHVyZXNfKS5jb25jYXQobWVkaWFWYWx1ZUtleXdvcmRzXylcbiAgICAuY29uY2F0KHByb3BlcnR5S2V5d29yZHNfKS5jb25jYXQobm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzXykuY29uY2F0KGNvbG9yS2V5d29yZHNfKVxuICAgIC5jb25jYXQodmFsdWVLZXl3b3Jkc18pO1xuICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKFwiaGludFdvcmRzXCIsIFwiY3NzXCIsIGFsbFdvcmRzKTtcblxuICBmdW5jdGlvbiB0b2tlbkNDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChtYXliZUVuZCAmJiBjaCA9PSBcIi9cIikge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW1wiY29tbWVudFwiLCBcImNvbW1lbnRcIl07XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2Nzc1wiLCB7XG4gICAgZG9jdW1lbnRUeXBlczogZG9jdW1lbnRUeXBlcyxcbiAgICBtZWRpYVR5cGVzOiBtZWRpYVR5cGVzLFxuICAgIG1lZGlhRmVhdHVyZXM6IG1lZGlhRmVhdHVyZXMsXG4gICAgbWVkaWFWYWx1ZUtleXdvcmRzOiBtZWRpYVZhbHVlS2V5d29yZHMsXG4gICAgcHJvcGVydHlLZXl3b3JkczogcHJvcGVydHlLZXl3b3JkcyxcbiAgICBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHM6IG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyxcbiAgICBmb250UHJvcGVydGllczogZm9udFByb3BlcnRpZXMsXG4gICAgY291bnRlckRlc2NyaXB0b3JzOiBjb3VudGVyRGVzY3JpcHRvcnMsXG4gICAgY29sb3JLZXl3b3JkczogY29sb3JLZXl3b3JkcyxcbiAgICB2YWx1ZUtleXdvcmRzOiB2YWx1ZUtleXdvcmRzLFxuICAgIHRva2VuSG9va3M6IHtcbiAgICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCJcbiAgfSk7XG5cbiAgQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC94LXNjc3NcIiwge1xuICAgIG1lZGlhVHlwZXM6IG1lZGlhVHlwZXMsXG4gICAgbWVkaWFGZWF0dXJlczogbWVkaWFGZWF0dXJlcyxcbiAgICBtZWRpYVZhbHVlS2V5d29yZHM6IG1lZGlhVmFsdWVLZXl3b3JkcyxcbiAgICBwcm9wZXJ0eUtleXdvcmRzOiBwcm9wZXJ0eUtleXdvcmRzLFxuICAgIG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3Jkczogbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICBmb250UHJvcGVydGllczogZm9udFByb3BlcnRpZXMsXG4gICAgYWxsb3dOZXN0ZWQ6IHRydWUsXG4gICAgbGluZUNvbW1lbnQ6IFwiLy9cIixcbiAgICB0b2tlbkhvb2tzOiB7XG4gICAgICBcIi9cIjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICAgICAgcmV0dXJuIFtcImNvbW1lbnRcIiwgXCJjb21tZW50XCJdO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICAgIHJldHVybiB0b2tlbkNDb21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbXCJvcGVyYXRvclwiLCBcIm9wZXJhdG9yXCJdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCI6XCI6IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKC9eXFxzKlxcey8sIGZhbHNlKSlcbiAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBcIiRcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXltcXHctXSsvKTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxccyo6LywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGUtZGVmaW5pdGlvblwiXTtcbiAgICAgICAgcmV0dXJuIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZVwiXTtcbiAgICAgIH0sXG4gICAgICBcIiNcIjogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIntcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFtudWxsLCBcImludGVycG9sYXRpb25cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBcImNzc1wiLFxuICAgIGhlbHBlclR5cGU6IFwic2Nzc1wiXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1sZXNzXCIsIHtcbiAgICBtZWRpYVR5cGVzOiBtZWRpYVR5cGVzLFxuICAgIG1lZGlhRmVhdHVyZXM6IG1lZGlhRmVhdHVyZXMsXG4gICAgbWVkaWFWYWx1ZUtleXdvcmRzOiBtZWRpYVZhbHVlS2V5d29yZHMsXG4gICAgcHJvcGVydHlLZXl3b3JkczogcHJvcGVydHlLZXl3b3JkcyxcbiAgICBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHM6IG5vblN0YW5kYXJkUHJvcGVydHlLZXl3b3JkcyxcbiAgICBjb2xvcktleXdvcmRzOiBjb2xvcktleXdvcmRzLFxuICAgIHZhbHVlS2V5d29yZHM6IHZhbHVlS2V5d29yZHMsXG4gICAgZm9udFByb3BlcnRpZXM6IGZvbnRQcm9wZXJ0aWVzLFxuICAgIGFsbG93TmVzdGVkOiB0cnVlLFxuICAgIGxpbmVDb21tZW50OiBcIi8vXCIsXG4gICAgdG9rZW5Ib29rczoge1xuICAgICAgXCIvXCI6IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICAgIHJldHVybiBbXCJjb21tZW50XCIsIFwiY29tbWVudFwiXTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW1wib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiQFwiOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKSByZXR1cm4gW251bGwsIFwiaW50ZXJwb2xhdGlvblwiXTtcbiAgICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXihjaGFyc2V0fGRvY3VtZW50fGZvbnQtZmFjZXxpbXBvcnR8KC0obW96fG1zfG98d2Via2l0KS0pP2tleWZyYW1lc3xtZWRpYXxuYW1lc3BhY2V8cGFnZXxzdXBwb3J0cylcXGIvaSwgZmFsc2UpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1dLyk7XG4gICAgICAgIGlmIChzdHJlYW0ubWF0Y2goL15cXHMqOi8sIGZhbHNlKSlcbiAgICAgICAgICByZXR1cm4gW1widmFyaWFibGUtMlwiLCBcInZhcmlhYmxlLWRlZmluaXRpb25cIl07XG4gICAgICAgIHJldHVybiBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVcIl07XG4gICAgICB9LFxuICAgICAgXCImXCI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1wiYXRvbVwiLCBcImF0b21cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBcImNzc1wiLFxuICAgIGhlbHBlclR5cGU6IFwibGVzc1wiXG4gIH0pO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQveC1nc3NcIiwge1xuICAgIGRvY3VtZW50VHlwZXM6IGRvY3VtZW50VHlwZXMsXG4gICAgbWVkaWFUeXBlczogbWVkaWFUeXBlcyxcbiAgICBtZWRpYUZlYXR1cmVzOiBtZWRpYUZlYXR1cmVzLFxuICAgIHByb3BlcnR5S2V5d29yZHM6IHByb3BlcnR5S2V5d29yZHMsXG4gICAgbm9uU3RhbmRhcmRQcm9wZXJ0eUtleXdvcmRzOiBub25TdGFuZGFyZFByb3BlcnR5S2V5d29yZHMsXG4gICAgZm9udFByb3BlcnRpZXM6IGZvbnRQcm9wZXJ0aWVzLFxuICAgIGNvdW50ZXJEZXNjcmlwdG9yczogY291bnRlckRlc2NyaXB0b3JzLFxuICAgIGNvbG9yS2V5d29yZHM6IGNvbG9yS2V5d29yZHMsXG4gICAgdmFsdWVLZXl3b3JkczogdmFsdWVLZXl3b3JkcyxcbiAgICBzdXBwb3J0c0F0Q29tcG9uZW50OiB0cnVlLFxuICAgIHRva2VuSG9va3M6IHtcbiAgICAgIFwiL1wiOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIipcIikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgICAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgaGVscGVyVHlwZTogXCJnc3NcIlxuICB9KTtcblxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/css/css.js\n')},"./node_modules/codemirror/mode/htmlmixed/htmlmixed.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"), __webpack_require__(/*! ../xml/xml */ "./node_modules/codemirror/mode/xml/xml.js"), __webpack_require__(/*! ../javascript/javascript */ "./node_modules/codemirror/mode/javascript/javascript.js"), __webpack_require__(/*! ../css/css */ "./node_modules/codemirror/mode/css/css.js"));\n  else {}\n})(function(CodeMirror) {\n  "use strict";\n\n  var defaultTags = {\n    script: [\n      ["lang", /(javascript|babel)/i, "javascript"],\n      ["type", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],\n      ["type", /./, "text/plain"],\n      [null, null, "javascript"]\n    ],\n    style:  [\n      ["lang", /^css$/i, "css"],\n      ["type", /^(text\\/)?(x-)?(stylesheet|css)$/i, "css"],\n      ["type", /./, "text/plain"],\n      [null, null, "css"]\n    ]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(), close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp("\\\\s+" + attr + "\\\\s*=\\\\s*(\'|\\")?([^\'\\"]+)(\'|\\")?\\\\s*");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr))\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : ""\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? "^" : "") + "<\\/\\s*" + tagName + "\\s*>", "i");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--)\n        dest.unshift(source[i])\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: "xml",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,\n      allowMissingTagName: parserConfig.allowMissingTagName,\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) &&\n          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&\n          tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + " "\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag)\n        state.inTag = null\n        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])\n        var mode = CodeMirror.getMode(config, modeSpec)\n        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));\n      } else if (state.inTag) {\n        state.inTag += stream.current()\n        if (stream.eol()) state.inTag += " "\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = CodeMirror.startState(htmlMode);\n        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return {token: state.token, inTag: state.inTag,\n                localMode: state.localMode, localState: local,\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter, line) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n          return htmlMode.indent(state.htmlState, textAfter, line);\n        else if (state.localMode.indent)\n          return state.localMode.indent(state.localState, textAfter, line);\n        else\n          return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n      }\n    };\n  }, "xml", "javascript", "css");\n\n  CodeMirror.defineMIME("text/html", "htmlmixed");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9odG1sbWl4ZWQvaHRtbG1peGVkLmpzP2Q2OWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQixHQUFHLG1CQUFPLENBQUMsNkRBQVksR0FBRyxtQkFBTyxDQUFDLHlGQUEwQixHQUFHLG1CQUFPLENBQUMsNkRBQVk7QUFDekgsT0FBTyxFQUdhO0FBQ3BCLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFFBQVE7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvaHRtbG1peGVkL2h0bWxtaXhlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvZGVNaXJyb3IsIGNvcHlyaWdodCAoYykgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgb3RoZXJzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBhbiBNSVQgbGljZW5zZTogaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC9MSUNFTlNFXG5cbihmdW5jdGlvbihtb2QpIHtcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiKSAvLyBDb21tb25KU1xuICAgIG1vZChyZXF1aXJlKFwiLi4vLi4vbGliL2NvZGVtaXJyb3JcIiksIHJlcXVpcmUoXCIuLi94bWwveG1sXCIpLCByZXF1aXJlKFwiLi4vamF2YXNjcmlwdC9qYXZhc2NyaXB0XCIpLCByZXF1aXJlKFwiLi4vY3NzL2Nzc1wiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiLCBcIi4uL3htbC94bWxcIiwgXCIuLi9qYXZhc2NyaXB0L2phdmFzY3JpcHRcIiwgXCIuLi9jc3MvY3NzXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgZGVmYXVsdFRhZ3MgPSB7XG4gICAgc2NyaXB0OiBbXG4gICAgICBbXCJsYW5nXCIsIC8oamF2YXNjcmlwdHxiYWJlbCkvaSwgXCJqYXZhc2NyaXB0XCJdLFxuICAgICAgW1widHlwZVwiLCAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvKD86eC0pPyg/OmphdmF8ZWNtYSlzY3JpcHQkfF5tb2R1bGUkfF4kL2ksIFwiamF2YXNjcmlwdFwiXSxcbiAgICAgIFtcInR5cGVcIiwgLy4vLCBcInRleHQvcGxhaW5cIl0sXG4gICAgICBbbnVsbCwgbnVsbCwgXCJqYXZhc2NyaXB0XCJdXG4gICAgXSxcbiAgICBzdHlsZTogIFtcbiAgICAgIFtcImxhbmdcIiwgL15jc3MkL2ksIFwiY3NzXCJdLFxuICAgICAgW1widHlwZVwiLCAvXih0ZXh0XFwvKT8oeC0pPyhzdHlsZXNoZWV0fGNzcykkL2ksIFwiY3NzXCJdLFxuICAgICAgW1widHlwZVwiLCAvLi8sIFwidGV4dC9wbGFpblwiXSxcbiAgICAgIFtudWxsLCBudWxsLCBcImNzc1wiXVxuICAgIF1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXliZUJhY2t1cChzdHJlYW0sIHBhdCwgc3R5bGUpIHtcbiAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKSwgY2xvc2UgPSBjdXIuc2VhcmNoKHBhdCk7XG4gICAgaWYgKGNsb3NlID4gLTEpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoY3VyLmxlbmd0aCAtIGNsb3NlKTtcbiAgICB9IGVsc2UgaWYgKGN1ci5tYXRjaCgvPFxcLz8kLykpIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoY3VyLmxlbmd0aCk7XG4gICAgICBpZiAoIXN0cmVhbS5tYXRjaChwYXQsIGZhbHNlKSkgc3RyZWFtLm1hdGNoKGN1cik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4gIHZhciBhdHRyUmVnZXhwQ2FjaGUgPSB7fTtcbiAgZnVuY3Rpb24gZ2V0QXR0clJlZ2V4cChhdHRyKSB7XG4gICAgdmFyIHJlZ2V4cCA9IGF0dHJSZWdleHBDYWNoZVthdHRyXTtcbiAgICBpZiAocmVnZXhwKSByZXR1cm4gcmVnZXhwO1xuICAgIHJldHVybiBhdHRyUmVnZXhwQ2FjaGVbYXR0cl0gPSBuZXcgUmVnRXhwKFwiXFxcXHMrXCIgKyBhdHRyICsgXCJcXFxccyo9XFxcXHMqKCd8XFxcIik/KFteJ1xcXCJdKykoJ3xcXFwiKT9cXFxccypcIik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdHRyVmFsdWUodGV4dCwgYXR0cikge1xuICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goZ2V0QXR0clJlZ2V4cChhdHRyKSlcbiAgICByZXR1cm4gbWF0Y2ggPyAvXlxccyooLio/KVxccyokLy5leGVjKG1hdGNoWzJdKVsxXSA6IFwiXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFRhZ1JlZ2V4cCh0YWdOYW1lLCBhbmNob3JlZCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKChhbmNob3JlZCA/IFwiXlwiIDogXCJcIikgKyBcIjxcXC9cXHMqXCIgKyB0YWdOYW1lICsgXCJcXHMqPlwiLCBcImlcIik7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUYWdzKGZyb20sIHRvKSB7XG4gICAgZm9yICh2YXIgdGFnIGluIGZyb20pIHtcbiAgICAgIHZhciBkZXN0ID0gdG9bdGFnXSB8fCAodG9bdGFnXSA9IFtdKTtcbiAgICAgIHZhciBzb3VyY2UgPSBmcm9tW3RhZ107XG4gICAgICBmb3IgKHZhciBpID0gc291cmNlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBkZXN0LnVuc2hpZnQoc291cmNlW2ldKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRNYXRjaGluZ01vZGUodGFnSW5mbywgdGFnVGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNwZWMgPSB0YWdJbmZvW2ldO1xuICAgICAgaWYgKCFzcGVjWzBdIHx8IHNwZWNbMV0udGVzdChnZXRBdHRyVmFsdWUodGFnVGV4dCwgc3BlY1swXSkpKSByZXR1cm4gc3BlY1syXTtcbiAgICB9XG4gIH1cblxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUoXCJodG1sbWl4ZWRcIiwgZnVuY3Rpb24gKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gICAgdmFyIGh0bWxNb2RlID0gQ29kZU1pcnJvci5nZXRNb2RlKGNvbmZpZywge1xuICAgICAgbmFtZTogXCJ4bWxcIixcbiAgICAgIGh0bWxNb2RlOiB0cnVlLFxuICAgICAgbXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yOiBwYXJzZXJDb25maWcubXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yLFxuICAgICAgbXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZzogcGFyc2VyQ29uZmlnLm11bHRpbGluZVRhZ0luZGVudFBhc3RUYWcsXG4gICAgICBhbGxvd01pc3NpbmdUYWdOYW1lOiBwYXJzZXJDb25maWcuYWxsb3dNaXNzaW5nVGFnTmFtZSxcbiAgICB9KTtcblxuICAgIHZhciB0YWdzID0ge307XG4gICAgdmFyIGNvbmZpZ1RhZ3MgPSBwYXJzZXJDb25maWcgJiYgcGFyc2VyQ29uZmlnLnRhZ3MsIGNvbmZpZ1NjcmlwdCA9IHBhcnNlckNvbmZpZyAmJiBwYXJzZXJDb25maWcuc2NyaXB0VHlwZXM7XG4gICAgYWRkVGFncyhkZWZhdWx0VGFncywgdGFncyk7XG4gICAgaWYgKGNvbmZpZ1RhZ3MpIGFkZFRhZ3MoY29uZmlnVGFncywgdGFncyk7XG4gICAgaWYgKGNvbmZpZ1NjcmlwdCkgZm9yICh2YXIgaSA9IGNvbmZpZ1NjcmlwdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgIHRhZ3Muc2NyaXB0LnVuc2hpZnQoW1widHlwZVwiLCBjb25maWdTY3JpcHRbaV0ubWF0Y2hlcywgY29uZmlnU2NyaXB0W2ldLm1vZGVdKVxuXG4gICAgZnVuY3Rpb24gaHRtbChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB2YXIgc3R5bGUgPSBodG1sTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmh0bWxTdGF0ZSksIHRhZyA9IC9cXGJ0YWdcXGIvLnRlc3Qoc3R5bGUpLCB0YWdOYW1lXG4gICAgICBpZiAodGFnICYmICEvWzw+XFxzXFwvXS8udGVzdChzdHJlYW0uY3VycmVudCgpKSAmJlxuICAgICAgICAgICh0YWdOYW1lID0gc3RhdGUuaHRtbFN0YXRlLnRhZ05hbWUgJiYgc3RhdGUuaHRtbFN0YXRlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICB0YWdzLmhhc093blByb3BlcnR5KHRhZ05hbWUpKSB7XG4gICAgICAgIHN0YXRlLmluVGFnID0gdGFnTmFtZSArIFwiIFwiXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmluVGFnICYmIHRhZyAmJiAvPiQvLnRlc3Qoc3RyZWFtLmN1cnJlbnQoKSkpIHtcbiAgICAgICAgdmFyIGluVGFnID0gL14oW1xcU10rKSAoLiopLy5leGVjKHN0YXRlLmluVGFnKVxuICAgICAgICBzdGF0ZS5pblRhZyA9IG51bGxcbiAgICAgICAgdmFyIG1vZGVTcGVjID0gc3RyZWFtLmN1cnJlbnQoKSA9PSBcIj5cIiAmJiBmaW5kTWF0Y2hpbmdNb2RlKHRhZ3NbaW5UYWdbMV1dLCBpblRhZ1syXSlcbiAgICAgICAgdmFyIG1vZGUgPSBDb2RlTWlycm9yLmdldE1vZGUoY29uZmlnLCBtb2RlU3BlYylcbiAgICAgICAgdmFyIGVuZFRhZ0EgPSBnZXRUYWdSZWdleHAoaW5UYWdbMV0sIHRydWUpLCBlbmRUYWcgPSBnZXRUYWdSZWdleHAoaW5UYWdbMV0sIGZhbHNlKTtcbiAgICAgICAgc3RhdGUudG9rZW4gPSBmdW5jdGlvbiAoc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goZW5kVGFnQSwgZmFsc2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbiA9IGh0bWw7XG4gICAgICAgICAgICBzdGF0ZS5sb2NhbFN0YXRlID0gc3RhdGUubG9jYWxNb2RlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF5YmVCYWNrdXAoc3RyZWFtLCBlbmRUYWcsIHN0YXRlLmxvY2FsTW9kZS50b2tlbihzdHJlYW0sIHN0YXRlLmxvY2FsU3RhdGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhdGUubG9jYWxNb2RlID0gbW9kZTtcbiAgICAgICAgc3RhdGUubG9jYWxTdGF0ZSA9IENvZGVNaXJyb3Iuc3RhcnRTdGF0ZShtb2RlLCBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbFN0YXRlLCBcIlwiLCBcIlwiKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmluVGFnKSB7XG4gICAgICAgIHN0YXRlLmluVGFnICs9IHN0cmVhbS5jdXJyZW50KClcbiAgICAgICAgaWYgKHN0cmVhbS5lb2woKSkgc3RhdGUuaW5UYWcgKz0gXCIgXCJcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gQ29kZU1pcnJvci5zdGFydFN0YXRlKGh0bWxNb2RlKTtcbiAgICAgICAgcmV0dXJuIHt0b2tlbjogaHRtbCwgaW5UYWc6IG51bGwsIGxvY2FsTW9kZTogbnVsbCwgbG9jYWxTdGF0ZTogbnVsbCwgaHRtbFN0YXRlOiBzdGF0ZX07XG4gICAgICB9LFxuXG4gICAgICBjb3B5U3RhdGU6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgbG9jYWw7XG4gICAgICAgIGlmIChzdGF0ZS5sb2NhbFN0YXRlKSB7XG4gICAgICAgICAgbG9jYWwgPSBDb2RlTWlycm9yLmNvcHlTdGF0ZShzdGF0ZS5sb2NhbE1vZGUsIHN0YXRlLmxvY2FsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dG9rZW46IHN0YXRlLnRva2VuLCBpblRhZzogc3RhdGUuaW5UYWcsXG4gICAgICAgICAgICAgICAgbG9jYWxNb2RlOiBzdGF0ZS5sb2NhbE1vZGUsIGxvY2FsU3RhdGU6IGxvY2FsLFxuICAgICAgICAgICAgICAgIGh0bWxTdGF0ZTogQ29kZU1pcnJvci5jb3B5U3RhdGUoaHRtbE1vZGUsIHN0YXRlLmh0bWxTdGF0ZSl9O1xuICAgICAgfSxcblxuICAgICAgdG9rZW46IGZ1bmN0aW9uIChzdHJlYW0sIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS50b2tlbihzdHJlYW0sIHN0YXRlKTtcbiAgICAgIH0sXG5cbiAgICAgIGluZGVudDogZnVuY3Rpb24gKHN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5sb2NhbE1vZGUgfHwgL15cXHMqPFxcLy8udGVzdCh0ZXh0QWZ0ZXIpKVxuICAgICAgICAgIHJldHVybiBodG1sTW9kZS5pbmRlbnQoc3RhdGUuaHRtbFN0YXRlLCB0ZXh0QWZ0ZXIsIGxpbmUpO1xuICAgICAgICBlbHNlIGlmIChzdGF0ZS5sb2NhbE1vZGUuaW5kZW50KVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5sb2NhbE1vZGUuaW5kZW50KHN0YXRlLmxvY2FsU3RhdGUsIHRleHRBZnRlciwgbGluZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gQ29kZU1pcnJvci5QYXNzO1xuICAgICAgfSxcblxuICAgICAgaW5uZXJNb2RlOiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtzdGF0ZTogc3RhdGUubG9jYWxTdGF0ZSB8fCBzdGF0ZS5odG1sU3RhdGUsIG1vZGU6IHN0YXRlLmxvY2FsTW9kZSB8fCBodG1sTW9kZX07XG4gICAgICB9XG4gICAgfTtcbiAgfSwgXCJ4bWxcIiwgXCJqYXZhc2NyaXB0XCIsIFwiY3NzXCIpO1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvaHRtbFwiLCBcImh0bWxtaXhlZFwiKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/htmlmixed/htmlmixed.js\n')},"./node_modules/codemirror/mode/javascript/javascript.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nCodeMirror.defineMode("javascript", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: "keyword"};}\n    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");\n    var operator = kw("operator"), atom = {type: "atom", style: "atom"};\n\n    return {\n      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,\n      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,\n      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),\n      "function": kw("function"), "catch": kw("catch"),\n      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),\n      "in": operator, "typeof": operator, "instanceof": operator,\n      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,\n      "this": kw("this"), "class": kw("class"), "super": kw("atom"),\n      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,\n      "await": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == "/" && !inSet) return;\n        if (next == "[") inSet = true;\n        else if (inSet && next == "]") inSet = false;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == \'"\' || ch == "\'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "." && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret("number", "number");\n    } else if (ch == "." && stream.match("..")) {\n      return ret("spread", "meta");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == "=" && stream.eat(">")) {\n      return ret("=>", "operator");\n    } else if (ch == "0" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret("number", "number");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret("number", "number");\n    } else if (ch == "/") {\n      if (stream.eat("*")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat("/")) {\n        stream.skipToEnd();\n        return ret("comment", "comment");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret("regexp", "string-2");\n      } else {\n        stream.eat("=");\n        return ret("operator", "operator", stream.current());\n      }\n    } else if (ch == "`") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == "#" && stream.peek() == "!") {\n      stream.skipToEnd();\n      return ret("meta", "meta");\n    } else if (ch == "#" && stream.eatWhile(wordRE)) {\n      return ret("variable", "property")\n    } else if (ch == "<" && stream.match("!--") ||\n               (ch == "-" && stream.match("->") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret("comment", "comment")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != ">" || !state.lexical || state.lexical.type != ">") {\n        if (stream.eat("=")) {\n          if (ch == "!" || ch == "=") stream.eat("=")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == ">") stream.eat(ch)\n        }\n      }\n      if (ch == "?" && stream.eat(".")) return ret(".")\n      return ret("operator", "operator", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != ".") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == "async" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret("async", "keyword", word)\n      }\n      return ret("variable", "variable", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret("jsonld-keyword", "meta");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == "\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == "/" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ret("comment", "comment");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n    return ret("quasi", "string-2", stream.current());\n  }\n\n  var brackets = "([{}])";\n  // This is a crude lookahead trick to try and notice that we\'re\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there\'s no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf("=>", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/["\'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != "\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true,\n                     "regexp": true, "this": true, "import": true, "jsonld-keyword": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty("align"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == "variable" && inScope(state, content)) return "variable-2";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = "def";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == "var" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var("this", new Var("arguments", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == "stat") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == ")")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);\n    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);\n    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);\n    if (type == "keyword d") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);\n    if (type == "debugger") return cont(expect(";"));\n    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);\n    if (type == ";") return cont();\n    if (type == "if") {\n      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == "function") return cont(functiondef);\n    if (type == "for") return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == "class" || (isTS && value == "interface")) {\n      cx.marked = "keyword"\n      return cont(pushlex("form", type == "class" ? type : value), className, poplex)\n    }\n    if (type == "variable") {\n      if (isTS && value == "declare") {\n        cx.marked = "keyword"\n        return cont(statement)\n      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = "keyword"\n        if (value == "enum") return cont(enumdef);\n        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));\n        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)\n      } else if (isTS && value == "namespace") {\n        cx.marked = "keyword"\n        return cont(pushlex("form"), expression, statement, poplex)\n      } else if (isTS && value == "abstract") {\n        cx.marked = "keyword"\n        return cont(statement)\n      } else {\n        return cont(pushlex("stat"), maybelabel);\n      }\n    }\n    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == "case") return cont(expression, expect(":"));\n    if (type == "default") return cont(expect(":"));\n    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);\n    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);\n    if (type == "async") return cont(statement)\n    if (value == "@") return cont(expression, statement)\n    return pass(pushlex("stat"), expression, expect(";"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == "(") return cont(funarg, expect(")"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != "(") return pass()\n    return cont(pushlex(")"), maybeexpression, expect(")"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);\n      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == "function") return cont(functiondef, maybeop);\n    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }\n    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);\n    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);\n    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);\n    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n    if (type == "{") return contCommasep(objprop, "}", null, maybeop);\n    if (type == "quasi") return pass(quasi, maybeop);\n    if (type == "new") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == ",") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == "operator") {\n      if (/\\+\\+|--/.test(value) || isTS && value == "!") return cont(me);\n      if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);\n      if (value == "?") return cont(expression, expect(":"), expr);\n      return cont(expr);\n    }\n    if (type == "quasi") { return pass(quasi, me); }\n    if (type == ";") return;\n    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);\n    if (type == ".") return cont(property, me);\n    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }\n    if (type == "regexp") {\n      cx.state.lastType = cx.marked = "operator"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != "quasi") return pass();\n    if (value.slice(value.length - 2) != "${") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == "}") {\n      cx.marked = "string-2";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == "{" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == "{" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == ".") return cont(noComma ? targetNoComma : target);\n      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == ":") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(";"), poplex);\n  }\n  function property(type) {\n    if (type == "variable") {cx.marked = "property"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == "async") {\n      cx.marked = "property";\n      return cont(objprop);\n    } else if (type == "variable" || cx.style == "keyword") {\n      cx.marked = "property";\n      if (value == "get" || value == "set") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == "number" || type == "string") {\n      cx.marked = jsonldMode ? "property" : (cx.style + " property");\n      return cont(afterprop);\n    } else if (type == "jsonld-keyword") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = "keyword"\n      return cont(objprop)\n    } else if (type == "[") {\n      return cont(expression, maybetype, expect("]"), afterprop);\n    } else if (type == "spread") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == "*") {\n      cx.marked = "keyword";\n      return cont(objprop);\n    } else if (type == ":") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != "variable") return pass(afterprop);\n    cx.marked = "property";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == ":") return cont(expressionNoComma);\n    if (type == "(") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == ",") {\n        var lex = cx.state.lexical;\n        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(";") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == "}") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == ":") return cont(typeexpr);\n      if (value == "?") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == ":" || value == "in")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == ":") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == "is") {\n      cx.marked = "keyword"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {\n      cx.marked = "keyword"\n      return cont(value == "typeof" ? expressionNoComma : typeexpr)\n    }\n    if (type == "variable" || value == "void") {\n      cx.marked = "type"\n      return cont(afterType)\n    }\n    if (value == "|" || value == "&") return cont(typeexpr)\n    if (type == "string" || type == "number" || type == "atom") return cont(afterType);\n    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)\n    if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType)\n    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)\n    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)\n  }\n  function maybeReturnType(type) {\n    if (type == "=>") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == "," || type == ";") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == "variable" || cx.style == "keyword") {\n      cx.marked = "property"\n      return cont(typeprop)\n    } else if (value == "?" || type == "number" || type == "string") {\n      return cont(typeprop)\n    } else if (type == ":") {\n      return cont(typeexpr)\n    } else if (type == "[") {\n      return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)\n    } else if (type == "(") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function typearg(type, value) {\n    if (type == "variable" && cx.stream.match(/^\\s*[?:]/, false) || value == "?") return cont(typearg)\n    if (type == ":") return cont(typeexpr)\n    if (type == "spread") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)\n    if (value == "|" || type == "." || value == "&") return cont(typeexpr)\n    if (type == "[") return cont(typeexpr, expect("]"), afterType)\n    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }\n    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == "=") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }\n    if (type == "variable") { register(value); return cont(); }\n    if (type == "spread") return cont(pattern);\n    if (type == "[") return contCommasep(eltpattern, "]");\n    if (type == "{") return contCommasep(proppattern, "}");\n  }\n  function proppattern(type, value) {\n    if (type == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == "variable") cx.marked = "property";\n    if (type == "spread") return cont(pattern);\n    if (type == "}") return pass();\n    if (type == "[") return cont(expression, expect(\']\'), expect(\':\'), proppattern);\n    return cont(expect(":"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == "=") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == ",") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == "await") return cont(forspec);\n    if (type == "(") return cont(pushlex(")"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == "var") return cont(vardef, forspec2);\n    if (type == "variable") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == ")") return cont()\n    if (type == ";") return cont(forspec2)\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}\n    if (type == "variable") {register(value); return cont(functiondef);}\n    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}\n    if (type == "variable") {register(value); return cont(functiondecl);}\n    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);\n    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == "keyword" || type == "variable") {\n      cx.marked = "type"\n      return cont(typename)\n    } else if (value == "<") {\n      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == "@") cont(expression, funarg)\n    if (type == "spread") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }\n    if (isTS && type == "this") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == "variable") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == "variable") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)\n    if (value == "extends" || value == "implements" || (isTS && type == ",")) {\n      if (value == "implements") cx.marked = "keyword";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == "{") return cont(pushlex("}"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == "async" ||\n        (type == "variable" &&\n         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = "keyword";\n      return cont(classBody);\n    }\n    if (type == "variable" || cx.style == "keyword") {\n      cx.marked = "property";\n      return cont(classfield, classBody);\n    }\n    if (type == "number" || type == "string") return cont(classfield, classBody);\n    if (type == "[")\n      return cont(expression, maybetype, expect("]"), classfield, classBody)\n    if (value == "*") {\n      cx.marked = "keyword";\n      return cont(classBody);\n    }\n    if (isTS && type == "(") return pass(functiondecl, classBody)\n    if (type == ";" || type == ",") return cont(classBody);\n    if (type == "}") return cont();\n    if (value == "@") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == "?") return cont(classfield)\n    if (type == ":") return cont(typeexpr, maybeAssign)\n    if (value == "=") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }\n    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }\n    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }\n    if (type == "variable") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == "string") return cont();\n    if (type == "(") return pass(expression);\n    if (type == ".") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == "{") return contCommasep(importSpec, "}");\n    if (type == "variable") register(value);\n    if (value == "*") cx.marked = "keyword";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == ",") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == "from") { cx.marked = "keyword"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == "]") return cont();\n    return pass(commasep(expressionNoComma, "]"));\n  }\n  function enumdef() {\n    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == "operator" || state.lastType == "," ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == "quasi" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: "sof",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty("align"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == "comment") return style;\n      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent \'maybelse\' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == "stat" || lexical.type == "form") &&\n             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);\n      else if (type == "form" && firstChar == "{") return lexical.indented;\n      else if (type == "form") return lexical.indented + indentUnit;\n      else if (type == "stat")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : "/*",\n    blockCommentEnd: jsonMode ? null : "*/",\n    blockCommentContinue: jsonMode ? null : " * ",\n    lineComment: jsonMode ? null : "//",\n    fold: "brace",\n    closeBrackets: "()[]{}\'\'\\"\\"``",\n\n    helperType: jsonMode ? "json" : "javascript",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper("wordChars", "javascript", /[\\w$]/);\n\nCodeMirror.defineMIME("text/javascript", "javascript");\nCodeMirror.defineMIME("text/ecmascript", "javascript");\nCodeMirror.defineMIME("application/javascript", "javascript");\nCodeMirror.defineMIME("application/x-javascript", "javascript");\nCodeMirror.defineMIME("application/ecmascript", "javascript");\nCodeMirror.defineMIME("application/json", { name: "javascript", json: true });\nCodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });\nCodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true })\nCodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });\nCodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\nCodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS9qYXZhc2NyaXB0L2phdmFzY3JpcHQuanM/ZjlkNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF1RDtBQUM3RCxRQUFRLG1CQUFPLENBQUMseUVBQXNCO0FBQ3RDLE9BQU8sRUFHYTtBQUNwQixDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUssa0JBQWtCLE1BQU07QUFDN0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QkFBd0IsdUJBQXVCLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1Qix5QkFBeUI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWMsMkJBQTJCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRSxJQUFJO0FBQzlFLHVDQUF1QztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZ0RBQWdELEdBQUc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaUNBQWlDO0FBQzVFLDZDQUE2QyxpQ0FBaUM7QUFDOUUsb0RBQW9ELGlDQUFpQztBQUNyRiw4Q0FBOEMsbUNBQW1DO0FBQ2pGLDBDQUEwQyx1Q0FBdUM7QUFDakYsaURBQWlELHVDQUF1Qzs7QUFFeEYsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL21vZGUvamF2YXNjcmlwdC9qYXZhc2NyaXB0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuKGZ1bmN0aW9uKG1vZCkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlID09IFwib2JqZWN0XCIpIC8vIENvbW1vbkpTXG4gICAgbW9kKHJlcXVpcmUoXCIuLi8uLi9saWIvY29kZW1pcnJvclwiKSk7XG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIC8vIEFNRFxuICAgIGRlZmluZShbXCIuLi8uLi9saWIvY29kZW1pcnJvclwiXSwgbW9kKTtcbiAgZWxzZSAvLyBQbGFpbiBicm93c2VyIGVudlxuICAgIG1vZChDb2RlTWlycm9yKTtcbn0pKGZ1bmN0aW9uKENvZGVNaXJyb3IpIHtcblwidXNlIHN0cmljdFwiO1xuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJqYXZhc2NyaXB0XCIsIGZ1bmN0aW9uKGNvbmZpZywgcGFyc2VyQ29uZmlnKSB7XG4gIHZhciBpbmRlbnRVbml0ID0gY29uZmlnLmluZGVudFVuaXQ7XG4gIHZhciBzdGF0ZW1lbnRJbmRlbnQgPSBwYXJzZXJDb25maWcuc3RhdGVtZW50SW5kZW50O1xuICB2YXIganNvbmxkTW9kZSA9IHBhcnNlckNvbmZpZy5qc29ubGQ7XG4gIHZhciBqc29uTW9kZSA9IHBhcnNlckNvbmZpZy5qc29uIHx8IGpzb25sZE1vZGU7XG4gIHZhciB0cmFja1Njb3BlID0gcGFyc2VyQ29uZmlnLnRyYWNrU2NvcGUgIT09IGZhbHNlXG4gIHZhciBpc1RTID0gcGFyc2VyQ29uZmlnLnR5cGVzY3JpcHQ7XG4gIHZhciB3b3JkUkUgPSBwYXJzZXJDb25maWcud29yZENoYXJhY3RlcnMgfHwgL1tcXHckXFx4YTEtXFx1ZmZmZl0vO1xuXG4gIC8vIFRva2VuaXplclxuXG4gIHZhciBrZXl3b3JkcyA9IGZ1bmN0aW9uKCl7XG4gICAgZnVuY3Rpb24ga3codHlwZSkge3JldHVybiB7dHlwZTogdHlwZSwgc3R5bGU6IFwia2V5d29yZFwifTt9XG4gICAgdmFyIEEgPSBrdyhcImtleXdvcmQgYVwiKSwgQiA9IGt3KFwia2V5d29yZCBiXCIpLCBDID0ga3coXCJrZXl3b3JkIGNcIiksIEQgPSBrdyhcImtleXdvcmQgZFwiKTtcbiAgICB2YXIgb3BlcmF0b3IgPSBrdyhcIm9wZXJhdG9yXCIpLCBhdG9tID0ge3R5cGU6IFwiYXRvbVwiLCBzdHlsZTogXCJhdG9tXCJ9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIFwiaWZcIjoga3coXCJpZlwiKSwgXCJ3aGlsZVwiOiBBLCBcIndpdGhcIjogQSwgXCJlbHNlXCI6IEIsIFwiZG9cIjogQiwgXCJ0cnlcIjogQiwgXCJmaW5hbGx5XCI6IEIsXG4gICAgICBcInJldHVyblwiOiBELCBcImJyZWFrXCI6IEQsIFwiY29udGludWVcIjogRCwgXCJuZXdcIjoga3coXCJuZXdcIiksIFwiZGVsZXRlXCI6IEMsIFwidm9pZFwiOiBDLCBcInRocm93XCI6IEMsXG4gICAgICBcImRlYnVnZ2VyXCI6IGt3KFwiZGVidWdnZXJcIiksIFwidmFyXCI6IGt3KFwidmFyXCIpLCBcImNvbnN0XCI6IGt3KFwidmFyXCIpLCBcImxldFwiOiBrdyhcInZhclwiKSxcbiAgICAgIFwiZnVuY3Rpb25cIjoga3coXCJmdW5jdGlvblwiKSwgXCJjYXRjaFwiOiBrdyhcImNhdGNoXCIpLFxuICAgICAgXCJmb3JcIjoga3coXCJmb3JcIiksIFwic3dpdGNoXCI6IGt3KFwic3dpdGNoXCIpLCBcImNhc2VcIjoga3coXCJjYXNlXCIpLCBcImRlZmF1bHRcIjoga3coXCJkZWZhdWx0XCIpLFxuICAgICAgXCJpblwiOiBvcGVyYXRvciwgXCJ0eXBlb2ZcIjogb3BlcmF0b3IsIFwiaW5zdGFuY2VvZlwiOiBvcGVyYXRvcixcbiAgICAgIFwidHJ1ZVwiOiBhdG9tLCBcImZhbHNlXCI6IGF0b20sIFwibnVsbFwiOiBhdG9tLCBcInVuZGVmaW5lZFwiOiBhdG9tLCBcIk5hTlwiOiBhdG9tLCBcIkluZmluaXR5XCI6IGF0b20sXG4gICAgICBcInRoaXNcIjoga3coXCJ0aGlzXCIpLCBcImNsYXNzXCI6IGt3KFwiY2xhc3NcIiksIFwic3VwZXJcIjoga3coXCJhdG9tXCIpLFxuICAgICAgXCJ5aWVsZFwiOiBDLCBcImV4cG9ydFwiOiBrdyhcImV4cG9ydFwiKSwgXCJpbXBvcnRcIjoga3coXCJpbXBvcnRcIiksIFwiZXh0ZW5kc1wiOiBDLFxuICAgICAgXCJhd2FpdFwiOiBDXG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fH5eQF0vO1xuICB2YXIgaXNKc29ubGRLZXl3b3JkID0gL15AKGNvbnRleHR8aWR8dmFsdWV8bGFuZ3VhZ2V8dHlwZXxjb250YWluZXJ8bGlzdHxzZXR8cmV2ZXJzZXxpbmRleHxiYXNlfHZvY2FifGdyYXBoKVwiLztcblxuICBmdW5jdGlvbiByZWFkUmVnZXhwKHN0cmVhbSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGluU2V0ID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKCFlc2NhcGVkKSB7XG4gICAgICAgIGlmIChuZXh0ID09IFwiL1wiICYmICFpblNldCkgcmV0dXJuO1xuICAgICAgICBpZiAobmV4dCA9PSBcIltcIikgaW5TZXQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChpblNldCAmJiBuZXh0ID09IFwiXVwiKSBpblNldCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCBhcyBzY3JhdGNoIHZhcmlhYmxlcyB0byBjb21tdW5pY2F0ZSBtdWx0aXBsZSB2YWx1ZXMgd2l0aG91dFxuICAvLyBjb25zaW5nIHVwIHRvbnMgb2Ygb2JqZWN0cy5cbiAgdmFyIHR5cGUsIGNvbnRlbnQ7XG4gIGZ1bmN0aW9uIHJldCh0cCwgc3R5bGUsIGNvbnQpIHtcbiAgICB0eXBlID0gdHA7IGNvbnRlbnQgPSBjb250O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBmdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCIuXCIgJiYgc3RyZWFtLm1hdGNoKC9eXFxkW1xcZF9dKig/OltlRV1bK1xcLV0/W1xcZF9dKyk/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIi5cIiAmJiBzdHJlYW0ubWF0Y2goXCIuLlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcInNwcmVhZFwiLCBcIm1ldGFcIik7XG4gICAgfSBlbHNlIGlmICgvW1xcW1xcXXt9XFwoXFwpLDtcXDpcXC5dLy50ZXN0KGNoKSkge1xuICAgICAgcmV0dXJuIHJldChjaCk7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIj1cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgcmV0dXJuIHJldChcIj0+XCIsIFwib3BlcmF0b3JcIik7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjBcIiAmJiBzdHJlYW0ubWF0Y2goL14oPzp4W1xcZEEtRmEtZl9dK3xvWzAtN19dK3xiWzAxX10rKW4/LykpIHtcbiAgICAgIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgICAgc3RyZWFtLm1hdGNoKC9eW1xcZF9dKig/Om58KD86XFwuW1xcZF9dKik/KD86W2VFXVsrXFwtXT9bXFxkX10rKT8pPy8pO1xuICAgICAgcmV0dXJuIHJldChcIm51bWJlclwiLCBcIm51bWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnQ7XG4gICAgICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xuICAgICAgfSBlbHNlIGlmIChleHByZXNzaW9uQWxsb3dlZChzdHJlYW0sIHN0YXRlLCAxKSkge1xuICAgICAgICByZWFkUmVnZXhwKHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlxcYigoW2dpbXl1c10pKD8hW2dpbXl1c10qXFwyKSkrXFxiLyk7XG4gICAgICAgIHJldHVybiByZXQoXCJyZWdleHBcIiwgXCJzdHJpbmctMlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lYXQoXCI9XCIpO1xuICAgICAgICByZXR1cm4gcmV0KFwib3BlcmF0b3JcIiwgXCJvcGVyYXRvclwiLCBzdHJlYW0uY3VycmVudCgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiYFwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuUXVhc2k7XG4gICAgICByZXR1cm4gdG9rZW5RdWFzaShzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5wZWVrKCkgPT0gXCIhXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiByZXQoXCJtZXRhXCIsIFwibWV0YVwiKTtcbiAgICB9IGVsc2UgaWYgKGNoID09IFwiI1wiICYmIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpKSB7XG4gICAgICByZXR1cm4gcmV0KFwidmFyaWFibGVcIiwgXCJwcm9wZXJ0eVwiKVxuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI8XCIgJiYgc3RyZWFtLm1hdGNoKFwiIS0tXCIpIHx8XG4gICAgICAgICAgICAgICAoY2ggPT0gXCItXCIgJiYgc3RyZWFtLm1hdGNoKFwiLT5cIikgJiYgIS9cXFMvLnRlc3Qoc3RyZWFtLnN0cmluZy5zbGljZSgwLCBzdHJlYW0uc3RhcnQpKSkpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKVxuICAgICAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpXG4gICAgfSBlbHNlIGlmIChpc09wZXJhdG9yQ2hhci50ZXN0KGNoKSkge1xuICAgICAgaWYgKGNoICE9IFwiPlwiIHx8ICFzdGF0ZS5sZXhpY2FsIHx8IHN0YXRlLmxleGljYWwudHlwZSAhPSBcIj5cIikge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIj1cIikpIHtcbiAgICAgICAgICBpZiAoY2ggPT0gXCIhXCIgfHwgY2ggPT0gXCI9XCIpIHN0cmVhbS5lYXQoXCI9XCIpXG4gICAgICAgIH0gZWxzZSBpZiAoL1s8PiorXFwtfCY/XS8udGVzdChjaCkpIHtcbiAgICAgICAgICBzdHJlYW0uZWF0KGNoKVxuICAgICAgICAgIGlmIChjaCA9PSBcIj5cIikgc3RyZWFtLmVhdChjaClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoID09IFwiP1wiICYmIHN0cmVhbS5lYXQoXCIuXCIpKSByZXR1cm4gcmV0KFwiLlwiKVxuICAgICAgcmV0dXJuIHJldChcIm9wZXJhdG9yXCIsIFwib3BlcmF0b3JcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gICAgfSBlbHNlIGlmICh3b3JkUkUudGVzdChjaCkpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSh3b3JkUkUpO1xuICAgICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpXG4gICAgICBpZiAoc3RhdGUubGFzdFR5cGUgIT0gXCIuXCIpIHtcbiAgICAgICAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKHdvcmQpKSB7XG4gICAgICAgICAgdmFyIGt3ID0ga2V5d29yZHNbd29yZF1cbiAgICAgICAgICByZXR1cm4gcmV0KGt3LnR5cGUsIGt3LnN0eWxlLCB3b3JkKVxuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JkID09IFwiYXN5bmNcIiAmJiBzdHJlYW0ubWF0Y2goL14oXFxzfFxcL1xcKihbXipdfFxcKig/IVxcLykpKj9cXCpcXC8pKltcXFtcXChcXHddLywgZmFsc2UpKVxuICAgICAgICAgIHJldHVybiByZXQoXCJhc3luY1wiLCBcImtleXdvcmRcIiwgd29yZClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQoXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlXCIsIHdvcmQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgICAgIGlmIChqc29ubGRNb2RlICYmIHN0cmVhbS5wZWVrKCkgPT0gXCJAXCIgJiYgc3RyZWFtLm1hdGNoKGlzSnNvbmxkS2V5d29yZCkpe1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgcmV0dXJuIHJldChcImpzb25sZC1rZXl3b3JkXCIsIFwibWV0YVwiKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIGJyZWFrO1xuICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICAgIH1cbiAgICAgIGlmICghZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwic3RyaW5nXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBtYXliZUVuZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwiY29tbWVudFwiLCBcImNvbW1lbnRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlblF1YXNpKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBuZXh0O1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmICghZXNjYXBlZCAmJiAobmV4dCA9PSBcImBcIiB8fCBuZXh0ID09IFwiJFwiICYmIHN0cmVhbS5lYXQoXCJ7XCIpKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJldChcInF1YXNpXCIsIFwic3RyaW5nLTJcIiwgc3RyZWFtLmN1cnJlbnQoKSk7XG4gIH1cblxuICB2YXIgYnJhY2tldHMgPSBcIihbe31dKVwiO1xuICAvLyBUaGlzIGlzIGEgY3J1ZGUgbG9va2FoZWFkIHRyaWNrIHRvIHRyeSBhbmQgbm90aWNlIHRoYXQgd2UncmVcbiAgLy8gcGFyc2luZyB0aGUgYXJndW1lbnQgcGF0dGVybnMgZm9yIGEgZmF0LWFycm93IGZ1bmN0aW9uIGJlZm9yZSB3ZVxuICAvLyBhY3R1YWxseSBoaXQgdGhlIGFycm93IHRva2VuLiBJdCBvbmx5IHdvcmtzIGlmIHRoZSBhcnJvdyBpcyBvblxuICAvLyB0aGUgc2FtZSBsaW5lIGFzIHRoZSBhcmd1bWVudHMgYW5kIHRoZXJlJ3Mgbm8gc3RyYW5nZSBub2lzZVxuICAvLyAoY29tbWVudHMpIGluIGJldHdlZW4uIEZhbGxiYWNrIGlzIHRvIG9ubHkgbm90aWNlIHdoZW4gd2UgaGl0IHRoZVxuICAvLyBhcnJvdywgYW5kIG5vdCBkZWNsYXJlIHRoZSBhcmd1bWVudHMgYXMgbG9jYWxzIGZvciB0aGUgYXJyb3dcbiAgLy8gYm9keS5cbiAgZnVuY3Rpb24gZmluZEZhdEFycm93KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZmF0QXJyb3dBdCkgc3RhdGUuZmF0QXJyb3dBdCA9IG51bGw7XG4gICAgdmFyIGFycm93ID0gc3RyZWFtLnN0cmluZy5pbmRleE9mKFwiPT5cIiwgc3RyZWFtLnN0YXJ0KTtcbiAgICBpZiAoYXJyb3cgPCAwKSByZXR1cm47XG5cbiAgICBpZiAoaXNUUykgeyAvLyBUcnkgdG8gc2tpcCBUeXBlU2NyaXB0IHJldHVybiB0eXBlIGRlY2xhcmF0aW9ucyBhZnRlciB0aGUgYXJndW1lbnRzXG4gICAgICB2YXIgbSA9IC86XFxzKig/OlxcdysoPzo8W14+XSo+fFxcW1xcXSk/fFxce1tefV0qXFx9KVxccyokLy5leGVjKHN0cmVhbS5zdHJpbmcuc2xpY2Uoc3RyZWFtLnN0YXJ0LCBhcnJvdykpXG4gICAgICBpZiAobSkgYXJyb3cgPSBtLmluZGV4XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoID0gMCwgc2F3U29tZXRoaW5nID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcG9zID0gYXJyb3cgLSAxOyBwb3MgPj0gMDsgLS1wb3MpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICB2YXIgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2YoY2gpO1xuICAgICAgaWYgKGJyYWNrZXQgPj0gMCAmJiBicmFja2V0IDwgMykge1xuICAgICAgICBpZiAoIWRlcHRoKSB7ICsrcG9zOyBicmVhazsgfVxuICAgICAgICBpZiAoLS1kZXB0aCA9PSAwKSB7IGlmIChjaCA9PSBcIihcIikgc2F3U29tZXRoaW5nID0gdHJ1ZTsgYnJlYWs7IH1cbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldCA+PSAzICYmIGJyYWNrZXQgPCA2KSB7XG4gICAgICAgICsrZGVwdGg7XG4gICAgICB9IGVsc2UgaWYgKHdvcmRSRS50ZXN0KGNoKSkge1xuICAgICAgICBzYXdTb21ldGhpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICgvW1wiJ1xcL2BdLy50ZXN0KGNoKSkge1xuICAgICAgICBmb3IgKDs7IC0tcG9zKSB7XG4gICAgICAgICAgaWYgKHBvcyA9PSAwKSByZXR1cm5cbiAgICAgICAgICB2YXIgbmV4dCA9IHN0cmVhbS5zdHJpbmcuY2hhckF0KHBvcyAtIDEpXG4gICAgICAgICAgaWYgKG5leHQgPT0gY2ggJiYgc3RyZWFtLnN0cmluZy5jaGFyQXQocG9zIC0gMikgIT0gXCJcXFxcXCIpIHsgcG9zLS07IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzYXdTb21ldGhpbmcgJiYgIWRlcHRoKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNhd1NvbWV0aGluZyAmJiAhZGVwdGgpIHN0YXRlLmZhdEFycm93QXQgPSBwb3M7XG4gIH1cblxuICAvLyBQYXJzZXJcblxuICB2YXIgYXRvbWljVHlwZXMgPSB7XCJhdG9tXCI6IHRydWUsIFwibnVtYmVyXCI6IHRydWUsIFwidmFyaWFibGVcIjogdHJ1ZSwgXCJzdHJpbmdcIjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgIFwicmVnZXhwXCI6IHRydWUsIFwidGhpc1wiOiB0cnVlLCBcImltcG9ydFwiOiB0cnVlLCBcImpzb25sZC1rZXl3b3JkXCI6IHRydWV9O1xuXG4gIGZ1bmN0aW9uIEpTTGV4aWNhbChpbmRlbnRlZCwgY29sdW1uLCB0eXBlLCBhbGlnbiwgcHJldiwgaW5mbykge1xuICAgIHRoaXMuaW5kZW50ZWQgPSBpbmRlbnRlZDtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgICBpZiAoYWxpZ24gIT0gbnVsbCkgdGhpcy5hbGlnbiA9IGFsaWduO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5TY29wZShzdGF0ZSwgdmFybmFtZSkge1xuICAgIGlmICghdHJhY2tTY29wZSkgcmV0dXJuIGZhbHNlXG4gICAgZm9yICh2YXIgdiA9IHN0YXRlLmxvY2FsVmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgIGlmICh2Lm5hbWUgPT0gdmFybmFtZSkgcmV0dXJuIHRydWU7XG4gICAgZm9yICh2YXIgY3ggPSBzdGF0ZS5jb250ZXh0OyBjeDsgY3ggPSBjeC5wcmV2KSB7XG4gICAgICBmb3IgKHZhciB2ID0gY3gudmFyczsgdjsgdiA9IHYubmV4dClcbiAgICAgICAgaWYgKHYubmFtZSA9PSB2YXJuYW1lKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUpTKHN0YXRlLCBzdHlsZSwgdHlwZSwgY29udGVudCwgc3RyZWFtKSB7XG4gICAgdmFyIGNjID0gc3RhdGUuY2M7XG4gICAgLy8gQ29tbXVuaWNhdGUgb3VyIGNvbnRleHQgdG8gdGhlIGNvbWJpbmF0b3JzLlxuICAgIC8vIChMZXNzIHdhc3RlZnVsIHRoYW4gY29uc2luZyB1cCBhIGh1bmRyZWQgY2xvc3VyZXMgb24gZXZlcnkgY2FsbC4pXG4gICAgY3guc3RhdGUgPSBzdGF0ZTsgY3guc3RyZWFtID0gc3RyZWFtOyBjeC5tYXJrZWQgPSBudWxsLCBjeC5jYyA9IGNjOyBjeC5zdHlsZSA9IHN0eWxlO1xuXG4gICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICBzdGF0ZS5sZXhpY2FsLmFsaWduID0gdHJ1ZTtcblxuICAgIHdoaWxlKHRydWUpIHtcbiAgICAgIHZhciBjb21iaW5hdG9yID0gY2MubGVuZ3RoID8gY2MucG9wKCkgOiBqc29uTW9kZSA/IGV4cHJlc3Npb24gOiBzdGF0ZW1lbnQ7XG4gICAgICBpZiAoY29tYmluYXRvcih0eXBlLCBjb250ZW50KSkge1xuICAgICAgICB3aGlsZShjYy5sZW5ndGggJiYgY2NbY2MubGVuZ3RoIC0gMV0ubGV4KVxuICAgICAgICAgIGNjLnBvcCgpKCk7XG4gICAgICAgIGlmIChjeC5tYXJrZWQpIHJldHVybiBjeC5tYXJrZWQ7XG4gICAgICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBpblNjb3BlKHN0YXRlLCBjb250ZW50KSkgcmV0dXJuIFwidmFyaWFibGUtMlwiO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tYmluYXRvciB1dGlsc1xuXG4gIHZhciBjeCA9IHtzdGF0ZTogbnVsbCwgY29sdW1uOiBudWxsLCBtYXJrZWQ6IG51bGwsIGNjOiBudWxsfTtcbiAgZnVuY3Rpb24gcGFzcygpIHtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjeC5jYy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udCgpIHtcbiAgICBwYXNzLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gaW5MaXN0KG5hbWUsIGxpc3QpIHtcbiAgICBmb3IgKHZhciB2ID0gbGlzdDsgdjsgdiA9IHYubmV4dCkgaWYgKHYubmFtZSA9PSBuYW1lKSByZXR1cm4gdHJ1ZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmdW5jdGlvbiByZWdpc3Rlcih2YXJuYW1lKSB7XG4gICAgdmFyIHN0YXRlID0gY3guc3RhdGU7XG4gICAgY3gubWFya2VkID0gXCJkZWZcIjtcbiAgICBpZiAoIXRyYWNrU2NvcGUpIHJldHVyblxuICAgIGlmIChzdGF0ZS5jb250ZXh0KSB7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC5pbmZvID09IFwidmFyXCIgJiYgc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LmJsb2NrKSB7XG4gICAgICAgIC8vIEZJWE1FIGZ1bmN0aW9uIGRlY2xzIGFyZSBhbHNvIG5vdCBibG9jayBzY29wZWRcbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSByZWdpc3RlclZhclNjb3BlZCh2YXJuYW1lLCBzdGF0ZS5jb250ZXh0KVxuICAgICAgICBpZiAobmV3Q29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgc3RhdGUuY29udGV4dCA9IG5ld0NvbnRleHRcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5MaXN0KHZhcm5hbWUsIHN0YXRlLmxvY2FsVmFycykpIHtcbiAgICAgICAgc3RhdGUubG9jYWxWYXJzID0gbmV3IFZhcih2YXJuYW1lLCBzdGF0ZS5sb2NhbFZhcnMpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIHRocm91Z2ggbWVhbnMgdGhpcyBpcyBnbG9iYWxcbiAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgJiYgIWluTGlzdCh2YXJuYW1lLCBzdGF0ZS5nbG9iYWxWYXJzKSlcbiAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSBuZXcgVmFyKHZhcm5hbWUsIHN0YXRlLmdsb2JhbFZhcnMpXG4gIH1cbiAgZnVuY3Rpb24gcmVnaXN0ZXJWYXJTY29wZWQodmFybmFtZSwgY29udGV4dCkge1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQuYmxvY2spIHtcbiAgICAgIHZhciBpbm5lciA9IHJlZ2lzdGVyVmFyU2NvcGVkKHZhcm5hbWUsIGNvbnRleHQucHJldilcbiAgICAgIGlmICghaW5uZXIpIHJldHVybiBudWxsXG4gICAgICBpZiAoaW5uZXIgPT0gY29udGV4dC5wcmV2KSByZXR1cm4gY29udGV4dFxuICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGlubmVyLCBjb250ZXh0LnZhcnMsIHRydWUpXG4gICAgfSBlbHNlIGlmIChpbkxpc3QodmFybmFtZSwgY29udGV4dC52YXJzKSkge1xuICAgICAgcmV0dXJuIGNvbnRleHRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDb250ZXh0KGNvbnRleHQucHJldiwgbmV3IFZhcih2YXJuYW1lLCBjb250ZXh0LnZhcnMpLCBmYWxzZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc01vZGlmaWVyKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSA9PSBcInB1YmxpY1wiIHx8IG5hbWUgPT0gXCJwcml2YXRlXCIgfHwgbmFtZSA9PSBcInByb3RlY3RlZFwiIHx8IG5hbWUgPT0gXCJhYnN0cmFjdFwiIHx8IG5hbWUgPT0gXCJyZWFkb25seVwiXG4gIH1cblxuICAvLyBDb21iaW5hdG9yc1xuXG4gIGZ1bmN0aW9uIENvbnRleHQocHJldiwgdmFycywgYmxvY2spIHsgdGhpcy5wcmV2ID0gcHJldjsgdGhpcy52YXJzID0gdmFyczsgdGhpcy5ibG9jayA9IGJsb2NrIH1cbiAgZnVuY3Rpb24gVmFyKG5hbWUsIG5leHQpIHsgdGhpcy5uYW1lID0gbmFtZTsgdGhpcy5uZXh0ID0gbmV4dCB9XG5cbiAgdmFyIGRlZmF1bHRWYXJzID0gbmV3IFZhcihcInRoaXNcIiwgbmV3IFZhcihcImFyZ3VtZW50c1wiLCBudWxsKSlcbiAgZnVuY3Rpb24gcHVzaGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUuY29udGV4dCA9IG5ldyBDb250ZXh0KGN4LnN0YXRlLmNvbnRleHQsIGN4LnN0YXRlLmxvY2FsVmFycywgZmFsc2UpXG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gZGVmYXVsdFZhcnNcbiAgfVxuICBmdW5jdGlvbiBwdXNoYmxvY2tjb250ZXh0KCkge1xuICAgIGN4LnN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChjeC5zdGF0ZS5jb250ZXh0LCBjeC5zdGF0ZS5sb2NhbFZhcnMsIHRydWUpXG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gbnVsbFxuICB9XG4gIGZ1bmN0aW9uIHBvcGNvbnRleHQoKSB7XG4gICAgY3guc3RhdGUubG9jYWxWYXJzID0gY3guc3RhdGUuY29udGV4dC52YXJzXG4gICAgY3guc3RhdGUuY29udGV4dCA9IGN4LnN0YXRlLmNvbnRleHQucHJldlxuICB9XG4gIHBvcGNvbnRleHQubGV4ID0gdHJ1ZVxuICBmdW5jdGlvbiBwdXNobGV4KHR5cGUsIGluZm8pIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZSwgaW5kZW50ID0gc3RhdGUuaW5kZW50ZWQ7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwic3RhdFwiKSBpbmRlbnQgPSBzdGF0ZS5sZXhpY2FsLmluZGVudGVkO1xuICAgICAgZWxzZSBmb3IgKHZhciBvdXRlciA9IHN0YXRlLmxleGljYWw7IG91dGVyICYmIG91dGVyLnR5cGUgPT0gXCIpXCIgJiYgb3V0ZXIuYWxpZ247IG91dGVyID0gb3V0ZXIucHJldilcbiAgICAgICAgaW5kZW50ID0gb3V0ZXIuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gbmV3IEpTTGV4aWNhbChpbmRlbnQsIGN4LnN0cmVhbS5jb2x1bW4oKSwgdHlwZSwgbnVsbCwgc3RhdGUubGV4aWNhbCwgaW5mbyk7XG4gICAgfTtcbiAgICByZXN1bHQubGV4ID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIHBvcGxleCgpIHtcbiAgICB2YXIgc3RhdGUgPSBjeC5zdGF0ZTtcbiAgICBpZiAoc3RhdGUubGV4aWNhbC5wcmV2KSB7XG4gICAgICBpZiAoc3RhdGUubGV4aWNhbC50eXBlID09IFwiKVwiKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0YXRlLmxleGljYWwuaW5kZW50ZWQ7XG4gICAgICBzdGF0ZS5sZXhpY2FsID0gc3RhdGUubGV4aWNhbC5wcmV2O1xuICAgIH1cbiAgfVxuICBwb3BsZXgubGV4ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBleHBlY3Qod2FudGVkKSB7XG4gICAgZnVuY3Rpb24gZXhwKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09IHdhbnRlZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIGVsc2UgaWYgKHdhbnRlZCA9PSBcIjtcIiB8fCB0eXBlID09IFwifVwiIHx8IHR5cGUgPT0gXCIpXCIgfHwgdHlwZSA9PSBcIl1cIikgcmV0dXJuIHBhc3MoKTtcbiAgICAgIGVsc2UgcmV0dXJuIGNvbnQoZXhwKTtcbiAgICB9O1xuICAgIHJldHVybiBleHA7XG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZW1lbnQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udChwdXNobGV4KFwidmFyZGVmXCIsIHZhbHVlKSwgdmFyZGVmLCBleHBlY3QoXCI7XCIpLCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBhXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwYXJlbkV4cHIsIHN0YXRlbWVudCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgYlwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBkXCIpIHJldHVybiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqJC8sIGZhbHNlKSA/IGNvbnQoKSA6IGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiO1wiKSwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImRlYnVnZ2VyXCIpIHJldHVybiBjb250KGV4cGVjdChcIjtcIikpO1xuICAgIGlmICh0eXBlID09IFwie1wiKSByZXR1cm4gY29udChwdXNobGV4KFwifVwiKSwgcHVzaGJsb2NrY29udGV4dCwgYmxvY2ssIHBvcGxleCwgcG9wY29udGV4dCk7XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KCk7XG4gICAgaWYgKHR5cGUgPT0gXCJpZlwiKSB7XG4gICAgICBpZiAoY3guc3RhdGUubGV4aWNhbC5pbmZvID09IFwiZWxzZVwiICYmIGN4LnN0YXRlLmNjW2N4LnN0YXRlLmNjLmxlbmd0aCAtIDFdID09IHBvcGxleClcbiAgICAgICAgY3guc3RhdGUuY2MucG9wKCkoKTtcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBwYXJlbkV4cHIsIHN0YXRlbWVudCwgcG9wbGV4LCBtYXliZWVsc2UpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTtcbiAgICBpZiAodHlwZSA9PSBcImZvclwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcHVzaGJsb2NrY29udGV4dCwgZm9yc3BlYywgc3RhdGVtZW50LCBwb3Bjb250ZXh0LCBwb3BsZXgpO1xuICAgIGlmICh0eXBlID09IFwiY2xhc3NcIiB8fCAoaXNUUyAmJiB2YWx1ZSA9PSBcImludGVyZmFjZVwiKSkge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIsIHR5cGUgPT0gXCJjbGFzc1wiID8gdHlwZSA6IHZhbHVlKSwgY2xhc3NOYW1lLCBwb3BsZXgpXG4gICAgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCJkZWNsYXJlXCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgICAgcmV0dXJuIGNvbnQoc3RhdGVtZW50KVxuICAgICAgfSBlbHNlIGlmIChpc1RTICYmICh2YWx1ZSA9PSBcIm1vZHVsZVwiIHx8IHZhbHVlID09IFwiZW51bVwiIHx8IHZhbHVlID09IFwidHlwZVwiKSAmJiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqXFx3LywgZmFsc2UpKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICAgIGlmICh2YWx1ZSA9PSBcImVudW1cIikgcmV0dXJuIGNvbnQoZW51bWRlZik7XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09IFwidHlwZVwiKSByZXR1cm4gY29udCh0eXBlbmFtZSwgZXhwZWN0KFwib3BlcmF0b3JcIiksIHR5cGVleHByLCBleHBlY3QoXCI7XCIpKTtcbiAgICAgICAgZWxzZSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGF0dGVybiwgZXhwZWN0KFwie1wiKSwgcHVzaGxleChcIn1cIiksIGJsb2NrLCBwb3BsZXgsIHBvcGxleClcbiAgICAgIH0gZWxzZSBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIm5hbWVzcGFjZVwiKSB7XG4gICAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBleHByZXNzaW9uLCBzdGF0ZW1lbnQsIHBvcGxleClcbiAgICAgIH0gZWxzZSBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcImFic3RyYWN0XCIpIHtcbiAgICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgICAgcmV0dXJuIGNvbnQoc3RhdGVtZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnQocHVzaGxleChcInN0YXRcIiksIG1heWJlbGFiZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInN3aXRjaFwiKSByZXR1cm4gY29udChwdXNobGV4KFwiZm9ybVwiKSwgcGFyZW5FeHByLCBleHBlY3QoXCJ7XCIpLCBwdXNobGV4KFwifVwiLCBcInN3aXRjaFwiKSwgcHVzaGJsb2NrY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ssIHBvcGxleCwgcG9wbGV4LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcImNhc2VcIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgZXhwZWN0KFwiOlwiKSk7XG4gICAgaWYgKHR5cGUgPT0gXCJkZWZhdWx0XCIpIHJldHVybiBjb250KGV4cGVjdChcIjpcIikpO1xuICAgIGlmICh0eXBlID09IFwiY2F0Y2hcIikgcmV0dXJuIGNvbnQocHVzaGxleChcImZvcm1cIiksIHB1c2hjb250ZXh0LCBtYXliZUNhdGNoQmluZGluZywgc3RhdGVtZW50LCBwb3BsZXgsIHBvcGNvbnRleHQpO1xuICAgIGlmICh0eXBlID09IFwiZXhwb3J0XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJzdGF0XCIpLCBhZnRlckV4cG9ydCwgcG9wbGV4KTtcbiAgICBpZiAodHlwZSA9PSBcImltcG9ydFwiKSByZXR1cm4gY29udChwdXNobGV4KFwic3RhdFwiKSwgYWZ0ZXJJbXBvcnQsIHBvcGxleCk7XG4gICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiKSByZXR1cm4gY29udChzdGF0ZW1lbnQpXG4gICAgaWYgKHZhbHVlID09IFwiQFwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBzdGF0ZW1lbnQpXG4gICAgcmV0dXJuIHBhc3MocHVzaGxleChcInN0YXRcIiksIGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVDYXRjaEJpbmRpbmcodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChmdW5hcmcsIGV4cGVjdChcIilcIikpXG4gIH1cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbih0eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uSW5uZXIodHlwZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBleHByZXNzaW9uTm9Db21tYSh0eXBlLCB2YWx1ZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uSW5uZXIodHlwZSwgdmFsdWUsIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcmVuRXhwcih0eXBlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCIoXCIpIHJldHVybiBwYXNzKClcbiAgICByZXR1cm4gY29udChwdXNobGV4KFwiKVwiKSwgbWF5YmVleHByZXNzaW9uLCBleHBlY3QoXCIpXCIpLCBwb3BsZXgpXG4gIH1cbiAgZnVuY3Rpb24gZXhwcmVzc2lvbklubmVyKHR5cGUsIHZhbHVlLCBub0NvbW1hKSB7XG4gICAgaWYgKGN4LnN0YXRlLmZhdEFycm93QXQgPT0gY3guc3RyZWFtLnN0YXJ0KSB7XG4gICAgICB2YXIgYm9keSA9IG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5O1xuICAgICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KHB1c2hjb250ZXh0LCBwdXNobGV4KFwiKVwiKSwgY29tbWFzZXAoZnVuYXJnLCBcIilcIiksIHBvcGxleCwgZXhwZWN0KFwiPT5cIiksIGJvZHksIHBvcGNvbnRleHQpO1xuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBwYXNzKHB1c2hjb250ZXh0LCBwYXR0ZXJuLCBleHBlY3QoXCI9PlwiKSwgYm9keSwgcG9wY29udGV4dCk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlb3AgPSBub0NvbW1hID8gbWF5YmVvcGVyYXRvck5vQ29tbWEgOiBtYXliZW9wZXJhdG9yQ29tbWE7XG4gICAgaWYgKGF0b21pY1R5cGVzLmhhc093blByb3BlcnR5KHR5cGUpKSByZXR1cm4gY29udChtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBjb250KGZ1bmN0aW9uZGVmLCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcImNsYXNzXCIgfHwgKGlzVFMgJiYgdmFsdWUgPT0gXCJpbnRlcmZhY2VcIikpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIpLCBjbGFzc0V4cHJlc3Npb24sIHBvcGxleCk7IH1cbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmQgY1wiIHx8IHR5cGUgPT0gXCJhc3luY1wiKSByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIG1heWJlZXhwcmVzc2lvbiwgZXhwZWN0KFwiKVwiKSwgcG9wbGV4LCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIgfHwgdHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChub0NvbW1hID8gZXhwcmVzc2lvbk5vQ29tbWEgOiBleHByZXNzaW9uKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGFycmF5TGl0ZXJhbCwgcG9wbGV4LCBtYXliZW9wKTtcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnRDb21tYXNlcChvYmpwcm9wLCBcIn1cIiwgbnVsbCwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJxdWFzaVwiKSByZXR1cm4gcGFzcyhxdWFzaSwgbWF5YmVvcCk7XG4gICAgaWYgKHR5cGUgPT0gXCJuZXdcIikgcmV0dXJuIGNvbnQobWF5YmVUYXJnZXQobm9Db21tYSkpO1xuICAgIHJldHVybiBjb250KCk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVleHByZXNzaW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS5tYXRjaCgvWztcXH1cXClcXF0sXS8pKSByZXR1cm4gcGFzcygpO1xuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvckNvbW1hKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KG1heWJlZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIG1heWJlb3BlcmF0b3JOb0NvbW1hKHR5cGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVvcGVyYXRvck5vQ29tbWEodHlwZSwgdmFsdWUsIG5vQ29tbWEpIHtcbiAgICB2YXIgbWUgPSBub0NvbW1hID09IGZhbHNlID8gbWF5YmVvcGVyYXRvckNvbW1hIDogbWF5YmVvcGVyYXRvck5vQ29tbWE7XG4gICAgdmFyIGV4cHIgPSBub0NvbW1hID09IGZhbHNlID8gZXhwcmVzc2lvbiA6IGV4cHJlc3Npb25Ob0NvbW1hO1xuICAgIGlmICh0eXBlID09IFwiPT5cIikgcmV0dXJuIGNvbnQocHVzaGNvbnRleHQsIG5vQ29tbWEgPyBhcnJvd0JvZHlOb0NvbW1hIDogYXJyb3dCb2R5LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAodHlwZSA9PSBcIm9wZXJhdG9yXCIpIHtcbiAgICAgIGlmICgvXFwrXFwrfC0tLy50ZXN0KHZhbHVlKSB8fCBpc1RTICYmIHZhbHVlID09IFwiIVwiKSByZXR1cm4gY29udChtZSk7XG4gICAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIjxcIiAmJiBjeC5zdHJlYW0ubWF0Y2goL14oW148Pl18PFtePD5dKj4pKj5cXHMqXFwoLywgZmFsc2UpKVxuICAgICAgICByZXR1cm4gY29udChwdXNobGV4KFwiPlwiKSwgY29tbWFzZXAodHlwZWV4cHIsIFwiPlwiKSwgcG9wbGV4LCBtZSk7XG4gICAgICBpZiAodmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjpcIiksIGV4cHIpO1xuICAgICAgcmV0dXJuIGNvbnQoZXhwcik7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwicXVhc2lcIikgeyByZXR1cm4gcGFzcyhxdWFzaSwgbWUpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybjtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnRDb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCIpXCIsIFwiY2FsbFwiLCBtZSk7XG4gICAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBjb250KHByb3BlcnR5LCBtZSk7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJdXCIpLCBtYXliZWV4cHJlc3Npb24sIGV4cGVjdChcIl1cIiksIHBvcGxleCwgbWUpO1xuICAgIGlmIChpc1RTICYmIHZhbHVlID09IFwiYXNcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQodHlwZWV4cHIsIG1lKSB9XG4gICAgaWYgKHR5cGUgPT0gXCJyZWdleHBcIikge1xuICAgICAgY3guc3RhdGUubGFzdFR5cGUgPSBjeC5tYXJrZWQgPSBcIm9wZXJhdG9yXCJcbiAgICAgIGN4LnN0cmVhbS5iYWNrVXAoY3guc3RyZWFtLnBvcyAtIGN4LnN0cmVhbS5zdGFydCAtIDEpXG4gICAgICByZXR1cm4gY29udChleHByKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBxdWFzaSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlICE9IFwicXVhc2lcIikgcmV0dXJuIHBhc3MoKTtcbiAgICBpZiAodmFsdWUuc2xpY2UodmFsdWUubGVuZ3RoIC0gMikgIT0gXCIke1wiKSByZXR1cm4gY29udChxdWFzaSk7XG4gICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgY29udGludWVRdWFzaSk7XG4gIH1cbiAgZnVuY3Rpb24gY29udGludWVRdWFzaSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwic3RyaW5nLTJcIjtcbiAgICAgIGN4LnN0YXRlLnRva2VuaXplID0gdG9rZW5RdWFzaTtcbiAgICAgIHJldHVybiBjb250KHF1YXNpKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXJyb3dCb2R5KHR5cGUpIHtcbiAgICBmaW5kRmF0QXJyb3coY3guc3RyZWFtLCBjeC5zdGF0ZSk7XG4gICAgcmV0dXJuIHBhc3ModHlwZSA9PSBcIntcIiA/IHN0YXRlbWVudCA6IGV4cHJlc3Npb24pO1xuICB9XG4gIGZ1bmN0aW9uIGFycm93Qm9keU5vQ29tbWEodHlwZSkge1xuICAgIGZpbmRGYXRBcnJvdyhjeC5zdHJlYW0sIGN4LnN0YXRlKTtcbiAgICByZXR1cm4gcGFzcyh0eXBlID09IFwie1wiID8gc3RhdGVtZW50IDogZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlVGFyZ2V0KG5vQ29tbWEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBjb250KG5vQ29tbWEgPyB0YXJnZXROb0NvbW1hIDogdGFyZ2V0KTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiICYmIGlzVFMpIHJldHVybiBjb250KG1heWJlVHlwZUFyZ3MsIG5vQ29tbWEgPyBtYXliZW9wZXJhdG9yTm9Db21tYSA6IG1heWJlb3BlcmF0b3JDb21tYSlcbiAgICAgIGVsc2UgcmV0dXJuIHBhc3Mobm9Db21tYSA/IGV4cHJlc3Npb25Ob0NvbW1hIDogZXhwcmVzc2lvbik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB0YXJnZXQoXywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJ0YXJnZXRcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvckNvbW1hKTsgfVxuICB9XG4gIGZ1bmN0aW9uIHRhcmdldE5vQ29tbWEoXywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJ0YXJnZXRcIikgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQobWF5YmVvcGVyYXRvck5vQ29tbWEpOyB9XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVsYWJlbCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KHBvcGxleCwgc3RhdGVtZW50KTtcbiAgICByZXR1cm4gcGFzcyhtYXliZW9wZXJhdG9yQ29tbWEsIGV4cGVjdChcIjtcIiksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvcGVydHkodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge2N4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjsgcmV0dXJuIGNvbnQoKTt9XG4gIH1cbiAgZnVuY3Rpb24gb2JqcHJvcCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwiYXN5bmNcIikge1xuICAgICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgcmV0dXJuIGNvbnQob2JqcHJvcCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwidmFyaWFibGVcIiB8fCBjeC5zdHlsZSA9PSBcImtleXdvcmRcIikge1xuICAgICAgY3gubWFya2VkID0gXCJwcm9wZXJ0eVwiO1xuICAgICAgaWYgKHZhbHVlID09IFwiZ2V0XCIgfHwgdmFsdWUgPT0gXCJzZXRcIikgcmV0dXJuIGNvbnQoZ2V0dGVyU2V0dGVyKTtcbiAgICAgIHZhciBtIC8vIFdvcmsgYXJvdW5kIGZhdC1hcnJvdy1kZXRlY3Rpb24gY29tcGxpY2F0aW9uIGZvciBkZXRlY3RpbmcgdHlwZXNjcmlwdCB0eXBlZCBhcnJvdyBwYXJhbXNcbiAgICAgIGlmIChpc1RTICYmIGN4LnN0YXRlLmZhdEFycm93QXQgPT0gY3guc3RyZWFtLnN0YXJ0ICYmIChtID0gY3guc3RyZWFtLm1hdGNoKC9eXFxzKjpcXHMqLywgZmFsc2UpKSlcbiAgICAgICAgY3guc3RhdGUuZmF0QXJyb3dBdCA9IGN4LnN0cmVhbS5wb3MgKyBtWzBdLmxlbmd0aFxuICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCJudW1iZXJcIiB8fCB0eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IGpzb25sZE1vZGUgPyBcInByb3BlcnR5XCIgOiAoY3guc3R5bGUgKyBcIiBwcm9wZXJ0eVwiKTtcbiAgICAgIHJldHVybiBjb250KGFmdGVycHJvcCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwianNvbmxkLWtleXdvcmRcIikge1xuICAgICAgcmV0dXJuIGNvbnQoYWZ0ZXJwcm9wKTtcbiAgICB9IGVsc2UgaWYgKGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiXG4gICAgICByZXR1cm4gY29udChvYmpwcm9wKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIltcIikge1xuICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgbWF5YmV0eXBlLCBleHBlY3QoXCJdXCIpLCBhZnRlcnByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSB7XG4gICAgICByZXR1cm4gY29udChleHByZXNzaW9uTm9Db21tYSwgYWZ0ZXJwcm9wKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwiKlwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBjb250KG9ianByb3ApO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIjpcIikge1xuICAgICAgcmV0dXJuIHBhc3MoYWZ0ZXJwcm9wKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXR0ZXJTZXR0ZXIodHlwZSkge1xuICAgIGlmICh0eXBlICE9IFwidmFyaWFibGVcIikgcmV0dXJuIHBhc3MoYWZ0ZXJwcm9wKTtcbiAgICBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgcmV0dXJuIGNvbnQoZnVuY3Rpb25kZWYpO1xuICB9XG4gIGZ1bmN0aW9uIGFmdGVycHJvcCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI6XCIpIHJldHVybiBjb250KGV4cHJlc3Npb25Ob0NvbW1hKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWYpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbW1hc2VwKHdoYXQsIGVuZCwgc2VwKSB7XG4gICAgZnVuY3Rpb24gcHJvY2VlZCh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHNlcCA/IHNlcC5pbmRleE9mKHR5cGUpID4gLTEgOiB0eXBlID09IFwiLFwiKSB7XG4gICAgICAgIHZhciBsZXggPSBjeC5zdGF0ZS5sZXhpY2FsO1xuICAgICAgICBpZiAobGV4LmluZm8gPT0gXCJjYWxsXCIpIGxleC5wb3MgPSAobGV4LnBvcyB8fCAwKSArIDE7XG4gICAgICAgIHJldHVybiBjb250KGZ1bmN0aW9uKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gZW5kIHx8IHZhbHVlID09IGVuZCkgcmV0dXJuIHBhc3MoKVxuICAgICAgICAgIHJldHVybiBwYXNzKHdoYXQpXG4gICAgICAgIH0sIHByb2NlZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gZW5kIHx8IHZhbHVlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIGlmIChzZXAgJiYgc2VwLmluZGV4T2YoXCI7XCIpID4gLTEpIHJldHVybiBwYXNzKHdoYXQpXG4gICAgICByZXR1cm4gY29udChleHBlY3QoZW5kKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgPT0gZW5kIHx8IHZhbHVlID09IGVuZCkgcmV0dXJuIGNvbnQoKTtcbiAgICAgIHJldHVybiBwYXNzKHdoYXQsIHByb2NlZWQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY29udENvbW1hc2VwKHdoYXQsIGVuZCwgaW5mbykge1xuICAgIGZvciAodmFyIGkgPSAzOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgY3guY2MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIHJldHVybiBjb250KHB1c2hsZXgoZW5kLCBpbmZvKSwgY29tbWFzZXAod2hhdCwgZW5kKSwgcG9wbGV4KTtcbiAgfVxuICBmdW5jdGlvbiBibG9jayh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBjb250KCk7XG4gICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50LCBibG9jayk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmV0eXBlKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKGlzVFMpIHtcbiAgICAgIGlmICh0eXBlID09IFwiOlwiKSByZXR1cm4gY29udCh0eXBlZXhwcik7XG4gICAgICBpZiAodmFsdWUgPT0gXCI/XCIpIHJldHVybiBjb250KG1heWJldHlwZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1heWJldHlwZU9ySW4odHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNUUyAmJiAodHlwZSA9PSBcIjpcIiB8fCB2YWx1ZSA9PSBcImluXCIpKSByZXR1cm4gY29udCh0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiBtYXliZXJldHR5cGUodHlwZSkge1xuICAgIGlmIChpc1RTICYmIHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgIGlmIChjeC5zdHJlYW0ubWF0Y2goL15cXHMqXFx3K1xccytpc1xcYi8sIGZhbHNlKSkgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgaXNLVywgdHlwZWV4cHIpXG4gICAgICBlbHNlIHJldHVybiBjb250KHR5cGVleHByKVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0tXKF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiaXNcIikge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgIHJldHVybiBjb250KClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHlwZWV4cHIodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJrZXlvZlwiIHx8IHZhbHVlID09IFwidHlwZW9mXCIgfHwgdmFsdWUgPT0gXCJpbmZlclwiIHx8IHZhbHVlID09IFwicmVhZG9ubHlcIikge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCJcbiAgICAgIHJldHVybiBjb250KHZhbHVlID09IFwidHlwZW9mXCIgPyBleHByZXNzaW9uTm9Db21tYSA6IHR5cGVleHByKVxuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgdmFsdWUgPT0gXCJ2b2lkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwidHlwZVwiXG4gICAgICByZXR1cm4gY29udChhZnRlclR5cGUpXG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBcInxcIiB8fCB2YWx1ZSA9PSBcIiZcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcImF0b21cIikgcmV0dXJuIGNvbnQoYWZ0ZXJUeXBlKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIl1cIiksIGNvbW1hc2VwKHR5cGVleHByLCBcIl1cIiwgXCIsXCIpLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgICBpZiAodHlwZSA9PSBcIntcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIn1cIiksIHR5cGVwcm9wcywgcG9wbGV4LCBhZnRlclR5cGUpXG4gICAgaWYgKHR5cGUgPT0gXCIoXCIpIHJldHVybiBjb250KGNvbW1hc2VwKHR5cGVhcmcsIFwiKVwiKSwgbWF5YmVSZXR1cm5UeXBlLCBhZnRlclR5cGUpXG4gICAgaWYgKHR5cGUgPT0gXCI8XCIpIHJldHVybiBjb250KGNvbW1hc2VwKHR5cGVleHByLCBcIj5cIiksIHR5cGVleHByKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlUmV0dXJuVHlwZSh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCI9PlwiKSByZXR1cm4gY29udCh0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiB0eXBlcHJvcHModHlwZSkge1xuICAgIGlmICh0eXBlLm1hdGNoKC9bXFx9XFwpXFxdXS8pKSByZXR1cm4gY29udCgpXG4gICAgaWYgKHR5cGUgPT0gXCIsXCIgfHwgdHlwZSA9PSBcIjtcIikgcmV0dXJuIGNvbnQodHlwZXByb3BzKVxuICAgIHJldHVybiBwYXNzKHR5cGVwcm9wLCB0eXBlcHJvcHMpXG4gIH1cbiAgZnVuY3Rpb24gdHlwZXByb3AodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIlxuICAgICAgcmV0dXJuIGNvbnQodHlwZXByb3ApXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIj9cIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gY29udCh0eXBlcHJvcClcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBjb250KHR5cGVleHByKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIltcIikge1xuICAgICAgcmV0dXJuIGNvbnQoZXhwZWN0KFwidmFyaWFibGVcIiksIG1heWJldHlwZU9ySW4sIGV4cGVjdChcIl1cIiksIHR5cGVwcm9wKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcIihcIikge1xuICAgICAgcmV0dXJuIHBhc3MoZnVuY3Rpb25kZWNsLCB0eXBlcHJvcClcbiAgICB9IGVsc2UgaWYgKCF0eXBlLm1hdGNoKC9bO1xcfVxcKVxcXSxdLykpIHtcbiAgICAgIHJldHVybiBjb250KClcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHlwZWFyZyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiBjeC5zdHJlYW0ubWF0Y2goL15cXHMqWz86XS8sIGZhbHNlKSB8fCB2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQodHlwZWFyZylcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJzcHJlYWRcIikgcmV0dXJuIGNvbnQodHlwZWFyZylcbiAgICByZXR1cm4gcGFzcyh0eXBlZXhwcilcbiAgfVxuICBmdW5jdGlvbiBhZnRlclR5cGUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgICBpZiAodmFsdWUgPT0gXCJ8XCIgfHwgdHlwZSA9PSBcIi5cIiB8fCB2YWx1ZSA9PSBcIiZcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KHR5cGVleHByLCBleHBlY3QoXCJdXCIpLCBhZnRlclR5cGUpXG4gICAgaWYgKHZhbHVlID09IFwiZXh0ZW5kc1wiIHx8IHZhbHVlID09IFwiaW1wbGVtZW50c1wiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udCh0eXBlZXhwcikgfVxuICAgIGlmICh2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQodHlwZWV4cHIsIGV4cGVjdChcIjpcIiksIHR5cGVleHByKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlVHlwZUFyZ3MoXywgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlZXhwciwgXCI+XCIpLCBwb3BsZXgsIGFmdGVyVHlwZSlcbiAgfVxuICBmdW5jdGlvbiB0eXBlcGFyYW0oKSB7XG4gICAgcmV0dXJuIHBhc3ModHlwZWV4cHIsIG1heWJlVHlwZURlZmF1bHQpXG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVUeXBlRGVmYXVsdChfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQodHlwZWV4cHIpXG4gIH1cbiAgZnVuY3Rpb24gdmFyZGVmKF8sIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiZW51bVwiKSB7Y3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGVudW1kZWYpfVxuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJldHlwZSwgbWF5YmVBc3NpZ24sIHZhcmRlZkNvbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHBhdHRlcm4odHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoaXNUUyAmJiBpc01vZGlmaWVyKHZhbHVlKSkgeyBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjsgcmV0dXJuIGNvbnQocGF0dGVybikgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgeyByZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KCk7IH1cbiAgICBpZiAodHlwZSA9PSBcInNwcmVhZFwiKSByZXR1cm4gY29udChwYXR0ZXJuKTtcbiAgICBpZiAodHlwZSA9PSBcIltcIikgcmV0dXJuIGNvbnRDb21tYXNlcChlbHRwYXR0ZXJuLCBcIl1cIik7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAocHJvcHBhdHRlcm4sIFwifVwiKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9wcGF0dGVybih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIiAmJiAhY3guc3RyZWFtLm1hdGNoKC9eXFxzKjovLCBmYWxzZSkpIHtcbiAgICAgIHJlZ2lzdGVyKHZhbHVlKTtcbiAgICAgIHJldHVybiBjb250KG1heWJlQXNzaWduKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSBjeC5tYXJrZWQgPSBcInByb3BlcnR5XCI7XG4gICAgaWYgKHR5cGUgPT0gXCJzcHJlYWRcIikgcmV0dXJuIGNvbnQocGF0dGVybik7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBwYXNzKCk7XG4gICAgaWYgKHR5cGUgPT0gXCJbXCIpIHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdCgnXScpLCBleHBlY3QoJzonKSwgcHJvcHBhdHRlcm4pO1xuICAgIHJldHVybiBjb250KGV4cGVjdChcIjpcIiksIHBhdHRlcm4sIG1heWJlQXNzaWduKTtcbiAgfVxuICBmdW5jdGlvbiBlbHRwYXR0ZXJuKCkge1xuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJlQXNzaWduKVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlQXNzaWduKF90eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpO1xuICB9XG4gIGZ1bmN0aW9uIHZhcmRlZkNvbnQodHlwZSkge1xuICAgIGlmICh0eXBlID09IFwiLFwiKSByZXR1cm4gY29udCh2YXJkZWYpO1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlZWxzZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwia2V5d29yZCBiXCIgJiYgdmFsdWUgPT0gXCJlbHNlXCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJmb3JtXCIsIFwiZWxzZVwiKSwgc3RhdGVtZW50LCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJhd2FpdFwiKSByZXR1cm4gY29udChmb3JzcGVjKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIilcIiksIGZvcnNwZWMxLCBwb3BsZXgpO1xuICB9XG4gIGZ1bmN0aW9uIGZvcnNwZWMxKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcInZhclwiKSByZXR1cm4gY29udCh2YXJkZWYsIGZvcnNwZWMyKTtcbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHJldHVybiBjb250KGZvcnNwZWMyKTtcbiAgICByZXR1cm4gcGFzcyhmb3JzcGVjMilcbiAgfVxuICBmdW5jdGlvbiBmb3JzcGVjMih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwiKVwiKSByZXR1cm4gY29udCgpXG4gICAgaWYgKHR5cGUgPT0gXCI7XCIpIHJldHVybiBjb250KGZvcnNwZWMyKVxuICAgIGlmICh2YWx1ZSA9PSBcImluXCIgfHwgdmFsdWUgPT0gXCJvZlwiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChleHByZXNzaW9uLCBmb3JzcGVjMikgfVxuICAgIHJldHVybiBwYXNzKGV4cHJlc3Npb24sIGZvcnNwZWMyKVxuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uZGVmKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSB7Y3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGZ1bmN0aW9uZGVmKTt9XG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSB7cmVnaXN0ZXIodmFsdWUpOyByZXR1cm4gY29udChmdW5jdGlvbmRlZik7fVxuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIG1heWJlcmV0dHlwZSwgc3RhdGVtZW50LCBwb3Bjb250ZXh0KTtcbiAgICBpZiAoaXNUUyAmJiB2YWx1ZSA9PSBcIjxcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIj5cIiksIGNvbW1hc2VwKHR5cGVwYXJhbSwgXCI+XCIpLCBwb3BsZXgsIGZ1bmN0aW9uZGVmKVxuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uZGVjbCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIipcIikge2N4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChmdW5jdGlvbmRlY2wpO31cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIpIHtyZWdpc3Rlcih2YWx1ZSk7IHJldHVybiBjb250KGZ1bmN0aW9uZGVjbCk7fVxuICAgIGlmICh0eXBlID09IFwiKFwiKSByZXR1cm4gY29udChwdXNoY29udGV4dCwgcHVzaGxleChcIilcIiksIGNvbW1hc2VwKGZ1bmFyZywgXCIpXCIpLCBwb3BsZXgsIG1heWJlcmV0dHlwZSwgcG9wY29udGV4dCk7XG4gICAgaWYgKGlzVFMgJiYgdmFsdWUgPT0gXCI8XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlcGFyYW0sIFwiPlwiKSwgcG9wbGV4LCBmdW5jdGlvbmRlY2wpXG4gIH1cbiAgZnVuY3Rpb24gdHlwZW5hbWUodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZSA9PSBcImtleXdvcmRcIiB8fCB0eXBlID09IFwidmFyaWFibGVcIikge1xuICAgICAgY3gubWFya2VkID0gXCJ0eXBlXCJcbiAgICAgIHJldHVybiBjb250KHR5cGVuYW1lKVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCI8XCIpIHtcbiAgICAgIHJldHVybiBjb250KHB1c2hsZXgoXCI+XCIpLCBjb21tYXNlcCh0eXBlcGFyYW0sIFwiPlwiKSwgcG9wbGV4KVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmdW5hcmcodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJAXCIpIGNvbnQoZXhwcmVzc2lvbiwgZnVuYXJnKVxuICAgIGlmICh0eXBlID09IFwic3ByZWFkXCIpIHJldHVybiBjb250KGZ1bmFyZyk7XG4gICAgaWYgKGlzVFMgJiYgaXNNb2RpZmllcih2YWx1ZSkpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGZ1bmFyZyk7IH1cbiAgICBpZiAoaXNUUyAmJiB0eXBlID09IFwidGhpc1wiKSByZXR1cm4gY29udChtYXliZXR5cGUsIG1heWJlQXNzaWduKVxuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJldHlwZSwgbWF5YmVBc3NpZ24pO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzRXhwcmVzc2lvbih0eXBlLCB2YWx1ZSkge1xuICAgIC8vIENsYXNzIGV4cHJlc3Npb25zIG1heSBoYXZlIGFuIG9wdGlvbmFsIG5hbWUuXG4gICAgaWYgKHR5cGUgPT0gXCJ2YXJpYWJsZVwiKSByZXR1cm4gY2xhc3NOYW1lKHR5cGUsIHZhbHVlKTtcbiAgICByZXR1cm4gY2xhc3NOYW1lQWZ0ZXIodHlwZSwgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNsYXNzTmFtZSh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikge3JlZ2lzdGVyKHZhbHVlKTsgcmV0dXJuIGNvbnQoY2xhc3NOYW1lQWZ0ZXIpO31cbiAgfVxuICBmdW5jdGlvbiBjbGFzc05hbWVBZnRlcih0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIjxcIikgcmV0dXJuIGNvbnQocHVzaGxleChcIj5cIiksIGNvbW1hc2VwKHR5cGVwYXJhbSwgXCI+XCIpLCBwb3BsZXgsIGNsYXNzTmFtZUFmdGVyKVxuICAgIGlmICh2YWx1ZSA9PSBcImV4dGVuZHNcIiB8fCB2YWx1ZSA9PSBcImltcGxlbWVudHNcIiB8fCAoaXNUUyAmJiB0eXBlID09IFwiLFwiKSkge1xuICAgICAgaWYgKHZhbHVlID09IFwiaW1wbGVtZW50c1wiKSBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBjb250KGlzVFMgPyB0eXBlZXhwciA6IGV4cHJlc3Npb24sIGNsYXNzTmFtZUFmdGVyKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KHB1c2hsZXgoXCJ9XCIpLCBjbGFzc0JvZHksIHBvcGxleCk7XG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NCb2R5KHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJhc3luY1wiIHx8XG4gICAgICAgICh0eXBlID09IFwidmFyaWFibGVcIiAmJlxuICAgICAgICAgKHZhbHVlID09IFwic3RhdGljXCIgfHwgdmFsdWUgPT0gXCJnZXRcIiB8fCB2YWx1ZSA9PSBcInNldFwiIHx8IChpc1RTICYmIGlzTW9kaWZpZXIodmFsdWUpKSkgJiZcbiAgICAgICAgIGN4LnN0cmVhbS5tYXRjaCgvXlxccytbXFx3JFxceGExLVxcdWZmZmZdLywgZmFsc2UpKSkge1xuICAgICAgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgICByZXR1cm4gY29udChjbGFzc0JvZHkpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcInZhcmlhYmxlXCIgfHwgY3guc3R5bGUgPT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgIGN4Lm1hcmtlZCA9IFwicHJvcGVydHlcIjtcbiAgICAgIHJldHVybiBjb250KGNsYXNzZmllbGQsIGNsYXNzQm9keSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udChjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpO1xuICAgIGlmICh0eXBlID09IFwiW1wiKVxuICAgICAgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbiwgbWF5YmV0eXBlLCBleHBlY3QoXCJdXCIpLCBjbGFzc2ZpZWxkLCBjbGFzc0JvZHkpXG4gICAgaWYgKHZhbHVlID09IFwiKlwiKSB7XG4gICAgICBjeC5tYXJrZWQgPSBcImtleXdvcmRcIjtcbiAgICAgIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgfVxuICAgIGlmIChpc1RTICYmIHR5cGUgPT0gXCIoXCIpIHJldHVybiBwYXNzKGZ1bmN0aW9uZGVjbCwgY2xhc3NCb2R5KVxuICAgIGlmICh0eXBlID09IFwiO1wiIHx8IHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KGNsYXNzQm9keSk7XG4gICAgaWYgKHR5cGUgPT0gXCJ9XCIpIHJldHVybiBjb250KCk7XG4gICAgaWYgKHZhbHVlID09IFwiQFwiKSByZXR1cm4gY29udChleHByZXNzaW9uLCBjbGFzc0JvZHkpXG4gIH1cbiAgZnVuY3Rpb24gY2xhc3NmaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcIj9cIikgcmV0dXJuIGNvbnQoY2xhc3NmaWVsZClcbiAgICBpZiAodHlwZSA9PSBcIjpcIikgcmV0dXJuIGNvbnQodHlwZWV4cHIsIG1heWJlQXNzaWduKVxuICAgIGlmICh2YWx1ZSA9PSBcIj1cIikgcmV0dXJuIGNvbnQoZXhwcmVzc2lvbk5vQ29tbWEpXG4gICAgdmFyIGNvbnRleHQgPSBjeC5zdGF0ZS5sZXhpY2FsLnByZXYsIGlzSW50ZXJmYWNlID0gY29udGV4dCAmJiBjb250ZXh0LmluZm8gPT0gXCJpbnRlcmZhY2VcIlxuICAgIHJldHVybiBwYXNzKGlzSW50ZXJmYWNlID8gZnVuY3Rpb25kZWNsIDogZnVuY3Rpb25kZWYpXG4gIH1cbiAgZnVuY3Rpb24gYWZ0ZXJFeHBvcnQodHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCIqXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7IH1cbiAgICBpZiAodmFsdWUgPT0gXCJkZWZhdWx0XCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24sIGV4cGVjdChcIjtcIikpOyB9XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250KGNvbW1hc2VwKGV4cG9ydEZpZWxkLCBcIn1cIiksIG1heWJlRnJvbSwgZXhwZWN0KFwiO1wiKSk7XG4gICAgcmV0dXJuIHBhc3Moc3RhdGVtZW50KTtcbiAgfVxuICBmdW5jdGlvbiBleHBvcnRGaWVsZCh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBcImFzXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cGVjdChcInZhcmlhYmxlXCIpKTsgfVxuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbk5vQ29tbWEsIGV4cG9ydEZpZWxkKTtcbiAgfVxuICBmdW5jdGlvbiBhZnRlckltcG9ydCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGNvbnQoKTtcbiAgICBpZiAodHlwZSA9PSBcIihcIikgcmV0dXJuIHBhc3MoZXhwcmVzc2lvbik7XG4gICAgaWYgKHR5cGUgPT0gXCIuXCIpIHJldHVybiBwYXNzKG1heWJlb3BlcmF0b3JDb21tYSk7XG4gICAgcmV0dXJuIHBhc3MoaW1wb3J0U3BlYywgbWF5YmVNb3JlSW1wb3J0cywgbWF5YmVGcm9tKTtcbiAgfVxuICBmdW5jdGlvbiBpbXBvcnRTcGVjKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJ7XCIpIHJldHVybiBjb250Q29tbWFzZXAoaW1wb3J0U3BlYywgXCJ9XCIpO1xuICAgIGlmICh0eXBlID09IFwidmFyaWFibGVcIikgcmVnaXN0ZXIodmFsdWUpO1xuICAgIGlmICh2YWx1ZSA9PSBcIipcIikgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7XG4gICAgcmV0dXJuIGNvbnQobWF5YmVBcyk7XG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVNb3JlSW1wb3J0cyh0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCIsXCIpIHJldHVybiBjb250KGltcG9ydFNwZWMsIG1heWJlTW9yZUltcG9ydHMpXG4gIH1cbiAgZnVuY3Rpb24gbWF5YmVBcyhfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJhc1wiKSB7IGN4Lm1hcmtlZCA9IFwia2V5d29yZFwiOyByZXR1cm4gY29udChpbXBvcnRTcGVjKTsgfVxuICB9XG4gIGZ1bmN0aW9uIG1heWJlRnJvbShfdHlwZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gXCJmcm9tXCIpIHsgY3gubWFya2VkID0gXCJrZXl3b3JkXCI7IHJldHVybiBjb250KGV4cHJlc3Npb24pOyB9XG4gIH1cbiAgZnVuY3Rpb24gYXJyYXlMaXRlcmFsKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIl1cIikgcmV0dXJuIGNvbnQoKTtcbiAgICByZXR1cm4gcGFzcyhjb21tYXNlcChleHByZXNzaW9uTm9Db21tYSwgXCJdXCIpKTtcbiAgfVxuICBmdW5jdGlvbiBlbnVtZGVmKCkge1xuICAgIHJldHVybiBwYXNzKHB1c2hsZXgoXCJmb3JtXCIpLCBwYXR0ZXJuLCBleHBlY3QoXCJ7XCIpLCBwdXNobGV4KFwifVwiKSwgY29tbWFzZXAoZW51bW1lbWJlciwgXCJ9XCIpLCBwb3BsZXgsIHBvcGxleClcbiAgfVxuICBmdW5jdGlvbiBlbnVtbWVtYmVyKCkge1xuICAgIHJldHVybiBwYXNzKHBhdHRlcm4sIG1heWJlQXNzaWduKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29udGludWVkU3RhdGVtZW50KHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICByZXR1cm4gc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiIHx8XG4gICAgICBpc09wZXJhdG9yQ2hhci50ZXN0KHRleHRBZnRlci5jaGFyQXQoMCkpIHx8XG4gICAgICAvWywuXS8udGVzdCh0ZXh0QWZ0ZXIuY2hhckF0KDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cHJlc3Npb25BbGxvd2VkKHN0cmVhbSwgc3RhdGUsIGJhY2tVcCkge1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZSA9PSB0b2tlbkJhc2UgJiZcbiAgICAgIC9eKD86b3BlcmF0b3J8c29mfGtleXdvcmQgW2JjZF18Y2FzZXxuZXd8ZXhwb3J0fGRlZmF1bHR8c3ByZWFkfFtcXFt7fVxcKCw7Ol18PT4pJC8udGVzdChzdGF0ZS5sYXN0VHlwZSkgfHxcbiAgICAgIChzdGF0ZS5sYXN0VHlwZSA9PSBcInF1YXNpXCIgJiYgL1xce1xccyokLy50ZXN0KHN0cmVhbS5zdHJpbmcuc2xpY2UoMCwgc3RyZWFtLnBvcyAtIChiYWNrVXAgfHwgMCkpKSlcbiAgfVxuXG4gIC8vIEludGVyZmFjZVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZWNvbHVtbikge1xuICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICBsYXN0VHlwZTogXCJzb2ZcIixcbiAgICAgICAgY2M6IFtdLFxuICAgICAgICBsZXhpY2FsOiBuZXcgSlNMZXhpY2FsKChiYXNlY29sdW1uIHx8IDApIC0gaW5kZW50VW5pdCwgMCwgXCJibG9ja1wiLCBmYWxzZSksXG4gICAgICAgIGxvY2FsVmFyczogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyxcbiAgICAgICAgY29udGV4dDogcGFyc2VyQ29uZmlnLmxvY2FsVmFycyAmJiBuZXcgQ29udGV4dChudWxsLCBudWxsLCBmYWxzZSksXG4gICAgICAgIGluZGVudGVkOiBiYXNlY29sdW1uIHx8IDBcbiAgICAgIH07XG4gICAgICBpZiAocGFyc2VyQ29uZmlnLmdsb2JhbFZhcnMgJiYgdHlwZW9mIHBhcnNlckNvbmZpZy5nbG9iYWxWYXJzID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN0YXRlLmdsb2JhbFZhcnMgPSBwYXJzZXJDb25maWcuZ2xvYmFsVmFycztcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9LFxuXG4gICAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5sZXhpY2FsLmhhc093blByb3BlcnR5KFwiYWxpZ25cIikpXG4gICAgICAgICAgc3RhdGUubGV4aWNhbC5hbGlnbiA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgICAgICBmaW5kRmF0QXJyb3coc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUudG9rZW5pemUgIT0gdG9rZW5Db21tZW50ICYmIHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHR5cGUgPT0gXCJjb21tZW50XCIpIHJldHVybiBzdHlsZTtcbiAgICAgIHN0YXRlLmxhc3RUeXBlID0gdHlwZSA9PSBcIm9wZXJhdG9yXCIgJiYgKGNvbnRlbnQgPT0gXCIrK1wiIHx8IGNvbnRlbnQgPT0gXCItLVwiKSA/IFwiaW5jZGVjXCIgOiB0eXBlO1xuICAgICAgcmV0dXJuIHBhcnNlSlMoc3RhdGUsIHN0eWxlLCB0eXBlLCBjb250ZW50LCBzdHJlYW0pO1xuICAgIH0sXG5cbiAgICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSA9PSB0b2tlbkNvbW1lbnQgfHwgc3RhdGUudG9rZW5pemUgPT0gdG9rZW5RdWFzaSkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSB0b2tlbkJhc2UpIHJldHVybiAwO1xuICAgICAgdmFyIGZpcnN0Q2hhciA9IHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApLCBsZXhpY2FsID0gc3RhdGUubGV4aWNhbCwgdG9wXG4gICAgICAvLyBLbHVkZ2UgdG8gcHJldmVudCAnbWF5YmVsc2UnIGZyb20gYmxvY2tpbmcgbGV4aWNhbCBzY29wZSBwb3BzXG4gICAgICBpZiAoIS9eXFxzKmVsc2VcXGIvLnRlc3QodGV4dEFmdGVyKSkgZm9yICh2YXIgaSA9IHN0YXRlLmNjLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBjID0gc3RhdGUuY2NbaV07XG4gICAgICAgIGlmIChjID09IHBvcGxleCkgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgICAgZWxzZSBpZiAoYyAhPSBtYXliZWVsc2UgJiYgYyAhPSBwb3Bjb250ZXh0KSBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgobGV4aWNhbC50eXBlID09IFwic3RhdFwiIHx8IGxleGljYWwudHlwZSA9PSBcImZvcm1cIikgJiZcbiAgICAgICAgICAgICAoZmlyc3RDaGFyID09IFwifVwiIHx8ICgodG9wID0gc3RhdGUuY2Nbc3RhdGUuY2MubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0b3AgPT0gbWF5YmVvcGVyYXRvckNvbW1hIHx8IHRvcCA9PSBtYXliZW9wZXJhdG9yTm9Db21tYSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIS9eWyxcXC49K1xcLSo6P1tcXChdLy50ZXN0KHRleHRBZnRlcikpKSlcbiAgICAgICAgbGV4aWNhbCA9IGxleGljYWwucHJldjtcbiAgICAgIGlmIChzdGF0ZW1lbnRJbmRlbnQgJiYgbGV4aWNhbC50eXBlID09IFwiKVwiICYmIGxleGljYWwucHJldi50eXBlID09IFwic3RhdFwiKVxuICAgICAgICBsZXhpY2FsID0gbGV4aWNhbC5wcmV2O1xuICAgICAgdmFyIHR5cGUgPSBsZXhpY2FsLnR5cGUsIGNsb3NpbmcgPSBmaXJzdENoYXIgPT0gdHlwZTtcblxuICAgICAgaWYgKHR5cGUgPT0gXCJ2YXJkZWZcIikgcmV0dXJuIGxleGljYWwuaW5kZW50ZWQgKyAoc3RhdGUubGFzdFR5cGUgPT0gXCJvcGVyYXRvclwiIHx8IHN0YXRlLmxhc3RUeXBlID09IFwiLFwiID8gbGV4aWNhbC5pbmZvLmxlbmd0aCArIDEgOiAwKTtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIgJiYgZmlyc3RDaGFyID09IFwie1wiKSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZDtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJmb3JtXCIpIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgaW5kZW50VW5pdDtcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJzdGF0XCIpXG4gICAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKGlzQ29udGludWVkU3RhdGVtZW50KHN0YXRlLCB0ZXh0QWZ0ZXIpID8gc3RhdGVtZW50SW5kZW50IHx8IGluZGVudFVuaXQgOiAwKTtcbiAgICAgIGVsc2UgaWYgKGxleGljYWwuaW5mbyA9PSBcInN3aXRjaFwiICYmICFjbG9zaW5nICYmIHBhcnNlckNvbmZpZy5kb3VibGVJbmRlbnRTd2l0Y2ggIT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBsZXhpY2FsLmluZGVudGVkICsgKC9eKD86Y2FzZXxkZWZhdWx0KVxcYi8udGVzdCh0ZXh0QWZ0ZXIpID8gaW5kZW50VW5pdCA6IDIgKiBpbmRlbnRVbml0KTtcbiAgICAgIGVsc2UgaWYgKGxleGljYWwuYWxpZ24pIHJldHVybiBsZXhpY2FsLmNvbHVtbiArIChjbG9zaW5nID8gMCA6IDEpO1xuICAgICAgZWxzZSByZXR1cm4gbGV4aWNhbC5pbmRlbnRlZCArIChjbG9zaW5nID8gMCA6IGluZGVudFVuaXQpO1xuICAgIH0sXG5cbiAgICBlbGVjdHJpY0lucHV0OiAvXlxccyooPzpjYXNlIC4qPzp8ZGVmYXVsdDp8XFx7fFxcfSkkLyxcbiAgICBibG9ja0NvbW1lbnRTdGFydDoganNvbk1vZGUgPyBudWxsIDogXCIvKlwiLFxuICAgIGJsb2NrQ29tbWVudEVuZDoganNvbk1vZGUgPyBudWxsIDogXCIqL1wiLFxuICAgIGJsb2NrQ29tbWVudENvbnRpbnVlOiBqc29uTW9kZSA/IG51bGwgOiBcIiAqIFwiLFxuICAgIGxpbmVDb21tZW50OiBqc29uTW9kZSA/IG51bGwgOiBcIi8vXCIsXG4gICAgZm9sZDogXCJicmFjZVwiLFxuICAgIGNsb3NlQnJhY2tldHM6IFwiKClbXXt9JydcXFwiXFxcImBgXCIsXG5cbiAgICBoZWxwZXJUeXBlOiBqc29uTW9kZSA/IFwianNvblwiIDogXCJqYXZhc2NyaXB0XCIsXG4gICAganNvbmxkTW9kZToganNvbmxkTW9kZSxcbiAgICBqc29uTW9kZToganNvbk1vZGUsXG5cbiAgICBleHByZXNzaW9uQWxsb3dlZDogZXhwcmVzc2lvbkFsbG93ZWQsXG5cbiAgICBza2lwRXhwcmVzc2lvbjogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHZhciB0b3AgPSBzdGF0ZS5jY1tzdGF0ZS5jYy5sZW5ndGggLSAxXVxuICAgICAgaWYgKHRvcCA9PSBleHByZXNzaW9uIHx8IHRvcCA9PSBleHByZXNzaW9uTm9Db21tYSkgc3RhdGUuY2MucG9wKClcbiAgICB9XG4gIH07XG59KTtcblxuQ29kZU1pcnJvci5yZWdpc3RlckhlbHBlcihcIndvcmRDaGFyc1wiLCBcImphdmFzY3JpcHRcIiwgL1tcXHckXS8pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L2phdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC9lY21hc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veC1qYXZhc2NyaXB0XCIsIFwiamF2YXNjcmlwdFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHRcIiwgXCJqYXZhc2NyaXB0XCIpO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24vanNvblwiLCB7IG5hbWU6IFwiamF2YXNjcmlwdFwiLCBqc29uOiB0cnVlIH0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwiYXBwbGljYXRpb24veC1qc29uXCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIGpzb246IHRydWUgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi9tYW5pZmVzdCtqc29uXCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIGpzb246IHRydWUgfSlcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL2xkK2pzb25cIiwgeyBuYW1lOiBcImphdmFzY3JpcHRcIiwganNvbmxkOiB0cnVlIH0pO1xuQ29kZU1pcnJvci5kZWZpbmVNSU1FKFwidGV4dC90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJhcHBsaWNhdGlvbi90eXBlc2NyaXB0XCIsIHsgbmFtZTogXCJqYXZhc2NyaXB0XCIsIHR5cGVzY3JpcHQ6IHRydWUgfSk7XG5cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/javascript/javascript.js\n')},"./node_modules/codemirror/mode/xml/xml.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ "./node_modules/codemirror/lib/codemirror.js"));\n  else {}\n})(function(CodeMirror) {\n"use strict";\n\nvar htmlConfig = {\n  autoSelfClosers: {\'area\': true, \'base\': true, \'br\': true, \'col\': true, \'command\': true,\n                    \'embed\': true, \'frame\': true, \'hr\': true, \'img\': true, \'input\': true,\n                    \'keygen\': true, \'link\': true, \'meta\': true, \'param\': true, \'source\': true,\n                    \'track\': true, \'wbr\': true, \'menuitem\': true},\n  implicitlyClosed: {\'dd\': true, \'li\': true, \'optgroup\': true, \'option\': true, \'p\': true,\n                     \'rp\': true, \'rt\': true, \'tbody\': true, \'td\': true, \'tfoot\': true,\n                     \'th\': true, \'tr\': true},\n  contextGrabbers: {\n    \'dd\': {\'dd\': true, \'dt\': true},\n    \'dt\': {\'dd\': true, \'dt\': true},\n    \'li\': {\'li\': true},\n    \'option\': {\'option\': true, \'optgroup\': true},\n    \'optgroup\': {\'optgroup\': true},\n    \'p\': {\'address\': true, \'article\': true, \'aside\': true, \'blockquote\': true, \'dir\': true,\n          \'div\': true, \'dl\': true, \'fieldset\': true, \'footer\': true, \'form\': true,\n          \'h1\': true, \'h2\': true, \'h3\': true, \'h4\': true, \'h5\': true, \'h6\': true,\n          \'header\': true, \'hgroup\': true, \'hr\': true, \'menu\': true, \'nav\': true, \'ol\': true,\n          \'p\': true, \'pre\': true, \'section\': true, \'table\': true, \'ul\': true},\n    \'rp\': {\'rp\': true, \'rt\': true},\n    \'rt\': {\'rp\': true, \'rt\': true},\n    \'tbody\': {\'tbody\': true, \'tfoot\': true},\n    \'td\': {\'td\': true, \'th\': true},\n    \'tfoot\': {\'tbody\': true},\n    \'th\': {\'td\': true, \'th\': true},\n    \'thead\': {\'tbody\': true, \'tfoot\': true},\n    \'tr\': {\'tr\': true}\n  },\n  doNotIndent: {"pre": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode("xml", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == "<") {\n      if (stream.eat("!")) {\n        if (stream.eat("[")) {\n          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));\n          else return null;\n        } else if (stream.match("--")) {\n          return chain(inBlock("comment", "--\x3e"));\n        } else if (stream.match("DOCTYPE", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat("?")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock("meta", "?>");\n        return "meta";\n      } else {\n        type = stream.eat("/") ? "closeTag" : "openTag";\n        state.tokenize = inTag;\n        return "tag bracket";\n      }\n    } else if (ch == "&") {\n      var ok;\n      if (stream.eat("#")) {\n        if (stream.eat("x")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(";");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(";");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(";");\n      }\n      return ok ? "atom" : "error";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == ">" || (ch == "/" && stream.eat(">"))) {\n      state.tokenize = inText;\n      type = ch == ">" ? "endTag" : "selfcloseTag";\n      return "tag bracket";\n    } else if (ch == "=") {\n      type = "equals";\n      return null;\n    } else if (ch == "<") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + " tag error" : "tag error";\n    } else if (/[\\\'\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\"\\\']*[^\\s\\u00a0=<>\\"\\\'\\/]/);\n      return "word";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return "string";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == "<") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == ">") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return "meta";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName || "";\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == "openTag") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == "closeTag") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == "word") {\n      state.tagName = stream.current();\n      setStyle = "tag";\n      return attrState;\n    } else if (config.allowMissingTagName && type == "endTag") {\n      setStyle = "tag bracket";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = "error";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == "word") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = "tag";\n        return closeState;\n      } else {\n        setStyle = "tag error";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == "endTag") {\n      setStyle = "tag bracket";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = "error";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != "endTag") {\n      setStyle = "error";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = "error";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == "word") {\n      setStyle = "attribute";\n      return attrEqState;\n    } else if (type == "endTag" || type == "selfcloseTag") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == "selfcloseTag" ||\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = "error";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == "equals") return attrValueState;\n    if (!config.allowMissing) setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}\n    setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != "comment") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == "error" ? style + " error" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[context.tagName];\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: "\x3c!--",\n    blockCommentEnd: "--\x3e",\n\n    configuration: config.htmlMode ? "html" : "xml",\n    helperType: config.htmlMode ? "html" : "xml",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME("text/xml", "xml");\nCodeMirror.defineMIME("application/xml", "xml");\nif (!CodeMirror.mimeModes.hasOwnProperty("text/html"))\n  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbW9kZS94bWwveG1sLmpzP2Q1ZTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBdUQ7QUFDN0QsUUFBUSxtQkFBTyxDQUFDLHlFQUFzQjtBQUN0QyxPQUFPLEVBR2E7QUFDcEIsQ0FBQztBQUNEOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUscUJBQXFCO0FBQ3JCO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxXQUFXO0FBQ3RCLGVBQWUsaUNBQWlDO0FBQ2hELGlCQUFpQixpQkFBaUI7QUFDbEMsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHVCQUF1QjtBQUNsQyxjQUFjLDZCQUE2QjtBQUMzQyxXQUFXLHVCQUF1QjtBQUNsQyxjQUFjLGNBQWM7QUFDNUIsV0FBVyx1QkFBdUI7QUFDbEMsY0FBYyw2QkFBNkI7QUFDM0MsV0FBVztBQUNYLEdBQUc7QUFDSCxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFNBQVM7QUFDVCx1REFBdUQ7QUFDdkQ7QUFDQSxPQUFPO0FBQ1AsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQkFBb0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU8scUJBQXFCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhCQUE4QixxREFBcUQ7QUFDbkYsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7O0FBRWxFLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9tb2RlL3htbC94bWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb2RlTWlycm9yLCBjb3B5cmlnaHQgKGMpIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIG90aGVyc1xuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vY29kZW1pcnJvci5uZXQvTElDRU5TRVxuXG4oZnVuY3Rpb24obW9kKSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIikgLy8gQ29tbW9uSlNcbiAgICBtb2QocmVxdWlyZShcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCIpKTtcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgLy8gQU1EXG4gICAgZGVmaW5lKFtcIi4uLy4uL2xpYi9jb2RlbWlycm9yXCJdLCBtb2QpO1xuICBlbHNlIC8vIFBsYWluIGJyb3dzZXIgZW52XG4gICAgbW9kKENvZGVNaXJyb3IpO1xufSkoZnVuY3Rpb24oQ29kZU1pcnJvcikge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBodG1sQ29uZmlnID0ge1xuICBhdXRvU2VsZkNsb3NlcnM6IHsnYXJlYSc6IHRydWUsICdiYXNlJzogdHJ1ZSwgJ2JyJzogdHJ1ZSwgJ2NvbCc6IHRydWUsICdjb21tYW5kJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYmVkJzogdHJ1ZSwgJ2ZyYW1lJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ2ltZyc6IHRydWUsICdpbnB1dCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdrZXlnZW4nOiB0cnVlLCAnbGluayc6IHRydWUsICdtZXRhJzogdHJ1ZSwgJ3BhcmFtJzogdHJ1ZSwgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0cmFjayc6IHRydWUsICd3YnInOiB0cnVlLCAnbWVudWl0ZW0nOiB0cnVlfSxcbiAgaW1wbGljaXRseUNsb3NlZDogeydkZCc6IHRydWUsICdsaSc6IHRydWUsICdvcHRncm91cCc6IHRydWUsICdvcHRpb24nOiB0cnVlLCAncCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAncnAnOiB0cnVlLCAncnQnOiB0cnVlLCAndGJvZHknOiB0cnVlLCAndGQnOiB0cnVlLCAndGZvb3QnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgJ3RoJzogdHJ1ZSwgJ3RyJzogdHJ1ZX0sXG4gIGNvbnRleHRHcmFiYmVyczoge1xuICAgICdkZCc6IHsnZGQnOiB0cnVlLCAnZHQnOiB0cnVlfSxcbiAgICAnZHQnOiB7J2RkJzogdHJ1ZSwgJ2R0JzogdHJ1ZX0sXG4gICAgJ2xpJzogeydsaSc6IHRydWV9LFxuICAgICdvcHRpb24nOiB7J29wdGlvbic6IHRydWUsICdvcHRncm91cCc6IHRydWV9LFxuICAgICdvcHRncm91cCc6IHsnb3B0Z3JvdXAnOiB0cnVlfSxcbiAgICAncCc6IHsnYWRkcmVzcyc6IHRydWUsICdhcnRpY2xlJzogdHJ1ZSwgJ2FzaWRlJzogdHJ1ZSwgJ2Jsb2NrcXVvdGUnOiB0cnVlLCAnZGlyJzogdHJ1ZSxcbiAgICAgICAgICAnZGl2JzogdHJ1ZSwgJ2RsJzogdHJ1ZSwgJ2ZpZWxkc2V0JzogdHJ1ZSwgJ2Zvb3Rlcic6IHRydWUsICdmb3JtJzogdHJ1ZSxcbiAgICAgICAgICAnaDEnOiB0cnVlLCAnaDInOiB0cnVlLCAnaDMnOiB0cnVlLCAnaDQnOiB0cnVlLCAnaDUnOiB0cnVlLCAnaDYnOiB0cnVlLFxuICAgICAgICAgICdoZWFkZXInOiB0cnVlLCAnaGdyb3VwJzogdHJ1ZSwgJ2hyJzogdHJ1ZSwgJ21lbnUnOiB0cnVlLCAnbmF2JzogdHJ1ZSwgJ29sJzogdHJ1ZSxcbiAgICAgICAgICAncCc6IHRydWUsICdwcmUnOiB0cnVlLCAnc2VjdGlvbic6IHRydWUsICd0YWJsZSc6IHRydWUsICd1bCc6IHRydWV9LFxuICAgICdycCc6IHsncnAnOiB0cnVlLCAncnQnOiB0cnVlfSxcbiAgICAncnQnOiB7J3JwJzogdHJ1ZSwgJ3J0JzogdHJ1ZX0sXG4gICAgJ3Rib2R5Jzogeyd0Ym9keSc6IHRydWUsICd0Zm9vdCc6IHRydWV9LFxuICAgICd0ZCc6IHsndGQnOiB0cnVlLCAndGgnOiB0cnVlfSxcbiAgICAndGZvb3QnOiB7J3Rib2R5JzogdHJ1ZX0sXG4gICAgJ3RoJzogeyd0ZCc6IHRydWUsICd0aCc6IHRydWV9LFxuICAgICd0aGVhZCc6IHsndGJvZHknOiB0cnVlLCAndGZvb3QnOiB0cnVlfSxcbiAgICAndHInOiB7J3RyJzogdHJ1ZX1cbiAgfSxcbiAgZG9Ob3RJbmRlbnQ6IHtcInByZVwiOiB0cnVlfSxcbiAgYWxsb3dVbnF1b3RlZDogdHJ1ZSxcbiAgYWxsb3dNaXNzaW5nOiB0cnVlLFxuICBjYXNlRm9sZDogdHJ1ZVxufVxuXG52YXIgeG1sQ29uZmlnID0ge1xuICBhdXRvU2VsZkNsb3NlcnM6IHt9LFxuICBpbXBsaWNpdGx5Q2xvc2VkOiB7fSxcbiAgY29udGV4dEdyYWJiZXJzOiB7fSxcbiAgZG9Ob3RJbmRlbnQ6IHt9LFxuICBhbGxvd1VucXVvdGVkOiBmYWxzZSxcbiAgYWxsb3dNaXNzaW5nOiBmYWxzZSxcbiAgYWxsb3dNaXNzaW5nVGFnTmFtZTogZmFsc2UsXG4gIGNhc2VGb2xkOiBmYWxzZVxufVxuXG5Db2RlTWlycm9yLmRlZmluZU1vZGUoXCJ4bWxcIiwgZnVuY3Rpb24oZWRpdG9yQ29uZiwgY29uZmlnXykge1xuICB2YXIgaW5kZW50VW5pdCA9IGVkaXRvckNvbmYuaW5kZW50VW5pdFxuICB2YXIgY29uZmlnID0ge31cbiAgdmFyIGRlZmF1bHRzID0gY29uZmlnXy5odG1sTW9kZSA/IGh0bWxDb25maWcgOiB4bWxDb25maWdcbiAgZm9yICh2YXIgcHJvcCBpbiBkZWZhdWx0cykgY29uZmlnW3Byb3BdID0gZGVmYXVsdHNbcHJvcF1cbiAgZm9yICh2YXIgcHJvcCBpbiBjb25maWdfKSBjb25maWdbcHJvcF0gPSBjb25maWdfW3Byb3BdXG5cbiAgLy8gUmV0dXJuIHZhcmlhYmxlcyBmb3IgdG9rZW5pemVyc1xuICB2YXIgdHlwZSwgc2V0U3R5bGU7XG5cbiAgZnVuY3Rpb24gaW5UZXh0KHN0cmVhbSwgc3RhdGUpIHtcbiAgICBmdW5jdGlvbiBjaGFpbihwYXJzZXIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gcGFyc2VyO1xuICAgICAgcmV0dXJuIHBhcnNlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBcIjxcIikge1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIhXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiW1wiKSkge1xuICAgICAgICAgIGlmIChzdHJlYW0ubWF0Y2goXCJDREFUQVtcIikpIHJldHVybiBjaGFpbihpbkJsb2NrKFwiYXRvbVwiLCBcIl1dPlwiKSk7XG4gICAgICAgICAgZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goXCItLVwiKSkge1xuICAgICAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiY29tbWVudFwiLCBcIi0tPlwiKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKFwiRE9DVFlQRVwiLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl9cXC1dLyk7XG4gICAgICAgICAgcmV0dXJuIGNoYWluKGRvY3R5cGUoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKSB7XG4gICAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLl9cXC1dLyk7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5CbG9jayhcIm1ldGFcIiwgXCI/PlwiKTtcbiAgICAgICAgcmV0dXJuIFwibWV0YVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHN0cmVhbS5lYXQoXCIvXCIpID8gXCJjbG9zZVRhZ1wiIDogXCJvcGVuVGFnXCI7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UYWc7XG4gICAgICAgIHJldHVybiBcInRhZyBicmFja2V0XCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIiZcIikge1xuICAgICAgdmFyIG9rO1xuICAgICAgaWYgKHN0cmVhbS5lYXQoXCIjXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwieFwiKSkge1xuICAgICAgICAgIG9rID0gc3RyZWFtLmVhdFdoaWxlKC9bYS1mQS1GXFxkXS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9rID0gc3RyZWFtLmVhdFdoaWxlKC9bXFxkXS8pICYmIHN0cmVhbS5lYXQoXCI7XCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvayA9IHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcLlxcLTpdLykgJiYgc3RyZWFtLmVhdChcIjtcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2sgPyBcImF0b21cIiA6IFwiZXJyb3JcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXiY8XS8pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGluVGV4dC5pc0luVGV4dCA9IHRydWU7XG5cbiAgZnVuY3Rpb24gaW5UYWcoc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09IFwiPlwiIHx8IChjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiPlwiKSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgdHlwZSA9IGNoID09IFwiPlwiID8gXCJlbmRUYWdcIiA6IFwic2VsZmNsb3NlVGFnXCI7XG4gICAgICByZXR1cm4gXCJ0YWcgYnJhY2tldFwiO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgIHR5cGUgPSBcImVxdWFsc1wiO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChjaCA9PSBcIjxcIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICBzdGF0ZS5zdGF0ZSA9IGJhc2VTdGF0ZTtcbiAgICAgIHN0YXRlLnRhZ05hbWUgPSBzdGF0ZS50YWdTdGFydCA9IG51bGw7XG4gICAgICB2YXIgbmV4dCA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgcmV0dXJuIG5leHQgPyBuZXh0ICsgXCIgdGFnIGVycm9yXCIgOiBcInRhZyBlcnJvclwiO1xuICAgIH0gZWxzZSBpZiAoL1tcXCdcXFwiXS8udGVzdChjaCkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xuICAgICAgc3RhdGUuc3RyaW5nU3RhcnRDb2wgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5tYXRjaCgvXlteXFxzXFx1MDBhMD08PlxcXCJcXCddKlteXFxzXFx1MDBhMD08PlxcXCJcXCdcXC9dLyk7XG4gICAgICByZXR1cm4gXCJ3b3JkXCI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5BdHRyaWJ1dGUocXVvdGUpIHtcbiAgICB2YXIgY2xvc3VyZSA9IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCgpID09IHF1b3RlKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRhZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfTtcbiAgICBjbG9zdXJlLmlzSW5BdHRyaWJ1dGUgPSB0cnVlO1xuICAgIHJldHVybiBjbG9zdXJlO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5CbG9jayhzdHlsZSwgdGVybWluYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgICBpZiAoc3RyZWFtLm1hdGNoKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblRleHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkb2N0eXBlKGRlcHRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICAgIHZhciBjaDtcbiAgICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjaCA9PSBcIjxcIikge1xuICAgICAgICAgIHN0YXRlLnRva2VuaXplID0gZG9jdHlwZShkZXB0aCArIDEpO1xuICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIj5cIikge1xuICAgICAgICAgIGlmIChkZXB0aCA9PSAxKSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IGRvY3R5cGUoZGVwdGggLSAxKTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dChzdGF0ZSwgdGFnTmFtZSwgc3RhcnRPZkxpbmUpIHtcbiAgICB0aGlzLnByZXYgPSBzdGF0ZS5jb250ZXh0O1xuICAgIHRoaXMudGFnTmFtZSA9IHRhZ05hbWUgfHwgXCJcIjtcbiAgICB0aGlzLmluZGVudCA9IHN0YXRlLmluZGVudGVkO1xuICAgIHRoaXMuc3RhcnRPZkxpbmUgPSBzdGFydE9mTGluZTtcbiAgICBpZiAoY29uZmlnLmRvTm90SW5kZW50Lmhhc093blByb3BlcnR5KHRhZ05hbWUpIHx8IChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQubm9JbmRlbnQpKVxuICAgICAgdGhpcy5ub0luZGVudCA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gcG9wQ29udGV4dChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jb250ZXh0KSBzdGF0ZS5jb250ZXh0ID0gc3RhdGUuY29udGV4dC5wcmV2O1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlUG9wQ29udGV4dChzdGF0ZSwgbmV4dFRhZ05hbWUpIHtcbiAgICB2YXIgcGFyZW50VGFnTmFtZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCFzdGF0ZS5jb250ZXh0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBhcmVudFRhZ05hbWUgPSBzdGF0ZS5jb250ZXh0LnRhZ05hbWU7XG4gICAgICBpZiAoIWNvbmZpZy5jb250ZXh0R3JhYmJlcnMuaGFzT3duUHJvcGVydHkocGFyZW50VGFnTmFtZSkgfHxcbiAgICAgICAgICAhY29uZmlnLmNvbnRleHRHcmFiYmVyc1twYXJlbnRUYWdOYW1lXS5oYXNPd25Qcm9wZXJ0eShuZXh0VGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIm9wZW5UYWdcIikge1xuICAgICAgc3RhdGUudGFnU3RhcnQgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICByZXR1cm4gdGFnTmFtZVN0YXRlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PSBcImNsb3NlVGFnXCIpIHtcbiAgICAgIHJldHVybiBjbG9zZVRhZ05hbWVTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2VTdGF0ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdGFnTmFtZVN0YXRlKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIikge1xuICAgICAgc3RhdGUudGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBzZXRTdHlsZSA9IFwidGFnXCI7XG4gICAgICByZXR1cm4gYXR0clN0YXRlO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmFsbG93TWlzc2luZ1RhZ05hbWUgJiYgdHlwZSA9PSBcImVuZFRhZ1wiKSB7XG4gICAgICBzZXRTdHlsZSA9IFwidGFnIGJyYWNrZXRcIjtcbiAgICAgIHJldHVybiBhdHRyU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgICAgcmV0dXJuIHRhZ05hbWVTdGF0ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2xvc2VUYWdOYW1lU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgICBpZiAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LnRhZ05hbWUgIT0gdGFnTmFtZSAmJlxuICAgICAgICAgIGNvbmZpZy5pbXBsaWNpdGx5Q2xvc2VkLmhhc093blByb3BlcnR5KHN0YXRlLmNvbnRleHQudGFnTmFtZSkpXG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgaWYgKChzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudGFnTmFtZSA9PSB0YWdOYW1lKSB8fCBjb25maWcubWF0Y2hDbG9zaW5nID09PSBmYWxzZSkge1xuICAgICAgICBzZXRTdHlsZSA9IFwidGFnXCI7XG4gICAgICAgIHJldHVybiBjbG9zZVN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U3R5bGUgPSBcInRhZyBlcnJvclwiO1xuICAgICAgICByZXR1cm4gY2xvc2VTdGF0ZUVycjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5hbGxvd01pc3NpbmdUYWdOYW1lICYmIHR5cGUgPT0gXCJlbmRUYWdcIikge1xuICAgICAgc2V0U3R5bGUgPSBcInRhZyBicmFja2V0XCI7XG4gICAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gY2xvc2VTdGF0ZUVycjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZVN0YXRlKHR5cGUsIF9zdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgIT0gXCJlbmRUYWdcIikge1xuICAgICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgICByZXR1cm4gY2xvc2VTdGF0ZTtcbiAgICB9XG4gICAgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgcmV0dXJuIGJhc2VTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBjbG9zZVN0YXRlRXJyKHR5cGUsIHN0cmVhbSwgc3RhdGUpIHtcbiAgICBzZXRTdHlsZSA9IFwiZXJyb3JcIjtcbiAgICByZXR1cm4gY2xvc2VTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGF0dHJTdGF0ZSh0eXBlLCBfc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwid29yZFwiKSB7XG4gICAgICBzZXRTdHlsZSA9IFwiYXR0cmlidXRlXCI7XG4gICAgICByZXR1cm4gYXR0ckVxU3RhdGU7XG4gICAgfSBlbHNlIGlmICh0eXBlID09IFwiZW5kVGFnXCIgfHwgdHlwZSA9PSBcInNlbGZjbG9zZVRhZ1wiKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHN0YXRlLnRhZ05hbWUsIHRhZ1N0YXJ0ID0gc3RhdGUudGFnU3RhcnQ7XG4gICAgICBzdGF0ZS50YWdOYW1lID0gc3RhdGUudGFnU3RhcnQgPSBudWxsO1xuICAgICAgaWYgKHR5cGUgPT0gXCJzZWxmY2xvc2VUYWdcIiB8fFxuICAgICAgICAgIGNvbmZpZy5hdXRvU2VsZkNsb3NlcnMuaGFzT3duUHJvcGVydHkodGFnTmFtZSkpIHtcbiAgICAgICAgbWF5YmVQb3BDb250ZXh0KHN0YXRlLCB0YWdOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heWJlUG9wQ29udGV4dChzdGF0ZSwgdGFnTmFtZSk7XG4gICAgICAgIHN0YXRlLmNvbnRleHQgPSBuZXcgQ29udGV4dChzdGF0ZSwgdGFnTmFtZSwgdGFnU3RhcnQgPT0gc3RhdGUuaW5kZW50ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTdGF0ZTtcbiAgICB9XG4gICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIGF0dHJTdGF0ZTtcbiAgfVxuICBmdW5jdGlvbiBhdHRyRXFTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJlcXVhbHNcIikgcmV0dXJuIGF0dHJWYWx1ZVN0YXRlO1xuICAgIGlmICghY29uZmlnLmFsbG93TWlzc2luZykgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhdHRyVmFsdWVTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHR5cGUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIGF0dHJDb250aW51ZWRTdGF0ZTtcbiAgICBpZiAodHlwZSA9PSBcIndvcmRcIiAmJiBjb25maWcuYWxsb3dVbnF1b3RlZCkge3NldFN0eWxlID0gXCJzdHJpbmdcIjsgcmV0dXJuIGF0dHJTdGF0ZTt9XG4gICAgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhdHRyQ29udGludWVkU3RhdGUodHlwZSwgc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmICh0eXBlID09IFwic3RyaW5nXCIpIHJldHVybiBhdHRyQ29udGludWVkU3RhdGU7XG4gICAgcmV0dXJuIGF0dHJTdGF0ZSh0eXBlLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZUluZGVudCkge1xuICAgICAgdmFyIHN0YXRlID0ge3Rva2VuaXplOiBpblRleHQsXG4gICAgICAgICAgICAgICAgICAgc3RhdGU6IGJhc2VTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICBpbmRlbnRlZDogYmFzZUluZGVudCB8fCAwLFxuICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IG51bGwsIHRhZ1N0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG51bGx9XG4gICAgICBpZiAoYmFzZUluZGVudCAhPSBudWxsKSBzdGF0ZS5iYXNlSW5kZW50ID0gYmFzZUluZGVudFxuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfSxcblxuICAgIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgICBpZiAoIXN0YXRlLnRhZ05hbWUgJiYgc3RyZWFtLnNvbCgpKVxuICAgICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuXG4gICAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgIGlmICgoc3R5bGUgfHwgdHlwZSkgJiYgc3R5bGUgIT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgc2V0U3R5bGUgPSBudWxsO1xuICAgICAgICBzdGF0ZS5zdGF0ZSA9IHN0YXRlLnN0YXRlKHR5cGUgfHwgc3R5bGUsIHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc2V0U3R5bGUpXG4gICAgICAgICAgc3R5bGUgPSBzZXRTdHlsZSA9PSBcImVycm9yXCIgPyBzdHlsZSArIFwiIGVycm9yXCIgOiBzZXRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9LFxuXG4gICAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBmdWxsTGluZSkge1xuICAgICAgdmFyIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgICAgLy8gSW5kZW50IG11bHRpLWxpbmUgc3RyaW5ncyAoZS5nLiBjc3MpLlxuICAgICAgaWYgKHN0YXRlLnRva2VuaXplLmlzSW5BdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKHN0YXRlLnRhZ1N0YXJ0ID09IHN0YXRlLmluZGVudGVkKVxuICAgICAgICAgIHJldHVybiBzdGF0ZS5zdHJpbmdTdGFydENvbCArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gc3RhdGUuaW5kZW50ZWQgKyBpbmRlbnRVbml0O1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5ub0luZGVudCkgcmV0dXJuIENvZGVNaXJyb3IuUGFzcztcbiAgICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPSBpblRhZyAmJiBzdGF0ZS50b2tlbml6ZSAhPSBpblRleHQpXG4gICAgICAgIHJldHVybiBmdWxsTGluZSA/IGZ1bGxMaW5lLm1hdGNoKC9eKFxccyopLylbMF0ubGVuZ3RoIDogMDtcbiAgICAgIC8vIEluZGVudCB0aGUgc3RhcnRzIG9mIGF0dHJpYnV0ZSBuYW1lcy5cbiAgICAgIGlmIChzdGF0ZS50YWdOYW1lKSB7XG4gICAgICAgIGlmIChjb25maWcubXVsdGlsaW5lVGFnSW5kZW50UGFzdFRhZyAhPT0gZmFsc2UpXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRhZ1N0YXJ0ICsgc3RhdGUudGFnTmFtZS5sZW5ndGggKyAyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIHN0YXRlLnRhZ1N0YXJ0ICsgaW5kZW50VW5pdCAqIChjb25maWcubXVsdGlsaW5lVGFnSW5kZW50RmFjdG9yIHx8IDEpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5hbGlnbkNEQVRBICYmIC88IVxcW0NEQVRBXFxbLy50ZXN0KHRleHRBZnRlcikpIHJldHVybiAwO1xuICAgICAgdmFyIHRhZ0FmdGVyID0gdGV4dEFmdGVyICYmIC9ePChcXC8pPyhbXFx3XzpcXC4tXSopLy5leGVjKHRleHRBZnRlcik7XG4gICAgICBpZiAodGFnQWZ0ZXIgJiYgdGFnQWZ0ZXJbMV0pIHsgLy8gQ2xvc2luZyB0YWcgc3BvdHRlZFxuICAgICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0LnRhZ05hbWUgPT0gdGFnQWZ0ZXJbMl0pIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5pbXBsaWNpdGx5Q2xvc2VkLmhhc093blByb3BlcnR5KGNvbnRleHQudGFnTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWdBZnRlcikgeyAvLyBPcGVuaW5nIHRhZyBzcG90dGVkXG4gICAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgICAgdmFyIGdyYWJiZXJzID0gY29uZmlnLmNvbnRleHRHcmFiYmVyc1tjb250ZXh0LnRhZ05hbWVdO1xuICAgICAgICAgIGlmIChncmFiYmVycyAmJiBncmFiYmVycy5oYXNPd25Qcm9wZXJ0eSh0YWdBZnRlclsyXSkpXG4gICAgICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoY29udGV4dCAmJiBjb250ZXh0LnByZXYgJiYgIWNvbnRleHQuc3RhcnRPZkxpbmUpXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgICBpZiAoY29udGV4dCkgcmV0dXJuIGNvbnRleHQuaW5kZW50ICsgaW5kZW50VW5pdDtcbiAgICAgIGVsc2UgcmV0dXJuIHN0YXRlLmJhc2VJbmRlbnQgfHwgMDtcbiAgICB9LFxuXG4gICAgZWxlY3RyaWNJbnB1dDogLzxcXC9bXFxzXFx3Ol0rPiQvLFxuICAgIGJsb2NrQ29tbWVudFN0YXJ0OiBcIjwhLS1cIixcbiAgICBibG9ja0NvbW1lbnRFbmQ6IFwiLS0+XCIsXG5cbiAgICBjb25maWd1cmF0aW9uOiBjb25maWcuaHRtbE1vZGUgPyBcImh0bWxcIiA6IFwieG1sXCIsXG4gICAgaGVscGVyVHlwZTogY29uZmlnLmh0bWxNb2RlID8gXCJodG1sXCIgOiBcInhtbFwiLFxuXG4gICAgc2tpcEF0dHJpYnV0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5zdGF0ZSA9PSBhdHRyVmFsdWVTdGF0ZSlcbiAgICAgICAgc3RhdGUuc3RhdGUgPSBhdHRyU3RhdGVcbiAgICB9LFxuXG4gICAgeG1sQ3VycmVudFRhZzogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZS50YWdOYW1lID8ge25hbWU6IHN0YXRlLnRhZ05hbWUsIGNsb3NlOiBzdGF0ZS50eXBlID09IFwiY2xvc2VUYWdcIn0gOiBudWxsXG4gICAgfSxcblxuICAgIHhtbEN1cnJlbnRDb250ZXh0OiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgdmFyIGNvbnRleHQgPSBbXVxuICAgICAgZm9yICh2YXIgY3ggPSBzdGF0ZS5jb250ZXh0OyBjeDsgY3ggPSBjeC5wcmV2KVxuICAgICAgICBjb250ZXh0LnB1c2goY3gudGFnTmFtZSlcbiAgICAgIHJldHVybiBjb250ZXh0LnJldmVyc2UoKVxuICAgIH1cbiAgfTtcbn0pO1xuXG5Db2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3htbFwiLCBcInhtbFwiKTtcbkNvZGVNaXJyb3IuZGVmaW5lTUlNRShcImFwcGxpY2F0aW9uL3htbFwiLCBcInhtbFwiKTtcbmlmICghQ29kZU1pcnJvci5taW1lTW9kZXMuaGFzT3duUHJvcGVydHkoXCJ0ZXh0L2h0bWxcIikpXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRShcInRleHQvaHRtbFwiLCB7bmFtZTogXCJ4bWxcIiwgaHRtbE1vZGU6IHRydWV9KTtcblxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/codemirror/mode/xml/xml.js\n')},"./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/cursors/src/CoCreate-cursors.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "4bae7f440ab1de156d0d0d0d0a566858.css");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jdXJzb3JzL3NyYy9Db0NyZWF0ZS1jdXJzb3JzLmNzcz83MjU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxxQkFBdUIseUNBQXlDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jdXJzb3JzL3NyYy9Db0NyZWF0ZS1jdXJzb3JzLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCI0YmFlN2Y0NDBhYjFkZTE1NmQwZDBkMGQwYTU2Njg1OC5jc3NcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/cursors/src/CoCreate-cursors.css\n')},"./node_modules/file-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "b1d4226960c02cf03533b3628c840872.css");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuY3NzP2Q3ZmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLHFCQUF1Qix5Q0FBeUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmlsZS1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvY29kZW1pcnJvci9saWIvY29kZW1pcnJvci5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiYjFkNDIyNjk2MGMwMmNmMDM1MzNiMzYyOGM4NDA4NzIuY3NzXCI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/file-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css\n')},"./node_modules/file-loader/dist/cjs.js!./src/css/index.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "a4752d52bc89a6341ce98cbef1b37ea9.css");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vc3JjL2Nzcy9pbmRleC5jc3M/MDczNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUscUJBQXVCLHlDQUF5QyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9maWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NyYy9jc3MvaW5kZXguY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImE0NzUyZDUyYmM4OWE2MzQxY2U5OGNiZWYxYjM3ZWE5LmNzc1wiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/file-loader/dist/cjs.js!./src/css/index.css\n')},"./node_modules/isomorphic.js/browser.js":(__unused_webpack_module,exports)=>{eval("/* eslint-env browser */\nconst perf = typeof performance === 'undefined' ? null : performance\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nconst cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n\nexports.performance = perf\nexports.cryptoRandomBuffer = cryptoRandomBuffer\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMuanMvYnJvd3Nlci5qcz83OTVkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkIsMEJBQTBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMuanMvYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuY29uc3QgcGVyZiA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcGVyZm9ybWFuY2VcblxuY29uc3QgaXNvQ3J5cHRvID0gdHlwZW9mIGNyeXB0byA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogY3J5cHRvXG5cbi8qKlxuICogQHR5cGUge2Z1bmN0aW9uKG51bWJlcik6QXJyYXlCdWZmZXJ9XG4gKi9cbmNvbnN0IGNyeXB0b1JhbmRvbUJ1ZmZlciA9IGlzb0NyeXB0byAhPT0gbnVsbFxuICA/IGxlbiA9PiB7XG4gICAgLy8gYnJvd3NlclxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pXG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGlzb0NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyKVxuICAgIHJldHVybiBidWZcbiAgfVxuICA6IGxlbiA9PiB7XG4gICAgLy8gcG9seWZpbGxcbiAgICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIobGVuKVxuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJbaV0gPSBNYXRoLmNlaWwoKE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRkZGKSA+Pj4gMClcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbmV4cG9ydHMucGVyZm9ybWFuY2UgPSBwZXJmXG5leHBvcnRzLmNyeXB0b1JhbmRvbUJ1ZmZlciA9IGNyeXB0b1JhbmRvbUJ1ZmZlclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/isomorphic.js/browser.js\n")},"./node_modules/isomorphic.js/browser.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"performance\": () => (/* binding */ performance),\n/* harmony export */   \"cryptoRandomBuffer\": () => (/* binding */ cryptoRandomBuffer)\n/* harmony export */ });\n/* eslint-env browser */\nconst performance = typeof window === 'undefined' ? null : (typeof window.performance !== 'undefined' && window.performance) || null\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nconst cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2lzb21vcnBoaWMuanMvYnJvd3Nlci5tanM/MjY5MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087O0FBRVA7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLmpzL2Jyb3dzZXIubWpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5leHBvcnQgY29uc3QgcGVyZm9ybWFuY2UgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiAodHlwZW9mIHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlKSB8fCBudWxsXG5cbmNvbnN0IGlzb0NyeXB0byA9IHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNyeXB0b1xuXG4vKipcbiAqIEB0eXBlIHtmdW5jdGlvbihudW1iZXIpOkFycmF5QnVmZmVyfVxuICovXG5leHBvcnQgY29uc3QgY3J5cHRvUmFuZG9tQnVmZmVyID0gaXNvQ3J5cHRvICE9PSBudWxsXG4gID8gbGVuID0+IHtcbiAgICAvLyBicm93c2VyXG4gICAgY29uc3QgYnVmID0gbmV3IEFycmF5QnVmZmVyKGxlbilcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgaXNvQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG4gIDogbGVuID0+IHtcbiAgICAvLyBwb2x5ZmlsbFxuICAgIGNvbnN0IGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW4pXG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycltpXSA9IE1hdGguY2VpbCgoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpID4+PiAwKVxuICAgIH1cbiAgICByZXR1cm4gYnVmXG4gIH1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isomorphic.js/browser.mjs\n")},"./node_modules/lib0/array.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "last": () => (/* binding */ last),\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "copy": () => (/* binding */ copy),\n/* harmony export */   "appendTo": () => (/* binding */ appendTo),\n/* harmony export */   "from": () => (/* binding */ from),\n/* harmony export */   "every": () => (/* binding */ every),\n/* harmony export */   "some": () => (/* binding */ some),\n/* harmony export */   "equalFlat": () => (/* binding */ equalFlat),\n/* harmony export */   "flatten": () => (/* binding */ flatten)\n/* harmony export */ });\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nconst every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nconst some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvYXJyYXkuanM/ZmNhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTyxnQ0FBZ0MsU0FBUzs7QUFFaEQ7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTyw2QkFBNkIsU0FBUzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ087QUFDUCxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsNENBQTRDO0FBQ3ZELFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQ0FBc0M7QUFDakQsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEFycmF5cy5cbiAqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gVGhlIGVsZW1lbnQgbXVzdCBleGlzdFxuICpcbiAqIEB0ZW1wbGF0ZSBMXG4gKiBAcGFyYW0ge0FycmF5PEw+fSBhcnJcbiAqIEByZXR1cm4ge0x9XG4gKi9cbmV4cG9ydCBjb25zdCBsYXN0ID0gYXJyID0+IGFyclthcnIubGVuZ3RoIC0gMV1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQ1xuICogQHJldHVybiB7QXJyYXk8Qz59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiAvKiogQHR5cGUge0FycmF5PEM+fSAqLyAoW10pXG5cbi8qKlxuICogQHRlbXBsYXRlIERcbiAqIEBwYXJhbSB7QXJyYXk8RD59IGFcbiAqIEByZXR1cm4ge0FycmF5PEQ+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IGEgPT4gLyoqIEB0eXBlIHtBcnJheTxEPn0gKi8gKGEuc2xpY2UoKSlcblxuLyoqXG4gKiBBcHBlbmQgZWxlbWVudHMgZnJvbSBzcmMgdG8gZGVzdFxuICpcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5PE0+fSBkZXN0XG4gKiBAcGFyYW0ge0FycmF5PE0+fSBzcmNcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZFRvID0gKGRlc3QsIHNyYykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QucHVzaChzcmNbaV0pXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHNvbWV0aGluZyBhcnJheS1saWtlIHRvIGFuIGFjdHVhbCBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPnxJdGVyYWJsZTxUPn0gYXJyYXlsaWtlXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9IEFycmF5LmZyb21cblxuLyoqXG4gKiBUcnVlIGlmZiBjb25kaXRpb24gaG9sZHMgb24gZXZlcnkgZWxlbWVudCBpbiB0aGUgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgSVRFTVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8SVRFTT59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihJVEVNLCBudW1iZXIsIEFycmF5PElURU0+KTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXZlcnkgPSAoYXJyLCBmKSA9PiBhcnIuZXZlcnkoZilcblxuLyoqXG4gKiBUcnVlIGlmZiBjb25kaXRpb24gaG9sZHMgb24gc29tZSBlbGVtZW50IGluIHRoZSBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAcGFyYW0ge0FycmF5PFM+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUywgbnVtYmVyLCBBcnJheTxTPik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSAoYXJyLCBmKSA9PiBhcnIuc29tZShmKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFTEVNXG4gKlxuICogQHBhcmFtIHtBcnJheTxFTEVNPn0gYVxuICogQHBhcmFtIHtBcnJheTxFTEVNPn0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsRmxhdCA9IChhLCBiKSA9PiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgZXZlcnkoYSwgKGl0ZW0sIGluZGV4KSA9PiBpdGVtID09PSBiW2luZGV4XSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgRUxFTVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxFTEVNPj59IGFyclxuICogQHJldHVybiB7QXJyYXk8RUxFTT59XG4gKi9cbmV4cG9ydCBjb25zdCBmbGF0dGVuID0gYXJyID0+IGFyci5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCksIFtdKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/array.js\n')},"./node_modules/lib0/binary.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "BIT1": () => (/* binding */ BIT1),\n/* harmony export */   "BIT2": () => (/* binding */ BIT2),\n/* harmony export */   "BIT3": () => (/* binding */ BIT3),\n/* harmony export */   "BIT4": () => (/* binding */ BIT4),\n/* harmony export */   "BIT5": () => (/* binding */ BIT5),\n/* harmony export */   "BIT6": () => (/* binding */ BIT6),\n/* harmony export */   "BIT7": () => (/* binding */ BIT7),\n/* harmony export */   "BIT8": () => (/* binding */ BIT8),\n/* harmony export */   "BIT9": () => (/* binding */ BIT9),\n/* harmony export */   "BIT10": () => (/* binding */ BIT10),\n/* harmony export */   "BIT11": () => (/* binding */ BIT11),\n/* harmony export */   "BIT12": () => (/* binding */ BIT12),\n/* harmony export */   "BIT13": () => (/* binding */ BIT13),\n/* harmony export */   "BIT14": () => (/* binding */ BIT14),\n/* harmony export */   "BIT15": () => (/* binding */ BIT15),\n/* harmony export */   "BIT16": () => (/* binding */ BIT16),\n/* harmony export */   "BIT17": () => (/* binding */ BIT17),\n/* harmony export */   "BIT18": () => (/* binding */ BIT18),\n/* harmony export */   "BIT19": () => (/* binding */ BIT19),\n/* harmony export */   "BIT20": () => (/* binding */ BIT20),\n/* harmony export */   "BIT21": () => (/* binding */ BIT21),\n/* harmony export */   "BIT22": () => (/* binding */ BIT22),\n/* harmony export */   "BIT23": () => (/* binding */ BIT23),\n/* harmony export */   "BIT24": () => (/* binding */ BIT24),\n/* harmony export */   "BIT25": () => (/* binding */ BIT25),\n/* harmony export */   "BIT26": () => (/* binding */ BIT26),\n/* harmony export */   "BIT27": () => (/* binding */ BIT27),\n/* harmony export */   "BIT28": () => (/* binding */ BIT28),\n/* harmony export */   "BIT29": () => (/* binding */ BIT29),\n/* harmony export */   "BIT30": () => (/* binding */ BIT30),\n/* harmony export */   "BIT31": () => (/* binding */ BIT31),\n/* harmony export */   "BIT32": () => (/* binding */ BIT32),\n/* harmony export */   "BITS0": () => (/* binding */ BITS0),\n/* harmony export */   "BITS1": () => (/* binding */ BITS1),\n/* harmony export */   "BITS2": () => (/* binding */ BITS2),\n/* harmony export */   "BITS3": () => (/* binding */ BITS3),\n/* harmony export */   "BITS4": () => (/* binding */ BITS4),\n/* harmony export */   "BITS5": () => (/* binding */ BITS5),\n/* harmony export */   "BITS6": () => (/* binding */ BITS6),\n/* harmony export */   "BITS7": () => (/* binding */ BITS7),\n/* harmony export */   "BITS8": () => (/* binding */ BITS8),\n/* harmony export */   "BITS9": () => (/* binding */ BITS9),\n/* harmony export */   "BITS10": () => (/* binding */ BITS10),\n/* harmony export */   "BITS11": () => (/* binding */ BITS11),\n/* harmony export */   "BITS12": () => (/* binding */ BITS12),\n/* harmony export */   "BITS13": () => (/* binding */ BITS13),\n/* harmony export */   "BITS14": () => (/* binding */ BITS14),\n/* harmony export */   "BITS15": () => (/* binding */ BITS15),\n/* harmony export */   "BITS16": () => (/* binding */ BITS16),\n/* harmony export */   "BITS17": () => (/* binding */ BITS17),\n/* harmony export */   "BITS18": () => (/* binding */ BITS18),\n/* harmony export */   "BITS19": () => (/* binding */ BITS19),\n/* harmony export */   "BITS20": () => (/* binding */ BITS20),\n/* harmony export */   "BITS21": () => (/* binding */ BITS21),\n/* harmony export */   "BITS22": () => (/* binding */ BITS22),\n/* harmony export */   "BITS23": () => (/* binding */ BITS23),\n/* harmony export */   "BITS24": () => (/* binding */ BITS24),\n/* harmony export */   "BITS25": () => (/* binding */ BITS25),\n/* harmony export */   "BITS26": () => (/* binding */ BITS26),\n/* harmony export */   "BITS27": () => (/* binding */ BITS27),\n/* harmony export */   "BITS28": () => (/* binding */ BITS28),\n/* harmony export */   "BITS29": () => (/* binding */ BITS29),\n/* harmony export */   "BITS30": () => (/* binding */ BITS30),\n/* harmony export */   "BITS31": () => (/* binding */ BITS31),\n/* harmony export */   "BITS32": () => (/* binding */ BITS32)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1\nconst BIT2 = 2\nconst BIT3 = 4\nconst BIT4 = 8\nconst BIT5 = 16\nconst BIT6 = 32\nconst BIT7 = 64\nconst BIT8 = 128\nconst BIT9 = 256\nconst BIT10 = 512\nconst BIT11 = 1024\nconst BIT12 = 2048\nconst BIT13 = 4096\nconst BIT14 = 8192\nconst BIT15 = 16384\nconst BIT16 = 32768\nconst BIT17 = 65536\nconst BIT18 = 1 << 17\nconst BIT19 = 1 << 18\nconst BIT20 = 1 << 19\nconst BIT21 = 1 << 20\nconst BIT22 = 1 << 21\nconst BIT23 = 1 << 22\nconst BIT24 = 1 << 23\nconst BIT25 = 1 << 24\nconst BIT26 = 1 << 25\nconst BIT27 = 1 << 26\nconst BIT28 = 1 << 27\nconst BIT29 = 1 << 28\nconst BIT30 = 1 << 29\nconst BIT31 = 1 << 30\nconst BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0\nconst BITS1 = 1\nconst BITS2 = 3\nconst BITS3 = 7\nconst BITS4 = 15\nconst BITS5 = 31\nconst BITS6 = 63\nconst BITS7 = 127\nconst BITS8 = 255\nconst BITS9 = 511\nconst BITS10 = 1023\nconst BITS11 = 2047\nconst BITS12 = 4095\nconst BITS13 = 8191\nconst BITS14 = 16383\nconst BITS15 = 32767\nconst BITS16 = 65535\nconst BITS17 = BIT18 - 1\nconst BITS18 = BIT19 - 1\nconst BITS19 = BIT20 - 1\nconst BITS20 = BIT21 - 1\nconst BITS21 = BIT22 - 1\nconst BITS22 = BIT23 - 1\nconst BITS23 = BIT24 - 1\nconst BITS24 = BIT25 - 1\nconst BITS25 = BIT26 - 1\nconst BITS26 = BIT27 - 1\nconst BITS27 = BIT28 - 1\nconst BITS28 = BIT29 - 1\nconst BITS29 = BIT30 - 1\nconst BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvYmluYXJ5LmpzP2M3N2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ1A7QUFDQSxVQUFVO0FBQ1Y7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2JpbmFyeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEJpbmFyeSBkYXRhIGNvbnN0YW50cy5cbiAqXG4gKiBAbW9kdWxlIGJpbmFyeVxuICovXG5cbi8qKlxuICogbi10aCBiaXQgYWN0aXZhdGVkLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVQxID0gMVxuZXhwb3J0IGNvbnN0IEJJVDIgPSAyXG5leHBvcnQgY29uc3QgQklUMyA9IDRcbmV4cG9ydCBjb25zdCBCSVQ0ID0gOFxuZXhwb3J0IGNvbnN0IEJJVDUgPSAxNlxuZXhwb3J0IGNvbnN0IEJJVDYgPSAzMlxuZXhwb3J0IGNvbnN0IEJJVDcgPSA2NFxuZXhwb3J0IGNvbnN0IEJJVDggPSAxMjhcbmV4cG9ydCBjb25zdCBCSVQ5ID0gMjU2XG5leHBvcnQgY29uc3QgQklUMTAgPSA1MTJcbmV4cG9ydCBjb25zdCBCSVQxMSA9IDEwMjRcbmV4cG9ydCBjb25zdCBCSVQxMiA9IDIwNDhcbmV4cG9ydCBjb25zdCBCSVQxMyA9IDQwOTZcbmV4cG9ydCBjb25zdCBCSVQxNCA9IDgxOTJcbmV4cG9ydCBjb25zdCBCSVQxNSA9IDE2Mzg0XG5leHBvcnQgY29uc3QgQklUMTYgPSAzMjc2OFxuZXhwb3J0IGNvbnN0IEJJVDE3ID0gNjU1MzZcbmV4cG9ydCBjb25zdCBCSVQxOCA9IDEgPDwgMTdcbmV4cG9ydCBjb25zdCBCSVQxOSA9IDEgPDwgMThcbmV4cG9ydCBjb25zdCBCSVQyMCA9IDEgPDwgMTlcbmV4cG9ydCBjb25zdCBCSVQyMSA9IDEgPDwgMjBcbmV4cG9ydCBjb25zdCBCSVQyMiA9IDEgPDwgMjFcbmV4cG9ydCBjb25zdCBCSVQyMyA9IDEgPDwgMjJcbmV4cG9ydCBjb25zdCBCSVQyNCA9IDEgPDwgMjNcbmV4cG9ydCBjb25zdCBCSVQyNSA9IDEgPDwgMjRcbmV4cG9ydCBjb25zdCBCSVQyNiA9IDEgPDwgMjVcbmV4cG9ydCBjb25zdCBCSVQyNyA9IDEgPDwgMjZcbmV4cG9ydCBjb25zdCBCSVQyOCA9IDEgPDwgMjdcbmV4cG9ydCBjb25zdCBCSVQyOSA9IDEgPDwgMjhcbmV4cG9ydCBjb25zdCBCSVQzMCA9IDEgPDwgMjlcbmV4cG9ydCBjb25zdCBCSVQzMSA9IDEgPDwgMzBcbmV4cG9ydCBjb25zdCBCSVQzMiA9IDEgPDwgMzFcblxuLyoqXG4gKiBGaXJzdCBuIGJpdHMgYWN0aXZhdGVkLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVRTMCA9IDBcbmV4cG9ydCBjb25zdCBCSVRTMSA9IDFcbmV4cG9ydCBjb25zdCBCSVRTMiA9IDNcbmV4cG9ydCBjb25zdCBCSVRTMyA9IDdcbmV4cG9ydCBjb25zdCBCSVRTNCA9IDE1XG5leHBvcnQgY29uc3QgQklUUzUgPSAzMVxuZXhwb3J0IGNvbnN0IEJJVFM2ID0gNjNcbmV4cG9ydCBjb25zdCBCSVRTNyA9IDEyN1xuZXhwb3J0IGNvbnN0IEJJVFM4ID0gMjU1XG5leHBvcnQgY29uc3QgQklUUzkgPSA1MTFcbmV4cG9ydCBjb25zdCBCSVRTMTAgPSAxMDIzXG5leHBvcnQgY29uc3QgQklUUzExID0gMjA0N1xuZXhwb3J0IGNvbnN0IEJJVFMxMiA9IDQwOTVcbmV4cG9ydCBjb25zdCBCSVRTMTMgPSA4MTkxXG5leHBvcnQgY29uc3QgQklUUzE0ID0gMTYzODNcbmV4cG9ydCBjb25zdCBCSVRTMTUgPSAzMjc2N1xuZXhwb3J0IGNvbnN0IEJJVFMxNiA9IDY1NTM1XG5leHBvcnQgY29uc3QgQklUUzE3ID0gQklUMTggLSAxXG5leHBvcnQgY29uc3QgQklUUzE4ID0gQklUMTkgLSAxXG5leHBvcnQgY29uc3QgQklUUzE5ID0gQklUMjAgLSAxXG5leHBvcnQgY29uc3QgQklUUzIwID0gQklUMjEgLSAxXG5leHBvcnQgY29uc3QgQklUUzIxID0gQklUMjIgLSAxXG5leHBvcnQgY29uc3QgQklUUzIyID0gQklUMjMgLSAxXG5leHBvcnQgY29uc3QgQklUUzIzID0gQklUMjQgLSAxXG5leHBvcnQgY29uc3QgQklUUzI0ID0gQklUMjUgLSAxXG5leHBvcnQgY29uc3QgQklUUzI1ID0gQklUMjYgLSAxXG5leHBvcnQgY29uc3QgQklUUzI2ID0gQklUMjcgLSAxXG5leHBvcnQgY29uc3QgQklUUzI3ID0gQklUMjggLSAxXG5leHBvcnQgY29uc3QgQklUUzI4ID0gQklUMjkgLSAxXG5leHBvcnQgY29uc3QgQklUUzI5ID0gQklUMzAgLSAxXG5leHBvcnQgY29uc3QgQklUUzMwID0gQklUMzEgLSAxXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVRTMzEgPSAweDdGRkZGRkZGXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBCSVRTMzIgPSAweEZGRkZGRkZGXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/binary.js\n')},"./node_modules/lib0/broadcastchannel.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"subscribe\": () => (/* binding */ subscribe),\n/* harmony export */   \"unsubscribe\": () => (/* binding */ unsubscribe),\n/* harmony export */   \"publish\": () => (/* binding */ publish)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ \"./node_modules/lib0/buffer.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storage.js */ \"./node_modules/lib0/storage.js\");\n/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\n\n\n\n\n/**\n * @typedef {Object} Channel\n * @property {Set<Function>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    _storage_js__WEBPACK_IMPORTED_MODULE_0__.onChange(e => e.key === room && this.onmessage !== null && this.onmessage({ data: _buffer_js__WEBPACK_IMPORTED_MODULE_1__.fromBase64(e.newValue || '') }))\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    _storage_js__WEBPACK_IMPORTED_MODULE_0__.varStorage.setItem(this.room, _buffer_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(_buffer_js__WEBPACK_IMPORTED_MODULE_1__.createUint8ArrayFromArrayBuffer(buf)))\n  }\n}\n\n// Use BroadcastChannel or Polyfill\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  _map_js__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(channels, room, () => {\n    const subs = new Set()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nconst subscribe = (room, f) => getChannel(room).subs.add(f)\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any):any} f\n */\nconst unsubscribe = (room, f) => getChannel(room).subs.delete(f)\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n */\nconst publish = (room, data) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvYnJvYWRjYXN0Y2hhbm5lbC5qcz80N2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRStCO0FBQ007QUFDRTs7QUFFdkM7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxjQUFjO0FBQzVCLGNBQWMsSUFBSTtBQUNsQjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWUsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxJQUFJLGlEQUFnQixtRUFBbUUsT0FBTyxrREFBaUIsb0JBQW9CO0FBQ25JOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQSxJQUFJLDJEQUEwQixZQUFZLGdEQUFlLENBQUMsdUVBQXNDO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUUsbURBQWtCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Jyb2FkY2FzdGNoYW5uZWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIGZvciBjcm9zcy10YWIgY29tbXVuaWNhdGlvbiB1c2luZyBicm9hZGNhc3RjaGFubmVsIHdpdGggTG9jYWxTdG9yYWdlIGZhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbiBicm93c2VyIHdpbmRvdyBBOlxuICogYnJvYWRjYXN0Y2hhbm5lbC5zdWJzY3JpYmUoJ215IGV2ZW50cycsIGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdIZWxsbyB3b3JsZCEnKSAvLyA9PiBBOiAnSGVsbG8gd29ybGQhJyBmaXJlcyBzeW5jaHJvbm91c2x5IGluIHNhbWUgdGFiXG4gKlxuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQjpcbiAqIGJyb2FkY2FzdGNoYW5uZWwucHVibGlzaCgnbXkgZXZlbnRzJywgJ2hlbGxvIGZyb20gdGFiIEInKSAvLyA9PiBBOiAnaGVsbG8gZnJvbSB0YWIgQidcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgYnJvYWRjYXN0Y2hhbm5lbFxuICovXG5cbi8vIEB0b2RvIGJlZm9yZSBuZXh0IG1ham9yOiB1c2UgVWludDhBcnJheSBpbnN0ZWFkIGFzIGJ1ZmZlciBvYmplY3RcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbFxuICogQHByb3BlcnR5IHtTZXQ8RnVuY3Rpb24+fSBDaGFubmVsLnN1YnNcbiAqIEBwcm9wZXJ0eSB7YW55fSBDaGFubmVsLmJjXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgQ2hhbm5lbD59XG4gKi9cbmNvbnN0IGNoYW5uZWxzID0gbmV3IE1hcCgpXG5cbmNsYXNzIExvY2FsU3RvcmFnZVBvbHlmaWxsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocm9vbSkge1xuICAgIHRoaXMucm9vbSA9IHJvb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbHxmdW5jdGlvbih7ZGF0YTpBcnJheUJ1ZmZlcn0pOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsXG4gICAgc3RvcmFnZS5vbkNoYW5nZShlID0+IGUua2V5ID09PSByb29tICYmIHRoaXMub25tZXNzYWdlICE9PSBudWxsICYmIHRoaXMub25tZXNzYWdlKHsgZGF0YTogYnVmZmVyLmZyb21CYXNlNjQoZS5uZXdWYWx1ZSB8fCAnJykgfSkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmXG4gICAqL1xuICBwb3N0TWVzc2FnZSAoYnVmKSB7XG4gICAgc3RvcmFnZS52YXJTdG9yYWdlLnNldEl0ZW0odGhpcy5yb29tLCBidWZmZXIudG9CYXNlNjQoYnVmZmVyLmNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIoYnVmKSkpXG4gIH1cbn1cblxuLy8gVXNlIEJyb2FkY2FzdENoYW5uZWwgb3IgUG9seWZpbGxcbmNvbnN0IEJDID0gdHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICd1bmRlZmluZWQnID8gTG9jYWxTdG9yYWdlUG9seWZpbGwgOiBCcm9hZGNhc3RDaGFubmVsXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEByZXR1cm4ge0NoYW5uZWx9XG4gKi9cbmNvbnN0IGdldENoYW5uZWwgPSByb29tID0+XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChjaGFubmVscywgcm9vbSwgKCkgPT4ge1xuICAgIGNvbnN0IHN1YnMgPSBuZXcgU2V0KClcbiAgICBjb25zdCBiYyA9IG5ldyBCQyhyb29tKVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e2RhdGE6QXJyYXlCdWZmZXJ9fSBlXG4gICAgICovXG4gICAgYmMub25tZXNzYWdlID0gZSA9PiBzdWJzLmZvckVhY2goc3ViID0+IHN1YihlLmRhdGEpKVxuICAgIHJldHVybiB7XG4gICAgICBiYywgc3Vic1xuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gZ2xvYmFsIGBwdWJsaXNoYCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IGdldENoYW5uZWwocm9vbSkuc3Vicy5hZGQoZilcblxuLyoqXG4gKiBVbnN1YnNjcmliZSBmcm9tIGBwdWJsaXNoYCBnbG9iYWwgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHVuc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IGdldENoYW5uZWwocm9vbSkuc3Vicy5kZWxldGUoZilcblxuLyoqXG4gKiBQdWJsaXNoIGRhdGEgdG8gYWxsIHN1YnNjcmliZXJzIChpbmNsdWRpbmcgc3Vic2NyaWJlcnMgb24gdGhpcyB0YWIpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHB1Ymxpc2ggPSAocm9vbSwgZGF0YSkgPT4ge1xuICBjb25zdCBjID0gZ2V0Q2hhbm5lbChyb29tKVxuICBjLmJjLnBvc3RNZXNzYWdlKGRhdGEpXG4gIGMuc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIoZGF0YSkpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/broadcastchannel.js\n")},"./node_modules/lib0/buffer.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createUint8ArrayFromLen": () => (/* binding */ createUint8ArrayFromLen),\n/* harmony export */   "createUint8ArrayViewFromArrayBuffer": () => (/* binding */ createUint8ArrayViewFromArrayBuffer),\n/* harmony export */   "createUint8ArrayFromArrayBuffer": () => (/* binding */ createUint8ArrayFromArrayBuffer),\n/* harmony export */   "toBase64": () => (/* binding */ toBase64),\n/* harmony export */   "fromBase64": () => (/* binding */ fromBase64),\n/* harmony export */   "copyUint8Array": () => (/* binding */ copyUint8Array),\n/* harmony export */   "encodeAny": () => (/* binding */ encodeAny),\n/* harmony export */   "decodeAny": () => (/* binding */ decodeAny)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ "./node_modules/lib0/string.js");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ "./node_modules/lib0/environment.js");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var _decoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoding.js */ "./node_modules/lib0/decoding.js");\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n\n\n\n\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = \'\'\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += _string_js__WEBPACK_IMPORTED_MODULE_0__.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString(\'base64\')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, \'base64\')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nconst toBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nconst fromBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It\'s a pun on typescripts\'s `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data => {\n  const encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_2__.createEncoder()\n  _encoding_js__WEBPACK_IMPORTED_MODULE_2__.writeAny(encoder, data)\n  return _encoding_js__WEBPACK_IMPORTED_MODULE_2__.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => _decoding_js__WEBPACK_IMPORTED_MODULE_3__.readAny(_decoding_js__WEBPACK_IMPORTED_MODULE_3__.createDecoder(buf))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvYnVmZmVyLmpzP2Q3MmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDRTtBQUNFO0FBQ0E7O0FBRXpDO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDLFNBQVMsb0RBQW1CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ08saUJBQWlCLHNEQUFhOztBQUVyQztBQUNPLG1CQUFtQixzREFBYTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTztBQUNQLGtCQUFrQix1REFBc0I7QUFDeEMsRUFBRSxrREFBaUI7QUFDbkIsU0FBUyxzREFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPLHlCQUF5QixpREFBZ0IsQ0FBQyx1REFBc0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9idWZmZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCBidWZmZXJzIChVaW50OEFycmF5KS5cbiAqXG4gKiBAbW9kdWxlIGJ1ZmZlclxuICovXG5cbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGVudiBmcm9tICcuL2Vudmlyb25tZW50LmpzJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnLi9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJy4vZGVjb2RpbmcuanMnXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21MZW4gPSBsZW4gPT4gbmV3IFVpbnQ4QXJyYXkobGVuKVxuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIgPSAoYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpID0+IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyID0gYnVmZmVyID0+IG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NEJyb3dzZXIgPSBieXRlcyA9PiB7XG4gIGxldCBzID0gJydcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBzICs9IHN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pXG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHJldHVybiBidG9hKHMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NE5vZGUgPSBieXRlcyA9PiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZnJvbUJhc2U2NEJyb3dzZXIgPSBzID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIGNvbnN0IGEgPSBhdG9iKHMpXG4gIGNvbnN0IGJ5dGVzID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4oYS5sZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYS5jaGFyQ29kZUF0KGkpXG4gIH1cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqL1xuY29uc3QgZnJvbUJhc2U2NE5vZGUgPSBzID0+IHtcbiAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20ocywgJ2Jhc2U2NCcpXG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjQgPSBlbnYuaXNCcm93c2VyID8gdG9CYXNlNjRCcm93c2VyIDogdG9CYXNlNjROb2RlXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZnJvbUJhc2U2NCA9IGVudi5pc0Jyb3dzZXIgPyBmcm9tQmFzZTY0QnJvd3NlciA6IGZyb21CYXNlNjROb2RlXG5cbi8qKlxuICogQ29weSB0aGUgY29udGVudCBvZiBhbiBVaW50OEFycmF5IHZpZXcgdG8gYSBuZXcgQXJyYXlCdWZmZXIuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgY29weVVpbnQ4QXJyYXkgPSB1aW50OEFycmF5ID0+IHtcbiAgY29uc3QgbmV3QnVmID0gY3JlYXRlVWludDhBcnJheUZyb21MZW4odWludDhBcnJheS5ieXRlTGVuZ3RoKVxuICBuZXdCdWYuc2V0KHVpbnQ4QXJyYXkpXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW55dGhpbmcgYXMgYSBVSW50OEFycmF5LiBJdCdzIGEgcHVuIG9uIHR5cGVzY3JpcHRzJ3MgYGFueWAgdHlwZS5cbiAqIFNlZSBlbmNvZGluZy53cml0ZUFueSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZUFueSA9IGRhdGEgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlQW55KGVuY29kZXIsIGRhdGEpXG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBEZWNvZGUgYW4gYW55LWVuY29kZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZUFueSA9IGJ1ZiA9PiBkZWNvZGluZy5yZWFkQW55KGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/buffer.js\n')},"./node_modules/lib0/conditions.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "undefinedToNull": () => (/* binding */ undefinedToNull)\n/* harmony export */ });\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nconst undefinedToNull = v => v === undefined ? null : v\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcz9lMzk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2Z0ZW4gdXNlZCBjb25kaXRpb25zLlxuICpcbiAqIEBtb2R1bGUgY29uZGl0aW9uc1xuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VHxudWxsfHVuZGVmaW5lZH0gdlxuICogQHJldHVybiB7VHxudWxsfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHVuZGVmaW5lZFRvTnVsbCA9IHYgPT4gdiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/conditions.js\n')},"./node_modules/lib0/decoding.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Decoder": () => (/* binding */ Decoder),\n/* harmony export */   "createDecoder": () => (/* binding */ createDecoder),\n/* harmony export */   "hasContent": () => (/* binding */ hasContent),\n/* harmony export */   "clone": () => (/* binding */ clone),\n/* harmony export */   "readUint8Array": () => (/* binding */ readUint8Array),\n/* harmony export */   "readVarUint8Array": () => (/* binding */ readVarUint8Array),\n/* harmony export */   "readTailAsUint8Array": () => (/* binding */ readTailAsUint8Array),\n/* harmony export */   "skip8": () => (/* binding */ skip8),\n/* harmony export */   "readUint8": () => (/* binding */ readUint8),\n/* harmony export */   "readUint16": () => (/* binding */ readUint16),\n/* harmony export */   "readUint32": () => (/* binding */ readUint32),\n/* harmony export */   "readUint32BigEndian": () => (/* binding */ readUint32BigEndian),\n/* harmony export */   "peekUint8": () => (/* binding */ peekUint8),\n/* harmony export */   "peekUint16": () => (/* binding */ peekUint16),\n/* harmony export */   "peekUint32": () => (/* binding */ peekUint32),\n/* harmony export */   "readVarUint": () => (/* binding */ readVarUint),\n/* harmony export */   "readVarInt": () => (/* binding */ readVarInt),\n/* harmony export */   "peekVarUint": () => (/* binding */ peekVarUint),\n/* harmony export */   "peekVarInt": () => (/* binding */ peekVarInt),\n/* harmony export */   "readVarString": () => (/* binding */ readVarString),\n/* harmony export */   "peekVarString": () => (/* binding */ peekVarString),\n/* harmony export */   "readFromDataView": () => (/* binding */ readFromDataView),\n/* harmony export */   "readFloat32": () => (/* binding */ readFloat32),\n/* harmony export */   "readFloat64": () => (/* binding */ readFloat64),\n/* harmony export */   "readBigInt64": () => (/* binding */ readBigInt64),\n/* harmony export */   "readBigUint64": () => (/* binding */ readBigUint64),\n/* harmony export */   "readAny": () => (/* binding */ readAny),\n/* harmony export */   "RleDecoder": () => (/* binding */ RleDecoder),\n/* harmony export */   "IntDiffDecoder": () => (/* binding */ IntDiffDecoder),\n/* harmony export */   "RleIntDiffDecoder": () => (/* binding */ RleIntDiffDecoder),\n/* harmony export */   "UintOptRleDecoder": () => (/* binding */ UintOptRleDecoder),\n/* harmony export */   "IncUintOptRleDecoder": () => (/* binding */ IncUintOptRleDecoder),\n/* harmony export */   "IntDiffOptRleDecoder": () => (/* binding */ IntDiffOptRleDecoder),\n/* harmony export */   "StringDecoder": () => (/* binding */ StringDecoder)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/lib0/buffer.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ "./node_modules/lib0/binary.js");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang\'s binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, \'Hello world!\')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => \'Hello world!\'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\n\n\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = _buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS7) << len)\n    len += 7\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error(\'Integer out of range!\')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS6\n  let len = 6\n  const sign = (r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT7) > 0 ? -1 : 1\n  if ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) === 0) {\n    // don\'t continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS7) << len)\n    len += 7\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_1__.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error(\'Integer out of range!\')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nconst readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return \'\'\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_2__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_2__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGVjb2RpbmcuanM/MWIyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNBO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQLGVBQWUsMkVBQTBDO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBOztBQUVPO0FBQ1A7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFTztBQUNQO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kZWNvZGluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBuZXcgZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gbmV3IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBkZWNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuXG4vKipcbiAqIEEgRGVjb2RlciBoYW5kbGVzIHRoZSBkZWNvZGluZyBvZiBhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXkgQmluYXJ5IGRhdGEgdG8gZGVjb2RlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIC8qKlxuICAgICAqIERlY29kaW5nIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gdWludDhBcnJheVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGVjb2RpbmcgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMFxuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge0RlY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWNvZGVyID0gdWludDhBcnJheSA9PiBuZXcgRGVjb2Rlcih1aW50OEFycmF5KVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzQ29udGVudCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MgIT09IGRlY29kZXIuYXJyLmxlbmd0aFxuXG4vKipcbiAqIENsb25lIGEgZGVjb2RlciBpbnN0YW5jZS5cbiAqIE9wdGlvbmFsbHkgc2V0IGEgbmV3IHBvc2l0aW9uIHBhcmFtZXRlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IFtuZXdQb3NdIERlZmF1bHRzIHRvIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0RlY29kZXJ9IEEgY2xvbmUgb2YgYGRlY29kZXJgXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IChkZWNvZGVyLCBuZXdQb3MgPSBkZWNvZGVyLnBvcykgPT4ge1xuICBjb25zdCBfZGVjb2RlciA9IGNyZWF0ZURlY29kZXIoZGVjb2Rlci5hcnIpXG4gIF9kZWNvZGVyLnBvcyA9IG5ld1Bvc1xuICByZXR1cm4gX2RlY29kZXJcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQ4QXJyYXkgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IHZpZXcgPSBidWZmZXIuY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbilcbiAgZGVjb2Rlci5wb3MgKz0gbGVuXG4gIHJldHVybiB2aWV3XG59XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCB0aGUgcmVzdCBvZiB0aGUgY29udGVudCBhcyBhbiBBcnJheUJ1ZmZlclxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVGFpbEFzVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgZGVjb2Rlci5hcnIubGVuZ3RoIC0gZGVjb2Rlci5wb3MpXG5cbi8qKlxuICogU2tpcCBvbmUgYnl0ZSwganVtcCB0byB0aGUgbmV4dCBwb3NpdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBza2lwOCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MrK1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50OCA9IGRlY29kZXIgPT4gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cblxuLyoqXG4gKiBSZWFkIDIgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQxNiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG4gIGRlY29kZXIucG9zICs9IDJcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgMTYpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMkJpZ0VuZGlhbiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zXVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MTYgPSBkZWNvZGVyID0+XG4gIGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQzMiA9IGRlY29kZXIgPT4gKFxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDNdIDw8IDI0KVxuKSA+Pj4gMFxuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDBcbiAgbGV0IGxlbiA9IDBcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBsZW4gKz0gN1xuICAgIGlmIChyIDwgYmluYXJ5LkJJVDgpIHtcbiAgICAgIHJldHVybiBudW0gPj4+IDAgLy8gcmV0dXJuIHVuc2lnbmVkIG51bWJlciFcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGxlbiA+IDM1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVnZXIgb3V0IG9mIHJhbmdlIScpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIG51bWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgbGV0IG51bSA9IHIgJiBiaW5hcnkuQklUUzZcbiAgbGV0IGxlbiA9IDZcbiAgY29uc3Qgc2lnbiA9IChyICYgYmluYXJ5LkJJVDcpID4gMCA/IC0xIDogMVxuICBpZiAoKHIgJiBiaW5hcnkuQklUOCkgPT09IDApIHtcbiAgICAvLyBkb24ndCBjb250aW51ZSByZWFkaW5nXG4gICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXVxuICAgIG51bSA9IG51bSB8ICgociAmIGJpbmFyeS5CSVRTNykgPDwgbGVuKVxuICAgIGxlbiArPSA3XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIHNpZ24gKiAobnVtID4+PiAwKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAobGVuID4gNDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBvdXQgb2YgcmFuZ2UhJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclVpbnQgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3NcbiAgY29uc3QgcyA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJVaW50IHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJJbnQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3NcbiAgY29uc3QgcyA9IHJlYWRWYXJJbnQoZGVjb2RlcilcbiAgZGVjb2Rlci5wb3MgPSBwb3NcbiAgcmV0dXJuIHNcbn1cblxuLyoqXG4gKiBSZWFkIHN0cmluZyBvZiB2YXJpYWJsZSBsZW5ndGhcbiAqICogdmFyVWludCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBsZXQgcmVtYWluaW5nTGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgaWYgKHJlbWFpbmluZ0xlbiA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9IGVsc2Uge1xuICAgIGxldCBlbmNvZGVkU3RyaW5nID0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKSAvLyByZW1lbWJlciB0byBkZWNyZWFzZSByZW1haW5pbmdMZW5cbiAgICBpZiAoLS1yZW1haW5pbmdMZW4gPCAxMDApIHsgLy8gZG8gbm90IGNyZWF0ZSBhIFVpbnQ4QXJyYXkgZm9yIHNtYWxsIHN0cmluZ3NcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4tLSkge1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dExlbiA9IHJlbWFpbmluZ0xlbiA8IDEwMDAwID8gcmVtYWluaW5nTGVuIDogMTAwMDBcbiAgICAgICAgLy8gdGhpcyBpcyBkYW5nZXJvdXMsIHdlIGNyZWF0ZSBhIGZyZXNoIGFycmF5IHZpZXcgZnJvbSB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZGVjb2Rlci5hcnIuc3ViYXJyYXkoZGVjb2Rlci5wb3MsIGRlY29kZXIucG9zICsgbmV4dExlbilcbiAgICAgICAgZGVjb2Rlci5wb3MgKz0gbmV4dExlblxuICAgICAgICAvLyBTdGFydGluZyB3aXRoIEVTNS4xIHdlIGNhbiBzdXBwbHkgYSBnZW5lcmljIGFycmF5LWxpa2Ugb2JqZWN0IGFzIGFyZ3VtZW50c1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKVxuICAgICAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlblxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShlbmNvZGVkU3RyaW5nKSlcbiAgfVxufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyU3RyaW5nIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJTdHJpbmcgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3NcbiAgY29uc3QgcyA9IHJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgZGVjb2Rlci5wb3MgPSBwb3NcbiAgcmV0dXJuIHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm4ge0RhdGFWaWV3fVxuICovXG5leHBvcnQgY29uc3QgcmVhZEZyb21EYXRhVmlldyA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0ICsgZGVjb2Rlci5wb3MsIGxlbilcbiAgZGVjb2Rlci5wb3MgKz0gbGVuXG4gIHJldHVybiBkdlxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEZsb2F0MzIgPSBkZWNvZGVyID0+IHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgNCkuZ2V0RmxvYXQzMigwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRGbG9hdDY0ID0gZGVjb2RlciA9PiByZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpLmdldEZsb2F0NjQoMCwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQmlnSW50NjQgPSBkZWNvZGVyID0+IC8qKiBAdHlwZSB7YW55fSAqLyAocmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KSkuZ2V0QmlnSW50NjQoMCwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQmlnVWludDY0ID0gZGVjb2RlciA9PiAvKiogQHR5cGUge2FueX0gKi8gKHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkpLmdldEJpZ1VpbnQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oRGVjb2Rlcik6YW55Pn1cbiAqL1xuY29uc3QgcmVhZEFueUxvb2t1cFRhYmxlID0gW1xuICBkZWNvZGVyID0+IHVuZGVmaW5lZCwgLy8gQ0FTRSAxMjc6IHVuZGVmaW5lZFxuICBkZWNvZGVyID0+IG51bGwsIC8vIENBU0UgMTI2OiBudWxsXG4gIHJlYWRWYXJJbnQsIC8vIENBU0UgMTI1OiBpbnRlZ2VyXG4gIHJlYWRGbG9hdDMyLCAvLyBDQVNFIDEyNDogZmxvYXQzMlxuICByZWFkRmxvYXQ2NCwgLy8gQ0FTRSAxMjM6IGZsb2F0NjRcbiAgcmVhZEJpZ0ludDY0LCAvLyBDQVNFIDEyMjogYmlnaW50XG4gIGRlY29kZXIgPT4gZmFsc2UsIC8vIENBU0UgMTIxOiBib29sZWFuIChmYWxzZSlcbiAgZGVjb2RlciA9PiB0cnVlLCAvLyBDQVNFIDEyMDogYm9vbGVhbiAodHJ1ZSlcbiAgcmVhZFZhclN0cmluZywgLy8gQ0FTRSAxMTk6IHN0cmluZ1xuICBkZWNvZGVyID0+IHsgLy8gQ0FTRSAxMTg6IG9iamVjdDxzdHJpbmcsYW55PlxuICAgIGNvbnN0IGxlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvYmogPSB7fVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IHJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgIG9ialtrZXldID0gcmVhZEFueShkZWNvZGVyKVxuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH0sXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExNzogYXJyYXk8YW55PlxuICAgIGNvbnN0IGxlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgY29uc3QgYXJyID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnIucHVzaChyZWFkQW55KGRlY29kZXIpKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH0sXG4gIHJlYWRWYXJVaW50OEFycmF5IC8vIENBU0UgMTE2OiBVaW50OEFycmF5XG5dXG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQW55ID0gZGVjb2RlciA9PiByZWFkQW55TG9va3VwVGFibGVbMTI3IC0gcmVhZFVpbnQ4KGRlY29kZXIpXShkZWNvZGVyKVxuXG4vKipcbiAqIFQgbXVzdCBub3QgYmUgbnVsbC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgUmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRGVjb2Rlcik6VH0gcmVhZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgcmVhZGVyKSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBUaGUgcmVhZGVyXG4gICAgICovXG4gICAgdGhpcy5yZWFkZXIgPSByZWFkZXJcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge1R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBudWxsXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgPSB0aGlzLnJlYWRlcih0aGlzKVxuICAgICAgaWYgKGhhc0NvbnRlbnQodGhpcykpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMSAvLyBzZWUgZW5jb2RlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBpbmNyZW1lbnRlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IC0xIC8vIHJlYWQgdGhlIGN1cnJlbnQgdmFsdWUgZm9yZXZlclxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtUfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnREaWZmRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXksIHN0YXJ0KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIHRoaXMucyArPSByZWFkVmFySW50KHRoaXMpXG4gICAgcmV0dXJuIHRoaXMuc1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSbGVJbnREaWZmRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXksIHN0YXJ0KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyArPSByZWFkVmFySW50KHRoaXMpXG4gICAgICBpZiAoaGFzQ29udGVudCh0aGlzKSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAxIC8vIHNlZSBlbmNvZGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVhc29uIHdoeSB0aGlzIGlzIGluY3JlbWVudGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ID0gLTEgLy8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSBmb3JldmVyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVWludE9wdFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gcmVhZFZhckludCh0aGlzKVxuICAgICAgLy8gaWYgdGhlIHNpZ24gaXMgbmVnYXRpdmUsIHdlIHJlYWQgdGhlIGNvdW50IHRvbywgb3RoZXJ3aXNlIGNvdW50IGlzIDFcbiAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSBtYXRoLmlzTmVnYXRpdmVaZXJvKHRoaXMucylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICB0aGlzLnMgPSAtdGhpcy5zXG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbmNVaW50T3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgc2lnbiBpcyBuZWdhdGl2ZSwgd2UgcmVhZCB0aGUgY291bnQgdG9vLCBvdGhlcndpc2UgY291bnQgaXMgMVxuICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8odGhpcy5zKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIHRoaXMucyA9IC10aGlzLnNcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMrKylcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW50RGlmZk9wdFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gICAgdGhpcy5kaWZmID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICBjb25zdCBkaWZmID0gcmVhZFZhckludCh0aGlzKVxuICAgICAgLy8gaWYgdGhlIGZpcnN0IGJpdCBpcyBzZXQsIHdlIHJlYWQgbW9yZSBkYXRhXG4gICAgICBjb25zdCBoYXNDb3VudCA9IGRpZmYgJiAxXG4gICAgICB0aGlzLmRpZmYgPSBkaWZmID4+IDFcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaGFzQ291bnQpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnMgKz0gdGhpcy5kaWZmXG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIHRoaXMuc1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIodWludDhBcnJheSlcbiAgICB0aGlzLnN0ciA9IHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zcG9zID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuc3BvcyArIHRoaXMuZGVjb2Rlci5yZWFkKClcbiAgICBjb25zdCByZXMgPSB0aGlzLnN0ci5zbGljZSh0aGlzLnNwb3MsIGVuZClcbiAgICB0aGlzLnNwb3MgPSBlbmRcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/decoding.js\n')},"./node_modules/lib0/diff.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "simpleDiffString": () => (/* binding */ simpleDiffString),\n/* harmony export */   "simpleDiff": () => (/* binding */ simpleDiff),\n/* harmony export */   "simpleDiffArray": () => (/* binding */ simpleDiffArray)\n/* harmony export */ });\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./function.js */ "./node_modules/lib0/function.js");\n/**\n * Efficient diffs.\n *\n * @module diff\n */\n\n\n\n/**\n * A SimpleDiff describes a change on a String.\n *\n * ```js\n * console.log(a) // the old value\n * console.log(b) // the updated value\n * // Apply changes of diff (pseudocode)\n * a.remove(diff.index, diff.remove) // Remove `diff.remove` characters\n * a.insert(diff.index, diff.insert) // Insert `diff.insert`\n * a === b // values match\n * ```\n *\n * @typedef {Object} SimpleDiff\n * @property {Number} index The index where changes were applied\n * @property {Number} remove The number of characters to delete starting\n *                                  at `index`.\n * @property {T} insert The new text to insert at `index` after applying\n *                           `delete`\n *\n * @template T\n */\n\n/**\n * Create a diff between two strings. This diff implementation is highly\n * efficient, but not very sophisticated.\n *\n * @function\n *\n * @param {string} a The old version of the string\n * @param {string} b The updated version of the string\n * @return {SimpleDiff<string>} The diff description.\n */\nconst simpleDiffString = (a, b) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && a[left] === b[left]) {\n    left++\n  }\n  if (left !== a.length || left !== b.length) {\n    // Only check right if a !== b\n    while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {\n      right++\n    }\n  }\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n\n/**\n * @todo Remove in favor of simpleDiffString\n * @deprecated\n */\nconst simpleDiff = simpleDiffString\n\n/**\n * Create a diff between two arrays. This diff implementation is highly\n * efficient, but not very sophisticated.\n *\n * Note: This is basically the same function as above. Another function was created so that the runtime\n * can better optimize these function calls.\n *\n * @function\n * @template T\n *\n * @param {Array<T>} a The old version of the array\n * @param {Array<T>} b The updated version of the array\n * @param {function(T, T):boolean} [compare]\n * @return {SimpleDiff<Array<T>>} The diff description.\n */\nconst simpleDiffArray = (a, b, compare = _function_js__WEBPACK_IMPORTED_MODULE_0__.equalityStrict) => {\n  let left = 0 // number of same characters counting from left\n  let right = 0 // number of same characters counting from right\n  while (left < a.length && left < b.length && compare(a[left], b[left])) {\n    left++\n  }\n  if (left !== a.length || left !== b.length) {\n    // Only check right if a !== b\n    while (right + left < a.length && right + left < b.length && compare(a[a.length - right - 1], b[b.length - right - 1])) {\n      right++\n    }\n  }\n  return {\n    index: left,\n    remove: a.length - left - right,\n    insert: b.slice(left, b.length - right)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlmZi5qcz81MzA1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQSxjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLG1CQUFtQjtBQUMvQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLHVCQUF1QjtBQUNsQyxZQUFZLHFCQUFxQjtBQUNqQztBQUNPLHlDQUF5Qyx3REFBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlmZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRWZmaWNpZW50IGRpZmZzLlxuICpcbiAqIEBtb2R1bGUgZGlmZlxuICovXG5cbmltcG9ydCB7IGVxdWFsaXR5U3RyaWN0IH0gZnJvbSAnLi9mdW5jdGlvbi5qcydcblxuLyoqXG4gKiBBIFNpbXBsZURpZmYgZGVzY3JpYmVzIGEgY2hhbmdlIG9uIGEgU3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zb2xlLmxvZyhhKSAvLyB0aGUgb2xkIHZhbHVlXG4gKiBjb25zb2xlLmxvZyhiKSAvLyB0aGUgdXBkYXRlZCB2YWx1ZVxuICogLy8gQXBwbHkgY2hhbmdlcyBvZiBkaWZmIChwc2V1ZG9jb2RlKVxuICogYS5yZW1vdmUoZGlmZi5pbmRleCwgZGlmZi5yZW1vdmUpIC8vIFJlbW92ZSBgZGlmZi5yZW1vdmVgIGNoYXJhY3RlcnNcbiAqIGEuaW5zZXJ0KGRpZmYuaW5kZXgsIGRpZmYuaW5zZXJ0KSAvLyBJbnNlcnQgYGRpZmYuaW5zZXJ0YFxuICogYSA9PT0gYiAvLyB2YWx1ZXMgbWF0Y2hcbiAqIGBgYFxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNpbXBsZURpZmZcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggd2hlcmUgY2hhbmdlcyB3ZXJlIGFwcGxpZWRcbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZW1vdmUgVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZSBzdGFydGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXQgYGluZGV4YC5cbiAqIEBwcm9wZXJ0eSB7VH0gaW5zZXJ0IFRoZSBuZXcgdGV4dCB0byBpbnNlcnQgYXQgYGluZGV4YCBhZnRlciBhcHBseWluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBgZGVsZXRlYFxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBkaWZmIGJldHdlZW4gdHdvIHN0cmluZ3MuIFRoaXMgZGlmZiBpbXBsZW1lbnRhdGlvbiBpcyBoaWdobHlcbiAqIGVmZmljaWVudCwgYnV0IG5vdCB2ZXJ5IHNvcGhpc3RpY2F0ZWQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGEgVGhlIG9sZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBiIFRoZSB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIHN0cmluZ1xuICogQHJldHVybiB7U2ltcGxlRGlmZjxzdHJpbmc+fSBUaGUgZGlmZiBkZXNjcmlwdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHNpbXBsZURpZmZTdHJpbmcgPSAoYSwgYikgPT4ge1xuICBsZXQgbGVmdCA9IDAgLy8gbnVtYmVyIG9mIHNhbWUgY2hhcmFjdGVycyBjb3VudGluZyBmcm9tIGxlZnRcbiAgbGV0IHJpZ2h0ID0gMCAvLyBudW1iZXIgb2Ygc2FtZSBjaGFyYWN0ZXJzIGNvdW50aW5nIGZyb20gcmlnaHRcbiAgd2hpbGUgKGxlZnQgPCBhLmxlbmd0aCAmJiBsZWZ0IDwgYi5sZW5ndGggJiYgYVtsZWZ0XSA9PT0gYltsZWZ0XSkge1xuICAgIGxlZnQrK1xuICB9XG4gIGlmIChsZWZ0ICE9PSBhLmxlbmd0aCB8fCBsZWZ0ICE9PSBiLmxlbmd0aCkge1xuICAgIC8vIE9ubHkgY2hlY2sgcmlnaHQgaWYgYSAhPT0gYlxuICAgIHdoaWxlIChyaWdodCArIGxlZnQgPCBhLmxlbmd0aCAmJiByaWdodCArIGxlZnQgPCBiLmxlbmd0aCAmJiBhW2EubGVuZ3RoIC0gcmlnaHQgLSAxXSA9PT0gYltiLmxlbmd0aCAtIHJpZ2h0IC0gMV0pIHtcbiAgICAgIHJpZ2h0KytcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbmRleDogbGVmdCxcbiAgICByZW1vdmU6IGEubGVuZ3RoIC0gbGVmdCAtIHJpZ2h0LFxuICAgIGluc2VydDogYi5zbGljZShsZWZ0LCBiLmxlbmd0aCAtIHJpZ2h0KVxuICB9XG59XG5cbi8qKlxuICogQHRvZG8gUmVtb3ZlIGluIGZhdm9yIG9mIHNpbXBsZURpZmZTdHJpbmdcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaW1wbGVEaWZmID0gc2ltcGxlRGlmZlN0cmluZ1xuXG4vKipcbiAqIENyZWF0ZSBhIGRpZmYgYmV0d2VlbiB0d28gYXJyYXlzLiBUaGlzIGRpZmYgaW1wbGVtZW50YXRpb24gaXMgaGlnaGx5XG4gKiBlZmZpY2llbnQsIGJ1dCBub3QgdmVyeSBzb3BoaXN0aWNhdGVkLlxuICpcbiAqIE5vdGU6IFRoaXMgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGZ1bmN0aW9uIGFzIGFib3ZlLiBBbm90aGVyIGZ1bmN0aW9uIHdhcyBjcmVhdGVkIHNvIHRoYXQgdGhlIHJ1bnRpbWVcbiAqIGNhbiBiZXR0ZXIgb3B0aW1pemUgdGhlc2UgZnVuY3Rpb24gY2FsbHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD59IGEgVGhlIG9sZCB2ZXJzaW9uIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtBcnJheTxUPn0gYiBUaGUgdXBkYXRlZCB2ZXJzaW9uIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtmdW5jdGlvbihULCBUKTpib29sZWFufSBbY29tcGFyZV1cbiAqIEByZXR1cm4ge1NpbXBsZURpZmY8QXJyYXk8VD4+fSBUaGUgZGlmZiBkZXNjcmlwdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHNpbXBsZURpZmZBcnJheSA9IChhLCBiLCBjb21wYXJlID0gZXF1YWxpdHlTdHJpY3QpID0+IHtcbiAgbGV0IGxlZnQgPSAwIC8vIG51bWJlciBvZiBzYW1lIGNoYXJhY3RlcnMgY291bnRpbmcgZnJvbSBsZWZ0XG4gIGxldCByaWdodCA9IDAgLy8gbnVtYmVyIG9mIHNhbWUgY2hhcmFjdGVycyBjb3VudGluZyBmcm9tIHJpZ2h0XG4gIHdoaWxlIChsZWZ0IDwgYS5sZW5ndGggJiYgbGVmdCA8IGIubGVuZ3RoICYmIGNvbXBhcmUoYVtsZWZ0XSwgYltsZWZ0XSkpIHtcbiAgICBsZWZ0KytcbiAgfVxuICBpZiAobGVmdCAhPT0gYS5sZW5ndGggfHwgbGVmdCAhPT0gYi5sZW5ndGgpIHtcbiAgICAvLyBPbmx5IGNoZWNrIHJpZ2h0IGlmIGEgIT09IGJcbiAgICB3aGlsZSAocmlnaHQgKyBsZWZ0IDwgYS5sZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYi5sZW5ndGggJiYgY29tcGFyZShhW2EubGVuZ3RoIC0gcmlnaHQgLSAxXSwgYltiLmxlbmd0aCAtIHJpZ2h0IC0gMV0pKSB7XG4gICAgICByaWdodCsrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGxlZnQsXG4gICAgcmVtb3ZlOiBhLmxlbmd0aCAtIGxlZnQgLSByaWdodCxcbiAgICBpbnNlcnQ6IGIuc2xpY2UobGVmdCwgYi5sZW5ndGggLSByaWdodClcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/diff.js\n')},"./node_modules/lib0/dist/array-b2d24238.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1];\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([]);\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice());\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i]);\n  }\n};\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from;\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nconst every = (arr, f) => arr.every(f);\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nconst some = (arr, f) => arr.some(f);\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index]);\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => arr.reduce((acc, val) => acc.concat(val), []);\n\nvar array = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  last: last,\n  create: create,\n  copy: copy,\n  appendTo: appendTo,\n  from: from,\n  every: every,\n  some: some,\n  equalFlat: equalFlat,\n  flatten: flatten\n});\n\nexports.appendTo = appendTo;\nexports.array = array;\nexports.copy = copy;\nexports.create = create;\nexports.equalFlat = equalFlat;\nexports.every = every;\nexports.flatten = flatten;\nexports.from = from;\nexports.last = last;\nexports.some = some;\n//# sourceMappingURL=array-b2d24238.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9hcnJheS1iMmQyNDIzOC5janM/YTY5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxnQ0FBZ0MsU0FBUzs7QUFFekM7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQSw2QkFBNkIsU0FBUzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEMsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsNENBQTRDO0FBQ3ZELFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQ0FBc0M7QUFDakQsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixZQUFZO0FBQ1osY0FBYztBQUNkLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsZUFBZTtBQUNmLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9hcnJheS1iMmQyNDIzOC5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEFycmF5cy5cbiAqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gVGhlIGVsZW1lbnQgbXVzdCBleGlzdFxuICpcbiAqIEB0ZW1wbGF0ZSBMXG4gKiBAcGFyYW0ge0FycmF5PEw+fSBhcnJcbiAqIEByZXR1cm4ge0x9XG4gKi9cbmNvbnN0IGxhc3QgPSBhcnIgPT4gYXJyW2Fyci5sZW5ndGggLSAxXTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgQ1xuICogQHJldHVybiB7QXJyYXk8Qz59XG4gKi9cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8Qz59ICovIChbXSk7XG5cbi8qKlxuICogQHRlbXBsYXRlIERcbiAqIEBwYXJhbSB7QXJyYXk8RD59IGFcbiAqIEByZXR1cm4ge0FycmF5PEQ+fVxuICovXG5jb25zdCBjb3B5ID0gYSA9PiAvKiogQHR5cGUge0FycmF5PEQ+fSAqLyAoYS5zbGljZSgpKTtcblxuLyoqXG4gKiBBcHBlbmQgZWxlbWVudHMgZnJvbSBzcmMgdG8gZGVzdFxuICpcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5PE0+fSBkZXN0XG4gKiBAcGFyYW0ge0FycmF5PE0+fSBzcmNcbiAqL1xuY29uc3QgYXBwZW5kVG8gPSAoZGVzdCwgc3JjKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdC5wdXNoKHNyY1tpXSk7XG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBzb21ldGhpbmcgYXJyYXktbGlrZSB0byBhbiBhY3R1YWwgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheUxpa2U8VD58SXRlcmFibGU8VD59IGFycmF5bGlrZVxuICogQHJldHVybiB7VH1cbiAqL1xuY29uc3QgZnJvbSA9IEFycmF5LmZyb207XG5cbi8qKlxuICogVHJ1ZSBpZmYgY29uZGl0aW9uIGhvbGRzIG9uIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIElURU1cbiAqXG4gKiBAcGFyYW0ge0FycmF5PElURU0+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSVRFTSwgbnVtYmVyLCBBcnJheTxJVEVNPik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXZlcnkgPSAoYXJyLCBmKSA9PiBhcnIuZXZlcnkoZik7XG5cbi8qKlxuICogVHJ1ZSBpZmYgY29uZGl0aW9uIGhvbGRzIG9uIHNvbWUgZWxlbWVudCBpbiB0aGUgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgU1xuICogQHBhcmFtIHtBcnJheTxTPn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFMsIG51bWJlciwgQXJyYXk8Uz4pOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IHNvbWUgPSAoYXJyLCBmKSA9PiBhcnIuc29tZShmKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgRUxFTVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RUxFTT59IGFcbiAqIEBwYXJhbSB7QXJyYXk8RUxFTT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsRmxhdCA9IChhLCBiKSA9PiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgZXZlcnkoYSwgKGl0ZW0sIGluZGV4KSA9PiBpdGVtID09PSBiW2luZGV4XSk7XG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RUxFTT4+fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5PEVMRU0+fVxuICovXG5jb25zdCBmbGF0dGVuID0gYXJyID0+IGFyci5yZWR1Y2UoKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCksIFtdKTtcblxudmFyIGFycmF5ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGxhc3Q6IGxhc3QsXG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjb3B5OiBjb3B5LFxuICBhcHBlbmRUbzogYXBwZW5kVG8sXG4gIGZyb206IGZyb20sXG4gIGV2ZXJ5OiBldmVyeSxcbiAgc29tZTogc29tZSxcbiAgZXF1YWxGbGF0OiBlcXVhbEZsYXQsXG4gIGZsYXR0ZW46IGZsYXR0ZW5cbn0pO1xuXG5leHBvcnRzLmFwcGVuZFRvID0gYXBwZW5kVG87XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmVxdWFsRmxhdCA9IGVxdWFsRmxhdDtcbmV4cG9ydHMuZXZlcnkgPSBldmVyeTtcbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5sYXN0ID0gbGFzdDtcbmV4cG9ydHMuc29tZSA9IHNvbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1iMmQyNDIzOC5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/array-b2d24238.cjs\n")},"./node_modules/lib0/dist/array.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar array = __webpack_require__(/*! ./array-b2d24238.cjs */ "./node_modules/lib0/dist/array-b2d24238.cjs");\n\n\n\nexports.appendTo = array.appendTo;\nexports.copy = array.copy;\nexports.create = array.create;\nexports.equalFlat = array.equalFlat;\nexports.every = array.every;\nexports.flatten = array.flatten;\nexports.from = array.from;\nexports.last = array.last;\nexports.some = array.some;\n//# sourceMappingURL=array.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9hcnJheS5janM/Mjk3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyx5RUFBc0I7Ozs7QUFJMUMsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixlQUFlO0FBQ2YsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1oiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2FycmF5LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGFycmF5ID0gcmVxdWlyZSgnLi9hcnJheS1iMmQyNDIzOC5janMnKTtcblxuXG5cbmV4cG9ydHMuYXBwZW5kVG8gPSBhcnJheS5hcHBlbmRUbztcbmV4cG9ydHMuY29weSA9IGFycmF5LmNvcHk7XG5leHBvcnRzLmNyZWF0ZSA9IGFycmF5LmNyZWF0ZTtcbmV4cG9ydHMuZXF1YWxGbGF0ID0gYXJyYXkuZXF1YWxGbGF0O1xuZXhwb3J0cy5ldmVyeSA9IGFycmF5LmV2ZXJ5O1xuZXhwb3J0cy5mbGF0dGVuID0gYXJyYXkuZmxhdHRlbjtcbmV4cG9ydHMuZnJvbSA9IGFycmF5LmZyb207XG5leHBvcnRzLmxhc3QgPSBhcnJheS5sYXN0O1xuZXhwb3J0cy5zb21lID0gYXJyYXkuc29tZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/array.cjs\n')},"./node_modules/lib0/dist/binary-ac8e39e2.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1;\nconst BIT2 = 2;\nconst BIT3 = 4;\nconst BIT4 = 8;\nconst BIT5 = 16;\nconst BIT6 = 32;\nconst BIT7 = 64;\nconst BIT8 = 128;\nconst BIT9 = 256;\nconst BIT10 = 512;\nconst BIT11 = 1024;\nconst BIT12 = 2048;\nconst BIT13 = 4096;\nconst BIT14 = 8192;\nconst BIT15 = 16384;\nconst BIT16 = 32768;\nconst BIT17 = 65536;\nconst BIT18 = 1 << 17;\nconst BIT19 = 1 << 18;\nconst BIT20 = 1 << 19;\nconst BIT21 = 1 << 20;\nconst BIT22 = 1 << 21;\nconst BIT23 = 1 << 22;\nconst BIT24 = 1 << 23;\nconst BIT25 = 1 << 24;\nconst BIT26 = 1 << 25;\nconst BIT27 = 1 << 26;\nconst BIT28 = 1 << 27;\nconst BIT29 = 1 << 28;\nconst BIT30 = 1 << 29;\nconst BIT31 = 1 << 30;\nconst BIT32 = 1 << 31;\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0;\nconst BITS1 = 1;\nconst BITS2 = 3;\nconst BITS3 = 7;\nconst BITS4 = 15;\nconst BITS5 = 31;\nconst BITS6 = 63;\nconst BITS7 = 127;\nconst BITS8 = 255;\nconst BITS9 = 511;\nconst BITS10 = 1023;\nconst BITS11 = 2047;\nconst BITS12 = 4095;\nconst BITS13 = 8191;\nconst BITS14 = 16383;\nconst BITS15 = 32767;\nconst BITS16 = 65535;\nconst BITS17 = BIT18 - 1;\nconst BITS18 = BIT19 - 1;\nconst BITS19 = BIT20 - 1;\nconst BITS20 = BIT21 - 1;\nconst BITS21 = BIT22 - 1;\nconst BITS22 = BIT23 - 1;\nconst BITS23 = BIT24 - 1;\nconst BITS24 = BIT25 - 1;\nconst BITS25 = BIT26 - 1;\nconst BITS26 = BIT27 - 1;\nconst BITS27 = BIT28 - 1;\nconst BITS28 = BIT29 - 1;\nconst BITS29 = BIT30 - 1;\nconst BITS30 = BIT31 - 1;\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF;\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF;\n\nvar binary = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBIT1: BIT1,\n\tBIT2: BIT2,\n\tBIT3: BIT3,\n\tBIT4: BIT4,\n\tBIT5: BIT5,\n\tBIT6: BIT6,\n\tBIT7: BIT7,\n\tBIT8: BIT8,\n\tBIT9: BIT9,\n\tBIT10: BIT10,\n\tBIT11: BIT11,\n\tBIT12: BIT12,\n\tBIT13: BIT13,\n\tBIT14: BIT14,\n\tBIT15: BIT15,\n\tBIT16: BIT16,\n\tBIT17: BIT17,\n\tBIT18: BIT18,\n\tBIT19: BIT19,\n\tBIT20: BIT20,\n\tBIT21: BIT21,\n\tBIT22: BIT22,\n\tBIT23: BIT23,\n\tBIT24: BIT24,\n\tBIT25: BIT25,\n\tBIT26: BIT26,\n\tBIT27: BIT27,\n\tBIT28: BIT28,\n\tBIT29: BIT29,\n\tBIT30: BIT30,\n\tBIT31: BIT31,\n\tBIT32: BIT32,\n\tBITS0: BITS0,\n\tBITS1: BITS1,\n\tBITS2: BITS2,\n\tBITS3: BITS3,\n\tBITS4: BITS4,\n\tBITS5: BITS5,\n\tBITS6: BITS6,\n\tBITS7: BITS7,\n\tBITS8: BITS8,\n\tBITS9: BITS9,\n\tBITS10: BITS10,\n\tBITS11: BITS11,\n\tBITS12: BITS12,\n\tBITS13: BITS13,\n\tBITS14: BITS14,\n\tBITS15: BITS15,\n\tBITS16: BITS16,\n\tBITS17: BITS17,\n\tBITS18: BITS18,\n\tBITS19: BITS19,\n\tBITS20: BITS20,\n\tBITS21: BITS21,\n\tBITS22: BITS22,\n\tBITS23: BITS23,\n\tBITS24: BITS24,\n\tBITS25: BITS25,\n\tBITS26: BITS26,\n\tBITS27: BITS27,\n\tBITS28: BITS28,\n\tBITS29: BITS29,\n\tBITS30: BITS30,\n\tBITS31: BITS31,\n\tBITS32: BITS32\n});\n\nexports.BIT1 = BIT1;\nexports.BIT10 = BIT10;\nexports.BIT11 = BIT11;\nexports.BIT12 = BIT12;\nexports.BIT13 = BIT13;\nexports.BIT14 = BIT14;\nexports.BIT15 = BIT15;\nexports.BIT16 = BIT16;\nexports.BIT17 = BIT17;\nexports.BIT18 = BIT18;\nexports.BIT19 = BIT19;\nexports.BIT2 = BIT2;\nexports.BIT20 = BIT20;\nexports.BIT21 = BIT21;\nexports.BIT22 = BIT22;\nexports.BIT23 = BIT23;\nexports.BIT24 = BIT24;\nexports.BIT25 = BIT25;\nexports.BIT26 = BIT26;\nexports.BIT27 = BIT27;\nexports.BIT28 = BIT28;\nexports.BIT29 = BIT29;\nexports.BIT3 = BIT3;\nexports.BIT30 = BIT30;\nexports.BIT31 = BIT31;\nexports.BIT32 = BIT32;\nexports.BIT4 = BIT4;\nexports.BIT5 = BIT5;\nexports.BIT6 = BIT6;\nexports.BIT7 = BIT7;\nexports.BIT8 = BIT8;\nexports.BIT9 = BIT9;\nexports.BITS0 = BITS0;\nexports.BITS1 = BITS1;\nexports.BITS10 = BITS10;\nexports.BITS11 = BITS11;\nexports.BITS12 = BITS12;\nexports.BITS13 = BITS13;\nexports.BITS14 = BITS14;\nexports.BITS15 = BITS15;\nexports.BITS16 = BITS16;\nexports.BITS17 = BITS17;\nexports.BITS18 = BITS18;\nexports.BITS19 = BITS19;\nexports.BITS2 = BITS2;\nexports.BITS20 = BITS20;\nexports.BITS21 = BITS21;\nexports.BITS22 = BITS22;\nexports.BITS23 = BITS23;\nexports.BITS24 = BITS24;\nexports.BITS25 = BITS25;\nexports.BITS26 = BITS26;\nexports.BITS27 = BITS27;\nexports.BITS28 = BITS28;\nexports.BITS29 = BITS29;\nexports.BITS3 = BITS3;\nexports.BITS30 = BITS30;\nexports.BITS31 = BITS31;\nexports.BITS32 = BITS32;\nexports.BITS4 = BITS4;\nexports.BITS5 = BITS5;\nexports.BITS6 = BITS6;\nexports.BITS7 = BITS7;\nexports.BITS8 = BITS8;\nexports.BITS9 = BITS9;\nexports.binary = binary;\n//# sourceMappingURL=binary-ac8e39e2.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9iaW5hcnktYWM4ZTM5ZTIuY2pzPzU3NTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELFlBQVk7QUFDWixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixZQUFZO0FBQ1osYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osYUFBYTtBQUNiLGFBQWE7QUFDYixjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsYUFBYTtBQUNiLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2IsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsY0FBYztBQUNkIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9iaW5hcnktYWM4ZTM5ZTIuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBCaW5hcnkgZGF0YSBjb25zdGFudHMuXG4gKlxuICogQG1vZHVsZSBiaW5hcnlcbiAqL1xuXG4vKipcbiAqIG4tdGggYml0IGFjdGl2YXRlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBCSVQxID0gMTtcbmNvbnN0IEJJVDIgPSAyO1xuY29uc3QgQklUMyA9IDQ7XG5jb25zdCBCSVQ0ID0gODtcbmNvbnN0IEJJVDUgPSAxNjtcbmNvbnN0IEJJVDYgPSAzMjtcbmNvbnN0IEJJVDcgPSA2NDtcbmNvbnN0IEJJVDggPSAxMjg7XG5jb25zdCBCSVQ5ID0gMjU2O1xuY29uc3QgQklUMTAgPSA1MTI7XG5jb25zdCBCSVQxMSA9IDEwMjQ7XG5jb25zdCBCSVQxMiA9IDIwNDg7XG5jb25zdCBCSVQxMyA9IDQwOTY7XG5jb25zdCBCSVQxNCA9IDgxOTI7XG5jb25zdCBCSVQxNSA9IDE2Mzg0O1xuY29uc3QgQklUMTYgPSAzMjc2ODtcbmNvbnN0IEJJVDE3ID0gNjU1MzY7XG5jb25zdCBCSVQxOCA9IDEgPDwgMTc7XG5jb25zdCBCSVQxOSA9IDEgPDwgMTg7XG5jb25zdCBCSVQyMCA9IDEgPDwgMTk7XG5jb25zdCBCSVQyMSA9IDEgPDwgMjA7XG5jb25zdCBCSVQyMiA9IDEgPDwgMjE7XG5jb25zdCBCSVQyMyA9IDEgPDwgMjI7XG5jb25zdCBCSVQyNCA9IDEgPDwgMjM7XG5jb25zdCBCSVQyNSA9IDEgPDwgMjQ7XG5jb25zdCBCSVQyNiA9IDEgPDwgMjU7XG5jb25zdCBCSVQyNyA9IDEgPDwgMjY7XG5jb25zdCBCSVQyOCA9IDEgPDwgMjc7XG5jb25zdCBCSVQyOSA9IDEgPDwgMjg7XG5jb25zdCBCSVQzMCA9IDEgPDwgMjk7XG5jb25zdCBCSVQzMSA9IDEgPDwgMzA7XG5jb25zdCBCSVQzMiA9IDEgPDwgMzE7XG5cbi8qKlxuICogRmlyc3QgbiBiaXRzIGFjdGl2YXRlZC5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBCSVRTMCA9IDA7XG5jb25zdCBCSVRTMSA9IDE7XG5jb25zdCBCSVRTMiA9IDM7XG5jb25zdCBCSVRTMyA9IDc7XG5jb25zdCBCSVRTNCA9IDE1O1xuY29uc3QgQklUUzUgPSAzMTtcbmNvbnN0IEJJVFM2ID0gNjM7XG5jb25zdCBCSVRTNyA9IDEyNztcbmNvbnN0IEJJVFM4ID0gMjU1O1xuY29uc3QgQklUUzkgPSA1MTE7XG5jb25zdCBCSVRTMTAgPSAxMDIzO1xuY29uc3QgQklUUzExID0gMjA0NztcbmNvbnN0IEJJVFMxMiA9IDQwOTU7XG5jb25zdCBCSVRTMTMgPSA4MTkxO1xuY29uc3QgQklUUzE0ID0gMTYzODM7XG5jb25zdCBCSVRTMTUgPSAzMjc2NztcbmNvbnN0IEJJVFMxNiA9IDY1NTM1O1xuY29uc3QgQklUUzE3ID0gQklUMTggLSAxO1xuY29uc3QgQklUUzE4ID0gQklUMTkgLSAxO1xuY29uc3QgQklUUzE5ID0gQklUMjAgLSAxO1xuY29uc3QgQklUUzIwID0gQklUMjEgLSAxO1xuY29uc3QgQklUUzIxID0gQklUMjIgLSAxO1xuY29uc3QgQklUUzIyID0gQklUMjMgLSAxO1xuY29uc3QgQklUUzIzID0gQklUMjQgLSAxO1xuY29uc3QgQklUUzI0ID0gQklUMjUgLSAxO1xuY29uc3QgQklUUzI1ID0gQklUMjYgLSAxO1xuY29uc3QgQklUUzI2ID0gQklUMjcgLSAxO1xuY29uc3QgQklUUzI3ID0gQklUMjggLSAxO1xuY29uc3QgQklUUzI4ID0gQklUMjkgLSAxO1xuY29uc3QgQklUUzI5ID0gQklUMzAgLSAxO1xuY29uc3QgQklUUzMwID0gQklUMzEgLSAxO1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBCSVRTMzEgPSAweDdGRkZGRkZGO1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBCSVRTMzIgPSAweEZGRkZGRkZGO1xuXG52YXIgYmluYXJ5ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdEJJVDE6IEJJVDEsXG5cdEJJVDI6IEJJVDIsXG5cdEJJVDM6IEJJVDMsXG5cdEJJVDQ6IEJJVDQsXG5cdEJJVDU6IEJJVDUsXG5cdEJJVDY6IEJJVDYsXG5cdEJJVDc6IEJJVDcsXG5cdEJJVDg6IEJJVDgsXG5cdEJJVDk6IEJJVDksXG5cdEJJVDEwOiBCSVQxMCxcblx0QklUMTE6IEJJVDExLFxuXHRCSVQxMjogQklUMTIsXG5cdEJJVDEzOiBCSVQxMyxcblx0QklUMTQ6IEJJVDE0LFxuXHRCSVQxNTogQklUMTUsXG5cdEJJVDE2OiBCSVQxNixcblx0QklUMTc6IEJJVDE3LFxuXHRCSVQxODogQklUMTgsXG5cdEJJVDE5OiBCSVQxOSxcblx0QklUMjA6IEJJVDIwLFxuXHRCSVQyMTogQklUMjEsXG5cdEJJVDIyOiBCSVQyMixcblx0QklUMjM6IEJJVDIzLFxuXHRCSVQyNDogQklUMjQsXG5cdEJJVDI1OiBCSVQyNSxcblx0QklUMjY6IEJJVDI2LFxuXHRCSVQyNzogQklUMjcsXG5cdEJJVDI4OiBCSVQyOCxcblx0QklUMjk6IEJJVDI5LFxuXHRCSVQzMDogQklUMzAsXG5cdEJJVDMxOiBCSVQzMSxcblx0QklUMzI6IEJJVDMyLFxuXHRCSVRTMDogQklUUzAsXG5cdEJJVFMxOiBCSVRTMSxcblx0QklUUzI6IEJJVFMyLFxuXHRCSVRTMzogQklUUzMsXG5cdEJJVFM0OiBCSVRTNCxcblx0QklUUzU6IEJJVFM1LFxuXHRCSVRTNjogQklUUzYsXG5cdEJJVFM3OiBCSVRTNyxcblx0QklUUzg6IEJJVFM4LFxuXHRCSVRTOTogQklUUzksXG5cdEJJVFMxMDogQklUUzEwLFxuXHRCSVRTMTE6IEJJVFMxMSxcblx0QklUUzEyOiBCSVRTMTIsXG5cdEJJVFMxMzogQklUUzEzLFxuXHRCSVRTMTQ6IEJJVFMxNCxcblx0QklUUzE1OiBCSVRTMTUsXG5cdEJJVFMxNjogQklUUzE2LFxuXHRCSVRTMTc6IEJJVFMxNyxcblx0QklUUzE4OiBCSVRTMTgsXG5cdEJJVFMxOTogQklUUzE5LFxuXHRCSVRTMjA6IEJJVFMyMCxcblx0QklUUzIxOiBCSVRTMjEsXG5cdEJJVFMyMjogQklUUzIyLFxuXHRCSVRTMjM6IEJJVFMyMyxcblx0QklUUzI0OiBCSVRTMjQsXG5cdEJJVFMyNTogQklUUzI1LFxuXHRCSVRTMjY6IEJJVFMyNixcblx0QklUUzI3OiBCSVRTMjcsXG5cdEJJVFMyODogQklUUzI4LFxuXHRCSVRTMjk6IEJJVFMyOSxcblx0QklUUzMwOiBCSVRTMzAsXG5cdEJJVFMzMTogQklUUzMxLFxuXHRCSVRTMzI6IEJJVFMzMlxufSk7XG5cbmV4cG9ydHMuQklUMSA9IEJJVDE7XG5leHBvcnRzLkJJVDEwID0gQklUMTA7XG5leHBvcnRzLkJJVDExID0gQklUMTE7XG5leHBvcnRzLkJJVDEyID0gQklUMTI7XG5leHBvcnRzLkJJVDEzID0gQklUMTM7XG5leHBvcnRzLkJJVDE0ID0gQklUMTQ7XG5leHBvcnRzLkJJVDE1ID0gQklUMTU7XG5leHBvcnRzLkJJVDE2ID0gQklUMTY7XG5leHBvcnRzLkJJVDE3ID0gQklUMTc7XG5leHBvcnRzLkJJVDE4ID0gQklUMTg7XG5leHBvcnRzLkJJVDE5ID0gQklUMTk7XG5leHBvcnRzLkJJVDIgPSBCSVQyO1xuZXhwb3J0cy5CSVQyMCA9IEJJVDIwO1xuZXhwb3J0cy5CSVQyMSA9IEJJVDIxO1xuZXhwb3J0cy5CSVQyMiA9IEJJVDIyO1xuZXhwb3J0cy5CSVQyMyA9IEJJVDIzO1xuZXhwb3J0cy5CSVQyNCA9IEJJVDI0O1xuZXhwb3J0cy5CSVQyNSA9IEJJVDI1O1xuZXhwb3J0cy5CSVQyNiA9IEJJVDI2O1xuZXhwb3J0cy5CSVQyNyA9IEJJVDI3O1xuZXhwb3J0cy5CSVQyOCA9IEJJVDI4O1xuZXhwb3J0cy5CSVQyOSA9IEJJVDI5O1xuZXhwb3J0cy5CSVQzID0gQklUMztcbmV4cG9ydHMuQklUMzAgPSBCSVQzMDtcbmV4cG9ydHMuQklUMzEgPSBCSVQzMTtcbmV4cG9ydHMuQklUMzIgPSBCSVQzMjtcbmV4cG9ydHMuQklUNCA9IEJJVDQ7XG5leHBvcnRzLkJJVDUgPSBCSVQ1O1xuZXhwb3J0cy5CSVQ2ID0gQklUNjtcbmV4cG9ydHMuQklUNyA9IEJJVDc7XG5leHBvcnRzLkJJVDggPSBCSVQ4O1xuZXhwb3J0cy5CSVQ5ID0gQklUOTtcbmV4cG9ydHMuQklUUzAgPSBCSVRTMDtcbmV4cG9ydHMuQklUUzEgPSBCSVRTMTtcbmV4cG9ydHMuQklUUzEwID0gQklUUzEwO1xuZXhwb3J0cy5CSVRTMTEgPSBCSVRTMTE7XG5leHBvcnRzLkJJVFMxMiA9IEJJVFMxMjtcbmV4cG9ydHMuQklUUzEzID0gQklUUzEzO1xuZXhwb3J0cy5CSVRTMTQgPSBCSVRTMTQ7XG5leHBvcnRzLkJJVFMxNSA9IEJJVFMxNTtcbmV4cG9ydHMuQklUUzE2ID0gQklUUzE2O1xuZXhwb3J0cy5CSVRTMTcgPSBCSVRTMTc7XG5leHBvcnRzLkJJVFMxOCA9IEJJVFMxODtcbmV4cG9ydHMuQklUUzE5ID0gQklUUzE5O1xuZXhwb3J0cy5CSVRTMiA9IEJJVFMyO1xuZXhwb3J0cy5CSVRTMjAgPSBCSVRTMjA7XG5leHBvcnRzLkJJVFMyMSA9IEJJVFMyMTtcbmV4cG9ydHMuQklUUzIyID0gQklUUzIyO1xuZXhwb3J0cy5CSVRTMjMgPSBCSVRTMjM7XG5leHBvcnRzLkJJVFMyNCA9IEJJVFMyNDtcbmV4cG9ydHMuQklUUzI1ID0gQklUUzI1O1xuZXhwb3J0cy5CSVRTMjYgPSBCSVRTMjY7XG5leHBvcnRzLkJJVFMyNyA9IEJJVFMyNztcbmV4cG9ydHMuQklUUzI4ID0gQklUUzI4O1xuZXhwb3J0cy5CSVRTMjkgPSBCSVRTMjk7XG5leHBvcnRzLkJJVFMzID0gQklUUzM7XG5leHBvcnRzLkJJVFMzMCA9IEJJVFMzMDtcbmV4cG9ydHMuQklUUzMxID0gQklUUzMxO1xuZXhwb3J0cy5CSVRTMzIgPSBCSVRTMzI7XG5leHBvcnRzLkJJVFM0ID0gQklUUzQ7XG5leHBvcnRzLkJJVFM1ID0gQklUUzU7XG5leHBvcnRzLkJJVFM2ID0gQklUUzY7XG5leHBvcnRzLkJJVFM3ID0gQklUUzc7XG5leHBvcnRzLkJJVFM4ID0gQklUUzg7XG5leHBvcnRzLkJJVFM5ID0gQklUUzk7XG5leHBvcnRzLmJpbmFyeSA9IGJpbmFyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeS1hYzhlMzllMi5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/binary-ac8e39e2.cjs\n")},"./node_modules/lib0/dist/binary.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar binary = __webpack_require__(/*! ./binary-ac8e39e2.cjs */ "./node_modules/lib0/dist/binary-ac8e39e2.cjs");\n\n\n\nexports.BIT1 = binary.BIT1;\nexports.BIT10 = binary.BIT10;\nexports.BIT11 = binary.BIT11;\nexports.BIT12 = binary.BIT12;\nexports.BIT13 = binary.BIT13;\nexports.BIT14 = binary.BIT14;\nexports.BIT15 = binary.BIT15;\nexports.BIT16 = binary.BIT16;\nexports.BIT17 = binary.BIT17;\nexports.BIT18 = binary.BIT18;\nexports.BIT19 = binary.BIT19;\nexports.BIT2 = binary.BIT2;\nexports.BIT20 = binary.BIT20;\nexports.BIT21 = binary.BIT21;\nexports.BIT22 = binary.BIT22;\nexports.BIT23 = binary.BIT23;\nexports.BIT24 = binary.BIT24;\nexports.BIT25 = binary.BIT25;\nexports.BIT26 = binary.BIT26;\nexports.BIT27 = binary.BIT27;\nexports.BIT28 = binary.BIT28;\nexports.BIT29 = binary.BIT29;\nexports.BIT3 = binary.BIT3;\nexports.BIT30 = binary.BIT30;\nexports.BIT31 = binary.BIT31;\nexports.BIT32 = binary.BIT32;\nexports.BIT4 = binary.BIT4;\nexports.BIT5 = binary.BIT5;\nexports.BIT6 = binary.BIT6;\nexports.BIT7 = binary.BIT7;\nexports.BIT8 = binary.BIT8;\nexports.BIT9 = binary.BIT9;\nexports.BITS0 = binary.BITS0;\nexports.BITS1 = binary.BITS1;\nexports.BITS10 = binary.BITS10;\nexports.BITS11 = binary.BITS11;\nexports.BITS12 = binary.BITS12;\nexports.BITS13 = binary.BITS13;\nexports.BITS14 = binary.BITS14;\nexports.BITS15 = binary.BITS15;\nexports.BITS16 = binary.BITS16;\nexports.BITS17 = binary.BITS17;\nexports.BITS18 = binary.BITS18;\nexports.BITS19 = binary.BITS19;\nexports.BITS2 = binary.BITS2;\nexports.BITS20 = binary.BITS20;\nexports.BITS21 = binary.BITS21;\nexports.BITS22 = binary.BITS22;\nexports.BITS23 = binary.BITS23;\nexports.BITS24 = binary.BITS24;\nexports.BITS25 = binary.BITS25;\nexports.BITS26 = binary.BITS26;\nexports.BITS27 = binary.BITS27;\nexports.BITS28 = binary.BITS28;\nexports.BITS29 = binary.BITS29;\nexports.BITS3 = binary.BITS3;\nexports.BITS30 = binary.BITS30;\nexports.BITS31 = binary.BITS31;\nexports.BITS32 = binary.BITS32;\nexports.BITS4 = binary.BITS4;\nexports.BITS5 = binary.BITS5;\nexports.BITS6 = binary.BITS6;\nexports.BITS7 = binary.BITS7;\nexports.BITS8 = binary.BITS8;\nexports.BITS9 = binary.BITS9;\n//# sourceMappingURL=binary.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9iaW5hcnkuY2pzPzE0ZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxhQUFhLG1CQUFPLENBQUMsMkVBQXVCOzs7O0FBSTVDLFlBQVk7QUFDWixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixZQUFZO0FBQ1osYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osYUFBYTtBQUNiLGFBQWE7QUFDYixjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsYUFBYTtBQUNiLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxhQUFhO0FBQ2IsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2JpbmFyeS5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeS1hYzhlMzllMi5janMnKTtcblxuXG5cbmV4cG9ydHMuQklUMSA9IGJpbmFyeS5CSVQxO1xuZXhwb3J0cy5CSVQxMCA9IGJpbmFyeS5CSVQxMDtcbmV4cG9ydHMuQklUMTEgPSBiaW5hcnkuQklUMTE7XG5leHBvcnRzLkJJVDEyID0gYmluYXJ5LkJJVDEyO1xuZXhwb3J0cy5CSVQxMyA9IGJpbmFyeS5CSVQxMztcbmV4cG9ydHMuQklUMTQgPSBiaW5hcnkuQklUMTQ7XG5leHBvcnRzLkJJVDE1ID0gYmluYXJ5LkJJVDE1O1xuZXhwb3J0cy5CSVQxNiA9IGJpbmFyeS5CSVQxNjtcbmV4cG9ydHMuQklUMTcgPSBiaW5hcnkuQklUMTc7XG5leHBvcnRzLkJJVDE4ID0gYmluYXJ5LkJJVDE4O1xuZXhwb3J0cy5CSVQxOSA9IGJpbmFyeS5CSVQxOTtcbmV4cG9ydHMuQklUMiA9IGJpbmFyeS5CSVQyO1xuZXhwb3J0cy5CSVQyMCA9IGJpbmFyeS5CSVQyMDtcbmV4cG9ydHMuQklUMjEgPSBiaW5hcnkuQklUMjE7XG5leHBvcnRzLkJJVDIyID0gYmluYXJ5LkJJVDIyO1xuZXhwb3J0cy5CSVQyMyA9IGJpbmFyeS5CSVQyMztcbmV4cG9ydHMuQklUMjQgPSBiaW5hcnkuQklUMjQ7XG5leHBvcnRzLkJJVDI1ID0gYmluYXJ5LkJJVDI1O1xuZXhwb3J0cy5CSVQyNiA9IGJpbmFyeS5CSVQyNjtcbmV4cG9ydHMuQklUMjcgPSBiaW5hcnkuQklUMjc7XG5leHBvcnRzLkJJVDI4ID0gYmluYXJ5LkJJVDI4O1xuZXhwb3J0cy5CSVQyOSA9IGJpbmFyeS5CSVQyOTtcbmV4cG9ydHMuQklUMyA9IGJpbmFyeS5CSVQzO1xuZXhwb3J0cy5CSVQzMCA9IGJpbmFyeS5CSVQzMDtcbmV4cG9ydHMuQklUMzEgPSBiaW5hcnkuQklUMzE7XG5leHBvcnRzLkJJVDMyID0gYmluYXJ5LkJJVDMyO1xuZXhwb3J0cy5CSVQ0ID0gYmluYXJ5LkJJVDQ7XG5leHBvcnRzLkJJVDUgPSBiaW5hcnkuQklUNTtcbmV4cG9ydHMuQklUNiA9IGJpbmFyeS5CSVQ2O1xuZXhwb3J0cy5CSVQ3ID0gYmluYXJ5LkJJVDc7XG5leHBvcnRzLkJJVDggPSBiaW5hcnkuQklUODtcbmV4cG9ydHMuQklUOSA9IGJpbmFyeS5CSVQ5O1xuZXhwb3J0cy5CSVRTMCA9IGJpbmFyeS5CSVRTMDtcbmV4cG9ydHMuQklUUzEgPSBiaW5hcnkuQklUUzE7XG5leHBvcnRzLkJJVFMxMCA9IGJpbmFyeS5CSVRTMTA7XG5leHBvcnRzLkJJVFMxMSA9IGJpbmFyeS5CSVRTMTE7XG5leHBvcnRzLkJJVFMxMiA9IGJpbmFyeS5CSVRTMTI7XG5leHBvcnRzLkJJVFMxMyA9IGJpbmFyeS5CSVRTMTM7XG5leHBvcnRzLkJJVFMxNCA9IGJpbmFyeS5CSVRTMTQ7XG5leHBvcnRzLkJJVFMxNSA9IGJpbmFyeS5CSVRTMTU7XG5leHBvcnRzLkJJVFMxNiA9IGJpbmFyeS5CSVRTMTY7XG5leHBvcnRzLkJJVFMxNyA9IGJpbmFyeS5CSVRTMTc7XG5leHBvcnRzLkJJVFMxOCA9IGJpbmFyeS5CSVRTMTg7XG5leHBvcnRzLkJJVFMxOSA9IGJpbmFyeS5CSVRTMTk7XG5leHBvcnRzLkJJVFMyID0gYmluYXJ5LkJJVFMyO1xuZXhwb3J0cy5CSVRTMjAgPSBiaW5hcnkuQklUUzIwO1xuZXhwb3J0cy5CSVRTMjEgPSBiaW5hcnkuQklUUzIxO1xuZXhwb3J0cy5CSVRTMjIgPSBiaW5hcnkuQklUUzIyO1xuZXhwb3J0cy5CSVRTMjMgPSBiaW5hcnkuQklUUzIzO1xuZXhwb3J0cy5CSVRTMjQgPSBiaW5hcnkuQklUUzI0O1xuZXhwb3J0cy5CSVRTMjUgPSBiaW5hcnkuQklUUzI1O1xuZXhwb3J0cy5CSVRTMjYgPSBiaW5hcnkuQklUUzI2O1xuZXhwb3J0cy5CSVRTMjcgPSBiaW5hcnkuQklUUzI3O1xuZXhwb3J0cy5CSVRTMjggPSBiaW5hcnkuQklUUzI4O1xuZXhwb3J0cy5CSVRTMjkgPSBiaW5hcnkuQklUUzI5O1xuZXhwb3J0cy5CSVRTMyA9IGJpbmFyeS5CSVRTMztcbmV4cG9ydHMuQklUUzMwID0gYmluYXJ5LkJJVFMzMDtcbmV4cG9ydHMuQklUUzMxID0gYmluYXJ5LkJJVFMzMTtcbmV4cG9ydHMuQklUUzMyID0gYmluYXJ5LkJJVFMzMjtcbmV4cG9ydHMuQklUUzQgPSBiaW5hcnkuQklUUzQ7XG5leHBvcnRzLkJJVFM1ID0gYmluYXJ5LkJJVFM1O1xuZXhwb3J0cy5CSVRTNiA9IGJpbmFyeS5CSVRTNjtcbmV4cG9ydHMuQklUUzcgPSBiaW5hcnkuQklUUzc7XG5leHBvcnRzLkJJVFM4ID0gYmluYXJ5LkJJVFM4O1xuZXhwb3J0cy5CSVRTOSA9IGJpbmFyeS5CSVRTOTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/binary.cjs\n')},"./node_modules/lib0/dist/buffer-ac2cdedf.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar string = __webpack_require__(/*! ./string-f3c3d805.cjs */ \"./node_modules/lib0/dist/string-f3c3d805.cjs\");\nvar environment = __webpack_require__(/*! ./environment-7e2ffaea.cjs */ \"./node_modules/lib0/dist/environment-7e2ffaea.cjs\");\nvar binary = __webpack_require__(/*! ./binary-ac8e39e2.cjs */ \"./node_modules/lib0/dist/binary-ac8e39e2.cjs\");\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ \"./node_modules/lib0/dist/math-08e068f9.cjs\");\nvar number = __webpack_require__(/*! ./number-24f1eabe.cjs */ \"./node_modules/lib0/dist/number-24f1eabe.cjs\");\n\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0;\n    this.cbuf = new Uint8Array(100);\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = [];\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder();\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length;\n  }\n  return len\n};\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder));\n  let curPos = 0;\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i];\n    uint8arr.set(d, curPos);\n    curPos += d.length;\n  }\n  uint8arr.set(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n  return uint8arr\n};\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length;\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2);\n    encoder.cpos = 0;\n  }\n};\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length;\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf);\n    encoder.cbuf = new Uint8Array(bufferLen * 2);\n    encoder.cpos = 0;\n  }\n  encoder.cbuf[encoder.cpos++] = num;\n};\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null;\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i];\n    if (pos < b.length) {\n      buffer = b; // found buffer\n    } else {\n      pos -= b.length;\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf;\n  }\n  buffer[pos] = num;\n};\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write;\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set;\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8);\n  write(encoder, (num >>> 8) & binary.BITS8);\n};\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8);\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8);\n};\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8);\n  }\n};\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8);\n    num >>>= 8;\n  }\n};\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num));\n    num >>>= 7;\n  }\n  write(encoder, binary.BITS7 & num);\n};\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num);\n  if (isNegative) {\n    num = -num;\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num));\n  num >>>= 6;\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num));\n    num >>>= 7;\n  }\n};\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)));\n  }\n};\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append));\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length;\n  const cpos = encoder.cpos;\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length);\n  const rightCopyLen = uint8Array.length - leftCopyLen;\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n  encoder.cpos += leftCopyLen;\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf);\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen));\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n    encoder.cpos = rightCopyLen;\n  }\n};\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength);\n  writeUint8Array(encoder, uint8Array);\n};\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len);\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n  encoder.cpos += len;\n  return dview\n};\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false);\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false);\n\nconst floatTestBed = new DataView(new ArrayBuffer(4));\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num);\n  return floatTestBed.getFloat32(0) === num\n};\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119);\n      writeVarString(encoder, data);\n      break\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125);\n        writeVarInt(encoder, data);\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124);\n        writeFloat32(encoder, data);\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123);\n        writeFloat64(encoder, data);\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122);\n      writeBigInt64(encoder, data);\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126);\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117);\n        writeVarUint(encoder, data.length);\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i]);\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116);\n        writeVarUint8Array(encoder, data);\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118);\n        const keys = Object.keys(data);\n        writeVarUint(encoder, keys.length);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          writeVarString(encoder, key);\n          writeAny(encoder, data[key]);\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121);\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127);\n  }\n};\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super();\n    /**\n     * The writer\n     */\n    this.w = writer;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null;\n    this.count = 0;\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1;\n      // write first value\n      this.w(this, v);\n      this.s = v;\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super();\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s);\n    this.s = v;\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super();\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++;\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1;\n      // write first value\n      writeVarInt(this, v - this.s);\n      this.s = v;\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++;\n    } else {\n      flushUintOptRleEncoder(this);\n      this.count = 1;\n      this.s = v;\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this);\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++;\n    } else {\n      flushUintOptRleEncoder(this);\n      this.count = 1;\n      this.s = v;\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this);\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1);\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff);\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n};\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder();\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v;\n      this.count++;\n    } else {\n      flushIntDiffOptRleEncoder(this);\n      this.count = 1;\n      this.diff = v - this.s;\n      this.s = v;\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this);\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = [];\n    this.s = '';\n    this.lensE = new UintOptRleEncoder();\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string;\n    if (this.s.length > 19) {\n      this.sarr.push(this.s);\n      this.s = '';\n    }\n    this.lensE.write(string.length);\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder();\n    this.sarr.push(this.s);\n    this.s = '';\n    writeVarString(encoder, this.sarr.join(''));\n    writeUint8Array(encoder, this.lensE.toUint8Array());\n    return toUint8Array(encoder)\n  }\n}\n\nvar encoding = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Encoder: Encoder,\n  createEncoder: createEncoder,\n  length: length,\n  toUint8Array: toUint8Array,\n  write: write,\n  set: set,\n  writeUint8: writeUint8,\n  setUint8: setUint8,\n  writeUint16: writeUint16,\n  setUint16: setUint16,\n  writeUint32: writeUint32,\n  writeUint32BigEndian: writeUint32BigEndian,\n  setUint32: setUint32,\n  writeVarUint: writeVarUint,\n  writeVarInt: writeVarInt,\n  writeVarString: writeVarString,\n  writeBinaryEncoder: writeBinaryEncoder,\n  writeUint8Array: writeUint8Array,\n  writeVarUint8Array: writeVarUint8Array,\n  writeOnDataView: writeOnDataView,\n  writeFloat32: writeFloat32,\n  writeFloat64: writeFloat64,\n  writeBigInt64: writeBigInt64,\n  writeBigUint64: writeBigUint64,\n  writeAny: writeAny,\n  RleEncoder: RleEncoder,\n  IntDiffEncoder: IntDiffEncoder,\n  RleIntDiffEncoder: RleIntDiffEncoder,\n  UintOptRleEncoder: UintOptRleEncoder,\n  IncUintOptRleEncoder: IncUintOptRleEncoder,\n  IntDiffOptRleEncoder: IntDiffOptRleEncoder,\n  StringEncoder: StringEncoder\n});\n\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length;\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr);\n  _decoder.pos = newPos;\n  return _decoder\n};\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos);\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++;\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8);\n  decoder.pos += 2;\n  return uint\n};\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0;\n  decoder.pos += 4;\n  return uint\n};\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0;\n  decoder.pos += 4;\n  return uint\n};\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos];\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8);\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0;\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0;\n  let len = 0;\n  while (true) {\n    const r = decoder.arr[decoder.pos++];\n    num = num | ((r & binary.BITS7) << len);\n    len += 7;\n    if (r < binary.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error('Integer out of range!')\n    }\n  }\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & binary.BITS6;\n  let len = 6;\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1;\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++];\n    num = num | ((r & binary.BITS7) << len);\n    len += 7;\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error('Integer out of range!')\n    }\n  }\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos;\n  const s = readVarUint(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos;\n  const s = readVarInt(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nconst readVarString = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n};\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s\n};\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv\n};\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false);\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder);\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {};\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder);\n      obj[key] = readAny(decoder);\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder);\n    const arr = [];\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder));\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n];\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder);\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array);\n    /**\n     * The reader\n     */\n    this.reader = reader;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null;\n    this.count = 0;\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1; // read the current value forever\n      }\n    }\n    this.count--;\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this);\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n    this.count = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1; // read the current value forever\n      }\n    }\n    this.count--;\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this);\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1;\n      this.diff = diff >> 1;\n      this.count = 1;\n      if (hasCount) {\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.s += this.diff;\n    this.count--;\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    /**\n     * @type {number}\n     */\n    this.spos = 0;\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read();\n    const res = this.str.slice(this.spos, end);\n    this.spos = end;\n    return res\n  }\n}\n\nvar decoding = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Decoder: Decoder,\n  createDecoder: createDecoder,\n  hasContent: hasContent,\n  clone: clone,\n  readUint8Array: readUint8Array,\n  readVarUint8Array: readVarUint8Array,\n  readTailAsUint8Array: readTailAsUint8Array,\n  skip8: skip8,\n  readUint8: readUint8,\n  readUint16: readUint16,\n  readUint32: readUint32,\n  readUint32BigEndian: readUint32BigEndian,\n  peekUint8: peekUint8,\n  peekUint16: peekUint16,\n  peekUint32: peekUint32,\n  readVarUint: readVarUint,\n  readVarInt: readVarInt,\n  peekVarUint: peekVarUint,\n  peekVarInt: peekVarInt,\n  readVarString: readVarString,\n  peekVarString: peekVarString,\n  readFromDataView: readFromDataView,\n  readFloat32: readFloat32,\n  readFloat64: readFloat64,\n  readBigInt64: readBigInt64,\n  readBigUint64: readBigUint64,\n  readAny: readAny,\n  RleDecoder: RleDecoder,\n  IntDiffDecoder: IntDiffDecoder,\n  RleIntDiffDecoder: RleIntDiffDecoder,\n  UintOptRleDecoder: UintOptRleDecoder,\n  IncUintOptRleDecoder: IncUintOptRleDecoder,\n  IntDiffOptRleDecoder: IntDiffOptRleDecoder,\n  StringDecoder: StringDecoder\n});\n\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len);\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length);\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer);\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i]);\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n};\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64');\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s);\n  const bytes = createUint8ArrayFromLen(a.length);\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i);\n  }\n  return bytes\n};\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64');\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n};\n\n/* istanbul ignore next */\nconst toBase64 = environment.isBrowser ? toBase64Browser : toBase64Node;\n\n/* istanbul ignore next */\nconst fromBase64 = environment.isBrowser ? fromBase64Browser : fromBase64Node;\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);\n  newBuf.set(uint8Array);\n  return newBuf\n};\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data => {\n  const encoder = createEncoder();\n  writeAny(encoder, data);\n  return toUint8Array(encoder)\n};\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => readAny(createDecoder(buf));\n\nvar buffer = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createUint8ArrayFromLen: createUint8ArrayFromLen,\n  createUint8ArrayViewFromArrayBuffer: createUint8ArrayViewFromArrayBuffer,\n  createUint8ArrayFromArrayBuffer: createUint8ArrayFromArrayBuffer,\n  toBase64: toBase64,\n  fromBase64: fromBase64,\n  copyUint8Array: copyUint8Array,\n  encodeAny: encodeAny,\n  decodeAny: decodeAny\n});\n\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.IncUintOptRleDecoder = IncUintOptRleDecoder;\nexports.IncUintOptRleEncoder = IncUintOptRleEncoder;\nexports.IntDiffDecoder = IntDiffDecoder;\nexports.IntDiffEncoder = IntDiffEncoder;\nexports.IntDiffOptRleDecoder = IntDiffOptRleDecoder;\nexports.IntDiffOptRleEncoder = IntDiffOptRleEncoder;\nexports.RleDecoder = RleDecoder;\nexports.RleEncoder = RleEncoder;\nexports.RleIntDiffDecoder = RleIntDiffDecoder;\nexports.RleIntDiffEncoder = RleIntDiffEncoder;\nexports.StringDecoder = StringDecoder;\nexports.StringEncoder = StringEncoder;\nexports.UintOptRleDecoder = UintOptRleDecoder;\nexports.UintOptRleEncoder = UintOptRleEncoder;\nexports.buffer = buffer;\nexports.clone = clone;\nexports.copyUint8Array = copyUint8Array;\nexports.createDecoder = createDecoder;\nexports.createEncoder = createEncoder;\nexports.createUint8ArrayFromArrayBuffer = createUint8ArrayFromArrayBuffer;\nexports.createUint8ArrayFromLen = createUint8ArrayFromLen;\nexports.createUint8ArrayViewFromArrayBuffer = createUint8ArrayViewFromArrayBuffer;\nexports.decodeAny = decodeAny;\nexports.decoding = decoding;\nexports.encodeAny = encodeAny;\nexports.encoding = encoding;\nexports.fromBase64 = fromBase64;\nexports.hasContent = hasContent;\nexports.length = length;\nexports.peekUint16 = peekUint16;\nexports.peekUint32 = peekUint32;\nexports.peekUint8 = peekUint8;\nexports.peekVarInt = peekVarInt;\nexports.peekVarString = peekVarString;\nexports.peekVarUint = peekVarUint;\nexports.readAny = readAny;\nexports.readBigInt64 = readBigInt64;\nexports.readBigUint64 = readBigUint64;\nexports.readFloat32 = readFloat32;\nexports.readFloat64 = readFloat64;\nexports.readFromDataView = readFromDataView;\nexports.readTailAsUint8Array = readTailAsUint8Array;\nexports.readUint16 = readUint16;\nexports.readUint32 = readUint32;\nexports.readUint32BigEndian = readUint32BigEndian;\nexports.readUint8 = readUint8;\nexports.readUint8Array = readUint8Array;\nexports.readVarInt = readVarInt;\nexports.readVarString = readVarString;\nexports.readVarUint = readVarUint;\nexports.readVarUint8Array = readVarUint8Array;\nexports.set = set;\nexports.setUint16 = setUint16;\nexports.setUint32 = setUint32;\nexports.setUint8 = setUint8;\nexports.skip8 = skip8;\nexports.toBase64 = toBase64;\nexports.toUint8Array = toUint8Array;\nexports.write = write;\nexports.writeAny = writeAny;\nexports.writeBigInt64 = writeBigInt64;\nexports.writeBigUint64 = writeBigUint64;\nexports.writeBinaryEncoder = writeBinaryEncoder;\nexports.writeFloat32 = writeFloat32;\nexports.writeFloat64 = writeFloat64;\nexports.writeOnDataView = writeOnDataView;\nexports.writeUint16 = writeUint16;\nexports.writeUint32 = writeUint32;\nexports.writeUint32BigEndian = writeUint32BigEndian;\nexports.writeUint8 = writeUint8;\nexports.writeUint8Array = writeUint8Array;\nexports.writeVarInt = writeVarInt;\nexports.writeVarString = writeVarString;\nexports.writeVarUint = writeVarUint;\nexports.writeVarUint8Array = writeVarUint8Array;\n//# sourceMappingURL=buffer-ac2cdedf.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9idWZmZXItYWMyY2RlZGYuY2pzP2M2NWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLDJFQUF1QjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDdEQsYUFBYSxtQkFBTyxDQUFDLDJFQUF1QjtBQUM1QyxXQUFXLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQywyRUFBdUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFP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QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7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Q2Ysb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIsV0FBVztBQUNYLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2J1ZmZlci1hYzJjZGVkZi5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy1mM2MzZDgwNS5janMnKTtcbnZhciBlbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vZW52aXJvbm1lbnQtN2UyZmZhZWEuY2pzJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnktYWM4ZTM5ZTIuY2pzJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aC0wOGUwNjhmOS5janMnKTtcbnZhciBudW1iZXIgPSByZXF1aXJlKCcuL251bWJlci0yNGYxZWFiZS5janMnKTtcblxuLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGVuY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9lbmNvZGluZ10gd2l0aCBbbGliMC9kZWNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IG5ldyBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBuZXcgZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gKiBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSAvLyA9PiAyNTZcbiAqIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcikgLy8gPT4gJ0hlbGxvIHdvcmxkISdcbiAqIGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgLy8gPT4gZmFsc2UgLSBhbGwgZGF0YSBpcyByZWFkXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIGVuY29kaW5nXG4gKi9cblxuLyoqXG4gKiBBIEJpbmFyeUVuY29kZXIgaGFuZGxlcyB0aGUgZW5jb2RpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNwb3MgPSAwO1xuICAgIHRoaXMuY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEwMCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFVpbnQ4QXJyYXk+fVxuICAgICAqL1xuICAgIHRoaXMuYnVmcyA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtFbmNvZGVyfVxuICovXG5jb25zdCBjcmVhdGVFbmNvZGVyID0gKCkgPT4gbmV3IEVuY29kZXIoKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBsZW5ndGggPSBlbmNvZGVyID0+IHtcbiAgbGV0IGxlbiA9IGVuY29kZXIuY3BvcztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gZW5jb2Rlci5idWZzW2ldLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gbGVuXG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0byBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fSBUaGUgY3JlYXRlZCBBcnJheUJ1ZmZlci5cbiAqL1xuY29uc3QgdG9VaW50OEFycmF5ID0gZW5jb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKGVuY29kZXIpKTtcbiAgbGV0IGN1clBvcyA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGVuY29kZXIuYnVmc1tpXTtcbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKTtcbiAgICBjdXJQb3MgKz0gZC5sZW5ndGg7XG4gIH1cbiAgdWludDhhcnIuc2V0KGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyKGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcyksIGN1clBvcyk7XG4gIHJldHVybiB1aW50OGFyclxufTtcblxuLyoqXG4gKiBWZXJpZnkgdGhhdCBpdCBpcyBwb3NzaWJsZSB0byB3cml0ZSBgbGVuYCBieXRlcyB3dGlob3V0IGNoZWNraW5nLiBJZlxuICogbmVjZXNzYXJ5LCBhIG5ldyBCdWZmZXIgd2l0aCB0aGUgcmVxdWlyZWQgbGVuZ3RoIGlzIGF0dGFjaGVkLlxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5jb25zdCB2ZXJpZnlMZW4gPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGlmIChidWZmZXJMZW4gLSBlbmNvZGVyLmNwb3MgPCBsZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChjcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpKTtcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShtYXRoLm1heChidWZmZXJMZW4sIGxlbikgKiAyKTtcbiAgICBlbmNvZGVyLmNwb3MgPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBieXRlIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3Qgd3JpdGUgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGg7XG4gIGlmIChlbmNvZGVyLmNwb3MgPT09IGJ1ZmZlckxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuICogMik7XG4gICAgZW5jb2Rlci5jcG9zID0gMDtcbiAgfVxuICBlbmNvZGVyLmNidWZbZW5jb2Rlci5jcG9zKytdID0gbnVtO1xufTtcblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICogUG9zaXRpb24gbXVzdCBhbHJlYWR5IGJlIHdyaXR0ZW4gKGkuZS4gZW5jb2Rlci5sZW5ndGggPiBwb3MpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gd2hpY2ggdG8gd3JpdGUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmNvbnN0IHNldCA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBsZXQgYnVmZmVyID0gbnVsbDtcbiAgLy8gaXRlcmF0ZSBhbGwgYnVmZmVycyBhbmQgYWRqdXN0IHBvc2l0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aCAmJiBidWZmZXIgPT09IG51bGw7IGkrKykge1xuICAgIGNvbnN0IGIgPSBlbmNvZGVyLmJ1ZnNbaV07XG4gICAgaWYgKHBvcyA8IGIubGVuZ3RoKSB7XG4gICAgICBidWZmZXIgPSBiOyAvLyBmb3VuZCBidWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zIC09IGIubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgLy8gdXNlIGN1cnJlbnQgYnVmZmVyXG4gICAgYnVmZmVyID0gZW5jb2Rlci5jYnVmO1xuICB9XG4gIGJ1ZmZlcltwb3NdID0gbnVtO1xufTtcblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVVpbnQ4ID0gd3JpdGU7XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgYXMgYW4gdW5zaWduZWQgSW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCBzZXRVaW50OCA9IHNldDtcblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3Qgd3JpdGVVaW50MTYgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOCk7XG4gIHdyaXRlKGVuY29kZXIsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KTtcbn07XG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHNldFVpbnQxNiA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBzZXQoZW5jb2RlciwgcG9zLCBudW0gJiBiaW5hcnkuQklUUzgpO1xuICBzZXQoZW5jb2RlciwgcG9zICsgMSwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpO1xufTtcblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlclxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVVpbnQzMiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpO1xuICAgIG51bSA+Pj49IDg7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlVWludDMyQmlnRW5kaWFuID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICB3cml0ZShlbmNvZGVyLCAobnVtID4+PiAoOCAqIGkpKSAmIGJpbmFyeS5CSVRTOCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgbG9jYXRpb24gd2hlcmUgdGhlIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuY29uc3Qgc2V0VWludDMyID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2V0KGVuY29kZXIsIHBvcyArIGksIG51bSAmIGJpbmFyeS5CSVRTOCk7XG4gICAgbnVtID4+Pj0gODtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEVuY29kZXMgaW50ZWdlcnMgaW4gdGhlIHJhbmdlIGZyb20gWzAsIDQyOTQ5NjcyOTVdIC8gWzAsIDB4ZmZmZmZmZmZdLiAobWF4IDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2VyKVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBiaW5hcnkuQklUUzcpIHtcbiAgICB3cml0ZShlbmNvZGVyLCBiaW5hcnkuQklUOCB8IChiaW5hcnkuQklUUzcgJiBudW0pKTtcbiAgICBudW0gPj4+PSA3O1xuICB9XG4gIHdyaXRlKGVuY29kZXIsIGJpbmFyeS5CSVRTNyAmIG51bSk7XG59O1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIuXG4gKlxuICogRW5jb2RlcyBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgZnJvbSBbLTIxNDc0ODM2NDgsIC0yMTQ3NDgzNjQ3XS5cbiAqXG4gKiBXZSBkb24ndCB1c2UgemlnLXphZyBlbmNvZGluZyBiZWNhdXNlIHdlIHdhbnQgdG8ga2VlcCB0aGUgb3B0aW9uIG9wZW5cbiAqIHRvIHVzZSB0aGUgc2FtZSBmdW5jdGlvbiBmb3IgQmlnSW50IGFuZCA1M2JpdCBpbnRlZ2VycyAoZG91YmxlcykuXG4gKlxuICogV2UgdXNlIHRoZSA3dGggYml0IGluc3RlYWQgZm9yIHNpZ25hbGluZyB0aGF0IHRoaXMgaXMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmNvbnN0IHdyaXRlVmFySW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyhudW0pO1xuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIG51bSA9IC1udW07XG4gIH1cbiAgLy8gICAgICAgICAgICAgfC0gd2hldGhlciB0byBjb250aW51ZSByZWFkaW5nICAgICAgICAgfC0gd2hldGhlciBpcyBuZWdhdGl2ZSAgICAgfC0gbnVtYmVyXG4gIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzYgPyBiaW5hcnkuQklUOCA6IDApIHwgKGlzTmVnYXRpdmUgPyBiaW5hcnkuQklUNyA6IDApIHwgKGJpbmFyeS5CSVRTNiAmIG51bSkpO1xuICBudW0gPj4+PSA2O1xuICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBjYXNlIG9mIG51bSA9PT0gMCBzbyB3ZSBjYW4gdXNlIGEgZGlmZmVyZW50XG4gIC8vIHBhdHRlcm4gaGVyZSB0aGFuIGFib3ZlLlxuICB3aGlsZSAobnVtID4gMCkge1xuICAgIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzcgPyBiaW5hcnkuQklUOCA6IDApIHwgKGJpbmFyeS5CSVRTNyAmIG51bSkpO1xuICAgIG51bSA+Pj49IDc7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5jb25zdCB3cml0ZVZhclN0cmluZyA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBsZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGNvbnRlbnQgb2YgYW5vdGhlciBFbmNvZGVyLlxuICpcbiAqIEBUT0RPOiBjYW4gYmUgaW1wcm92ZWQhXG4gKiAgICAgICAgLSBOb3RlOiBTaG91bGQgY29uc2lkZXIgdGhhdCB3aGVuIGFwcGVuZGluZyBhIGxvdCBvZiBzbWFsbCBFbmNvZGVycywgd2Ugc2hvdWxkIHJhdGhlciBjbG9uZSB0aGFuIHJlZmVyZW5jaW5nIHRoZSBvbGQgc3RydWN0dXJlLlxuICogICAgICAgICAgICAgICAgRW5jb2RlcnMgc3RhcnQgd2l0aCBhIHJhdGhlciBiaWcgaW5pdGlhbCBidWZmZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgVGhlIGVuVWludDhBcnJcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gYXBwZW5kIFRoZSBCaW5hcnlFbmNvZGVyIHRvIGJlIHdyaXR0ZW4uXG4gKi9cbmNvbnN0IHdyaXRlQmluYXJ5RW5jb2RlciA9IChlbmNvZGVyLCBhcHBlbmQpID0+IHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkoYXBwZW5kKSk7XG5cbi8qKlxuICogQXBwZW5kIGZpeGVkLWxlbmd0aCBVaW50OEFycmF5IHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuY29uc3Qgd3JpdGVVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aDtcbiAgY29uc3QgY3BvcyA9IGVuY29kZXIuY3BvcztcbiAgY29uc3QgbGVmdENvcHlMZW4gPSBtYXRoLm1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aCk7XG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW47XG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpO1xuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW47XG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1Zik7XG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGgubWF4KGJ1ZmZlckxlbiAqIDIsIHJpZ2h0Q29weUxlbikpO1xuICAgIC8vIGNvcHkgYXJyYXlcbiAgICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkobGVmdENvcHlMZW4pKTtcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW47XG4gIH1cbn07XG5cbi8qKlxuICogQXBwZW5kIGFuIFVpbnQ4QXJyYXkgdG8gRW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmNvbnN0IHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpO1xuICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdWludDhBcnJheSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBEYXRhVmlldyBvZiB0aGUgbmV4dCBgbGVuYCBieXRlcy4gVXNlIGl0IHRvIHdyaXRlIGRhdGEgYWZ0ZXJcbiAqIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogLy8gd3JpdGUgZmxvYXQzMiB1c2luZyBEYXRhVmlld1xuICogY29uc3QgZHYgPSB3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgNClcbiAqIGR2LnNldEZsb2F0MzIoMCwgMS4xKVxuICogLy8gcmVhZCBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHJlYWRGcm9tRGF0YVZpZXcoZW5jb2RlciwgNClcbiAqIGR2LmdldEZsb2F0MzIoMCkgLy8gPT4gMS4xMDAwMDAwMjM4NDE4NTggKGxlYXZpbmcgaXQgdG8gdGhlIHJlYWRlciB0byBmaW5kIG91dCB3aHkgdGhpcyBpcyB0aGUgY29ycmVjdCByZXN1bHQpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm4ge0RhdGFWaWV3fVxuICovXG5jb25zdCB3cml0ZU9uRGF0YVZpZXcgPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIHZlcmlmeUxlbihlbmNvZGVyLCBsZW4pO1xuICBjb25zdCBkdmlldyA9IG5ldyBEYXRhVmlldyhlbmNvZGVyLmNidWYuYnVmZmVyLCBlbmNvZGVyLmNwb3MsIGxlbik7XG4gIGVuY29kZXIuY3BvcyArPSBsZW47XG4gIHJldHVybiBkdmlld1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuY29uc3Qgd3JpdGVGbG9hdDMyID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDQpLnNldEZsb2F0MzIoMCwgbnVtLCBmYWxzZSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKi9cbmNvbnN0IHdyaXRlRmxvYXQ2NCA9IChlbmNvZGVyLCBudW0pID0+IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KS5zZXRGbG9hdDY0KDAsIG51bSwgZmFsc2UpO1xuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5jb25zdCB3cml0ZUJpZ0ludDY0ID0gKGVuY29kZXIsIG51bSkgPT4gLyoqIEB0eXBlIHthbnl9ICovICh3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkpLnNldEJpZ0ludDY0KDAsIG51bSwgZmFsc2UpO1xuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5jb25zdCB3cml0ZUJpZ1VpbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdVaW50NjQoMCwgbnVtLCBmYWxzZSk7XG5cbmNvbnN0IGZsb2F0VGVzdEJlZCA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpO1xuLyoqXG4gKiBDaGVjayBpZiBhIG51bWJlciBjYW4gYmUgZW5jb2RlZCBhcyBhIDMyIGJpdCBmbG9hdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc0Zsb2F0MzIgPSBudW0gPT4ge1xuICBmbG9hdFRlc3RCZWQuc2V0RmxvYXQzMigwLCBudW0pO1xuICByZXR1cm4gZmxvYXRUZXN0QmVkLmdldEZsb2F0MzIoMCkgPT09IG51bVxufTtcblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIGVmZmljaWVudCBiaW5hcnkgZm9ybWF0LlxuICpcbiAqIERpZmZlcmVuY2VzIHRvIEpTT046XG4gKiDigKIgVHJhbnNmb3JtcyBkYXRhIHRvIGEgYmluYXJ5IGZvcm1hdCAobm90IHRvIGEgc3RyaW5nKVxuICog4oCiIEVuY29kZXMgdW5kZWZpbmVkLCBOYU4sIGFuZCBBcnJheUJ1ZmZlciAodGhlc2UgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTilcbiAqIOKAoiBOdW1iZXJzIGFyZSBlZmZpY2llbnRseSBlbmNvZGVkIGVpdGhlciBhcyBhIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyLCBhcyBhXG4gKiAgIDMyIGJpdCBmbG9hdCwgYXMgYSA2NCBiaXQgZmxvYXQsIG9yIGFzIGEgNjQgYml0IGJpZ2ludC5cbiAqXG4gKiBFbmNvZGluZyB0YWJsZTpcbiAqXG4gKiB8IERhdGEgVHlwZSAgICAgICAgICAgfCBQcmVmaXggICB8IEVuY29kaW5nIE1ldGhvZCAgICB8IENvbW1lbnQgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tIHxcbiAqIHwgdW5kZWZpbmVkICAgICAgICAgICB8IDEyNyAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgRnVuY3Rpb25zLCBzeW1ib2wsIGFuZCBldmVyeXRoaW5nIHRoYXQgY2Fubm90IGJlIGlkZW50aWZpZWQgaXMgZW5jb2RlZCBhcyB1bmRlZmluZWQgfFxuICogfCBudWxsICAgICAgICAgICAgICAgIHwgMTI2ICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCB8XG4gKiB8IGludGVnZXIgICAgICAgICAgICAgfCAxMjUgICAgICB8IHdyaXRlVmFySW50ICAgICAgICB8IE9ubHkgZW5jb2RlcyAzMiBiaXQgc2lnbmVkIGludGVnZXJzIHxcbiAqIHwgZmxvYXQzMiAgICAgICAgICAgICB8IDEyNCAgICAgIHwgd3JpdGVGbG9hdDMyICAgICAgIHwgfFxuICogfCBmbG9hdDY0ICAgICAgICAgICAgIHwgMTIzICAgICAgfCB3cml0ZUZsb2F0NjQgICAgICAgfCB8XG4gKiB8IGJpZ2ludCAgICAgICAgICAgICAgfCAxMjIgICAgICB8IHdyaXRlQmlnSW50NjQgICAgICB8IHxcbiAqIHwgYm9vbGVhbiAoZmFsc2UpICAgICB8IDEyMSAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgVHJ1ZSBhbmQgZmFsc2UgYXJlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHNvIHdlIHNhdmUgdGhlIGZvbGxvd2luZyBieXRlIHxcbiAqIHwgYm9vbGVhbiAodHJ1ZSkgICAgICB8IDEyMCAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgLSAwYjAxMTExMDAwIHNvIHRoZSBsYXN0IGJpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdHJ1ZSBvciBmYWxzZSB8XG4gKiB8IHN0cmluZyAgICAgICAgICAgICAgfCAxMTkgICAgICB8IHdyaXRlVmFyU3RyaW5nICAgICB8IHxcbiAqIHwgb2JqZWN0PHN0cmluZyxhbnk+ICB8IDExOCAgICAgIHwgY3VzdG9tICAgICAgICAgICAgIHwgV3JpdGVzIHtsZW5ndGh9IHRoZW4ge2xlbmd0aH0ga2V5LXZhbHVlIHBhaXJzIHxcbiAqIHwgYXJyYXk8YW55PiAgICAgICAgICB8IDExNyAgICAgIHwgY3VzdG9tICAgICAgICAgICAgIHwgV3JpdGVzIHtsZW5ndGh9IHRoZW4ge2xlbmd0aH0ganNvbiB2YWx1ZXMgfFxuICogfCBVaW50OEFycmF5ICAgICAgICAgIHwgMTE2ICAgICAgfCB3cml0ZVZhclVpbnQ4QXJyYXkgfCBXZSB1c2UgVWludDhBcnJheSBmb3IgYW55IGtpbmQgb2YgYmluYXJ5IGRhdGEgfFxuICpcbiAqIFJlYXNvbnMgZm9yIHRoZSBkZWNyZWFzaW5nIHByZWZpeDpcbiAqIFdlIG5lZWQgdGhlIGZpcnN0IGJpdCBmb3IgZXh0ZW5kYWJpbGl0eSAobGF0ZXIgd2UgbWF5IHdhbnQgdG8gZW5jb2RlIHRoZVxuICogcHJlZml4IHdpdGggd3JpdGVWYXJVaW50KS4gVGhlIHJlbWFpbmluZyA3IGJpdHMgYXJlIGRpdmlkZWQgYXMgZm9sbG93czpcbiAqIFswLTMwXSAgIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCBmb3IgY3VzdG9tIHB1cnBvc2VzXG4gKiAgICAgICAgICAoZGVmaW5lZCBieSB0aGUgZnVuY3Rpb24gdGhhdCB1c2VzIHRoaXMgbGlicmFyeSlcbiAqIFszMS0xMjddIHRoZSBlbmQgb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCBmb3IgZGF0YSBlbmNvZGluZyBieVxuICogICAgICAgICAgbGliMC9lbmNvZGluZy5qc1xuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxudW1iZXJ8YmlnaW50fGJvb2xlYW58c3RyaW5nfE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fFVpbnQ4QXJyYXl9IGRhdGFcbiAqL1xuY29uc3Qgd3JpdGVBbnkgPSAoZW5jb2RlciwgZGF0YSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBkYXRhKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIFRZUEUgMTE5OiBTVFJJTkdcbiAgICAgIHdyaXRlKGVuY29kZXIsIDExOSk7XG4gICAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkYXRhKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXIuaXNJbnRlZ2VyKGRhdGEpICYmIGRhdGEgPD0gYmluYXJ5LkJJVFMzMSkge1xuICAgICAgICAvLyBUWVBFIDEyNTogSU5URUdFUlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjUpO1xuICAgICAgICB3cml0ZVZhckludChlbmNvZGVyLCBkYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGbG9hdDMyKGRhdGEpKSB7XG4gICAgICAgIC8vIFRZUEUgMTI0OiBGTE9BVDMyXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNCk7XG4gICAgICAgIHdyaXRlRmxvYXQzMihlbmNvZGVyLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRZUEUgMTIzOiBGTE9BVDY0XG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyMyk7XG4gICAgICAgIHdyaXRlRmxvYXQ2NChlbmNvZGVyLCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIC8vIFRZUEUgMTIyOiBCaWdJbnRcbiAgICAgIHdyaXRlKGVuY29kZXIsIDEyMik7XG4gICAgICB3cml0ZUJpZ0ludDY0KGVuY29kZXIsIGRhdGEpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVFlQRSAxMjY6IG51bGxcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTI2KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIC8vIFRZUEUgMTE3OiBBcnJheVxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMTcpO1xuICAgICAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB3cml0ZUFueShlbmNvZGVyLCBkYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBUWVBFIDExNjogQXJyYXlCdWZmZXJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE2KTtcbiAgICAgICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVFlQRSAxMTg6IE9iamVjdFxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMTgpO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBrZXlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwga2V5KTtcbiAgICAgICAgICB3cml0ZUFueShlbmNvZGVyLCBkYXRhW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgLy8gVFlQRSAxMjAvMTIxOiBib29sZWFuICh0cnVlL2ZhbHNlKVxuICAgICAgd3JpdGUoZW5jb2RlciwgZGF0YSA/IDEyMCA6IDEyMSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUWVBFIDEyNzogdW5kZWZpbmVkXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMjcpO1xuICB9XG59O1xuXG4vKipcbiAqIE5vdyBjb21lIGEgZmV3IHN0YXRlZnVsIGVuY29kZXIgdGhhdCBoYXZlIHRoZWlyIG93biBjbGFzc2VzLlxuICovXG5cbi8qKlxuICogQmFzaWMgUnVuIExlbmd0aCBFbmNvZGVyIC0gYSBiYXNpYyBjb21wcmVzc2lvbiBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBFbmNvZGVzIFsxLDEsMSw3XSB0byBbMSwzLDcsMV0gKDMgdGltZXMgMSwgMSB0aW1lIDcpLiBUaGlzIGVuY29kZXIgbWlnaHQgZG8gbW9yZSBoYXJtIHRoYW4gZ29vZCBpZiB0aGVyZSBhcmUgYSBsb3Qgb2YgdmFsdWVzIHRoYXQgYXJlIG5vdCByZXBlYXRlZC5cbiAqXG4gKiBJdCB3YXMgb3JpZ2luYWxseSB1c2VkIGZvciBpbWFnZSBjb21wcmVzc2lvbi4gQ29vbCAuLiBhcnRpY2xlIGh0dHA6Ly9jc2JydWNlLmNvbS9jYm0vdHJhbnNhY3Rvci9wZGZzL3RyYW5zX3Y3X2kwNi5wZGZcbiAqXG4gKiBAbm90ZSBUIG11c3Qgbm90IGJlIG51bGwhXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUmxlRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFbmNvZGVyLCBUKTp2b2lkfSB3cml0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh3cml0ZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIFRoZSB3cml0ZXJcbiAgICAgKi9cbiAgICB0aGlzLncgPSB3cml0ZXI7XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyA9PT0gdikge1xuICAgICAgdGhpcy5jb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSk7IC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDAsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgICB9XG4gICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgIC8vIHdyaXRlIGZpcnN0IHZhbHVlXG4gICAgICB0aGlzLncodGhpcywgdik7XG4gICAgICB0aGlzLnMgPSB2O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2ljIGRpZmYgZGVjb2RlciB1c2luZyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogRW5jb2RlcyB0aGUgdmFsdWVzIFszLCAxMTAwLCAxMTAxLCAxMDUwLCAwXSB0byBbMywgMTA5NywgMSwgLTUxLCAtMTA1MF0gdXNpbmcgd3JpdGVWYXJJbnQuXG4gKi9cbmNsYXNzIEludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgd3JpdGVWYXJJbnQodGhpcywgdiAtIHRoaXMucyk7XG4gICAgdGhpcy5zID0gdjtcbiAgfVxufVxuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgSW50RGlmZkVuY29kZXIgYW5kIFJsZUVuY29kZXIuXG4gKlxuICogQmFzaWNhbGx5IGZpcnN0IHdyaXRlcyB0aGUgSW50RGlmZkVuY29kZXIgYW5kIHRoZW4gY291bnRzIGR1cGxpY2F0ZSBkaWZmcyB1c2luZyBSbGVFbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzEsMSwxLDIsMyw0LDUsNl0gYXMgWzEsMSwwLDIsMSw1XSAoUkxFKFsxLDAsMCwxLDEsMSwxLDFdKSDih5IgUmxlSW50RGlmZlsxLDEsMCwyLDEsNV0pXG4gKi9cbmNsYXNzIFJsZUludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyA9PT0gdiAmJiB0aGlzLmNvdW50ID4gMCkge1xuICAgICAgdGhpcy5jb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSk7IC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDAsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgICB9XG4gICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgIC8vIHdyaXRlIGZpcnN0IHZhbHVlXG4gICAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKTtcbiAgICAgIHRoaXMucyA9IHY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50T3B0UmxlRW5jb2Rlcn0gZW5jb2RlclxuICovXG5jb25zdCBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyID0gZW5jb2RlciA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbmNvZGVyLmNvdW50ID4gMCkge1xuICAgIC8vIGZsdXNoIGNvdW50ZXIsIHVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCB2YWx1ZSAoY291bnQgPSAwKVxuICAgIC8vIGNhc2UgMToganVzdCBhIHNpbmdsZSB2YWx1ZS4gc2V0IHNpZ24gdG8gcG9zaXRpdmVcbiAgICAvLyBjYXNlIDI6IHdyaXRlIHNldmVyYWwgdmFsdWVzLiBzZXQgc2lnbiB0byBuZWdhdGl2ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZXJlIGlzIGEgbGVuZ3RoIGNvbWluZ1xuICAgIHdyaXRlVmFySW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCA9PT0gMSA/IGVuY29kZXIucyA6IC1lbmNvZGVyLnMpO1xuICAgIGlmIChlbmNvZGVyLmNvdW50ID4gMSkge1xuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCAtIDIpOyAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAxLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBPcHRpbWl6ZWQgUmxlIGVuY29kZXIgdGhhdCBkb2VzIG5vdCBzdWZmZXIgZnJvbSB0aGUgbWVudGlvbmVkIHByb2JsZW0gb2YgdGhlIGJhc2ljIFJsZSBlbmNvZGVyLlxuICpcbiAqIEludGVybmFsbHkgdXNlcyBWYXJJbnQgZW5jb2RlciB0byB3cml0ZSB1bnNpZ25lZCBpbnRlZ2Vycy4gSWYgdGhlIGlucHV0IG9jY3VycyBtdWx0aXBsZSB0aW1lcywgd2Ugd3JpdGVcbiAqIHdyaXRlIGl0IGFzIGEgbmVnYXRpdmUgbnVtYmVyLiBUaGUgVWludE9wdFJsZURlY29kZXIgdGhlbiB1bmRlcnN0YW5kcyB0aGF0IGl0IG5lZWRzIHRvIHJlYWQgYSBjb3VudC5cbiAqXG4gKiBFbmNvZGVzIFsxLDIsMywzLDNdIGFzIFsxLDIsLTMsM10gKG9uY2UgMSwgb25jZSAyLCB0aHJlZSB0aW1lcyAzKVxuICovXG5jbGFzcyBVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMDtcbiAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcyk7XG4gICAgICB0aGlzLmNvdW50ID0gMTtcbiAgICAgIHRoaXMucyA9IHY7XG4gICAgfVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpO1xuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogSW5jcmVhc2luZyBVaW50IE9wdGltaXplZCBSTEUgRW5jb2RlclxuICpcbiAqIFRoZSBSTEUgZW5jb2RlciBjb3VudHMgdGhlIG51bWJlciBvZiBzYW1lIG9jY3VyZW5jZXMgb2YgdGhlIHNhbWUgdmFsdWUuXG4gKiBUaGUgSW5jVWludE9wdFJsZSBlbmNvZGVyIGNvdW50cyBpZiB0aGUgdmFsdWUgaW5jcmVhc2VzLlxuICogSS5lLiA3LCA4LCA5LCAxMCB3aWxsIGJlIGVuY29kZWQgYXMgWy03LCA0XS4gMSwgMywgNSB3aWxsIGJlIGVuY29kZWRcbiAqIGFzIFsxLCAzLCA1XS5cbiAqL1xuY2xhc3MgSW5jVWludE9wdFJsZUVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDA7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyArIHRoaXMuY291bnQgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKTtcbiAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgdGhpcy5zID0gdjtcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcyk7XG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ludERpZmZPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gICAgICAgICAgMzEgYml0IG1ha2luZyB1cCB0aGUgZGlmZiB8IHdldGhlciB0byB3cml0ZSB0aGUgY291bnRlclxuICAgIGNvbnN0IGVuY29kZWREaWZmID0gZW5jb2Rlci5kaWZmIDw8IDEgfCAoZW5jb2Rlci5jb3VudCA9PT0gMSA/IDAgOiAxKTtcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBmaXJzdCBiaXQgdG8gcG9zaXRpdmVcbiAgICAvLyBjYXNlIDI6IHdyaXRlIHNldmVyYWwgdmFsdWVzLiBzZXQgZmlyc3QgYml0IHRvIG5lZ2F0aXZlIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgYSBsZW5ndGggY29taW5nXG4gICAgd3JpdGVWYXJJbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVkRGlmZik7XG4gICAgaWYgKGVuY29kZXIuY291bnQgPiAxKSB7XG4gICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50IC0gMik7IC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDEsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgdGhlIEludERpZmZFbmNvZGVyIGFuZCB0aGUgVWludE9wdFJsZUVuY29kZXIuXG4gKlxuICogVGhlIGNvdW50IGFwcHJvYWNoIGlzIHNpbWlsYXIgdG8gdGhlIFVpbnREaWZmT3B0UmxlRW5jb2RlciwgYnV0IGluc3RlYWQgb2YgdXNpbmcgdGhlIG5lZ2F0aXZlIGJpdGZsYWcsIGl0IGVuY29kZXNcbiAqIGluIHRoZSBMU0Igd2hldGhlciBhIGNvdW50IGlzIHRvIGJlIHJlYWQuIFRoZXJlZm9yZSB0aGlzIEVuY29kZXIgb25seSBzdXBwb3J0cyAzMSBiaXQgaW50ZWdlcnMhXG4gKlxuICogRW5jb2RlcyBbMSwgMiwgMywgMl0gYXMgWzMsIDEsIDYsIC0xXSAobW9yZSBzcGVjaWZpY2FsbHkgWygxIDw8IDEpIHwgMSwgKDMgPDwgMCkgfCAwLCAtMV0pXG4gKlxuICogSW50ZXJuYWxseSB1c2VzIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy4gQ29udHJhcnkgdG8gbm9ybWFsIFVpbnRWYXIgZW5jb2RpbmcsIHRoZSBmaXJzdCBieXRlIGNvbnRhaW5zOlxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGUgbmV4dCB2YWx1ZSBpcyBhIGNvdW50IChMU0IpXG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgbmVnYXRpdmUgKE1TQiAtIDEpXG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRvIGNvbnRpbnVlIHJlYWRpbmcgdGhlIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyIChNU0IpXG4gKlxuICogVGhlcmVmb3JlLCBvbmx5IGZpdmUgYml0cyByZW1haW4gdG8gZW5jb2RlIGRpZmYgcmFuZ2VzLlxuICpcbiAqIFVzZSB0aGlzIEVuY29kZXIgb25seSB3aGVuIGFwcHJvcHJpYXRlLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIHByb2JhYmx5IGEgYmFkIGlkZWEuXG4gKi9cbmNsYXNzIEludERpZmZPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuZGlmZiA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMuZGlmZiA9PT0gdiAtIHRoaXMucykge1xuICAgICAgdGhpcy5zID0gdjtcbiAgICAgIHRoaXMuY291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2Rlcih0aGlzKTtcbiAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgdGhpcy5kaWZmID0gdiAtIHRoaXMucztcbiAgICAgIHRoaXMucyA9IHY7XG4gICAgfVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpO1xuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFN0cmluZyBFbmNvZGVyLlxuICpcbiAqIEVuY29kaW5nIG1hbnkgc21hbGwgc3RyaW5ncyBpbiBhIHNpbXBsZSBFbmNvZGVyIGlzIG5vdCB2ZXJ5IGVmZmljaWVudC4gVGhlIGZ1bmN0aW9uIGNhbGwgdG8gZGVjb2RlIGEgc3RyaW5nIHRha2VzIHNvbWUgdGltZSBhbmQgY3JlYXRlcyByZWZlcmVuY2VzIHRoYXQgbXVzdCBiZSBldmVudHVhbGx5IGRlbGV0ZWQuXG4gKiBJbiBwcmFjdGljZSwgd2hlbiBkZWNvZGluZyBzZXZlcmFsIG1pbGxpb24gc21hbGwgc3RyaW5ncywgdGhlIEdDIHdpbGwga2ljayBpbiBtb3JlIGFuZCBtb3JlIG9mdGVuIHRvIGNvbGxlY3Qgb3JwaGFuZWQgc3RyaW5nIG9iamVjdHMgKG9yIG1heWJlIHRoZXJlIGlzIGFub3RoZXIgcmVhc29uPykuXG4gKlxuICogVGhpcyBzdHJpbmcgZW5jb2RlciBzb2x2ZXMgdGhlIGFib3ZlIHByb2JsZW0uIEFsbCBzdHJpbmdzIGFyZSBjb25jYXRlbmF0ZWQgYW5kIHdyaXR0ZW4gYXMgYSBzaW5nbGUgc3RyaW5nIHVzaW5nIGEgc2luZ2xlIGVuY29kaW5nIGNhbGwuXG4gKlxuICogVGhlIGxlbmd0aHMgYXJlIGVuY29kZWQgdXNpbmcgYSBVaW50T3B0UmxlRW5jb2Rlci5cbiAqL1xuY2xhc3MgU3RyaW5nRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnNhcnIgPSBbXTtcbiAgICB0aGlzLnMgPSAnJztcbiAgICB0aGlzLmxlbnNFID0gbmV3IFVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKi9cbiAgd3JpdGUgKHN0cmluZykge1xuICAgIHRoaXMucyArPSBzdHJpbmc7XG4gICAgaWYgKHRoaXMucy5sZW5ndGggPiAxOSkge1xuICAgICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKTtcbiAgICAgIHRoaXMucyA9ICcnO1xuICAgIH1cbiAgICB0aGlzLmxlbnNFLndyaXRlKHN0cmluZy5sZW5ndGgpO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IEVuY29kZXIoKTtcbiAgICB0aGlzLnNhcnIucHVzaCh0aGlzLnMpO1xuICAgIHRoaXMucyA9ICcnO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRoaXMuc2Fyci5qb2luKCcnKSk7XG4gICAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuc0UudG9VaW50OEFycmF5KCkpO1xuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxufVxuXG52YXIgZW5jb2RpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgRW5jb2RlcjogRW5jb2RlcixcbiAgY3JlYXRlRW5jb2RlcjogY3JlYXRlRW5jb2RlcixcbiAgbGVuZ3RoOiBsZW5ndGgsXG4gIHRvVWludDhBcnJheTogdG9VaW50OEFycmF5LFxuICB3cml0ZTogd3JpdGUsXG4gIHNldDogc2V0LFxuICB3cml0ZVVpbnQ4OiB3cml0ZVVpbnQ4LFxuICBzZXRVaW50ODogc2V0VWludDgsXG4gIHdyaXRlVWludDE2OiB3cml0ZVVpbnQxNixcbiAgc2V0VWludDE2OiBzZXRVaW50MTYsXG4gIHdyaXRlVWludDMyOiB3cml0ZVVpbnQzMixcbiAgd3JpdGVVaW50MzJCaWdFbmRpYW46IHdyaXRlVWludDMyQmlnRW5kaWFuLFxuICBzZXRVaW50MzI6IHNldFVpbnQzMixcbiAgd3JpdGVWYXJVaW50OiB3cml0ZVZhclVpbnQsXG4gIHdyaXRlVmFySW50OiB3cml0ZVZhckludCxcbiAgd3JpdGVWYXJTdHJpbmc6IHdyaXRlVmFyU3RyaW5nLFxuICB3cml0ZUJpbmFyeUVuY29kZXI6IHdyaXRlQmluYXJ5RW5jb2RlcixcbiAgd3JpdGVVaW50OEFycmF5OiB3cml0ZVVpbnQ4QXJyYXksXG4gIHdyaXRlVmFyVWludDhBcnJheTogd3JpdGVWYXJVaW50OEFycmF5LFxuICB3cml0ZU9uRGF0YVZpZXc6IHdyaXRlT25EYXRhVmlldyxcbiAgd3JpdGVGbG9hdDMyOiB3cml0ZUZsb2F0MzIsXG4gIHdyaXRlRmxvYXQ2NDogd3JpdGVGbG9hdDY0LFxuICB3cml0ZUJpZ0ludDY0OiB3cml0ZUJpZ0ludDY0LFxuICB3cml0ZUJpZ1VpbnQ2NDogd3JpdGVCaWdVaW50NjQsXG4gIHdyaXRlQW55OiB3cml0ZUFueSxcbiAgUmxlRW5jb2RlcjogUmxlRW5jb2RlcixcbiAgSW50RGlmZkVuY29kZXI6IEludERpZmZFbmNvZGVyLFxuICBSbGVJbnREaWZmRW5jb2RlcjogUmxlSW50RGlmZkVuY29kZXIsXG4gIFVpbnRPcHRSbGVFbmNvZGVyOiBVaW50T3B0UmxlRW5jb2RlcixcbiAgSW5jVWludE9wdFJsZUVuY29kZXI6IEluY1VpbnRPcHRSbGVFbmNvZGVyLFxuICBJbnREaWZmT3B0UmxlRW5jb2RlcjogSW50RGlmZk9wdFJsZUVuY29kZXIsXG4gIFN0cmluZ0VuY29kZXI6IFN0cmluZ0VuY29kZXJcbn0pO1xuXG4vKipcbiAqIEVmZmljaWVudCBzY2hlbWEtbGVzcyBiaW5hcnkgZGVjb2Rpbmcgd2l0aCBzdXBwb3J0IGZvciB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogVXNlIFtsaWIwL2RlY29kaW5nXSB3aXRoIFtsaWIwL2VuY29kaW5nXS4gRXZlcnkgZW5jb2RpbmcgZnVuY3Rpb24gaGFzIGEgY29ycmVzcG9uZGluZyBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBFbmNvZGVzIG51bWJlcnMgaW4gbGl0dGxlLWVuZGlhbiBvcmRlciAobGVhc3QgdG8gbW9zdCBzaWduaWZpY2FudCBieXRlIG9yZGVyKVxuICogYW5kIGlzIGNvbXBhdGlibGUgd2l0aCBHb2xhbmcncyBiaW5hcnkgZW5jb2RpbmcgKGh0dHBzOi8vZ29sYW5nLm9yZy9wa2cvZW5jb2RpbmcvYmluYXJ5LylcbiAqIHdoaWNoIGlzIGFsc28gdXNlZCBpbiBQcm90b2NvbCBCdWZmZXJzLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBlbmNvZGluZyBzdGVwXG4gKiBjb25zdCBlbmNvZGVyID0gbmV3IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IG5ldyBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG4vKipcbiAqIEEgRGVjb2RlciBoYW5kbGVzIHRoZSBkZWNvZGluZyBvZiBhbiBVaW50OEFycmF5LlxuICovXG5jbGFzcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheSBCaW5hcnkgZGF0YSB0byBkZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSB1aW50OEFycmF5O1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGVjb2RpbmcgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtEZWNvZGVyfVxuICovXG5jb25zdCBjcmVhdGVEZWNvZGVyID0gdWludDhBcnJheSA9PiBuZXcgRGVjb2Rlcih1aW50OEFycmF5KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzQ29udGVudCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MgIT09IGRlY29kZXIuYXJyLmxlbmd0aDtcblxuLyoqXG4gKiBDbG9uZSBhIGRlY29kZXIgaW5zdGFuY2UuXG4gKiBPcHRpb25hbGx5IHNldCBhIG5ldyBwb3NpdGlvbiBwYXJhbWV0ZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbmV3UG9zXSBEZWZhdWx0cyB0byBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtEZWNvZGVyfSBBIGNsb25lIG9mIGBkZWNvZGVyYFxuICovXG5jb25zdCBjbG9uZSA9IChkZWNvZGVyLCBuZXdQb3MgPSBkZWNvZGVyLnBvcykgPT4ge1xuICBjb25zdCBfZGVjb2RlciA9IGNyZWF0ZURlY29kZXIoZGVjb2Rlci5hcnIpO1xuICBfZGVjb2Rlci5wb3MgPSBuZXdQb3M7XG4gIHJldHVybiBfZGVjb2RlclxufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyKGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pO1xuICBkZWNvZGVyLnBvcyArPSBsZW47XG4gIHJldHVybiB2aWV3XG59O1xuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpO1xuXG4vKipcbiAqIFJlYWQgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCByZWFkVGFpbEFzVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgZGVjb2Rlci5hcnIubGVuZ3RoIC0gZGVjb2Rlci5wb3MpO1xuXG4vKipcbiAqIFNraXAgb25lIGJ5dGUsIGp1bXAgdG8gdGhlIG5leHQgcG9zaXRpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBwb3NpdGlvblxuICovXG5jb25zdCBza2lwOCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MrKztcblxuLyoqXG4gKiBSZWFkIG9uZSBieXRlIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmNvbnN0IHJlYWRVaW50OCA9IGRlY29kZXIgPT4gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK107XG5cbi8qKlxuICogUmVhZCAyIGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuY29uc3QgcmVhZFVpbnQxNiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpO1xuICBkZWNvZGVyLnBvcyArPSAyO1xuICByZXR1cm4gdWludFxufTtcblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5jb25zdCByZWFkVWludDMyID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQgPVxuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAyXSA8PCAxNikgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDNdIDw8IDI0KSkgPj4+IDA7XG4gIGRlY29kZXIucG9zICs9IDQ7XG4gIHJldHVybiB1aW50XG59O1xuXG4vKipcbiAqIFJlYWQgNCBieXRlcyBhcyB1bnNpZ25lZCBpbnRlZ2VyIGluIGJpZyBlbmRpYW4gb3JkZXIuXG4gKiAobW9zdCBzaWduaWZpY2FudCBieXRlIGZpcnN0KVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmNvbnN0IHJlYWRVaW50MzJCaWdFbmRpYW4gPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDgpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCAxNikgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gPDwgMjQpKSA+Pj4gMDtcbiAgZGVjb2Rlci5wb3MgKz0gNDtcbiAgcmV0dXJuIHVpbnRcbn07XG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5jb25zdCBwZWVrVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zXTtcblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmNvbnN0IHBlZWtVaW50MTYgPSBkZWNvZGVyID0+XG4gIGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpO1xuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuY29uc3QgcGVla1VpbnQzMiA9IGRlY29kZXIgPT4gKFxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDNdIDw8IDI0KVxuKSA+Pj4gMDtcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDA7XG4gIGxldCBsZW4gPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgICBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbik7XG4gICAgbGVuICs9IDc7XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIG51bSA+Pj4gMCAvLyByZXR1cm4gdW5zaWduZWQgbnVtYmVyIVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAobGVuID4gMzUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBvdXQgb2YgcmFuZ2UhJylcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIG51bWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmNvbnN0IHJlYWRWYXJJbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgbGV0IG51bSA9IHIgJiBiaW5hcnkuQklUUzY7XG4gIGxldCBsZW4gPSA2O1xuICBjb25zdCBzaWduID0gKHIgJiBiaW5hcnkuQklUNykgPiAwID8gLTEgOiAxO1xuICBpZiAoKHIgJiBiaW5hcnkuQklUOCkgPT09IDApIHtcbiAgICAvLyBkb24ndCBjb250aW51ZSByZWFkaW5nXG4gICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHIgPSBkZWNvZGVyLmFycltkZWNvZGVyLnBvcysrXTtcbiAgICBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbik7XG4gICAgbGVuICs9IDc7XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIHNpZ24gKiAobnVtID4+PiAwKVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAobGVuID4gNDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZWdlciBvdXQgb2YgcmFuZ2UhJylcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJVaW50IHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgcGVla1ZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3M7XG4gIGNvbnN0IHMgPSByZWFkVmFyVWludChkZWNvZGVyKTtcbiAgZGVjb2Rlci5wb3MgPSBwb3M7XG4gIHJldHVybiBzXG59O1xuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyVWludCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHBlZWtWYXJJbnQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgcG9zID0gZGVjb2Rlci5wb3M7XG4gIGNvbnN0IHMgPSByZWFkVmFySW50KGRlY29kZXIpO1xuICBkZWNvZGVyLnBvcyA9IHBvcztcbiAgcmV0dXJuIHNcbn07XG5cbi8qKlxuICogUmVhZCBzdHJpbmcgb2YgdmFyaWFibGUgbGVuZ3RoXG4gKiAqIHZhclVpbnQgaXMgdXNlZCB0byBzdG9yZSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmdcbiAqXG4gKiBUcmFuc2Zvcm1pbmcgdXRmOCB0byBhIHN0cmluZyBpcyBwcmV0dHkgZXhwZW5zaXZlLiBUaGUgY29kZSBwZXJmb3JtcyAxMHggYmV0dGVyXG4gKiB3aGVuIFN0cmluZy5mcm9tQ29kZVBvaW50IGlzIGZlZCB3aXRoIGFsbCBjaGFyYWN0ZXJzIGFzIGFyZ3VtZW50cy5cbiAqIEJ1dCBtb3N0IGVudmlyb25tZW50cyBoYXZlIGEgbWF4aW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHBlciBmdW5jdGlvbnMuXG4gKiBGb3IgZWZmaWVuY3kgcmVhc29ucyB3ZSBhcHBseSBhIG1heGltdW0gb2YgMTAwMDAgY2hhcmFjdGVycyBhdCBvbmNlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZy5cbiAqL1xuY29uc3QgcmVhZFZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBsZXQgcmVtYWluaW5nTGVuID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gIGlmIChyZW1haW5pbmdMZW4gPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW5jb2RlZFN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSk7IC8vIHJlbWVtYmVyIHRvIGRlY3JlYXNlIHJlbWFpbmluZ0xlblxuICAgIGlmICgtLXJlbWFpbmluZ0xlbiA8IDEwMCkgeyAvLyBkbyBub3QgY3JlYXRlIGEgVWludDhBcnJheSBmb3Igc21hbGwgc3RyaW5nc1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbi0tKSB7XG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dExlbiA9IHJlbWFpbmluZ0xlbiA8IDEwMDAwID8gcmVtYWluaW5nTGVuIDogMTAwMDA7XG4gICAgICAgIC8vIHRoaXMgaXMgZGFuZ2Vyb3VzLCB3ZSBjcmVhdGUgYSBmcmVzaCBhcnJheSB2aWV3IGZyb20gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZXIuYXJyLnN1YmFycmF5KGRlY29kZXIucG9zLCBkZWNvZGVyLnBvcyArIG5leHRMZW4pO1xuICAgICAgICBkZWNvZGVyLnBvcyArPSBuZXh0TGVuO1xuICAgICAgICAvLyBTdGFydGluZyB3aXRoIEVTNS4xIHdlIGNhbiBzdXBwbHkgYSBnZW5lcmljIGFycmF5LWxpa2Ugb2JqZWN0IGFzIGFyZ3VtZW50c1xuICAgICAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKTtcbiAgICAgICAgcmVtYWluaW5nTGVuIC09IG5leHRMZW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxuICB9XG59O1xuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyU3RyaW5nIHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgcGVla1ZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvcztcbiAgY29uc3QgcyA9IHJlYWRWYXJTdHJpbmcoZGVjb2Rlcik7XG4gIGRlY29kZXIucG9zID0gcG9zO1xuICByZXR1cm4gc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm4ge0RhdGFWaWV3fVxuICovXG5jb25zdCByZWFkRnJvbURhdGFWaWV3ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhkZWNvZGVyLmFyci5idWZmZXIsIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQgKyBkZWNvZGVyLnBvcywgbGVuKTtcbiAgZGVjb2Rlci5wb3MgKz0gbGVuO1xuICByZXR1cm4gZHZcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmNvbnN0IHJlYWRGbG9hdDMyID0gZGVjb2RlciA9PiByZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDQpLmdldEZsb2F0MzIoMCwgZmFsc2UpO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5jb25zdCByZWFkRmxvYXQ2NCA9IGRlY29kZXIgPT4gcmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KS5nZXRGbG9hdDY0KDAsIGZhbHNlKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuY29uc3QgcmVhZEJpZ0ludDY0ID0gZGVjb2RlciA9PiAvKiogQHR5cGUge2FueX0gKi8gKHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkpLmdldEJpZ0ludDY0KDAsIGZhbHNlKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuY29uc3QgcmVhZEJpZ1VpbnQ2NCA9IGRlY29kZXIgPT4gLyoqIEB0eXBlIHthbnl9ICovIChyZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpKS5nZXRCaWdVaW50NjQoMCwgZmFsc2UpO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihEZWNvZGVyKTphbnk+fVxuICovXG5jb25zdCByZWFkQW55TG9va3VwVGFibGUgPSBbXG4gIGRlY29kZXIgPT4gdW5kZWZpbmVkLCAvLyBDQVNFIDEyNzogdW5kZWZpbmVkXG4gIGRlY29kZXIgPT4gbnVsbCwgLy8gQ0FTRSAxMjY6IG51bGxcbiAgcmVhZFZhckludCwgLy8gQ0FTRSAxMjU6IGludGVnZXJcbiAgcmVhZEZsb2F0MzIsIC8vIENBU0UgMTI0OiBmbG9hdDMyXG4gIHJlYWRGbG9hdDY0LCAvLyBDQVNFIDEyMzogZmxvYXQ2NFxuICByZWFkQmlnSW50NjQsIC8vIENBU0UgMTIyOiBiaWdpbnRcbiAgZGVjb2RlciA9PiBmYWxzZSwgLy8gQ0FTRSAxMjE6IGJvb2xlYW4gKGZhbHNlKVxuICBkZWNvZGVyID0+IHRydWUsIC8vIENBU0UgMTIwOiBib29sZWFuICh0cnVlKVxuICByZWFkVmFyU3RyaW5nLCAvLyBDQVNFIDExOTogc3RyaW5nXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExODogb2JqZWN0PHN0cmluZyxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSByZWFkVmFyU3RyaW5nKGRlY29kZXIpO1xuICAgICAgb2JqW2tleV0gPSByZWFkQW55KGRlY29kZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH0sXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExNzogYXJyYXk8YW55PlxuICAgIGNvbnN0IGxlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpO1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKHJlYWRBbnkoZGVjb2RlcikpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH0sXG4gIHJlYWRWYXJVaW50OEFycmF5IC8vIENBU0UgMTE2OiBVaW50OEFycmF5XG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5jb25zdCByZWFkQW55ID0gZGVjb2RlciA9PiByZWFkQW55TG9va3VwVGFibGVbMTI3IC0gcmVhZFVpbnQ4KGRlY29kZXIpXShkZWNvZGVyKTtcblxuLyoqXG4gKiBUIG11c3Qgbm90IGJlIG51bGwuXG4gKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuY2xhc3MgUmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRGVjb2Rlcik6VH0gcmVhZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgcmVhZGVyKSB7XG4gICAgc3VwZXIodWludDhBcnJheSk7XG4gICAgLyoqXG4gICAgICogVGhlIHJlYWRlclxuICAgICAqL1xuICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGw7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gdGhpcy5yZWFkZXIodGhpcyk7XG4gICAgICBpZiAoaGFzQ29udGVudCh0aGlzKSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAxOyAvLyBzZWUgZW5jb2RlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHJlYXNvbiB3aHkgdGhpcyBpcyBpbmNyZW1lbnRlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IC0xOyAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tO1xuICAgIHJldHVybiAvKiogQHR5cGUge1R9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuY2xhc3MgSW50RGlmZkRlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCBzdGFydCkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIHRoaXMucyArPSByZWFkVmFySW50KHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnNcbiAgfVxufVxuXG5jbGFzcyBSbGVJbnREaWZmRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXksIHN0YXJ0KSB7XG4gICAgc3VwZXIodWludDhBcnJheSk7XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnQ7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyArPSByZWFkVmFySW50KHRoaXMpO1xuICAgICAgaWYgKGhhc0NvbnRlbnQodGhpcykpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMTsgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMTsgLy8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSBmb3JldmVyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuY2xhc3MgVWludE9wdFJsZURlY29kZXIgZXh0ZW5kcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDA7XG4gICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cblxuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zID0gcmVhZFZhckludCh0aGlzKTtcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpO1xuICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICB0aGlzLnMgPSAtdGhpcy5zO1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS07XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmNsYXNzIEluY1VpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcyk7XG4gICAgICAvLyBpZiB0aGUgc2lnbiBpcyBuZWdhdGl2ZSwgd2UgcmVhZCB0aGUgY291bnQgdG9vLCBvdGhlcndpc2UgY291bnQgaXMgMVxuICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8odGhpcy5zKTtcbiAgICAgIHRoaXMuY291bnQgPSAxO1xuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMucztcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tO1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucysrKVxuICB9XG59XG5cbmNsYXNzIEludERpZmZPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMuZGlmZiA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIGNvbnN0IGRpZmYgPSByZWFkVmFySW50KHRoaXMpO1xuICAgICAgLy8gaWYgdGhlIGZpcnN0IGJpdCBpcyBzZXQsIHdlIHJlYWQgbW9yZSBkYXRhXG4gICAgICBjb25zdCBoYXNDb3VudCA9IGRpZmYgJiAxO1xuICAgICAgdGhpcy5kaWZmID0gZGlmZiA+PiAxO1xuICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICBpZiAoaGFzQ291bnQpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zICs9IHRoaXMuZGlmZjtcbiAgICB0aGlzLmNvdW50LS07XG4gICAgcmV0dXJuIHRoaXMuc1xuICB9XG59XG5cbmNsYXNzIFN0cmluZ0RlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBVaW50T3B0UmxlRGVjb2Rlcih1aW50OEFycmF5KTtcbiAgICB0aGlzLnN0ciA9IHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3BvcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5zcG9zICsgdGhpcy5kZWNvZGVyLnJlYWQoKTtcbiAgICBjb25zdCByZXMgPSB0aGlzLnN0ci5zbGljZSh0aGlzLnNwb3MsIGVuZCk7XG4gICAgdGhpcy5zcG9zID0gZW5kO1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG52YXIgZGVjb2RpbmcgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgRGVjb2RlcjogRGVjb2RlcixcbiAgY3JlYXRlRGVjb2RlcjogY3JlYXRlRGVjb2RlcixcbiAgaGFzQ29udGVudDogaGFzQ29udGVudCxcbiAgY2xvbmU6IGNsb25lLFxuICByZWFkVWludDhBcnJheTogcmVhZFVpbnQ4QXJyYXksXG4gIHJlYWRWYXJVaW50OEFycmF5OiByZWFkVmFyVWludDhBcnJheSxcbiAgcmVhZFRhaWxBc1VpbnQ4QXJyYXk6IHJlYWRUYWlsQXNVaW50OEFycmF5LFxuICBza2lwODogc2tpcDgsXG4gIHJlYWRVaW50ODogcmVhZFVpbnQ4LFxuICByZWFkVWludDE2OiByZWFkVWludDE2LFxuICByZWFkVWludDMyOiByZWFkVWludDMyLFxuICByZWFkVWludDMyQmlnRW5kaWFuOiByZWFkVWludDMyQmlnRW5kaWFuLFxuICBwZWVrVWludDg6IHBlZWtVaW50OCxcbiAgcGVla1VpbnQxNjogcGVla1VpbnQxNixcbiAgcGVla1VpbnQzMjogcGVla1VpbnQzMixcbiAgcmVhZFZhclVpbnQ6IHJlYWRWYXJVaW50LFxuICByZWFkVmFySW50OiByZWFkVmFySW50LFxuICBwZWVrVmFyVWludDogcGVla1ZhclVpbnQsXG4gIHBlZWtWYXJJbnQ6IHBlZWtWYXJJbnQsXG4gIHJlYWRWYXJTdHJpbmc6IHJlYWRWYXJTdHJpbmcsXG4gIHBlZWtWYXJTdHJpbmc6IHBlZWtWYXJTdHJpbmcsXG4gIHJlYWRGcm9tRGF0YVZpZXc6IHJlYWRGcm9tRGF0YVZpZXcsXG4gIHJlYWRGbG9hdDMyOiByZWFkRmxvYXQzMixcbiAgcmVhZEZsb2F0NjQ6IHJlYWRGbG9hdDY0LFxuICByZWFkQmlnSW50NjQ6IHJlYWRCaWdJbnQ2NCxcbiAgcmVhZEJpZ1VpbnQ2NDogcmVhZEJpZ1VpbnQ2NCxcbiAgcmVhZEFueTogcmVhZEFueSxcbiAgUmxlRGVjb2RlcjogUmxlRGVjb2RlcixcbiAgSW50RGlmZkRlY29kZXI6IEludERpZmZEZWNvZGVyLFxuICBSbGVJbnREaWZmRGVjb2RlcjogUmxlSW50RGlmZkRlY29kZXIsXG4gIFVpbnRPcHRSbGVEZWNvZGVyOiBVaW50T3B0UmxlRGVjb2RlcixcbiAgSW5jVWludE9wdFJsZURlY29kZXI6IEluY1VpbnRPcHRSbGVEZWNvZGVyLFxuICBJbnREaWZmT3B0UmxlRGVjb2RlcjogSW50RGlmZk9wdFJsZURlY29kZXIsXG4gIFN0cmluZ0RlY29kZXI6IFN0cmluZ0RlY29kZXJcbn0pO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aCBidWZmZXJzIChVaW50OEFycmF5KS5cbiAqXG4gKiBAbW9kdWxlIGJ1ZmZlclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICovXG5jb25zdCBjcmVhdGVVaW50OEFycmF5RnJvbUxlbiA9IGxlbiA9PiBuZXcgVWludDhBcnJheShsZW4pO1xuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZU9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5jb25zdCBjcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlciA9IChidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aCkgPT4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuXG4vKipcbiAqIENyZWF0ZSBVaW50OEFycmF5IHdpdGggaW5pdGlhbCBjb250ZW50IGZyb20gYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmZmVyXG4gKi9cbmNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NEJyb3dzZXIgPSBieXRlcyA9PiB7XG4gIGxldCBzID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgcyArPSBzdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuIGJ0b2Eocylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NE5vZGUgPSBieXRlcyA9PiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGZyb21CYXNlNjRCcm93c2VyID0gcyA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBjb25zdCBhID0gYXRvYihzKTtcbiAgY29uc3QgYnl0ZXMgPSBjcmVhdGVVaW50OEFycmF5RnJvbUxlbihhLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBieXRlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICovXG5jb25zdCBmcm9tQmFzZTY0Tm9kZSA9IHMgPT4ge1xuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzLCAnYmFzZTY0Jyk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgdG9CYXNlNjQgPSBlbnZpcm9ubWVudC5pc0Jyb3dzZXIgPyB0b0Jhc2U2NEJyb3dzZXIgOiB0b0Jhc2U2NE5vZGU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBmcm9tQmFzZTY0ID0gZW52aXJvbm1lbnQuaXNCcm93c2VyID8gZnJvbUJhc2U2NEJyb3dzZXIgOiBmcm9tQmFzZTY0Tm9kZTtcblxuLyoqXG4gKiBDb3B5IHRoZSBjb250ZW50IG9mIGFuIFVpbnQ4QXJyYXkgdmlldyB0byBhIG5ldyBBcnJheUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGNvcHlVaW50OEFycmF5ID0gdWludDhBcnJheSA9PiB7XG4gIGNvbnN0IG5ld0J1ZiA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuKHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aCk7XG4gIG5ld0J1Zi5zZXQodWludDhBcnJheSk7XG4gIHJldHVybiBuZXdCdWZcbn07XG5cbi8qKlxuICogRW5jb2RlIGFueXRoaW5nIGFzIGEgVUludDhBcnJheS4gSXQncyBhIHB1biBvbiB0eXBlc2NyaXB0cydzIGBhbnlgIHR5cGUuXG4gKiBTZWUgZW5jb2Rpbmcud3JpdGVBbnkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZUFueSA9IGRhdGEgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICB3cml0ZUFueShlbmNvZGVyLCBkYXRhKTtcbiAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYW4gYW55LWVuY29kZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgZGVjb2RlQW55ID0gYnVmID0+IHJlYWRBbnkoY3JlYXRlRGVjb2RlcihidWYpKTtcblxudmFyIGJ1ZmZlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGVVaW50OEFycmF5RnJvbUxlbjogY3JlYXRlVWludDhBcnJheUZyb21MZW4sXG4gIGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyOiBjcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcixcbiAgY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlcjogY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlcixcbiAgdG9CYXNlNjQ6IHRvQmFzZTY0LFxuICBmcm9tQmFzZTY0OiBmcm9tQmFzZTY0LFxuICBjb3B5VWludDhBcnJheTogY29weVVpbnQ4QXJyYXksXG4gIGVuY29kZUFueTogZW5jb2RlQW55LFxuICBkZWNvZGVBbnk6IGRlY29kZUFueVxufSk7XG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuZXhwb3J0cy5JbmNVaW50T3B0UmxlRGVjb2RlciA9IEluY1VpbnRPcHRSbGVEZWNvZGVyO1xuZXhwb3J0cy5JbmNVaW50T3B0UmxlRW5jb2RlciA9IEluY1VpbnRPcHRSbGVFbmNvZGVyO1xuZXhwb3J0cy5JbnREaWZmRGVjb2RlciA9IEludERpZmZEZWNvZGVyO1xuZXhwb3J0cy5JbnREaWZmRW5jb2RlciA9IEludERpZmZFbmNvZGVyO1xuZXhwb3J0cy5JbnREaWZmT3B0UmxlRGVjb2RlciA9IEludERpZmZPcHRSbGVEZWNvZGVyO1xuZXhwb3J0cy5JbnREaWZmT3B0UmxlRW5jb2RlciA9IEludERpZmZPcHRSbGVFbmNvZGVyO1xuZXhwb3J0cy5SbGVEZWNvZGVyID0gUmxlRGVjb2RlcjtcbmV4cG9ydHMuUmxlRW5jb2RlciA9IFJsZUVuY29kZXI7XG5leHBvcnRzLlJsZUludERpZmZEZWNvZGVyID0gUmxlSW50RGlmZkRlY29kZXI7XG5leHBvcnRzLlJsZUludERpZmZFbmNvZGVyID0gUmxlSW50RGlmZkVuY29kZXI7XG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZXhwb3J0cy5TdHJpbmdFbmNvZGVyID0gU3RyaW5nRW5jb2RlcjtcbmV4cG9ydHMuVWludE9wdFJsZURlY29kZXIgPSBVaW50T3B0UmxlRGVjb2RlcjtcbmV4cG9ydHMuVWludE9wdFJsZUVuY29kZXIgPSBVaW50T3B0UmxlRW5jb2RlcjtcbmV4cG9ydHMuYnVmZmVyID0gYnVmZmVyO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5jb3B5VWludDhBcnJheSA9IGNvcHlVaW50OEFycmF5O1xuZXhwb3J0cy5jcmVhdGVEZWNvZGVyID0gY3JlYXRlRGVjb2RlcjtcbmV4cG9ydHMuY3JlYXRlRW5jb2RlciA9IGNyZWF0ZUVuY29kZXI7XG5leHBvcnRzLmNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIgPSBjcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyO1xuZXhwb3J0cy5jcmVhdGVVaW50OEFycmF5RnJvbUxlbiA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuO1xuZXhwb3J0cy5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlciA9IGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyO1xuZXhwb3J0cy5kZWNvZGVBbnkgPSBkZWNvZGVBbnk7XG5leHBvcnRzLmRlY29kaW5nID0gZGVjb2Rpbmc7XG5leHBvcnRzLmVuY29kZUFueSA9IGVuY29kZUFueTtcbmV4cG9ydHMuZW5jb2RpbmcgPSBlbmNvZGluZztcbmV4cG9ydHMuZnJvbUJhc2U2NCA9IGZyb21CYXNlNjQ7XG5leHBvcnRzLmhhc0NvbnRlbnQgPSBoYXNDb250ZW50O1xuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLnBlZWtVaW50MTYgPSBwZWVrVWludDE2O1xuZXhwb3J0cy5wZWVrVWludDMyID0gcGVla1VpbnQzMjtcbmV4cG9ydHMucGVla1VpbnQ4ID0gcGVla1VpbnQ4O1xuZXhwb3J0cy5wZWVrVmFySW50ID0gcGVla1ZhckludDtcbmV4cG9ydHMucGVla1ZhclN0cmluZyA9IHBlZWtWYXJTdHJpbmc7XG5leHBvcnRzLnBlZWtWYXJVaW50ID0gcGVla1ZhclVpbnQ7XG5leHBvcnRzLnJlYWRBbnkgPSByZWFkQW55O1xuZXhwb3J0cy5yZWFkQmlnSW50NjQgPSByZWFkQmlnSW50NjQ7XG5leHBvcnRzLnJlYWRCaWdVaW50NjQgPSByZWFkQmlnVWludDY0O1xuZXhwb3J0cy5yZWFkRmxvYXQzMiA9IHJlYWRGbG9hdDMyO1xuZXhwb3J0cy5yZWFkRmxvYXQ2NCA9IHJlYWRGbG9hdDY0O1xuZXhwb3J0cy5yZWFkRnJvbURhdGFWaWV3ID0gcmVhZEZyb21EYXRhVmlldztcbmV4cG9ydHMucmVhZFRhaWxBc1VpbnQ4QXJyYXkgPSByZWFkVGFpbEFzVWludDhBcnJheTtcbmV4cG9ydHMucmVhZFVpbnQxNiA9IHJlYWRVaW50MTY7XG5leHBvcnRzLnJlYWRVaW50MzIgPSByZWFkVWludDMyO1xuZXhwb3J0cy5yZWFkVWludDMyQmlnRW5kaWFuID0gcmVhZFVpbnQzMkJpZ0VuZGlhbjtcbmV4cG9ydHMucmVhZFVpbnQ4ID0gcmVhZFVpbnQ4O1xuZXhwb3J0cy5yZWFkVWludDhBcnJheSA9IHJlYWRVaW50OEFycmF5O1xuZXhwb3J0cy5yZWFkVmFySW50ID0gcmVhZFZhckludDtcbmV4cG9ydHMucmVhZFZhclN0cmluZyA9IHJlYWRWYXJTdHJpbmc7XG5leHBvcnRzLnJlYWRWYXJVaW50ID0gcmVhZFZhclVpbnQ7XG5leHBvcnRzLnJlYWRWYXJVaW50OEFycmF5ID0gcmVhZFZhclVpbnQ4QXJyYXk7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMuc2V0VWludDE2ID0gc2V0VWludDE2O1xuZXhwb3J0cy5zZXRVaW50MzIgPSBzZXRVaW50MzI7XG5leHBvcnRzLnNldFVpbnQ4ID0gc2V0VWludDg7XG5leHBvcnRzLnNraXA4ID0gc2tpcDg7XG5leHBvcnRzLnRvQmFzZTY0ID0gdG9CYXNlNjQ7XG5leHBvcnRzLnRvVWludDhBcnJheSA9IHRvVWludDhBcnJheTtcbmV4cG9ydHMud3JpdGUgPSB3cml0ZTtcbmV4cG9ydHMud3JpdGVBbnkgPSB3cml0ZUFueTtcbmV4cG9ydHMud3JpdGVCaWdJbnQ2NCA9IHdyaXRlQmlnSW50NjQ7XG5leHBvcnRzLndyaXRlQmlnVWludDY0ID0gd3JpdGVCaWdVaW50NjQ7XG5leHBvcnRzLndyaXRlQmluYXJ5RW5jb2RlciA9IHdyaXRlQmluYXJ5RW5jb2RlcjtcbmV4cG9ydHMud3JpdGVGbG9hdDMyID0gd3JpdGVGbG9hdDMyO1xuZXhwb3J0cy53cml0ZUZsb2F0NjQgPSB3cml0ZUZsb2F0NjQ7XG5leHBvcnRzLndyaXRlT25EYXRhVmlldyA9IHdyaXRlT25EYXRhVmlldztcbmV4cG9ydHMud3JpdGVVaW50MTYgPSB3cml0ZVVpbnQxNjtcbmV4cG9ydHMud3JpdGVVaW50MzIgPSB3cml0ZVVpbnQzMjtcbmV4cG9ydHMud3JpdGVVaW50MzJCaWdFbmRpYW4gPSB3cml0ZVVpbnQzMkJpZ0VuZGlhbjtcbmV4cG9ydHMud3JpdGVVaW50OCA9IHdyaXRlVWludDg7XG5leHBvcnRzLndyaXRlVWludDhBcnJheSA9IHdyaXRlVWludDhBcnJheTtcbmV4cG9ydHMud3JpdGVWYXJJbnQgPSB3cml0ZVZhckludDtcbmV4cG9ydHMud3JpdGVWYXJTdHJpbmcgPSB3cml0ZVZhclN0cmluZztcbmV4cG9ydHMud3JpdGVWYXJVaW50ID0gd3JpdGVWYXJVaW50O1xuZXhwb3J0cy53cml0ZVZhclVpbnQ4QXJyYXkgPSB3cml0ZVZhclVpbnQ4QXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXItYWMyY2RlZGYuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/buffer-ac2cdedf.cjs\n")},"./node_modules/lib0/dist/buffer.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n__webpack_require__(/*! ./string-f3c3d805.cjs */ "./node_modules/lib0/dist/string-f3c3d805.cjs");\n__webpack_require__(/*! ./environment-7e2ffaea.cjs */ "./node_modules/lib0/dist/environment-7e2ffaea.cjs");\nvar encoding = __webpack_require__(/*! ./buffer-ac2cdedf.cjs */ "./node_modules/lib0/dist/buffer-ac2cdedf.cjs");\n__webpack_require__(/*! ./map-28a001c9.cjs */ "./node_modules/lib0/dist/map-28a001c9.cjs");\n__webpack_require__(/*! ./conditions-fb475c70.cjs */ "./node_modules/lib0/dist/conditions-fb475c70.cjs");\n__webpack_require__(/*! ./storage.cjs */ "./node_modules/lib0/dist/storage.cjs");\n__webpack_require__(/*! ./binary-ac8e39e2.cjs */ "./node_modules/lib0/dist/binary-ac8e39e2.cjs");\n__webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\n__webpack_require__(/*! ./number-24f1eabe.cjs */ "./node_modules/lib0/dist/number-24f1eabe.cjs");\n\n\n\nexports.copyUint8Array = encoding.copyUint8Array;\nexports.createUint8ArrayFromArrayBuffer = encoding.createUint8ArrayFromArrayBuffer;\nexports.createUint8ArrayFromLen = encoding.createUint8ArrayFromLen;\nexports.createUint8ArrayViewFromArrayBuffer = encoding.createUint8ArrayViewFromArrayBuffer;\nexports.decodeAny = encoding.decodeAny;\nexports.encodeAny = encoding.encodeAny;\nexports.fromBase64 = encoding.fromBase64;\nexports.toBase64 = encoding.toBase64;\n//# sourceMappingURL=buffer.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9idWZmZXIuY2pzP2U0ZTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxtQkFBTyxDQUFDLDJFQUF1QjtBQUMvQixtQkFBTyxDQUFDLHFGQUE0QjtBQUNwQyxlQUFlLG1CQUFPLENBQUMsMkVBQXVCO0FBQzlDLG1CQUFPLENBQUMscUVBQW9CO0FBQzVCLG1CQUFPLENBQUMsbUZBQTJCO0FBQ25DLG1CQUFPLENBQUMsMkRBQWU7QUFDdkIsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQywyRUFBdUI7Ozs7QUFJL0Isc0JBQXNCO0FBQ3RCLHVDQUF1QztBQUN2QywrQkFBK0I7QUFDL0IsMkNBQTJDO0FBQzNDLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvYnVmZmVyLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnLi9zdHJpbmctZjNjM2Q4MDUuY2pzJyk7XG5yZXF1aXJlKCcuL2Vudmlyb25tZW50LTdlMmZmYWVhLmNqcycpO1xudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9idWZmZXItYWMyY2RlZGYuY2pzJyk7XG5yZXF1aXJlKCcuL21hcC0yOGEwMDFjOS5janMnKTtcbnJlcXVpcmUoJy4vY29uZGl0aW9ucy1mYjQ3NWM3MC5janMnKTtcbnJlcXVpcmUoJy4vc3RvcmFnZS5janMnKTtcbnJlcXVpcmUoJy4vYmluYXJ5LWFjOGUzOWUyLmNqcycpO1xucmVxdWlyZSgnLi9tYXRoLTA4ZTA2OGY5LmNqcycpO1xucmVxdWlyZSgnLi9udW1iZXItMjRmMWVhYmUuY2pzJyk7XG5cblxuXG5leHBvcnRzLmNvcHlVaW50OEFycmF5ID0gZW5jb2RpbmcuY29weVVpbnQ4QXJyYXk7XG5leHBvcnRzLmNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIgPSBlbmNvZGluZy5jcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyO1xuZXhwb3J0cy5jcmVhdGVVaW50OEFycmF5RnJvbUxlbiA9IGVuY29kaW5nLmNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuO1xuZXhwb3J0cy5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlciA9IGVuY29kaW5nLmNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyO1xuZXhwb3J0cy5kZWNvZGVBbnkgPSBlbmNvZGluZy5kZWNvZGVBbnk7XG5leHBvcnRzLmVuY29kZUFueSA9IGVuY29kaW5nLmVuY29kZUFueTtcbmV4cG9ydHMuZnJvbUJhc2U2NCA9IGVuY29kaW5nLmZyb21CYXNlNjQ7XG5leHBvcnRzLnRvQmFzZTY0ID0gZW5jb2RpbmcudG9CYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWZmZXIuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/buffer.cjs\n')},"./node_modules/lib0/dist/conditions-fb475c70.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nconst undefinedToNull = v => v === undefined ? null : v;\n\nvar conditions = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tundefinedToNull: undefinedToNull\n});\n\nexports.conditions = conditions;\nexports.undefinedToNull = undefinedToNull;\n//# sourceMappingURL=conditions-fb475c70.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9jb25kaXRpb25zLWZiNDc1YzcwLmNqcz80YjQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxrQkFBa0I7QUFDbEIsdUJBQXVCO0FBQ3ZCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9jb25kaXRpb25zLWZiNDc1YzcwLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBPZnRlbiB1c2VkIGNvbmRpdGlvbnMuXG4gKlxuICogQG1vZHVsZSBjb25kaXRpb25zXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfG51bGx8dW5kZWZpbmVkfSB2XG4gKiBAcmV0dXJuIHtUfG51bGx9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmRlZmluZWRUb051bGwgPSB2ID0+IHYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB2O1xuXG52YXIgY29uZGl0aW9ucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHR1bmRlZmluZWRUb051bGw6IHVuZGVmaW5lZFRvTnVsbFxufSk7XG5cbmV4cG9ydHMuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnM7XG5leHBvcnRzLnVuZGVmaW5lZFRvTnVsbCA9IHVuZGVmaW5lZFRvTnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmRpdGlvbnMtZmI0NzVjNzAuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/conditions-fb475c70.cjs\n")},"./node_modules/lib0/dist/decoding.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar encoding = __webpack_require__(/*! ./buffer-ac2cdedf.cjs */ "./node_modules/lib0/dist/buffer-ac2cdedf.cjs");\n__webpack_require__(/*! ./binary-ac8e39e2.cjs */ "./node_modules/lib0/dist/binary-ac8e39e2.cjs");\n__webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\n__webpack_require__(/*! ./string-f3c3d805.cjs */ "./node_modules/lib0/dist/string-f3c3d805.cjs");\n__webpack_require__(/*! ./environment-7e2ffaea.cjs */ "./node_modules/lib0/dist/environment-7e2ffaea.cjs");\n__webpack_require__(/*! ./map-28a001c9.cjs */ "./node_modules/lib0/dist/map-28a001c9.cjs");\n__webpack_require__(/*! ./conditions-fb475c70.cjs */ "./node_modules/lib0/dist/conditions-fb475c70.cjs");\n__webpack_require__(/*! ./storage.cjs */ "./node_modules/lib0/dist/storage.cjs");\n__webpack_require__(/*! ./number-24f1eabe.cjs */ "./node_modules/lib0/dist/number-24f1eabe.cjs");\n\n\n\nexports.Decoder = encoding.Decoder;\nexports.IncUintOptRleDecoder = encoding.IncUintOptRleDecoder;\nexports.IntDiffDecoder = encoding.IntDiffDecoder;\nexports.IntDiffOptRleDecoder = encoding.IntDiffOptRleDecoder;\nexports.RleDecoder = encoding.RleDecoder;\nexports.RleIntDiffDecoder = encoding.RleIntDiffDecoder;\nexports.StringDecoder = encoding.StringDecoder;\nexports.UintOptRleDecoder = encoding.UintOptRleDecoder;\nexports.clone = encoding.clone;\nexports.createDecoder = encoding.createDecoder;\nexports.hasContent = encoding.hasContent;\nexports.peekUint16 = encoding.peekUint16;\nexports.peekUint32 = encoding.peekUint32;\nexports.peekUint8 = encoding.peekUint8;\nexports.peekVarInt = encoding.peekVarInt;\nexports.peekVarString = encoding.peekVarString;\nexports.peekVarUint = encoding.peekVarUint;\nexports.readAny = encoding.readAny;\nexports.readBigInt64 = encoding.readBigInt64;\nexports.readBigUint64 = encoding.readBigUint64;\nexports.readFloat32 = encoding.readFloat32;\nexports.readFloat64 = encoding.readFloat64;\nexports.readFromDataView = encoding.readFromDataView;\nexports.readTailAsUint8Array = encoding.readTailAsUint8Array;\nexports.readUint16 = encoding.readUint16;\nexports.readUint32 = encoding.readUint32;\nexports.readUint32BigEndian = encoding.readUint32BigEndian;\nexports.readUint8 = encoding.readUint8;\nexports.readUint8Array = encoding.readUint8Array;\nexports.readVarInt = encoding.readVarInt;\nexports.readVarString = encoding.readVarString;\nexports.readVarUint = encoding.readVarUint;\nexports.readVarUint8Array = encoding.readVarUint8Array;\nexports.skip8 = encoding.skip8;\n//# sourceMappingURL=decoding.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9kZWNvZGluZy5janM/NjRlOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELGVBQWUsbUJBQU8sQ0FBQywyRUFBdUI7QUFDOUMsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDNUIsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQywyREFBZTtBQUN2QixtQkFBTyxDQUFDLDJFQUF1Qjs7OztBQUkvQixlQUFlO0FBQ2YsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2RlY29kaW5nLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGVuY29kaW5nID0gcmVxdWlyZSgnLi9idWZmZXItYWMyY2RlZGYuY2pzJyk7XG5yZXF1aXJlKCcuL2JpbmFyeS1hYzhlMzllMi5janMnKTtcbnJlcXVpcmUoJy4vbWF0aC0wOGUwNjhmOS5janMnKTtcbnJlcXVpcmUoJy4vc3RyaW5nLWYzYzNkODA1LmNqcycpO1xucmVxdWlyZSgnLi9lbnZpcm9ubWVudC03ZTJmZmFlYS5janMnKTtcbnJlcXVpcmUoJy4vbWFwLTI4YTAwMWM5LmNqcycpO1xucmVxdWlyZSgnLi9jb25kaXRpb25zLWZiNDc1YzcwLmNqcycpO1xucmVxdWlyZSgnLi9zdG9yYWdlLmNqcycpO1xucmVxdWlyZSgnLi9udW1iZXItMjRmMWVhYmUuY2pzJyk7XG5cblxuXG5leHBvcnRzLkRlY29kZXIgPSBlbmNvZGluZy5EZWNvZGVyO1xuZXhwb3J0cy5JbmNVaW50T3B0UmxlRGVjb2RlciA9IGVuY29kaW5nLkluY1VpbnRPcHRSbGVEZWNvZGVyO1xuZXhwb3J0cy5JbnREaWZmRGVjb2RlciA9IGVuY29kaW5nLkludERpZmZEZWNvZGVyO1xuZXhwb3J0cy5JbnREaWZmT3B0UmxlRGVjb2RlciA9IGVuY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyO1xuZXhwb3J0cy5SbGVEZWNvZGVyID0gZW5jb2RpbmcuUmxlRGVjb2RlcjtcbmV4cG9ydHMuUmxlSW50RGlmZkRlY29kZXIgPSBlbmNvZGluZy5SbGVJbnREaWZmRGVjb2RlcjtcbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGVuY29kaW5nLlN0cmluZ0RlY29kZXI7XG5leHBvcnRzLlVpbnRPcHRSbGVEZWNvZGVyID0gZW5jb2RpbmcuVWludE9wdFJsZURlY29kZXI7XG5leHBvcnRzLmNsb25lID0gZW5jb2RpbmcuY2xvbmU7XG5leHBvcnRzLmNyZWF0ZURlY29kZXIgPSBlbmNvZGluZy5jcmVhdGVEZWNvZGVyO1xuZXhwb3J0cy5oYXNDb250ZW50ID0gZW5jb2RpbmcuaGFzQ29udGVudDtcbmV4cG9ydHMucGVla1VpbnQxNiA9IGVuY29kaW5nLnBlZWtVaW50MTY7XG5leHBvcnRzLnBlZWtVaW50MzIgPSBlbmNvZGluZy5wZWVrVWludDMyO1xuZXhwb3J0cy5wZWVrVWludDggPSBlbmNvZGluZy5wZWVrVWludDg7XG5leHBvcnRzLnBlZWtWYXJJbnQgPSBlbmNvZGluZy5wZWVrVmFySW50O1xuZXhwb3J0cy5wZWVrVmFyU3RyaW5nID0gZW5jb2RpbmcucGVla1ZhclN0cmluZztcbmV4cG9ydHMucGVla1ZhclVpbnQgPSBlbmNvZGluZy5wZWVrVmFyVWludDtcbmV4cG9ydHMucmVhZEFueSA9IGVuY29kaW5nLnJlYWRBbnk7XG5leHBvcnRzLnJlYWRCaWdJbnQ2NCA9IGVuY29kaW5nLnJlYWRCaWdJbnQ2NDtcbmV4cG9ydHMucmVhZEJpZ1VpbnQ2NCA9IGVuY29kaW5nLnJlYWRCaWdVaW50NjQ7XG5leHBvcnRzLnJlYWRGbG9hdDMyID0gZW5jb2RpbmcucmVhZEZsb2F0MzI7XG5leHBvcnRzLnJlYWRGbG9hdDY0ID0gZW5jb2RpbmcucmVhZEZsb2F0NjQ7XG5leHBvcnRzLnJlYWRGcm9tRGF0YVZpZXcgPSBlbmNvZGluZy5yZWFkRnJvbURhdGFWaWV3O1xuZXhwb3J0cy5yZWFkVGFpbEFzVWludDhBcnJheSA9IGVuY29kaW5nLnJlYWRUYWlsQXNVaW50OEFycmF5O1xuZXhwb3J0cy5yZWFkVWludDE2ID0gZW5jb2RpbmcucmVhZFVpbnQxNjtcbmV4cG9ydHMucmVhZFVpbnQzMiA9IGVuY29kaW5nLnJlYWRVaW50MzI7XG5leHBvcnRzLnJlYWRVaW50MzJCaWdFbmRpYW4gPSBlbmNvZGluZy5yZWFkVWludDMyQmlnRW5kaWFuO1xuZXhwb3J0cy5yZWFkVWludDggPSBlbmNvZGluZy5yZWFkVWludDg7XG5leHBvcnRzLnJlYWRVaW50OEFycmF5ID0gZW5jb2RpbmcucmVhZFVpbnQ4QXJyYXk7XG5leHBvcnRzLnJlYWRWYXJJbnQgPSBlbmNvZGluZy5yZWFkVmFySW50O1xuZXhwb3J0cy5yZWFkVmFyU3RyaW5nID0gZW5jb2RpbmcucmVhZFZhclN0cmluZztcbmV4cG9ydHMucmVhZFZhclVpbnQgPSBlbmNvZGluZy5yZWFkVmFyVWludDtcbmV4cG9ydHMucmVhZFZhclVpbnQ4QXJyYXkgPSBlbmNvZGluZy5yZWFkVmFyVWludDhBcnJheTtcbmV4cG9ydHMuc2tpcDggPSBlbmNvZGluZy5za2lwODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kaW5nLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/decoding.cjs\n')},"./node_modules/lib0/dist/dom-58958c04.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar pair = __webpack_require__(/*! ./pair-ab022bc3.cjs */ \"./node_modules/lib0/dist/pair-ab022bc3.cjs\");\nvar map = __webpack_require__(/*! ./map-28a001c9.cjs */ \"./node_modules/lib0/dist/map-28a001c9.cjs\");\n\n/* eslint-env browser */\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {});\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst createElement = name => doc.createElement(name);\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst createDocumentFragment = () => doc.createDocumentFragment();\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nconst createTextNode = text => doc.createTextNode(text);\n\n/* istanbul ignore next */\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null);\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts));\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key);\n    } else if (value === true) {\n      el.setAttribute(key, '');\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value);\n    }\n  });\n  return el\n};\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value); });\n  return el\n};\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst fragment = children => {\n  const fragment = createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i]);\n  }\n  return fragment\n};\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes));\n  return parent\n};\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nconst remove = el => el.remove();\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f);\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f);\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f));\n  return node\n};\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f));\n  return node\n};\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children);\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'));\n  c.height = height;\n  c.width = width;\n  return c\n};\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nconst text = createTextNode;\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`;\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join('');\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nconst mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('');\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nconst querySelector = (el, query) => el.querySelector(query);\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query);\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id));\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body;\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes));\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild);\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl);\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref);\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nconst appendChild = (parent, child) => parent.appendChild(child);\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE;\nconst TEXT_NODE = doc.TEXT_NODE;\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;\nconst COMMENT_NODE = doc.COMMENT_NODE;\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE;\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type;\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode;\n  while (p && p !== parent) {\n    p = p.parentNode;\n  }\n  return p === parent\n};\n\nvar dom = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  doc: doc,\n  createElement: createElement,\n  createDocumentFragment: createDocumentFragment,\n  createTextNode: createTextNode,\n  domParser: domParser,\n  emitCustomEvent: emitCustomEvent,\n  setAttributes: setAttributes,\n  setAttributesMap: setAttributesMap,\n  fragment: fragment,\n  append: append,\n  remove: remove,\n  addEventListener: addEventListener,\n  removeEventListener: removeEventListener,\n  addEventListeners: addEventListeners,\n  removeEventListeners: removeEventListeners,\n  element: element,\n  canvas: canvas,\n  text: text,\n  pairToStyleString: pairToStyleString,\n  pairsToStyleString: pairsToStyleString,\n  mapToStyleString: mapToStyleString,\n  querySelector: querySelector,\n  querySelectorAll: querySelectorAll,\n  getElementById: getElementById,\n  parseFragment: parseFragment,\n  parseElement: parseElement,\n  replaceWith: replaceWith,\n  insertBefore: insertBefore,\n  appendChild: appendChild,\n  ELEMENT_NODE: ELEMENT_NODE,\n  TEXT_NODE: TEXT_NODE,\n  CDATA_SECTION_NODE: CDATA_SECTION_NODE,\n  COMMENT_NODE: COMMENT_NODE,\n  DOCUMENT_NODE: DOCUMENT_NODE,\n  DOCUMENT_TYPE_NODE: DOCUMENT_TYPE_NODE,\n  DOCUMENT_FRAGMENT_NODE: DOCUMENT_FRAGMENT_NODE,\n  checkNodeType: checkNodeType,\n  isParentOf: isParentOf\n});\n\nexports.CDATA_SECTION_NODE = CDATA_SECTION_NODE;\nexports.COMMENT_NODE = COMMENT_NODE;\nexports.DOCUMENT_FRAGMENT_NODE = DOCUMENT_FRAGMENT_NODE;\nexports.DOCUMENT_NODE = DOCUMENT_NODE;\nexports.DOCUMENT_TYPE_NODE = DOCUMENT_TYPE_NODE;\nexports.ELEMENT_NODE = ELEMENT_NODE;\nexports.TEXT_NODE = TEXT_NODE;\nexports.addEventListener = addEventListener;\nexports.addEventListeners = addEventListeners;\nexports.append = append;\nexports.appendChild = appendChild;\nexports.canvas = canvas;\nexports.checkNodeType = checkNodeType;\nexports.createDocumentFragment = createDocumentFragment;\nexports.createElement = createElement;\nexports.createTextNode = createTextNode;\nexports.doc = doc;\nexports.dom = dom;\nexports.domParser = domParser;\nexports.element = element;\nexports.emitCustomEvent = emitCustomEvent;\nexports.fragment = fragment;\nexports.getElementById = getElementById;\nexports.insertBefore = insertBefore;\nexports.isParentOf = isParentOf;\nexports.mapToStyleString = mapToStyleString;\nexports.pairToStyleString = pairToStyleString;\nexports.pairsToStyleString = pairsToStyleString;\nexports.parseElement = parseElement;\nexports.parseFragment = parseFragment;\nexports.querySelector = querySelector;\nexports.querySelectorAll = querySelectorAll;\nexports.remove = remove;\nexports.removeEventListener = removeEventListener;\nexports.removeEventListeners = removeEventListeners;\nexports.replaceWith = replaceWith;\nexports.setAttributes = setAttributes;\nexports.setAttributesMap = setAttributesMap;\nexports.text = text;\n//# sourceMappingURL=dom-58958c04.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9kb20tNTg5NThjMDQuY2pzP2EyZjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHVFQUFxQjtBQUN4QyxVQUFVLG1CQUFPLENBQUMscUVBQW9COztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUJBQXVCLFNBQVMsb0RBQW9EOztBQUVwRjtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFVBQVU7O0FBRXZDO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0NBQXdDO0FBQ25ELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw2QkFBNkIsRUFBRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtB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Q25CLGNBQWM7QUFDZCxxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsV0FBVztBQUNYLFdBQVc7QUFDWCxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLHVCQUF1QjtBQUN2QixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLGNBQWM7QUFDZCwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLFlBQVk7QUFDWiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvZG9tLTU4OTU4YzA0LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHBhaXIgPSByZXF1aXJlKCcuL3BhaXItYWIwMjJiYzMuY2pzJyk7XG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAtMjhhMDAxYzkuY2pzJyk7XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAdHlwZSB7RG9jdW1lbnR9XG4gKi9cbmNvbnN0IGRvYyA9IC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY3JlYXRlRWxlbWVudCA9IG5hbWUgPT4gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSk7XG5cbi8qKlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoKSA9PiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtUZXh0fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgY3JlYXRlVGV4dE5vZGUgPSB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGRvbVBhcnNlciA9IC8qKiBAdHlwZSB7RE9NUGFyc2VyfSAqLyAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRE9NUGFyc2VyKCkgOiBudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBlbWl0Q3VzdG9tRXZlbnQgPSAoZWwsIG5hbWUsIG9wdHMpID0+IGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIG9wdHMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nfGJvb2xlYW4+Pn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3Qgc2V0QXR0cmlidXRlcyA9IChlbCwgYXR0cnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGF0dHJzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIHN0cmluZz59IGF0dHJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlyc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHNldEF0dHJpYnV0ZXNNYXAgPSAoZWwsIGF0dHJzKSA9PiB7XG4gIGF0dHJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHsgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpOyB9KTtcbiAgcmV0dXJuIGVsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT58SFRNTENvbGxlY3Rpb259IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZnJhZ21lbnQgPSBjaGlsZHJlbiA9PiB7XG4gIGNvbnN0IGZyYWdtZW50ID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kQ2hpbGQoZnJhZ21lbnQsIGNoaWxkcmVuW2ldKTtcbiAgfVxuICByZXR1cm4gZnJhZ21lbnRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgYXBwZW5kID0gKHBhcmVudCwgbm9kZXMpID0+IHtcbiAgYXBwZW5kQ2hpbGQocGFyZW50LCBmcmFnbWVudChub2RlcykpO1xuICByZXR1cm4gcGFyZW50XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCByZW1vdmUgPSBlbCA9PiBlbC5yZW1vdmUoKTtcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmKTtcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmKTtcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxFdmVudExpc3RlbmVyPj59IGxpc3RlbmVyc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJzID0gKG5vZGUsIGxpc3RlbmVycykgPT4ge1xuICBwYWlyLmZvckVhY2gobGlzdGVuZXJzLCAobmFtZSwgZikgPT4gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBmKSk7XG4gIHJldHVybiBub2RlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLEV2ZW50TGlzdGVuZXI+Pn0gbGlzdGVuZXJzXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSAobm9kZSwgbGlzdGVuZXJzKSA9PiB7XG4gIHBhaXIuZm9yRWFjaChsaXN0ZW5lcnMsIChuYW1lLCBmKSA9PiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIG5hbWUsIGYpKTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+fHBhaXIuUGFpcjxzdHJpbmcsYm9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZWxlbWVudCA9IChuYW1lLCBhdHRycyA9IFtdLCBjaGlsZHJlbiA9IFtdKSA9PlxuICBhcHBlbmQoc2V0QXR0cmlidXRlcyhjcmVhdGVFbGVtZW50KG5hbWUpLCBhdHRycyksIGNoaWxkcmVuKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGNhbnZhcyA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gIGNvbnN0IGMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICBjLmhlaWdodCA9IGhlaWdodDtcbiAgYy53aWR0aCA9IHdpZHRoO1xuICByZXR1cm4gY1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHJldHVybiB7VGV4dH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHRleHQgPSBjcmVhdGVUZXh0Tm9kZTtcblxuLyoqXG4gKiBAcGFyYW0ge3BhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPn0gcGFpclxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcGFpclRvU3R5bGVTdHJpbmcgPSBwYWlyID0+IGAke3BhaXIubGVmdH06JHtwYWlyLnJpZ2h0fTtgO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn0gcGFpcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHBhaXJzVG9TdHlsZVN0cmluZyA9IHBhaXJzID0+IHBhaXJzLm1hcChwYWlyVG9TdHlsZVN0cmluZykuam9pbignJyk7XG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLHN0cmluZz59IG1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IG1hcFRvU3R5bGVTdHJpbmcgPSBtID0+IG1hcC5tYXAobSwgKHZhbHVlLCBrZXkpID0+IGAke2tleX06JHt2YWx1ZX07YCkuam9pbignJyk7XG5cbi8qKlxuICogQHRvZG8gc2hvdWxkIGFsd2F5cyBxdWVyeSBvbiBhIGRvbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBxdWVyeVNlbGVjdG9yID0gKGVsLCBxdWVyeSkgPT4gZWwucXVlcnlTZWxlY3RvcihxdWVyeSk7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHF1ZXJ5U2VsZWN0b3JBbGwgPSAoZWwsIHF1ZXJ5KSA9PiBlbC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZ2V0RWxlbWVudEJ5SWQgPSBpZCA9PiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAoZG9jLmdldEVsZW1lbnRCeUlkKGlkKSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgX3BhcnNlID0gaHRtbCA9PiBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKGA8aHRtbD48Ym9keT4ke2h0bWx9PC9ib2R5PjwvaHRtbD5gLCAndGV4dC9odG1sJykuYm9keTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHBhcnNlRnJhZ21lbnQgPSBodG1sID0+IGZyYWdtZW50KC8qKiBAdHlwZSB7YW55fSAqLyAoX3BhcnNlKGh0bWwpLmNoaWxkTm9kZXMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBwYXJzZUVsZW1lbnQgPSBodG1sID0+IC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqLyAoX3BhcnNlKGh0bWwpLmZpcnN0RWxlbWVudENoaWxkKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvbGRFbFxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBuZXdFbFxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcmVwbGFjZVdpdGggPSAob2xkRWwsIG5ld0VsKSA9PiBvbGRFbC5yZXBsYWNlV2l0aChuZXdFbCk7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtOb2RlfG51bGx9IHJlZlxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBpbnNlcnRCZWZvcmUgPSAocGFyZW50LCBlbCwgcmVmKSA9PiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCByZWYpO1xuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge05vZGV9IGNoaWxkXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgYXBwZW5kQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcblxuY29uc3QgRUxFTUVOVF9OT0RFID0gZG9jLkVMRU1FTlRfTk9ERTtcbmNvbnN0IFRFWFRfTk9ERSA9IGRvYy5URVhUX05PREU7XG5jb25zdCBDREFUQV9TRUNUSU9OX05PREUgPSBkb2MuQ0RBVEFfU0VDVElPTl9OT0RFO1xuY29uc3QgQ09NTUVOVF9OT0RFID0gZG9jLkNPTU1FTlRfTk9ERTtcbmNvbnN0IERPQ1VNRU5UX05PREUgPSBkb2MuRE9DVU1FTlRfTk9ERTtcbmNvbnN0IERPQ1VNRU5UX1RZUEVfTk9ERSA9IGRvYy5ET0NVTUVOVF9UWVBFX05PREU7XG5jb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKi9cbmNvbnN0IGNoZWNrTm9kZVR5cGUgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gdHlwZTtcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRcbiAqL1xuY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGxldCBwID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgd2hpbGUgKHAgJiYgcCAhPT0gcGFyZW50KSB7XG4gICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gcCA9PT0gcGFyZW50XG59O1xuXG52YXIgZG9tID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRvYzogZG9jLFxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVEb2N1bWVudEZyYWdtZW50OiBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGRvbVBhcnNlcjogZG9tUGFyc2VyLFxuICBlbWl0Q3VzdG9tRXZlbnQ6IGVtaXRDdXN0b21FdmVudCxcbiAgc2V0QXR0cmlidXRlczogc2V0QXR0cmlidXRlcyxcbiAgc2V0QXR0cmlidXRlc01hcDogc2V0QXR0cmlidXRlc01hcCxcbiAgZnJhZ21lbnQ6IGZyYWdtZW50LFxuICBhcHBlbmQ6IGFwcGVuZCxcbiAgcmVtb3ZlOiByZW1vdmUsXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGFkZEV2ZW50TGlzdGVuZXIsXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXI6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXG4gIGFkZEV2ZW50TGlzdGVuZXJzOiBhZGRFdmVudExpc3RlbmVycyxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnM6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICBlbGVtZW50OiBlbGVtZW50LFxuICBjYW52YXM6IGNhbnZhcyxcbiAgdGV4dDogdGV4dCxcbiAgcGFpclRvU3R5bGVTdHJpbmc6IHBhaXJUb1N0eWxlU3RyaW5nLFxuICBwYWlyc1RvU3R5bGVTdHJpbmc6IHBhaXJzVG9TdHlsZVN0cmluZyxcbiAgbWFwVG9TdHlsZVN0cmluZzogbWFwVG9TdHlsZVN0cmluZyxcbiAgcXVlcnlTZWxlY3RvcjogcXVlcnlTZWxlY3RvcixcbiAgcXVlcnlTZWxlY3RvckFsbDogcXVlcnlTZWxlY3RvckFsbCxcbiAgZ2V0RWxlbWVudEJ5SWQ6IGdldEVsZW1lbnRCeUlkLFxuICBwYXJzZUZyYWdtZW50OiBwYXJzZUZyYWdtZW50LFxuICBwYXJzZUVsZW1lbnQ6IHBhcnNlRWxlbWVudCxcbiAgcmVwbGFjZVdpdGg6IHJlcGxhY2VXaXRoLFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBFTEVNRU5UX05PREU6IEVMRU1FTlRfTk9ERSxcbiAgVEVYVF9OT0RFOiBURVhUX05PREUsXG4gIENEQVRBX1NFQ1RJT05fTk9ERTogQ0RBVEFfU0VDVElPTl9OT0RFLFxuICBDT01NRU5UX05PREU6IENPTU1FTlRfTk9ERSxcbiAgRE9DVU1FTlRfTk9ERTogRE9DVU1FTlRfTk9ERSxcbiAgRE9DVU1FTlRfVFlQRV9OT0RFOiBET0NVTUVOVF9UWVBFX05PREUsXG4gIERPQ1VNRU5UX0ZSQUdNRU5UX05PREU6IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUsXG4gIGNoZWNrTm9kZVR5cGU6IGNoZWNrTm9kZVR5cGUsXG4gIGlzUGFyZW50T2Y6IGlzUGFyZW50T2Zcbn0pO1xuXG5leHBvcnRzLkNEQVRBX1NFQ1RJT05fTk9ERSA9IENEQVRBX1NFQ1RJT05fTk9ERTtcbmV4cG9ydHMuQ09NTUVOVF9OT0RFID0gQ09NTUVOVF9OT0RFO1xuZXhwb3J0cy5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbmV4cG9ydHMuRE9DVU1FTlRfTk9ERSA9IERPQ1VNRU5UX05PREU7XG5leHBvcnRzLkRPQ1VNRU5UX1RZUEVfTk9ERSA9IERPQ1VNRU5UX1RZUEVfTk9ERTtcbmV4cG9ydHMuRUxFTUVOVF9OT0RFID0gRUxFTUVOVF9OT0RFO1xuZXhwb3J0cy5URVhUX05PREUgPSBURVhUX05PREU7XG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVycyA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuZXhwb3J0cy5hcHBlbmQgPSBhcHBlbmQ7XG5leHBvcnRzLmFwcGVuZENoaWxkID0gYXBwZW5kQ2hpbGQ7XG5leHBvcnRzLmNhbnZhcyA9IGNhbnZhcztcbmV4cG9ydHMuY2hlY2tOb2RlVHlwZSA9IGNoZWNrTm9kZVR5cGU7XG5leHBvcnRzLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZTtcbmV4cG9ydHMuZG9jID0gZG9jO1xuZXhwb3J0cy5kb20gPSBkb207XG5leHBvcnRzLmRvbVBhcnNlciA9IGRvbVBhcnNlcjtcbmV4cG9ydHMuZWxlbWVudCA9IGVsZW1lbnQ7XG5leHBvcnRzLmVtaXRDdXN0b21FdmVudCA9IGVtaXRDdXN0b21FdmVudDtcbmV4cG9ydHMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbmV4cG9ydHMuZ2V0RWxlbWVudEJ5SWQgPSBnZXRFbGVtZW50QnlJZDtcbmV4cG9ydHMuaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlO1xuZXhwb3J0cy5pc1BhcmVudE9mID0gaXNQYXJlbnRPZjtcbmV4cG9ydHMubWFwVG9TdHlsZVN0cmluZyA9IG1hcFRvU3R5bGVTdHJpbmc7XG5leHBvcnRzLnBhaXJUb1N0eWxlU3RyaW5nID0gcGFpclRvU3R5bGVTdHJpbmc7XG5leHBvcnRzLnBhaXJzVG9TdHlsZVN0cmluZyA9IHBhaXJzVG9TdHlsZVN0cmluZztcbmV4cG9ydHMucGFyc2VFbGVtZW50ID0gcGFyc2VFbGVtZW50O1xuZXhwb3J0cy5wYXJzZUZyYWdtZW50ID0gcGFyc2VGcmFnbWVudDtcbmV4cG9ydHMucXVlcnlTZWxlY3RvciA9IHF1ZXJ5U2VsZWN0b3I7XG5leHBvcnRzLnF1ZXJ5U2VsZWN0b3JBbGwgPSBxdWVyeVNlbGVjdG9yQWxsO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG5leHBvcnRzLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVycyA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuZXhwb3J0cy5yZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoO1xuZXhwb3J0cy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbmV4cG9ydHMuc2V0QXR0cmlidXRlc01hcCA9IHNldEF0dHJpYnV0ZXNNYXA7XG5leHBvcnRzLnRleHQgPSB0ZXh0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLTU4OTU4YzA0LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/dom-58958c04.cjs\n")},"./node_modules/lib0/dist/encoding.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar encoding = __webpack_require__(/*! ./buffer-ac2cdedf.cjs */ "./node_modules/lib0/dist/buffer-ac2cdedf.cjs");\n__webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\n__webpack_require__(/*! ./number-24f1eabe.cjs */ "./node_modules/lib0/dist/number-24f1eabe.cjs");\n__webpack_require__(/*! ./binary-ac8e39e2.cjs */ "./node_modules/lib0/dist/binary-ac8e39e2.cjs");\n__webpack_require__(/*! ./string-f3c3d805.cjs */ "./node_modules/lib0/dist/string-f3c3d805.cjs");\n__webpack_require__(/*! ./environment-7e2ffaea.cjs */ "./node_modules/lib0/dist/environment-7e2ffaea.cjs");\n__webpack_require__(/*! ./map-28a001c9.cjs */ "./node_modules/lib0/dist/map-28a001c9.cjs");\n__webpack_require__(/*! ./conditions-fb475c70.cjs */ "./node_modules/lib0/dist/conditions-fb475c70.cjs");\n__webpack_require__(/*! ./storage.cjs */ "./node_modules/lib0/dist/storage.cjs");\n\n\n\nexports.Encoder = encoding.Encoder;\nexports.IncUintOptRleEncoder = encoding.IncUintOptRleEncoder;\nexports.IntDiffEncoder = encoding.IntDiffEncoder;\nexports.IntDiffOptRleEncoder = encoding.IntDiffOptRleEncoder;\nexports.RleEncoder = encoding.RleEncoder;\nexports.RleIntDiffEncoder = encoding.RleIntDiffEncoder;\nexports.StringEncoder = encoding.StringEncoder;\nexports.UintOptRleEncoder = encoding.UintOptRleEncoder;\nexports.createEncoder = encoding.createEncoder;\nexports.length = encoding.length;\nexports.set = encoding.set;\nexports.setUint16 = encoding.setUint16;\nexports.setUint32 = encoding.setUint32;\nexports.setUint8 = encoding.setUint8;\nexports.toUint8Array = encoding.toUint8Array;\nexports.write = encoding.write;\nexports.writeAny = encoding.writeAny;\nexports.writeBigInt64 = encoding.writeBigInt64;\nexports.writeBigUint64 = encoding.writeBigUint64;\nexports.writeBinaryEncoder = encoding.writeBinaryEncoder;\nexports.writeFloat32 = encoding.writeFloat32;\nexports.writeFloat64 = encoding.writeFloat64;\nexports.writeOnDataView = encoding.writeOnDataView;\nexports.writeUint16 = encoding.writeUint16;\nexports.writeUint32 = encoding.writeUint32;\nexports.writeUint32BigEndian = encoding.writeUint32BigEndian;\nexports.writeUint8 = encoding.writeUint8;\nexports.writeUint8Array = encoding.writeUint8Array;\nexports.writeVarInt = encoding.writeVarInt;\nexports.writeVarString = encoding.writeVarString;\nexports.writeVarUint = encoding.writeVarUint;\nexports.writeVarUint8Array = encoding.writeVarUint8Array;\n//# sourceMappingURL=encoding.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9lbmNvZGluZy5janM/YmZkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELGVBQWUsbUJBQU8sQ0FBQywyRUFBdUI7QUFDOUMsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDNUIsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQywyREFBZTs7OztBQUl2QixlQUFlO0FBQ2YsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QsV0FBVztBQUNYLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9lbmNvZGluZy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBlbmNvZGluZyA9IHJlcXVpcmUoJy4vYnVmZmVyLWFjMmNkZWRmLmNqcycpO1xucmVxdWlyZSgnLi9tYXRoLTA4ZTA2OGY5LmNqcycpO1xucmVxdWlyZSgnLi9udW1iZXItMjRmMWVhYmUuY2pzJyk7XG5yZXF1aXJlKCcuL2JpbmFyeS1hYzhlMzllMi5janMnKTtcbnJlcXVpcmUoJy4vc3RyaW5nLWYzYzNkODA1LmNqcycpO1xucmVxdWlyZSgnLi9lbnZpcm9ubWVudC03ZTJmZmFlYS5janMnKTtcbnJlcXVpcmUoJy4vbWFwLTI4YTAwMWM5LmNqcycpO1xucmVxdWlyZSgnLi9jb25kaXRpb25zLWZiNDc1YzcwLmNqcycpO1xucmVxdWlyZSgnLi9zdG9yYWdlLmNqcycpO1xuXG5cblxuZXhwb3J0cy5FbmNvZGVyID0gZW5jb2RpbmcuRW5jb2RlcjtcbmV4cG9ydHMuSW5jVWludE9wdFJsZUVuY29kZXIgPSBlbmNvZGluZy5JbmNVaW50T3B0UmxlRW5jb2RlcjtcbmV4cG9ydHMuSW50RGlmZkVuY29kZXIgPSBlbmNvZGluZy5JbnREaWZmRW5jb2RlcjtcbmV4cG9ydHMuSW50RGlmZk9wdFJsZUVuY29kZXIgPSBlbmNvZGluZy5JbnREaWZmT3B0UmxlRW5jb2RlcjtcbmV4cG9ydHMuUmxlRW5jb2RlciA9IGVuY29kaW5nLlJsZUVuY29kZXI7XG5leHBvcnRzLlJsZUludERpZmZFbmNvZGVyID0gZW5jb2RpbmcuUmxlSW50RGlmZkVuY29kZXI7XG5leHBvcnRzLlN0cmluZ0VuY29kZXIgPSBlbmNvZGluZy5TdHJpbmdFbmNvZGVyO1xuZXhwb3J0cy5VaW50T3B0UmxlRW5jb2RlciA9IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyO1xuZXhwb3J0cy5jcmVhdGVFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcjtcbmV4cG9ydHMubGVuZ3RoID0gZW5jb2RpbmcubGVuZ3RoO1xuZXhwb3J0cy5zZXQgPSBlbmNvZGluZy5zZXQ7XG5leHBvcnRzLnNldFVpbnQxNiA9IGVuY29kaW5nLnNldFVpbnQxNjtcbmV4cG9ydHMuc2V0VWludDMyID0gZW5jb2Rpbmcuc2V0VWludDMyO1xuZXhwb3J0cy5zZXRVaW50OCA9IGVuY29kaW5nLnNldFVpbnQ4O1xuZXhwb3J0cy50b1VpbnQ4QXJyYXkgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXk7XG5leHBvcnRzLndyaXRlID0gZW5jb2Rpbmcud3JpdGU7XG5leHBvcnRzLndyaXRlQW55ID0gZW5jb2Rpbmcud3JpdGVBbnk7XG5leHBvcnRzLndyaXRlQmlnSW50NjQgPSBlbmNvZGluZy53cml0ZUJpZ0ludDY0O1xuZXhwb3J0cy53cml0ZUJpZ1VpbnQ2NCA9IGVuY29kaW5nLndyaXRlQmlnVWludDY0O1xuZXhwb3J0cy53cml0ZUJpbmFyeUVuY29kZXIgPSBlbmNvZGluZy53cml0ZUJpbmFyeUVuY29kZXI7XG5leHBvcnRzLndyaXRlRmxvYXQzMiA9IGVuY29kaW5nLndyaXRlRmxvYXQzMjtcbmV4cG9ydHMud3JpdGVGbG9hdDY0ID0gZW5jb2Rpbmcud3JpdGVGbG9hdDY0O1xuZXhwb3J0cy53cml0ZU9uRGF0YVZpZXcgPSBlbmNvZGluZy53cml0ZU9uRGF0YVZpZXc7XG5leHBvcnRzLndyaXRlVWludDE2ID0gZW5jb2Rpbmcud3JpdGVVaW50MTY7XG5leHBvcnRzLndyaXRlVWludDMyID0gZW5jb2Rpbmcud3JpdGVVaW50MzI7XG5leHBvcnRzLndyaXRlVWludDMyQmlnRW5kaWFuID0gZW5jb2Rpbmcud3JpdGVVaW50MzJCaWdFbmRpYW47XG5leHBvcnRzLndyaXRlVWludDggPSBlbmNvZGluZy53cml0ZVVpbnQ4O1xuZXhwb3J0cy53cml0ZVVpbnQ4QXJyYXkgPSBlbmNvZGluZy53cml0ZVVpbnQ4QXJyYXk7XG5leHBvcnRzLndyaXRlVmFySW50ID0gZW5jb2Rpbmcud3JpdGVWYXJJbnQ7XG5leHBvcnRzLndyaXRlVmFyU3RyaW5nID0gZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmc7XG5leHBvcnRzLndyaXRlVmFyVWludCA9IGVuY29kaW5nLndyaXRlVmFyVWludDtcbmV4cG9ydHMud3JpdGVWYXJVaW50OEFycmF5ID0gZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RpbmcuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/encoding.cjs\n')},"./node_modules/lib0/dist/environment-7e2ffaea.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar map = __webpack_require__(/*! ./map-28a001c9.cjs */ \"./node_modules/lib0/dist/map-28a001c9.cjs\");\nvar string = __webpack_require__(/*! ./string-f3c3d805.cjs */ \"./node_modules/lib0/dist/string-f3c3d805.cjs\");\nvar conditions = __webpack_require__(/*! ./conditions-fb475c70.cjs */ \"./node_modules/lib0/dist/conditions-fb475c70.cjs\");\nvar storage = __webpack_require__(/*! ./storage.cjs */ \"./node_modules/lib0/dist/storage.cjs\");\n\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n/* istanbul ignore next */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name);\n/* istanbul ignore next */\nconst isBrowser = typeof window !== 'undefined' && !isNode;\n/* istanbul ignore next */\nconst isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;\n\n/**\n * @type {Map<string,string>}\n */\nlet params;\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create();\n      const pargs = process.argv;\n      let currParamName = null;\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i];\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '');\n          }\n          currParamName = parg;\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg);\n            currParamName = null;\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '');\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=');\n          params.set(`--${string.fromCamelCase(key, '-')}`, value);\n          params.set(`-${string.fromCamelCase(key, '-')}`, value);\n        }\n      });\n    } else {\n      params = map.create();\n    }\n  }\n  return params\n};\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasParam = name => computeParams().has(name);\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nconst getParam = (name, defaultVal) => computeParams().get(name) || defaultVal;\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nconst getVariable = name => isNode ? conditions.undefinedToNull(process.env[name.toUpperCase()]) : conditions.undefinedToNull(storage.varStorage.getItem(name));\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nconst getConf = name => computeParams().get('--' + name) || getVariable(name);\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasConf = name => hasParam('--' + name) || getVariable(name) !== null;\n\n/* istanbul ignore next */\nconst production = hasConf('production');\n\nvar environment = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  isNode: isNode,\n  isBrowser: isBrowser,\n  isMac: isMac,\n  hasParam: hasParam,\n  getParam: getParam,\n  getVariable: getVariable,\n  getConf: getConf,\n  hasConf: hasConf,\n  production: production\n});\n\nexports.environment = environment;\nexports.getConf = getConf;\nexports.getParam = getParam;\nexports.getVariable = getVariable;\nexports.hasConf = hasConf;\nexports.hasParam = hasParam;\nexports.isBrowser = isBrowser;\nexports.isMac = isMac;\nexports.isNode = isNode;\nexports.production = production;\n//# sourceMappingURL=environment-7e2ffaea.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9lbnZpcm9ubWVudC03ZTJmZmFlYS5janM/NDY2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLG1CQUFPLENBQUMscUVBQW9CO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQywyRUFBdUI7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsbUZBQTJCO0FBQ3BELGNBQWMsbUJBQU8sQ0FBQywyREFBZTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pELHlCQUF5QiwrQkFBK0I7QUFDeEQ7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsY0FBYztBQUNkLGtCQUFrQjtBQUNsQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvZW52aXJvbm1lbnQtN2UyZmZhZWEuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAtMjhhMDAxYzkuY2pzJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmctZjNjM2Q4MDUuY2pzJyk7XG52YXIgY29uZGl0aW9ucyA9IHJlcXVpcmUoJy4vY29uZGl0aW9ucy1mYjQ3NWM3MC5janMnKTtcbnZhciBzdG9yYWdlID0gcmVxdWlyZSgnLi9zdG9yYWdlLmNqcycpO1xuXG4vKipcbiAqIElzb21vcnBoaWMgbW9kdWxlIHRvIHdvcmsgYWNjZXNzIHRoZSBlbnZpcm9ubWVudCAocXVlcnkgcGFyYW1zLCBlbnYgdmFyaWFibGVzKS5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5yZWxlYXNlICYmIC9ub2RlfGlvXFwuanMvLnRlc3QocHJvY2Vzcy5yZWxlYXNlLm5hbWUpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFpc05vZGU7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaXNNYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSA6IGZhbHNlO1xuXG4vKipcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLHN0cmluZz59XG4gKi9cbmxldCBwYXJhbXM7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjb21wdXRlUGFyYW1zID0gKCkgPT4ge1xuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKCk7XG4gICAgICBjb25zdCBwYXJncyA9IHByb2Nlc3MuYXJndjtcbiAgICAgIGxldCBjdXJyUGFyYW1OYW1lID0gbnVsbDtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmcgPSBwYXJnc1tpXTtcbiAgICAgICAgaWYgKHBhcmdbMF0gPT09ICctJykge1xuICAgICAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyclBhcmFtTmFtZSA9IHBhcmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgcGFyZyk7XG4gICAgICAgICAgICBjdXJyUGFyYW1OYW1lID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyUGFyYW1OYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgJycpO1xuICAgICAgfVxuICAgIC8vIGluIFJlYWN0TmF0aXZlIGZvciBleGFtcGxlIHRoaXMgd291bGQgbm90IGJlIHRydWUgKHVubGVzcyBjb25uZWN0ZWQgdG8gdGhlIFJlbW90ZSBEZWJ1Z2dlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICA7KGxvY2F0aW9uLnNlYXJjaCB8fCAnPycpLnNsaWNlKDEpLnNwbGl0KCcmJykuZm9yRWFjaChrdiA9PiB7XG4gICAgICAgIGlmIChrdi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBrdi5zcGxpdCgnPScpO1xuICAgICAgICAgIHBhcmFtcy5zZXQoYC0tJHtzdHJpbmcuZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpO1xuICAgICAgICAgIHBhcmFtcy5zZXQoYC0ke3N0cmluZy5mcm9tQ2FtZWxDYXNlKGtleSwgJy0nKX1gLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJhbXNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBoYXNQYXJhbSA9IG5hbWUgPT4gY29tcHV0ZVBhcmFtcygpLmhhcyhuYW1lKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRWYWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGdldFBhcmFtID0gKG5hbWUsIGRlZmF1bHRWYWwpID0+IGNvbXB1dGVQYXJhbXMoKS5nZXQobmFtZSkgfHwgZGVmYXVsdFZhbDtcbi8vIGV4cG9ydCBjb25zdCBnZXRBcmdzID0gbmFtZSA9PiBjb21wdXRlUGFyYW1zKCkgJiYgYXJnc1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGdldFZhcmlhYmxlID0gbmFtZSA9PiBpc05vZGUgPyBjb25kaXRpb25zLnVuZGVmaW5lZFRvTnVsbChwcm9jZXNzLmVudltuYW1lLnRvVXBwZXJDYXNlKCldKSA6IGNvbmRpdGlvbnMudW5kZWZpbmVkVG9OdWxsKHN0b3JhZ2UudmFyU3RvcmFnZS5nZXRJdGVtKG5hbWUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmNvbnN0IGdldENvbmYgPSBuYW1lID0+IGNvbXB1dGVQYXJhbXMoKS5nZXQoJy0tJyArIG5hbWUpIHx8IGdldFZhcmlhYmxlKG5hbWUpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaGFzQ29uZiA9IG5hbWUgPT4gaGFzUGFyYW0oJy0tJyArIG5hbWUpIHx8IGdldFZhcmlhYmxlKG5hbWUpICE9PSBudWxsO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgcHJvZHVjdGlvbiA9IGhhc0NvbmYoJ3Byb2R1Y3Rpb24nKTtcblxudmFyIGVudmlyb25tZW50ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGlzTm9kZTogaXNOb2RlLFxuICBpc0Jyb3dzZXI6IGlzQnJvd3NlcixcbiAgaXNNYWM6IGlzTWFjLFxuICBoYXNQYXJhbTogaGFzUGFyYW0sXG4gIGdldFBhcmFtOiBnZXRQYXJhbSxcbiAgZ2V0VmFyaWFibGU6IGdldFZhcmlhYmxlLFxuICBnZXRDb25mOiBnZXRDb25mLFxuICBoYXNDb25mOiBoYXNDb25mLFxuICBwcm9kdWN0aW9uOiBwcm9kdWN0aW9uXG59KTtcblxuZXhwb3J0cy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuZXhwb3J0cy5nZXRDb25mID0gZ2V0Q29uZjtcbmV4cG9ydHMuZ2V0UGFyYW0gPSBnZXRQYXJhbTtcbmV4cG9ydHMuZ2V0VmFyaWFibGUgPSBnZXRWYXJpYWJsZTtcbmV4cG9ydHMuaGFzQ29uZiA9IGhhc0NvbmY7XG5leHBvcnRzLmhhc1BhcmFtID0gaGFzUGFyYW07XG5leHBvcnRzLmlzQnJvd3NlciA9IGlzQnJvd3NlcjtcbmV4cG9ydHMuaXNNYWMgPSBpc01hYztcbmV4cG9ydHMuaXNOb2RlID0gaXNOb2RlO1xuZXhwb3J0cy5wcm9kdWN0aW9uID0gcHJvZHVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudmlyb25tZW50LTdlMmZmYWVhLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/environment-7e2ffaea.cjs\n")},"./node_modules/lib0/dist/error-55a9a8c8.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nconst create = s => new Error(s);\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst methodUnimplemented = () => {\n  throw create('Method unimplemented')\n};\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst unexpectedCase = () => {\n  throw create('Unexpected case')\n};\n\nvar error = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  create: create,\n  methodUnimplemented: methodUnimplemented,\n  unexpectedCase: unexpectedCase\n});\n\nexports.create = create;\nexports.error = error;\nexports.methodUnimplemented = methodUnimplemented;\nexports.unexpectedCase = unexpectedCase;\n//# sourceMappingURL=error-55a9a8c8.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9lcnJvci01NWE5YThjOC5janM/ZGI0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYztBQUNkLGFBQWE7QUFDYiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9lcnJvci01NWE5YThjOC5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXJyb3IgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGVycm9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjcmVhdGUgPSBzID0+IG5ldyBFcnJvcihzKTtcblxuLyoqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge25ldmVyfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgbWV0aG9kVW5pbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgdGhyb3cgY3JlYXRlKCdNZXRob2QgdW5pbXBsZW1lbnRlZCcpXG59O1xuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7bmV2ZXJ9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmV4cGVjdGVkQ2FzZSA9ICgpID0+IHtcbiAgdGhyb3cgY3JlYXRlKCdVbmV4cGVjdGVkIGNhc2UnKVxufTtcblxudmFyIGVycm9yID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGNyZWF0ZTogY3JlYXRlLFxuICBtZXRob2RVbmltcGxlbWVudGVkOiBtZXRob2RVbmltcGxlbWVudGVkLFxuICB1bmV4cGVjdGVkQ2FzZTogdW5leHBlY3RlZENhc2Vcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmV4cG9ydHMubWV0aG9kVW5pbXBsZW1lbnRlZCA9IG1ldGhvZFVuaW1wbGVtZW50ZWQ7XG5leHBvcnRzLnVuZXhwZWN0ZWRDYXNlID0gdW5leHBlY3RlZENhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci01NWE5YThjOC5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/error-55a9a8c8.cjs\n")},"./node_modules/lib0/dist/error.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar error = __webpack_require__(/*! ./error-55a9a8c8.cjs */ "./node_modules/lib0/dist/error-55a9a8c8.cjs");\n\n\n\nexports.create = error.create;\nexports.methodUnimplemented = error.methodUnimplemented;\nexports.unexpectedCase = error.unexpectedCase;\n//# sourceMappingURL=error.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9lcnJvci5janM/MjNlMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELFlBQVksbUJBQU8sQ0FBQyx5RUFBc0I7Ozs7QUFJMUMsY0FBYztBQUNkLDJCQUEyQjtBQUMzQixzQkFBc0I7QUFDdEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2Vycm9yLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGVycm9yID0gcmVxdWlyZSgnLi9lcnJvci01NWE5YThjOC5janMnKTtcblxuXG5cbmV4cG9ydHMuY3JlYXRlID0gZXJyb3IuY3JlYXRlO1xuZXhwb3J0cy5tZXRob2RVbmltcGxlbWVudGVkID0gZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZDtcbmV4cG9ydHMudW5leHBlY3RlZENhc2UgPSBlcnJvci51bmV4cGVjdGVkQ2FzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/error.cjs\n')},"./node_modules/lib0/dist/eventloop-c60b5658.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = [];\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue = [];\n};\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f);\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0);\n  }\n};\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId;\n  }\n\n  destroy () {\n    clearFunction(this._);\n  }\n};\n\nconst Timeout = createTimeoutClass(clearTimeout);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout));\n\nconst Interval = createTimeoutClass(clearInterval);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout));\n\n/* istanbul ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg));\n\n/* istanbul ignore next */\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\nconst animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));\n\n/* istanbul ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg));\n\n/* istanbul ignore next */\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nconst createDebouncer = timeout => {\n  let timer = -1;\n  return f => {\n    clearTimeout(timer);\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout));\n    }\n  }\n};\n\nvar eventloop = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  enqueue: enqueue,\n  timeout: timeout,\n  interval: interval,\n  Animation: Animation,\n  animationFrame: animationFrame,\n  idleCallback: idleCallback,\n  createDebouncer: createDebouncer\n});\n\nexports.Animation = Animation;\nexports.animationFrame = animationFrame;\nexports.createDebouncer = createDebouncer;\nexports.enqueue = enqueue;\nexports.eventloop = eventloop;\nexports.idleCallback = idleCallback;\nexports.interval = interval;\nexports.timeout = timeout;\n//# sourceMappingURL=eventloop-c60b5658.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9ldmVudGxvb3AtYzYwYjU2NTguY2pzPzIwMGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsU0FBUztBQUN2Qjs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9ldmVudGxvb3AtYzYwYjU2NTguY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgcmVxdWVzdElkbGVDYWxsYmFjaywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxJZGxlQ2FsbGJhY2ssIGNhbmNlbEFuaW1hdGlvbkZyYW1lICovXG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEVjbWFTY3JpcHQncyBldmVudCBsb29wLlxuICpcbiAqIEBtb2R1bGUgZXZlbnRsb29wXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fVxuICovXG5sZXQgcXVldWUgPSBbXTtcblxuY29uc3QgX3J1blF1ZXVlID0gKCkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKTtcbiAgfVxuICBxdWV1ZSA9IFtdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gZlxuICovXG5jb25zdCBlbnF1ZXVlID0gZiA9PiB7XG4gIHF1ZXVlLnB1c2goZik7XG4gIGlmIChxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICBzZXRUaW1lb3V0KF9ydW5RdWV1ZSwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZW91dE9iamVjdFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gVGltZW91dE9iamVjdC5kZXN0cm95XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gY2xlYXJGdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVUaW1lb3V0Q2xhc3MgPSBjbGVhckZ1bmN0aW9uID0+IGNsYXNzIFRUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SWRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0aW1lb3V0SWQpIHtcbiAgICB0aGlzLl8gPSB0aW1lb3V0SWQ7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBjbGVhckZ1bmN0aW9uKHRoaXMuXyk7XG4gIH1cbn07XG5cbmNvbnN0IFRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoY2xlYXJUaW1lb3V0KTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmNvbnN0IHRpbWVvdXQgPSAodGltZW91dCwgY2FsbGJhY2spID0+IG5ldyBUaW1lb3V0KHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpKTtcblxuY29uc3QgSW50ZXJ2YWwgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoY2xlYXJJbnRlcnZhbCk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtUaW1lb3V0T2JqZWN0fVxuICovXG5jb25zdCBpbnRlcnZhbCA9ICh0aW1lb3V0LCBjYWxsYmFjaykgPT4gbmV3IEludGVydmFsKHNldEludGVydmFsKGNhbGxiYWNrLCB0aW1lb3V0KSk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBBbmltYXRpb24gPSBjcmVhdGVUaW1lb3V0Q2xhc3MoYXJnID0+IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFyZykpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gY2JcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmNvbnN0IGFuaW1hdGlvbkZyYW1lID0gY2IgPT4gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aW1lb3V0KDAsIGNiKSA6IG5ldyBBbmltYXRpb24ocmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vLyBAdHMtaWdub3JlXG5jb25zdCBJZGxlID0gY3JlYXRlVGltZW91dENsYXNzKGFyZyA9PiB0eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBjYW5jZWxJZGxlQ2FsbGJhY2soYXJnKSk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIE5vdGU6IHRoaXMgaXMgZXhwZXJpbWVudGFsIGFuZCBpcyBwcm9iYWJseSBvbmx5IHVzZWZ1bCBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxuICogQHJldHVybiB7VGltZW91dE9iamVjdH1cbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgaWRsZUNhbGxiYWNrID0gY2IgPT4gdHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnID8gbmV3IElkbGUocmVxdWVzdElkbGVDYWxsYmFjayhjYikpIDogdGltZW91dCgxMDAwLCBjYik7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgVGltZW91dCBvZiB0aGUgZGVib3VuY2UgYWN0aW9uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpOnZvaWQpOnZvaWR9XG4gKi9cbmNvbnN0IGNyZWF0ZURlYm91bmNlciA9IHRpbWVvdXQgPT4ge1xuICBsZXQgdGltZXIgPSAtMTtcbiAgcmV0dXJuIGYgPT4ge1xuICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgaWYgKGYpIHtcbiAgICAgIHRpbWVyID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRUaW1lb3V0KGYsIHRpbWVvdXQpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBldmVudGxvb3AgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZW5xdWV1ZTogZW5xdWV1ZSxcbiAgdGltZW91dDogdGltZW91dCxcbiAgaW50ZXJ2YWw6IGludGVydmFsLFxuICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgYW5pbWF0aW9uRnJhbWU6IGFuaW1hdGlvbkZyYW1lLFxuICBpZGxlQ2FsbGJhY2s6IGlkbGVDYWxsYmFjayxcbiAgY3JlYXRlRGVib3VuY2VyOiBjcmVhdGVEZWJvdW5jZXJcbn0pO1xuXG5leHBvcnRzLkFuaW1hdGlvbiA9IEFuaW1hdGlvbjtcbmV4cG9ydHMuYW5pbWF0aW9uRnJhbWUgPSBhbmltYXRpb25GcmFtZTtcbmV4cG9ydHMuY3JlYXRlRGVib3VuY2VyID0gY3JlYXRlRGVib3VuY2VyO1xuZXhwb3J0cy5lbnF1ZXVlID0gZW5xdWV1ZTtcbmV4cG9ydHMuZXZlbnRsb29wID0gZXZlbnRsb29wO1xuZXhwb3J0cy5pZGxlQ2FsbGJhY2sgPSBpZGxlQ2FsbGJhY2s7XG5leHBvcnRzLmludGVydmFsID0gaW50ZXJ2YWw7XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlbnRsb29wLWM2MGI1NjU4LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/eventloop-c60b5658.cjs\n")},"./node_modules/lib0/dist/function-f8acb5f5.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nvar array = __webpack_require__(/*! ./array-b2d24238.cjs */ "./node_modules/lib0/dist/array-b2d24238.cjs");\nvar object = __webpack_require__(/*! ./object-dcdd6eed.cjs */ "./node_modules/lib0/dist/object-dcdd6eed.cjs");\n\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args);\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1);\n    }\n  }\n};\n\nconst nop = () => {};\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f();\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a;\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b;\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === \'object\' && object.equalFlat(a, b))));\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a);\n      b = new Uint8Array(b);\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n};\n\nvar _function = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  callAll: callAll,\n  nop: nop,\n  apply: apply,\n  id: id,\n  equalityStrict: equalityStrict,\n  equalityFlat: equalityFlat,\n  equalityDeep: equalityDeep\n});\n\nexports._function = _function;\nexports.apply = apply;\nexports.callAll = callAll;\nexports.equalityDeep = equalityDeep;\nexports.equalityFlat = equalityFlat;\nexports.equalityStrict = equalityStrict;\nexports.id = id;\nexports.nop = nop;\n//# sourceMappingURL=function-f8acb5f5.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9mdW5jdGlvbi1mOGFjYjVmNS5janM/NDA1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMseUVBQXNCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQywyRUFBdUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZO0FBQ1o7QUFDQSw4SkFBOEosU0FBUzs7QUFFdks7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixlQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsVUFBVTtBQUNWLFdBQVc7QUFDWCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvZnVuY3Rpb24tZjhhY2I1ZjUuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXJyYXkgPSByZXF1aXJlKCcuL2FycmF5LWIyZDI0MjM4LmNqcycpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0LWRjZGQ2ZWVkLmNqcycpO1xuXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIGBmc2Agd2l0aCBhcmdzLiBPbmx5IHRocm93cyBhZnRlciBhbGwgZnVuY3Rpb25zIHdlcmUgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24+fSBmc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzXG4gKi9cbmNvbnN0IGNhbGxBbGwgPSAoZnMsIGFyZ3MsIGkgPSAwKSA9PiB7XG4gIHRyeSB7XG4gICAgZm9yICg7IGkgPCBmcy5sZW5ndGg7IGkrKykge1xuICAgICAgZnNbaV0oLi4uYXJncyk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpIDwgZnMubGVuZ3RoKSB7XG4gICAgICBjYWxsQWxsKGZzLCBhcmdzLCBpICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBub3AgPSAoKSA9PiB7fTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOlR9IGZcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IGFwcGx5ID0gZiA9PiBmKCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqXG4gKiBAcGFyYW0ge0F9IGFcbiAqIEByZXR1cm4ge0F9XG4gKi9cbmNvbnN0IGlkID0gYSA9PiBhO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtUfSBhXG4gKiBAcGFyYW0ge1R9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsaXR5U3RyaWN0ID0gKGEsIGIpID0+IGEgPT09IGI7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge0FycmF5PFQ+fG9iamVjdH0gYVxuICogQHBhcmFtIHtBcnJheTxUPnxvYmplY3R9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsaXR5RmxhdCA9IChhLCBiKSA9PiBhID09PSBiIHx8IChhICE9IG51bGwgJiYgYiAhPSBudWxsICYmIGEuY29uc3RydWN0b3IgPT09IGIuY29uc3RydWN0b3IgJiYgKChhIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXkuZXF1YWxGbGF0KGEsIC8qKiBAdHlwZSB7QXJyYXk8VD59ICovIChiKSkpIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSkpKTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsaXR5RGVlcCA9IChhLCBiKSA9PiB7XG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVxdWFsaXR5U3RyaWN0KGEsIGIpXG4gIH1cbiAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgc3dpdGNoIChhLmNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBBcnJheUJ1ZmZlcjpcbiAgICAgIGEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgICAgIGIgPSBuZXcgVWludDhBcnJheShiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBjYXNlIFVpbnQ4QXJyYXk6IHtcbiAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIFNldDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgTWFwOiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWVxdWFsaXR5RGVlcChhLmdldChrZXkpLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmIChvYmplY3QubGVuZ3RoKGEpICE9PSBvYmplY3QubGVuZ3RoKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoIW9iamVjdC5oYXNQcm9wZXJ0eShhLCBrZXkpIHx8ICFlcXVhbGl0eURlZXAoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBBcnJheTpcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbnZhciBfZnVuY3Rpb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY2FsbEFsbDogY2FsbEFsbCxcbiAgbm9wOiBub3AsXG4gIGFwcGx5OiBhcHBseSxcbiAgaWQ6IGlkLFxuICBlcXVhbGl0eVN0cmljdDogZXF1YWxpdHlTdHJpY3QsXG4gIGVxdWFsaXR5RmxhdDogZXF1YWxpdHlGbGF0LFxuICBlcXVhbGl0eURlZXA6IGVxdWFsaXR5RGVlcFxufSk7XG5cbmV4cG9ydHMuX2Z1bmN0aW9uID0gX2Z1bmN0aW9uO1xuZXhwb3J0cy5hcHBseSA9IGFwcGx5O1xuZXhwb3J0cy5jYWxsQWxsID0gY2FsbEFsbDtcbmV4cG9ydHMuZXF1YWxpdHlEZWVwID0gZXF1YWxpdHlEZWVwO1xuZXhwb3J0cy5lcXVhbGl0eUZsYXQgPSBlcXVhbGl0eUZsYXQ7XG5leHBvcnRzLmVxdWFsaXR5U3RyaWN0ID0gZXF1YWxpdHlTdHJpY3Q7XG5leHBvcnRzLmlkID0gaWQ7XG5leHBvcnRzLm5vcCA9IG5vcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uLWY4YWNiNWY1LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/function-f8acb5f5.cjs\n')},"./node_modules/lib0/dist/function.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n__webpack_require__(/*! ./array-b2d24238.cjs */ "./node_modules/lib0/dist/array-b2d24238.cjs");\n__webpack_require__(/*! ./object-dcdd6eed.cjs */ "./node_modules/lib0/dist/object-dcdd6eed.cjs");\nvar _function = __webpack_require__(/*! ./function-f8acb5f5.cjs */ "./node_modules/lib0/dist/function-f8acb5f5.cjs");\n\n\n\nexports.apply = _function.apply;\nexports.callAll = _function.callAll;\nexports.equalityDeep = _function.equalityDeep;\nexports.equalityFlat = _function.equalityFlat;\nexports.equalityStrict = _function.equalityStrict;\nexports.id = _function.id;\nexports.nop = _function.nop;\n//# sourceMappingURL=function.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9mdW5jdGlvbi5janM/YTJkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELG1CQUFPLENBQUMseUVBQXNCO0FBQzlCLG1CQUFPLENBQUMsMkVBQXVCO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLCtFQUF5Qjs7OztBQUlqRCxhQUFhO0FBQ2IsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLFVBQVU7QUFDVixXQUFXO0FBQ1giLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2Z1bmN0aW9uLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnLi9hcnJheS1iMmQyNDIzOC5janMnKTtcbnJlcXVpcmUoJy4vb2JqZWN0LWRjZGQ2ZWVkLmNqcycpO1xudmFyIF9mdW5jdGlvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24tZjhhY2I1ZjUuY2pzJyk7XG5cblxuXG5leHBvcnRzLmFwcGx5ID0gX2Z1bmN0aW9uLmFwcGx5O1xuZXhwb3J0cy5jYWxsQWxsID0gX2Z1bmN0aW9uLmNhbGxBbGw7XG5leHBvcnRzLmVxdWFsaXR5RGVlcCA9IF9mdW5jdGlvbi5lcXVhbGl0eURlZXA7XG5leHBvcnRzLmVxdWFsaXR5RmxhdCA9IF9mdW5jdGlvbi5lcXVhbGl0eUZsYXQ7XG5leHBvcnRzLmVxdWFsaXR5U3RyaWN0ID0gX2Z1bmN0aW9uLmVxdWFsaXR5U3RyaWN0O1xuZXhwb3J0cy5pZCA9IF9mdW5jdGlvbi5pZDtcbmV4cG9ydHMubm9wID0gX2Z1bmN0aW9uLm5vcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZ1bmN0aW9uLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/function.cjs\n')},"./node_modules/lib0/dist/iterator-fe01d209.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next();\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n});\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n});\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res;\n  do {\n    res = iterator.next();\n  } while (!res.done && !filter(res.value))\n  return res\n});\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next();\n  return { done, value: done ? undefined : fmap(value) }\n});\n\nvar iterator = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mapIterator: mapIterator,\n  createIterator: createIterator,\n  iteratorFilter: iteratorFilter,\n  iteratorMap: iteratorMap\n});\n\nexports.createIterator = createIterator;\nexports.iterator = iterator;\nexports.iteratorFilter = iteratorFilter;\nexports.iteratorMap = iteratorMap;\nexports.mapIterator = mapIterator;\n//# sourceMappingURL=iterator-fe01d209.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9pdGVyYXRvci1mZTAxZDIwOS5janM/YzJhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBLFNBQVMsY0FBYztBQUN2QixVQUFVO0FBQ1YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2l0ZXJhdG9yLWZlMDFkMjA5LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byBjcmVhdGUgYW5kIG1hbmlwdWxhdGUgSXRlcmF0b3JzLlxuICpcbiAqIEBtb2R1bGUgaXRlcmF0b3JcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULFJcbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOlJ9IGZcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8Uj59XG4gKi9cbmNvbnN0IG1hcEl0ZXJhdG9yID0gKGl0ZXJhdG9yLCBmKSA9PiAoe1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUKTpSfSBmXG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBuZXh0ICgpIHtcbiAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHJldHVybiB7IHZhbHVlOiByLmRvbmUgPyB1bmRlZmluZWQgOiBmKHIudmFsdWUpLCBkb25lOiByLmRvbmUgfVxuICB9XG59KTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOkl0ZXJhdG9yUmVzdWx0PFQ+fSBuZXh0XG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5jb25zdCBjcmVhdGVJdGVyYXRvciA9IG5leHQgPT4gKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBuZXh0XG59KTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gZmlsdGVyXG4gKi9cbmNvbnN0IGl0ZXJhdG9yRmlsdGVyID0gKGl0ZXJhdG9yLCBmaWx0ZXIpID0+IGNyZWF0ZUl0ZXJhdG9yKCgpID0+IHtcbiAgbGV0IHJlcztcbiAgZG8ge1xuICAgIHJlcyA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfSB3aGlsZSAoIXJlcy5kb25lICYmICFmaWx0ZXIocmVzLnZhbHVlKSlcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFQsTVxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6TX0gZm1hcFxuICovXG5jb25zdCBpdGVyYXRvck1hcCA9IChpdGVyYXRvciwgZm1hcCkgPT4gY3JlYXRlSXRlcmF0b3IoKCkgPT4ge1xuICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBpdGVyYXRvci5uZXh0KCk7XG4gIHJldHVybiB7IGRvbmUsIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogZm1hcCh2YWx1ZSkgfVxufSk7XG5cbnZhciBpdGVyYXRvciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBtYXBJdGVyYXRvcjogbWFwSXRlcmF0b3IsXG4gIGNyZWF0ZUl0ZXJhdG9yOiBjcmVhdGVJdGVyYXRvcixcbiAgaXRlcmF0b3JGaWx0ZXI6IGl0ZXJhdG9yRmlsdGVyLFxuICBpdGVyYXRvck1hcDogaXRlcmF0b3JNYXBcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZUl0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3I7XG5leHBvcnRzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG5leHBvcnRzLml0ZXJhdG9yRmlsdGVyID0gaXRlcmF0b3JGaWx0ZXI7XG5leHBvcnRzLml0ZXJhdG9yTWFwID0gaXRlcmF0b3JNYXA7XG5leHBvcnRzLm1hcEl0ZXJhdG9yID0gbWFwSXRlcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRvci1mZTAxZDIwOS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/iterator-fe01d209.cjs\n")},"./node_modules/lib0/dist/iterator.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar iterator = __webpack_require__(/*! ./iterator-fe01d209.cjs */ "./node_modules/lib0/dist/iterator-fe01d209.cjs");\n\n\n\nexports.createIterator = iterator.createIterator;\nexports.iteratorFilter = iterator.iteratorFilter;\nexports.iteratorMap = iterator.iteratorMap;\nexports.mapIterator = iterator.mapIterator;\n//# sourceMappingURL=iterator.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9pdGVyYXRvci5janM/NWNiMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELGVBQWUsbUJBQU8sQ0FBQywrRUFBeUI7Ozs7QUFJaEQsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9pdGVyYXRvci5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBpdGVyYXRvciA9IHJlcXVpcmUoJy4vaXRlcmF0b3ItZmUwMWQyMDkuY2pzJyk7XG5cblxuXG5leHBvcnRzLmNyZWF0ZUl0ZXJhdG9yID0gaXRlcmF0b3IuY3JlYXRlSXRlcmF0b3I7XG5leHBvcnRzLml0ZXJhdG9yRmlsdGVyID0gaXRlcmF0b3IuaXRlcmF0b3JGaWx0ZXI7XG5leHBvcnRzLml0ZXJhdG9yTWFwID0gaXRlcmF0b3IuaXRlcmF0b3JNYXA7XG5leHBvcnRzLm1hcEl0ZXJhdG9yID0gaXRlcmF0b3IubWFwSXRlcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRvci5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/iterator.cjs\n')},"./node_modules/lib0/dist/json-092190a1.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify;\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse;\n\nvar json = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tstringify: stringify,\n\tparse: parse\n});\n\nexports.json = json;\nexports.parse = parse;\nexports.stringify = stringify;\n//# sourceMappingURL=json-092190a1.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9qc29uLTA5MjE5MGExLmNqcz9hZTE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxZQUFZO0FBQ1osYUFBYTtBQUNiLGlCQUFpQjtBQUNqQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvanNvbi0wOTIxOTBhMS5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogSlNPTiB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAbW9kdWxlIGpzb25cbiAqL1xuXG4vKipcbiAqIFRyYW5zZm9ybSBKYXZhU2NyaXB0IG9iamVjdCB0byBKU09OLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmplY3RcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3Qgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnk7XG5cbi8qKlxuICogUGFyc2UgSlNPTiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGpzb25cbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgcGFyc2UgPSBKU09OLnBhcnNlO1xuXG52YXIganNvbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRzdHJpbmdpZnk6IHN0cmluZ2lmeSxcblx0cGFyc2U6IHBhcnNlXG59KTtcblxuZXhwb3J0cy5qc29uID0ganNvbjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi0wOTIxOTBhMS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/json-092190a1.cjs\n")},"./node_modules/lib0/dist/logging-7cc36806.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar environment = __webpack_require__(/*! ./environment-7e2ffaea.cjs */ \"./node_modules/lib0/dist/environment-7e2ffaea.cjs\");\nvar symbol = __webpack_require__(/*! ./symbol-c5caa724.cjs */ \"./node_modules/lib0/dist/symbol-c5caa724.cjs\");\nvar pair = __webpack_require__(/*! ./pair-ab022bc3.cjs */ \"./node_modules/lib0/dist/pair-ab022bc3.cjs\");\nvar dom = __webpack_require__(/*! ./dom-58958c04.cjs */ \"./node_modules/lib0/dist/dom-58958c04.cjs\");\nvar json = __webpack_require__(/*! ./json-092190a1.cjs */ \"./node_modules/lib0/dist/json-092190a1.cjs\");\nvar map = __webpack_require__(/*! ./map-28a001c9.cjs */ \"./node_modules/lib0/dist/map-28a001c9.cjs\");\nvar eventloop = __webpack_require__(/*! ./eventloop-c60b5658.cjs */ \"./node_modules/lib0/dist/eventloop-c60b5658.cjs\");\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ \"./node_modules/lib0/dist/math-08e068f9.cjs\");\nvar time = __webpack_require__(/*! ./time-e00067da.cjs */ \"./node_modules/lib0/dist/time-e00067da.cjs\");\nvar _function = __webpack_require__(/*! ./function-f8acb5f5.cjs */ \"./node_modules/lib0/dist/function-f8acb5f5.cjs\");\n\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\nconst BOLD = symbol.create();\nconst UNBOLD = symbol.create();\nconst BLUE = symbol.create();\nconst GREY = symbol.create();\nconst GREEN = symbol.create();\nconst RED = symbol.create();\nconst PURPLE = symbol.create();\nconst ORANGE = symbol.create();\nconst UNCOLOR = symbol.create();\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: pair.create('font-weight', 'bold'),\n  [UNBOLD]: pair.create('font-weight', 'normal'),\n  [BLUE]: pair.create('color', 'blue'),\n  [GREEN]: pair.create('color', 'green'),\n  [GREY]: pair.create('color', 'grey'),\n  [RED]: pair.create('color', 'red'),\n  [PURPLE]: pair.create('color', 'purple'),\n  [ORANGE]: pair.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: pair.create('color', 'black')\n};\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n};\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = [];\n  const styles = [];\n  const currentStyle = map.create();\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = [];\n  // try with formatting until we find something unsupported\n  let i = 0;\n\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    // @ts-ignore\n    const style = _browserStyleMap[arg];\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = dom.mapToStyleString(currentStyle);\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg);\n          styles.push(style);\n        } else {\n          strBuilder.push(arg);\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles;\n    logArgs.unshift(strBuilder.join(''));\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg);\n    }\n  }\n  return logArgs\n};\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = [];\n  const logArgs = [];\n\n  // try with formatting until we find something unsupported\n  let i = 0;\n\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    // @ts-ignore\n    const style = _nodeStyleMap[arg];\n    if (style !== undefined) {\n      strBuilder.push(style);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg);\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m');\n    logArgs.push(strBuilder.join(''));\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg);\n    }\n  }\n  return logArgs\n};\n\n/* istanbul ignore next */\nconst computeLoggingArgs = environment.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs;\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args));\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args));\n};\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args));\n  args.unshift(ORANGE);\n  vconsoles.forEach(vc => vc.print(args));\n};\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nconst printError = err => {\n  console.error(err);\n  vconsoles.forEach(vc => vc.printError(err));\n};\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nconst printImg = (url, height) => {\n  if (environment.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`);\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height));\n};\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nconst printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height);\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args));\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args));\n};\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args));\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args));\n};\n\nconst groupEnd = () => {\n  console.groupEnd();\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd());\n};\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nconst printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()));\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nconst printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height);\n\nconst vconsoles = new Set();\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = [];\n  const currentStyle = new Map();\n  // try with formatting until we find something unsupported\n  let i = 0;\n  for (; i < args.length; i++) {\n    const arg = args[i];\n    // @ts-ignore\n    const style = _browserStyleMap[arg];\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right);\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = dom.element('span', [pair.create('style', dom.mapToStyleString(currentStyle))], [dom.text(arg)]);\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;';\n        }\n        spans.push(span);\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i];\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + json.stringify(content) + ' ';\n      }\n      spans.push(dom.element('span', [], [dom.text(/** @type {string} */ (content))]));\n    }\n  }\n  return spans\n};\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;';\n\n/* istanbul ignore next */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom;\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom;\n    this.depth = 0;\n    vconsoles.add(this);\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    eventloop.enqueue(() => {\n      const triangleDown = dom.element('span', [pair.create('hidden', collapsed), pair.create('style', 'color:grey;font-size:120%;')], [dom.text('▼')]);\n      const triangleRight = dom.element('span', [pair.create('hidden', !collapsed), pair.create('style', 'color:grey;font-size:125%;')], [dom.text('▶')]);\n      const content = dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, dom.text(' ')].concat(_computeLineSpans(args)));\n      const nextContainer = dom.element('div', [pair.create('hidden', collapsed)]);\n      const nextLine = dom.element('div', [], [content, nextContainer]);\n      dom.append(this.ccontainer, [nextLine]);\n      this.ccontainer = nextContainer;\n      this.depth++;\n      // when header is clicked, collapse/uncollapse container\n      dom.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden');\n        triangleDown.toggleAttribute('hidden');\n        triangleRight.toggleAttribute('hidden');\n      });\n    });\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true);\n  }\n\n  groupEnd () {\n    eventloop.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--;\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement;\n      }\n    });\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))]);\n    });\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()]);\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('img', [pair.create('src', url), pair.create('height', `${math.round(height * 1.5)}px`)])]);\n    });\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [node]);\n    });\n  }\n\n  destroy () {\n    eventloop.enqueue(() => {\n      vconsoles.delete(this);\n    });\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nconst createVConsole = dom => new VConsole(dom);\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE];\nlet nextColor = 0;\nlet lastLoggingTime = time.getUnixTime();\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor];\n  const debugRegexVar = environment.getVariable('log');\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName));\n  nextColor = (nextColor + 1) % loggingColors.length;\n  moduleName += ': ';\n\n  return !doLogging ? _function.nop : (...args) => {\n    const timeNow = time.getUnixTime();\n    const timeDiff = timeNow - lastLoggingTime;\n    lastLoggingTime = timeNow;\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms');\n  }\n};\n\nvar logging = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BOLD: BOLD,\n  UNBOLD: UNBOLD,\n  BLUE: BLUE,\n  GREY: GREY,\n  GREEN: GREEN,\n  RED: RED,\n  PURPLE: PURPLE,\n  ORANGE: ORANGE,\n  UNCOLOR: UNCOLOR,\n  print: print,\n  warn: warn,\n  printError: printError,\n  printImg: printImg,\n  printImgBase64: printImgBase64,\n  group: group,\n  groupCollapsed: groupCollapsed,\n  groupEnd: groupEnd,\n  printDom: printDom,\n  printCanvas: printCanvas,\n  vconsoles: vconsoles,\n  VConsole: VConsole,\n  createVConsole: createVConsole,\n  createModuleLogger: createModuleLogger\n});\n\nexports.BLUE = BLUE;\nexports.BOLD = BOLD;\nexports.GREEN = GREEN;\nexports.GREY = GREY;\nexports.ORANGE = ORANGE;\nexports.PURPLE = PURPLE;\nexports.RED = RED;\nexports.UNBOLD = UNBOLD;\nexports.UNCOLOR = UNCOLOR;\nexports.VConsole = VConsole;\nexports.createModuleLogger = createModuleLogger;\nexports.createVConsole = createVConsole;\nexports.group = group;\nexports.groupCollapsed = groupCollapsed;\nexports.groupEnd = groupEnd;\nexports.logging = logging;\nexports.print = print;\nexports.printCanvas = printCanvas;\nexports.printDom = printDom;\nexports.printError = printError;\nexports.printImg = printImg;\nexports.printImgBase64 = printImgBase64;\nexports.vconsoles = vconsoles;\nexports.warn = warn;\n//# sourceMappingURL=logging-7cc36806.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9sb2dnaW5nLTdjYzM2ODA2LmNqcz83NDRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHFGQUE0QjtBQUN0RCxhQUFhLG1CQUFPLENBQUMsMkVBQXVCO0FBQzVDLFdBQVcsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDeEMsVUFBVSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsaUZBQTBCO0FBQ2xELFdBQVcsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDeEMsV0FBVyxtQkFBTyxDQUFDLHVFQUFxQjtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBeUI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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T0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcseUJBQXlCO0FBQ2xJLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWTtBQUNaLFlBQVk7QUFDWixhQUFhO0FBQ2IsWUFBWTtBQUNaLGNBQWM7QUFDZCxjQUFjO0FBQ2QsV0FBVztBQUNYLGNBQWM7QUFDZCxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1oiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L2xvZ2dpbmctN2NjMzY4MDYuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL2Vudmlyb25tZW50LTdlMmZmYWVhLmNqcycpO1xudmFyIHN5bWJvbCA9IHJlcXVpcmUoJy4vc3ltYm9sLWM1Y2FhNzI0LmNqcycpO1xudmFyIHBhaXIgPSByZXF1aXJlKCcuL3BhaXItYWIwMjJiYzMuY2pzJyk7XG52YXIgZG9tID0gcmVxdWlyZSgnLi9kb20tNTg5NThjMDQuY2pzJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbi0wOTIxOTBhMS5janMnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL21hcC0yOGEwMDFjOS5janMnKTtcbnZhciBldmVudGxvb3AgPSByZXF1aXJlKCcuL2V2ZW50bG9vcC1jNjBiNTY1OC5janMnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoLTA4ZTA2OGY5LmNqcycpO1xudmFyIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUtZTAwMDY3ZGEuY2pzJyk7XG52YXIgX2Z1bmN0aW9uID0gcmVxdWlyZSgnLi9mdW5jdGlvbi1mOGFjYjVmNS5janMnKTtcblxuLyoqXG4gKiBJc29tb3JwaGljIGxvZ2dpbmcgbW9kdWxlIHdpdGggc3VwcG9ydCBmb3IgY29sb3JzIVxuICpcbiAqIEBtb2R1bGUgbG9nZ2luZ1xuICovXG5cbmNvbnN0IEJPTEQgPSBzeW1ib2wuY3JlYXRlKCk7XG5jb25zdCBVTkJPTEQgPSBzeW1ib2wuY3JlYXRlKCk7XG5jb25zdCBCTFVFID0gc3ltYm9sLmNyZWF0ZSgpO1xuY29uc3QgR1JFWSA9IHN5bWJvbC5jcmVhdGUoKTtcbmNvbnN0IEdSRUVOID0gc3ltYm9sLmNyZWF0ZSgpO1xuY29uc3QgUkVEID0gc3ltYm9sLmNyZWF0ZSgpO1xuY29uc3QgUFVSUExFID0gc3ltYm9sLmNyZWF0ZSgpO1xuY29uc3QgT1JBTkdFID0gc3ltYm9sLmNyZWF0ZSgpO1xuY29uc3QgVU5DT0xPUiA9IHN5bWJvbC5jcmVhdGUoKTtcblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFN5bWJvbCxwYWlyLlBhaXI8c3RyaW5nLHN0cmluZz4+fVxuICovXG5jb25zdCBfYnJvd3NlclN0eWxlTWFwID0ge1xuICBbQk9MRF06IHBhaXIuY3JlYXRlKCdmb250LXdlaWdodCcsICdib2xkJyksXG4gIFtVTkJPTERdOiBwYWlyLmNyZWF0ZSgnZm9udC13ZWlnaHQnLCAnbm9ybWFsJyksXG4gIFtCTFVFXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2JsdWUnKSxcbiAgW0dSRUVOXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2dyZWVuJyksXG4gIFtHUkVZXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2dyZXknKSxcbiAgW1JFRF06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdyZWQnKSxcbiAgW1BVUlBMRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdwdXJwbGUnKSxcbiAgW09SQU5HRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdvcmFuZ2UnKSwgLy8gbm90IHdlbGwgc3VwcG9ydGVkIGluIGNocm9tZSB3aGVuIGRlYnVnZ2luZyBub2RlIHdpdGggaW5zcGVjdG9yIC0gVE9ETzogZGVwcmVjYXRlXG4gIFtVTkNPTE9SXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2JsYWNrJylcbn07XG5cbmNvbnN0IF9ub2RlU3R5bGVNYXAgPSB7XG4gIFtCT0xEXTogJ1xcdTAwMWJbMW0nLFxuICBbVU5CT0xEXTogJ1xcdTAwMWJbMm0nLFxuICBbQkxVRV06ICdcXHgxYlszNG0nLFxuICBbR1JFRU5dOiAnXFx4MWJbMzJtJyxcbiAgW0dSRVldOiAnXFx1MDAxYlszN20nLFxuICBbUkVEXTogJ1xceDFiWzMxbScsXG4gIFtQVVJQTEVdOiAnXFx4MWJbMzVtJyxcbiAgW09SQU5HRV06ICdcXHgxYlszODs1OzIwOG0nLFxuICBbVU5DT0xPUl06ICdcXHgxYlswbSdcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG9iamVjdHxudW1iZXI+fVxuICovXG5jb25zdCBjb21wdXRlQnJvd3NlckxvZ2dpbmdBcmdzID0gYXJncyA9PiB7XG4gIGNvbnN0IHN0ckJ1aWxkZXIgPSBbXTtcbiAgY29uc3Qgc3R5bGVzID0gW107XG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG1hcC5jcmVhdGUoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmd8T2JqZWN0fG51bWJlcj59XG4gICAqL1xuICBsZXQgbG9nQXJncyA9IFtdO1xuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXTtcbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudFN0eWxlLnNldChzdHlsZS5sZWZ0LCBzdHlsZS5yaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvbS5tYXBUb1N0eWxlU3RyaW5nKGN1cnJlbnRTdHlsZSk7XG4gICAgICAgIGlmIChpID4gMCB8fCBzdHlsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3RyQnVpbGRlci5wdXNoKCclYycgKyBhcmcpO1xuICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaSA+IDApIHtcbiAgICAvLyBjcmVhdGUgbG9nQXJncyB3aXRoIHdoYXQgd2UgaGF2ZSBzbyBmYXJcbiAgICBsb2dBcmdzID0gc3R5bGVzO1xuICAgIGxvZ0FyZ3MudW5zaGlmdChzdHJCdWlsZGVyLmpvaW4oJycpKTtcbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBsb2dBcmdzLnB1c2goYXJnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvZ0FyZ3Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbmNvbnN0IGNvbXB1dGVOb2RlTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdO1xuICBjb25zdCBsb2dBcmdzID0gW107XG5cbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3R5bGUgPSBfbm9kZVN0eWxlTWFwW2FyZ107XG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0ckJ1aWxkZXIucHVzaChzdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIHN0ckJ1aWxkZXIucHVzaCgnXFx4MWJbMG0nKTtcbiAgICBsb2dBcmdzLnB1c2goc3RyQnVpbGRlci5qb2luKCcnKSk7XG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBsb2dBcmdzLnB1c2goYXJnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvZ0FyZ3Ncbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjb21wdXRlTG9nZ2luZ0FyZ3MgPSBlbnZpcm9ubWVudC5pc05vZGUgPyBjb21wdXRlTm9kZUxvZ2dpbmdBcmdzIDogY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJncztcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuY29uc3QgcHJpbnQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludChhcmdzKSk7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuY29uc3Qgd2FybiA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUud2FybiguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpO1xuICBhcmdzLnVuc2hpZnQoT1JBTkdFKTtcbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnQoYXJncykpO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKi9cbmNvbnN0IHByaW50RXJyb3IgPSBlcnIgPT4ge1xuICBjb25zb2xlLmVycm9yKGVycik7XG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLnByaW50RXJyb3IoZXJyKSk7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIGltYWdlIGxvY2F0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxcbiAqL1xuY29uc3QgcHJpbnRJbWcgPSAodXJsLCBoZWlnaHQpID0+IHtcbiAgaWYgKGVudmlyb25tZW50LmlzQnJvd3Nlcikge1xuICAgIGNvbnNvbGUubG9nKCclYyAgICAgICAgICAgICAgICAgICAgICAnLCBgZm9udC1zaXplOiAke2hlaWdodH1weDsgYmFja2dyb3VuZC1zaXplOiBjb250YWluOyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHt1cmx9KWApO1xuICAgIC8vIGNvbnNvbGUubG9nKCclYyAgICAgICAgICAgICAgICAnLCBgZm9udC1zaXplOiAke2hlaWdodH14OyBiYWNrZ3JvdW5kOiB1cmwoJHt1cmx9KSBuby1yZXBlYXQ7YClcbiAgfVxuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludEltZyh1cmwsIGhlaWdodCkpO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICovXG5jb25zdCBwcmludEltZ0Jhc2U2NCA9IChiYXNlNjQsIGhlaWdodCkgPT4gcHJpbnRJbWcoYGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwke2Jhc2U2NH1gLCBoZWlnaHQpO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5jb25zdCBncm91cCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXAoLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMuZ3JvdXAoYXJncykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuY29uc3QgZ3JvdXBDb2xsYXBzZWQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwQ29sbGFwc2VkKGFyZ3MpKTtcbn07XG5cbmNvbnN0IGdyb3VwRW5kID0gKCkgPT4ge1xuICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwRW5kKCkpO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOk5vZGV9IGNyZWF0ZU5vZGVcbiAqL1xuY29uc3QgcHJpbnREb20gPSBjcmVhdGVOb2RlID0+XG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLnByaW50RG9tKGNyZWF0ZU5vZGUoKSkpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuY29uc3QgcHJpbnRDYW52YXMgPSAoY2FudmFzLCBoZWlnaHQpID0+IHByaW50SW1nKGNhbnZhcy50b0RhdGFVUkwoKSwgaGVpZ2h0KTtcblxuY29uc3QgdmNvbnNvbGVzID0gbmV3IFNldCgpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqIEByZXR1cm4ge0FycmF5PEVsZW1lbnQ+fVxuICovXG5jb25zdCBfY29tcHV0ZUxpbmVTcGFucyA9IGFyZ3MgPT4ge1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBjb25zdCBjdXJyZW50U3R5bGUgPSBuZXcgTWFwKCk7XG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXTtcbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudFN0eWxlLnNldChzdHlsZS5sZWZ0LCBzdHlsZS5yaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHNwYW4gPSBkb20uZWxlbWVudCgnc3BhbicsIFtwYWlyLmNyZWF0ZSgnc3R5bGUnLCBkb20ubWFwVG9TdHlsZVN0cmluZyhjdXJyZW50U3R5bGUpKV0sIFtkb20udGV4dChhcmcpXSk7XG4gICAgICAgIGlmIChzcGFuLmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICBzcGFuLmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgICAgICB9XG4gICAgICAgIHNwYW5zLnB1c2goc3Bhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBhcmdzW2ldO1xuICAgIGlmICghKGNvbnRlbnQgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBpZiAoY29udGVudC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nICYmIGNvbnRlbnQuY29uc3RydWN0b3IgIT09IE51bWJlcikge1xuICAgICAgICBjb250ZW50ID0gJyAnICsganNvbi5zdHJpbmdpZnkoY29udGVudCkgKyAnICc7XG4gICAgICB9XG4gICAgICBzcGFucy5wdXNoKGRvbS5lbGVtZW50KCdzcGFuJywgW10sIFtkb20udGV4dCgvKiogQHR5cGUge3N0cmluZ30gKi8gKGNvbnRlbnQpKV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNwYW5zXG59O1xuXG5jb25zdCBsaW5lU3R5bGUgPSAnZm9udC1mYW1pbHk6bW9ub3NwYWNlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMmUyZTI7cGFkZGluZzoycHg7JztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNsYXNzIFZDb25zb2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9tKSB7XG4gICAgdGhpcy5kb20gPSBkb207XG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5kb207XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdmNvbnNvbGVzLmFkZCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWRcbiAgICovXG4gIGdyb3VwIChhcmdzLCBjb2xsYXBzZWQgPSBmYWxzZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlRG93biA9IGRvbS5lbGVtZW50KCdzcGFuJywgW3BhaXIuY3JlYXRlKCdoaWRkZW4nLCBjb2xsYXBzZWQpLCBwYWlyLmNyZWF0ZSgnc3R5bGUnLCAnY29sb3I6Z3JleTtmb250LXNpemU6MTIwJTsnKV0sIFtkb20udGV4dCgn4pa8JyldKTtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlUmlnaHQgPSBkb20uZWxlbWVudCgnc3BhbicsIFtwYWlyLmNyZWF0ZSgnaGlkZGVuJywgIWNvbGxhcHNlZCksIHBhaXIuY3JlYXRlKCdzdHlsZScsICdjb2xvcjpncmV5O2ZvbnQtc2l6ZToxMjUlOycpXSwgW2RvbS50ZXh0KCfilrYnKV0pO1xuICAgICAgY29uc3QgY29udGVudCA9IGRvbS5lbGVtZW50KCdkaXYnLCBbcGFpci5jcmVhdGUoJ3N0eWxlJywgYCR7bGluZVN0eWxlfTtwYWRkaW5nLWxlZnQ6JHt0aGlzLmRlcHRoICogMTB9cHhgKV0sIFt0cmlhbmdsZURvd24sIHRyaWFuZ2xlUmlnaHQsIGRvbS50ZXh0KCcgJyldLmNvbmNhdChfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSkpO1xuICAgICAgY29uc3QgbmV4dENvbnRhaW5lciA9IGRvbS5lbGVtZW50KCdkaXYnLCBbcGFpci5jcmVhdGUoJ2hpZGRlbicsIGNvbGxhcHNlZCldKTtcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gZG9tLmVsZW1lbnQoJ2RpdicsIFtdLCBbY29udGVudCwgbmV4dENvbnRhaW5lcl0pO1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtuZXh0TGluZV0pO1xuICAgICAgdGhpcy5jY29udGFpbmVyID0gbmV4dENvbnRhaW5lcjtcbiAgICAgIHRoaXMuZGVwdGgrKztcbiAgICAgIC8vIHdoZW4gaGVhZGVyIGlzIGNsaWNrZWQsIGNvbGxhcHNlL3VuY29sbGFwc2UgY29udGFpbmVyXG4gICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihjb250ZW50LCAnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIG5leHRDb250YWluZXIudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgICAgdHJpYW5nbGVEb3duLnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJyk7XG4gICAgICAgIHRyaWFuZ2xlUmlnaHQudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKi9cbiAgZ3JvdXBDb2xsYXBzZWQgKGFyZ3MpIHtcbiAgICB0aGlzLmdyb3VwKGFyZ3MsIHRydWUpO1xuICB9XG5cbiAgZ3JvdXBFbmQgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlcHRoID4gMCkge1xuICAgICAgICB0aGlzLmRlcHRoLS07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5jY29udGFpbmVyLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIHByaW50IChhcmdzKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtkb20uZWxlbWVudCgnZGl2JywgW3BhaXIuY3JlYXRlKCdzdHlsZScsIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YCldLCBfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSldKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICovXG4gIHByaW50RXJyb3IgKGVycikge1xuICAgIHRoaXMucHJpbnQoW1JFRCwgQk9MRCwgZXJyLnRvU3RyaW5nKCldKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHByaW50SW1nICh1cmwsIGhlaWdodCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbZG9tLmVsZW1lbnQoJ2ltZycsIFtwYWlyLmNyZWF0ZSgnc3JjJywgdXJsKSwgcGFpci5jcmVhdGUoJ2hlaWdodCcsIGAke21hdGgucm91bmQoaGVpZ2h0ICogMS41KX1weGApXSldKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHByaW50RG9tIChub2RlKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtub2RlXSk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICB2Y29uc29sZXMuZGVsZXRlKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKi9cbmNvbnN0IGNyZWF0ZVZDb25zb2xlID0gZG9tID0+IG5ldyBWQ29uc29sZShkb20pO1xuXG5jb25zdCBsb2dnaW5nQ29sb3JzID0gW0dSRUVOLCBQVVJQTEUsIE9SQU5HRSwgQkxVRV07XG5sZXQgbmV4dENvbG9yID0gMDtcbmxldCBsYXN0TG9nZ2luZ1RpbWUgPSB0aW1lLmdldFVuaXhUaW1lKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuY29uc3QgY3JlYXRlTW9kdWxlTG9nZ2VyID0gbW9kdWxlTmFtZSA9PiB7XG4gIGNvbnN0IGNvbG9yID0gbG9nZ2luZ0NvbG9yc1tuZXh0Q29sb3JdO1xuICBjb25zdCBkZWJ1Z1JlZ2V4VmFyID0gZW52aXJvbm1lbnQuZ2V0VmFyaWFibGUoJ2xvZycpO1xuICBjb25zdCBkb0xvZ2dpbmcgPSBkZWJ1Z1JlZ2V4VmFyICE9PSBudWxsICYmIChkZWJ1Z1JlZ2V4VmFyID09PSAnKicgfHwgZGVidWdSZWdleFZhciA9PT0gJ3RydWUnIHx8IG5ldyBSZWdFeHAoZGVidWdSZWdleFZhciwgJ2dpJykudGVzdChtb2R1bGVOYW1lKSk7XG4gIG5leHRDb2xvciA9IChuZXh0Q29sb3IgKyAxKSAlIGxvZ2dpbmdDb2xvcnMubGVuZ3RoO1xuICBtb2R1bGVOYW1lICs9ICc6ICc7XG5cbiAgcmV0dXJuICFkb0xvZ2dpbmcgPyBfZnVuY3Rpb24ubm9wIDogKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCB0aW1lTm93ID0gdGltZS5nZXRVbml4VGltZSgpO1xuICAgIGNvbnN0IHRpbWVEaWZmID0gdGltZU5vdyAtIGxhc3RMb2dnaW5nVGltZTtcbiAgICBsYXN0TG9nZ2luZ1RpbWUgPSB0aW1lTm93O1xuICAgIHByaW50KGNvbG9yLCBtb2R1bGVOYW1lLCBVTkNPTE9SLCAuLi5hcmdzLm1hcChhcmcgPT4gKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnKSA/IGFyZyA6IEpTT04uc3RyaW5naWZ5KGFyZykpLCBjb2xvciwgJyArJyArIHRpbWVEaWZmICsgJ21zJyk7XG4gIH1cbn07XG5cbnZhciBsb2dnaW5nID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEJPTEQ6IEJPTEQsXG4gIFVOQk9MRDogVU5CT0xELFxuICBCTFVFOiBCTFVFLFxuICBHUkVZOiBHUkVZLFxuICBHUkVFTjogR1JFRU4sXG4gIFJFRDogUkVELFxuICBQVVJQTEU6IFBVUlBMRSxcbiAgT1JBTkdFOiBPUkFOR0UsXG4gIFVOQ09MT1I6IFVOQ09MT1IsXG4gIHByaW50OiBwcmludCxcbiAgd2Fybjogd2FybixcbiAgcHJpbnRFcnJvcjogcHJpbnRFcnJvcixcbiAgcHJpbnRJbWc6IHByaW50SW1nLFxuICBwcmludEltZ0Jhc2U2NDogcHJpbnRJbWdCYXNlNjQsXG4gIGdyb3VwOiBncm91cCxcbiAgZ3JvdXBDb2xsYXBzZWQ6IGdyb3VwQ29sbGFwc2VkLFxuICBncm91cEVuZDogZ3JvdXBFbmQsXG4gIHByaW50RG9tOiBwcmludERvbSxcbiAgcHJpbnRDYW52YXM6IHByaW50Q2FudmFzLFxuICB2Y29uc29sZXM6IHZjb25zb2xlcyxcbiAgVkNvbnNvbGU6IFZDb25zb2xlLFxuICBjcmVhdGVWQ29uc29sZTogY3JlYXRlVkNvbnNvbGUsXG4gIGNyZWF0ZU1vZHVsZUxvZ2dlcjogY3JlYXRlTW9kdWxlTG9nZ2VyXG59KTtcblxuZXhwb3J0cy5CTFVFID0gQkxVRTtcbmV4cG9ydHMuQk9MRCA9IEJPTEQ7XG5leHBvcnRzLkdSRUVOID0gR1JFRU47XG5leHBvcnRzLkdSRVkgPSBHUkVZO1xuZXhwb3J0cy5PUkFOR0UgPSBPUkFOR0U7XG5leHBvcnRzLlBVUlBMRSA9IFBVUlBMRTtcbmV4cG9ydHMuUkVEID0gUkVEO1xuZXhwb3J0cy5VTkJPTEQgPSBVTkJPTEQ7XG5leHBvcnRzLlVOQ09MT1IgPSBVTkNPTE9SO1xuZXhwb3J0cy5WQ29uc29sZSA9IFZDb25zb2xlO1xuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG5leHBvcnRzLmNyZWF0ZVZDb25zb2xlID0gY3JlYXRlVkNvbnNvbGU7XG5leHBvcnRzLmdyb3VwID0gZ3JvdXA7XG5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gZ3JvdXBDb2xsYXBzZWQ7XG5leHBvcnRzLmdyb3VwRW5kID0gZ3JvdXBFbmQ7XG5leHBvcnRzLmxvZ2dpbmcgPSBsb2dnaW5nO1xuZXhwb3J0cy5wcmludCA9IHByaW50O1xuZXhwb3J0cy5wcmludENhbnZhcyA9IHByaW50Q2FudmFzO1xuZXhwb3J0cy5wcmludERvbSA9IHByaW50RG9tO1xuZXhwb3J0cy5wcmludEVycm9yID0gcHJpbnRFcnJvcjtcbmV4cG9ydHMucHJpbnRJbWcgPSBwcmludEltZztcbmV4cG9ydHMucHJpbnRJbWdCYXNlNjQgPSBwcmludEltZ0Jhc2U2NDtcbmV4cG9ydHMudmNvbnNvbGVzID0gdmNvbnNvbGVzO1xuZXhwb3J0cy53YXJuID0gd2Fybjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmctN2NjMzY4MDYuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/logging-7cc36806.cjs\n")},"./node_modules/lib0/dist/logging.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n__webpack_require__(/*! ./environment-7e2ffaea.cjs */ "./node_modules/lib0/dist/environment-7e2ffaea.cjs");\n__webpack_require__(/*! ./symbol-c5caa724.cjs */ "./node_modules/lib0/dist/symbol-c5caa724.cjs");\n__webpack_require__(/*! ./pair-ab022bc3.cjs */ "./node_modules/lib0/dist/pair-ab022bc3.cjs");\n__webpack_require__(/*! ./dom-58958c04.cjs */ "./node_modules/lib0/dist/dom-58958c04.cjs");\n__webpack_require__(/*! ./json-092190a1.cjs */ "./node_modules/lib0/dist/json-092190a1.cjs");\n__webpack_require__(/*! ./map-28a001c9.cjs */ "./node_modules/lib0/dist/map-28a001c9.cjs");\n__webpack_require__(/*! ./eventloop-c60b5658.cjs */ "./node_modules/lib0/dist/eventloop-c60b5658.cjs");\n__webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\n__webpack_require__(/*! ./time-e00067da.cjs */ "./node_modules/lib0/dist/time-e00067da.cjs");\n__webpack_require__(/*! ./function-f8acb5f5.cjs */ "./node_modules/lib0/dist/function-f8acb5f5.cjs");\nvar logging = __webpack_require__(/*! ./logging-7cc36806.cjs */ "./node_modules/lib0/dist/logging-7cc36806.cjs");\n__webpack_require__(/*! ./string-f3c3d805.cjs */ "./node_modules/lib0/dist/string-f3c3d805.cjs");\n__webpack_require__(/*! ./conditions-fb475c70.cjs */ "./node_modules/lib0/dist/conditions-fb475c70.cjs");\n__webpack_require__(/*! ./storage.cjs */ "./node_modules/lib0/dist/storage.cjs");\n__webpack_require__(/*! ./metric.cjs */ "./node_modules/lib0/dist/metric.cjs");\n__webpack_require__(/*! ./array-b2d24238.cjs */ "./node_modules/lib0/dist/array-b2d24238.cjs");\n__webpack_require__(/*! ./object-dcdd6eed.cjs */ "./node_modules/lib0/dist/object-dcdd6eed.cjs");\n\n\n\nexports.BLUE = logging.BLUE;\nexports.BOLD = logging.BOLD;\nexports.GREEN = logging.GREEN;\nexports.GREY = logging.GREY;\nexports.ORANGE = logging.ORANGE;\nexports.PURPLE = logging.PURPLE;\nexports.RED = logging.RED;\nexports.UNBOLD = logging.UNBOLD;\nexports.UNCOLOR = logging.UNCOLOR;\nexports.VConsole = logging.VConsole;\nexports.createModuleLogger = logging.createModuleLogger;\nexports.createVConsole = logging.createVConsole;\nexports.group = logging.group;\nexports.groupCollapsed = logging.groupCollapsed;\nexports.groupEnd = logging.groupEnd;\nexports.print = logging.print;\nexports.printCanvas = logging.printCanvas;\nexports.printDom = logging.printDom;\nexports.printError = logging.printError;\nexports.printImg = logging.printImg;\nexports.printImgBase64 = logging.printImgBase64;\nexports.vconsoles = logging.vconsoles;\nexports.warn = logging.warn;\n//# sourceMappingURL=logging.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9sb2dnaW5nLmNqcz8yMTNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxDQUFDLGNBQWMsRUFBQzs7QUFFN0QsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDNUIsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQyxxRUFBb0I7QUFDNUIsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDN0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsY0FBYyxtQkFBTyxDQUFDLDZFQUF3QjtBQUM5QyxtQkFBTyxDQUFDLDJFQUF1QjtBQUMvQixtQkFBTyxDQUFDLG1GQUEyQjtBQUNuQyxtQkFBTyxDQUFDLDJEQUFlO0FBQ3ZCLG1CQUFPLENBQUMseURBQWM7QUFDdEIsbUJBQU8sQ0FBQyx5RUFBc0I7QUFDOUIsbUJBQU8sQ0FBQywyRUFBdUI7Ozs7QUFJL0IsWUFBWTtBQUNaLFlBQVk7QUFDWixhQUFhO0FBQ2IsWUFBWTtBQUNaLGNBQWM7QUFDZCxjQUFjO0FBQ2QsV0FBVztBQUNYLGNBQWM7QUFDZCxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsaUJBQWlCO0FBQ2pCLFlBQVk7QUFDWiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvbG9nZ2luZy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnJlcXVpcmUoJy4vZW52aXJvbm1lbnQtN2UyZmZhZWEuY2pzJyk7XG5yZXF1aXJlKCcuL3N5bWJvbC1jNWNhYTcyNC5janMnKTtcbnJlcXVpcmUoJy4vcGFpci1hYjAyMmJjMy5janMnKTtcbnJlcXVpcmUoJy4vZG9tLTU4OTU4YzA0LmNqcycpO1xucmVxdWlyZSgnLi9qc29uLTA5MjE5MGExLmNqcycpO1xucmVxdWlyZSgnLi9tYXAtMjhhMDAxYzkuY2pzJyk7XG5yZXF1aXJlKCcuL2V2ZW50bG9vcC1jNjBiNTY1OC5janMnKTtcbnJlcXVpcmUoJy4vbWF0aC0wOGUwNjhmOS5janMnKTtcbnJlcXVpcmUoJy4vdGltZS1lMDAwNjdkYS5janMnKTtcbnJlcXVpcmUoJy4vZnVuY3Rpb24tZjhhY2I1ZjUuY2pzJyk7XG52YXIgbG9nZ2luZyA9IHJlcXVpcmUoJy4vbG9nZ2luZy03Y2MzNjgwNi5janMnKTtcbnJlcXVpcmUoJy4vc3RyaW5nLWYzYzNkODA1LmNqcycpO1xucmVxdWlyZSgnLi9jb25kaXRpb25zLWZiNDc1YzcwLmNqcycpO1xucmVxdWlyZSgnLi9zdG9yYWdlLmNqcycpO1xucmVxdWlyZSgnLi9tZXRyaWMuY2pzJyk7XG5yZXF1aXJlKCcuL2FycmF5LWIyZDI0MjM4LmNqcycpO1xucmVxdWlyZSgnLi9vYmplY3QtZGNkZDZlZWQuY2pzJyk7XG5cblxuXG5leHBvcnRzLkJMVUUgPSBsb2dnaW5nLkJMVUU7XG5leHBvcnRzLkJPTEQgPSBsb2dnaW5nLkJPTEQ7XG5leHBvcnRzLkdSRUVOID0gbG9nZ2luZy5HUkVFTjtcbmV4cG9ydHMuR1JFWSA9IGxvZ2dpbmcuR1JFWTtcbmV4cG9ydHMuT1JBTkdFID0gbG9nZ2luZy5PUkFOR0U7XG5leHBvcnRzLlBVUlBMRSA9IGxvZ2dpbmcuUFVSUExFO1xuZXhwb3J0cy5SRUQgPSBsb2dnaW5nLlJFRDtcbmV4cG9ydHMuVU5CT0xEID0gbG9nZ2luZy5VTkJPTEQ7XG5leHBvcnRzLlVOQ09MT1IgPSBsb2dnaW5nLlVOQ09MT1I7XG5leHBvcnRzLlZDb25zb2xlID0gbG9nZ2luZy5WQ29uc29sZTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gbG9nZ2luZy5jcmVhdGVNb2R1bGVMb2dnZXI7XG5leHBvcnRzLmNyZWF0ZVZDb25zb2xlID0gbG9nZ2luZy5jcmVhdGVWQ29uc29sZTtcbmV4cG9ydHMuZ3JvdXAgPSBsb2dnaW5nLmdyb3VwO1xuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ2dpbmcuZ3JvdXBDb2xsYXBzZWQ7XG5leHBvcnRzLmdyb3VwRW5kID0gbG9nZ2luZy5ncm91cEVuZDtcbmV4cG9ydHMucHJpbnQgPSBsb2dnaW5nLnByaW50O1xuZXhwb3J0cy5wcmludENhbnZhcyA9IGxvZ2dpbmcucHJpbnRDYW52YXM7XG5leHBvcnRzLnByaW50RG9tID0gbG9nZ2luZy5wcmludERvbTtcbmV4cG9ydHMucHJpbnRFcnJvciA9IGxvZ2dpbmcucHJpbnRFcnJvcjtcbmV4cG9ydHMucHJpbnRJbWcgPSBsb2dnaW5nLnByaW50SW1nO1xuZXhwb3J0cy5wcmludEltZ0Jhc2U2NCA9IGxvZ2dpbmcucHJpbnRJbWdCYXNlNjQ7XG5leHBvcnRzLnZjb25zb2xlcyA9IGxvZ2dpbmcudmNvbnNvbGVzO1xuZXhwb3J0cy53YXJuID0gbG9nZ2luZy53YXJuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/logging.cjs\n')},"./node_modules/lib0/dist/map-28a001c9.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map();\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nconst copy = m => {\n  const r = create();\n  m.forEach((v, k) => { r.set(k, v); });\n  return r\n};\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key);\n  if (set === undefined) {\n    map.set(key, set = createT());\n  }\n  return set\n};\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = [];\n  for (const [key, value] of m) {\n    res.push(f(value, key));\n  }\n  return res\n};\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n};\n\nvar map$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  create: create,\n  copy: copy,\n  setIfUndefined: setIfUndefined,\n  map: map,\n  any: any,\n  all: all\n});\n\nexports.all = all;\nexports.any = any;\nexports.copy = copy;\nexports.create = create;\nexports.map = map;\nexports.map$1 = map$1;\nexports.setIfUndefined = setIfUndefined;\n//# sourceMappingURL=map-28a001c9.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tYXAtMjhhMDAxYzkuY2pzPzkxOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxFQUFFO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1gsV0FBVztBQUNYLFlBQVk7QUFDWixjQUFjO0FBQ2QsV0FBVztBQUNYLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L21hcC0yOGEwMDFjOS5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIGtleS12YWx1ZSBzdG9yZXMuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTWFwIGluc3RhbmNlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7TWFwPGFueSwgYW55Pn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlID0gKCkgPT4gbmV3IE1hcCgpO1xuXG4vKipcbiAqIENvcHkgYSBNYXAgb2JqZWN0IGludG8gYSBmcmVzaCBNYXAgb2JqZWN0LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFgsWVxuICogQHBhcmFtIHtNYXA8WCxZPn0gbVxuICogQHJldHVybiB7TWFwPFgsWT59XG4gKi9cbmNvbnN0IGNvcHkgPSBtID0+IHtcbiAgY29uc3QgciA9IGNyZWF0ZSgpO1xuICBtLmZvckVhY2goKHYsIGspID0+IHsgci5zZXQoaywgdik7IH0pO1xuICByZXR1cm4gclxufTtcblxuLyoqXG4gKiBHZXQgbWFwIHByb3BlcnR5LiBDcmVhdGUgVCBpZiBwcm9wZXJ0eSBpcyB1bmRlZmluZWQgYW5kIHNldCBUIG9uIG1hcC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbGlzdGVuZXJzID0gbWFwLnNldElmVW5kZWZpbmVkKGV2ZW50cywgJ2V2ZW50TmFtZScsIHNldC5jcmVhdGUpXG4gKiBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKVxuICogYGBgXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCxLXG4gKiBAcGFyYW0ge01hcDxLLCBUPn0gbWFwXG4gKiBAcGFyYW0ge0t9IGtleVxuICogQHBhcmFtIHtmdW5jdGlvbigpOlR9IGNyZWF0ZVRcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IHNldElmVW5kZWZpbmVkID0gKG1hcCwga2V5LCBjcmVhdGVUKSA9PiB7XG4gIGxldCBzZXQgPSBtYXAuZ2V0KGtleSk7XG4gIGlmIChzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpO1xuICB9XG4gIHJldHVybiBzZXRcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBBcnJheSBhbmQgcG9wdWxhdGVzIGl0IHdpdGggdGhlIGNvbnRlbnQgb2YgYWxsIGtleS12YWx1ZSBwYWlycyB1c2luZyB0aGUgYGYodmFsdWUsIGtleSlgIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIEtcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOlJ9IGZcbiAqIEByZXR1cm4ge0FycmF5PFI+fVxuICovXG5jb25zdCBtYXAgPSAobSwgZikgPT4ge1xuICBjb25zdCByZXMgPSBbXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIHJlcy5wdXNoKGYodmFsdWUsIGtleSkpO1xuICB9XG4gIHJldHVybiByZXNcbn07XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBhbnkga2V5LXZhbHVlIHBhaXJzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgYGYodmFsdWUsIGtleSlgLlxuICpcbiAqIEB0b2RvIHNob3VsZCByZW5hbWUgdG8gc29tZSAtIHNpbWlsYXJseSB0byBBcnJheS5zb21lXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBhbnkgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKGYodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFsbCBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBhbGwgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKCFmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbnZhciBtYXAkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY29weTogY29weSxcbiAgc2V0SWZVbmRlZmluZWQ6IHNldElmVW5kZWZpbmVkLFxuICBtYXA6IG1hcCxcbiAgYW55OiBhbnksXG4gIGFsbDogYWxsXG59KTtcblxuZXhwb3J0cy5hbGwgPSBhbGw7XG5leHBvcnRzLmFueSA9IGFueTtcbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5tYXAkMSA9IG1hcCQxO1xuZXhwb3J0cy5zZXRJZlVuZGVmaW5lZCA9IHNldElmVW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLTI4YTAwMWM5LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/map-28a001c9.cjs\n")},"./node_modules/lib0/dist/map.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar map = __webpack_require__(/*! ./map-28a001c9.cjs */ "./node_modules/lib0/dist/map-28a001c9.cjs");\n\n\n\nexports.all = map.all;\nexports.any = map.any;\nexports.copy = map.copy;\nexports.create = map.create;\nexports.map = map.map;\nexports.setIfUndefined = map.setIfUndefined;\n//# sourceMappingURL=map.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tYXAuY2pzPzk1MDEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxVQUFVLG1CQUFPLENBQUMscUVBQW9COzs7O0FBSXRDLFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWTtBQUNaLGNBQWM7QUFDZCxXQUFXO0FBQ1gsc0JBQXNCO0FBQ3RCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tYXAuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAtMjhhMDAxYzkuY2pzJyk7XG5cblxuXG5leHBvcnRzLmFsbCA9IG1hcC5hbGw7XG5leHBvcnRzLmFueSA9IG1hcC5hbnk7XG5leHBvcnRzLmNvcHkgPSBtYXAuY29weTtcbmV4cG9ydHMuY3JlYXRlID0gbWFwLmNyZWF0ZTtcbmV4cG9ydHMubWFwID0gbWFwLm1hcDtcbmV4cG9ydHMuc2V0SWZVbmRlZmluZWQgPSBtYXAuc2V0SWZVbmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/map.cjs\n')},"./node_modules/lib0/dist/math-08e068f9.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor;\nconst ceil = Math.ceil;\nconst abs = Math.abs;\nconst imul = Math.imul;\nconst round = Math.round;\nconst log10 = Math.log10;\nconst log2 = Math.log2;\nconst log = Math.log;\nconst sqrt = Math.sqrt;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b;\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b;\n\nconst isNaN = Number.isNaN;\n\nconst pow = Math.pow;\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp);\n\nconst sign = Math.sign;\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0;\n\nvar math = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tfloor: floor,\n\tceil: ceil,\n\tabs: abs,\n\timul: imul,\n\tround: round,\n\tlog10: log10,\n\tlog2: log2,\n\tlog: log,\n\tsqrt: sqrt,\n\tadd: add,\n\tmin: min,\n\tmax: max,\n\tisNaN: isNaN,\n\tpow: pow,\n\texp10: exp10,\n\tsign: sign,\n\tisNegativeZero: isNegativeZero\n});\n\nexports.abs = abs;\nexports.add = add;\nexports.ceil = ceil;\nexports.exp10 = exp10;\nexports.floor = floor;\nexports.imul = imul;\nexports.isNaN = isNaN;\nexports.isNegativeZero = isNegativeZero;\nexports.log = log;\nexports.log10 = log10;\nexports.log2 = log2;\nexports.math = math;\nexports.max = max;\nexports.min = min;\nexports.pow = pow;\nexports.round = round;\nexports.sign = sign;\nexports.sqrt = sqrt;\n//# sourceMappingURL=math-08e068f9.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tYXRoLTA4ZTA2OGY5LmNqcz85NTc3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxXQUFXO0FBQ1gsV0FBVztBQUNYLFlBQVk7QUFDWixhQUFhO0FBQ2IsYUFBYTtBQUNiLFlBQVk7QUFDWixhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3QvbWF0aC0wOGUwNjhmOS5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY2VpbCA9IE1hdGguY2VpbDtcbmNvbnN0IGFicyA9IE1hdGguYWJzO1xuY29uc3QgaW11bCA9IE1hdGguaW11bDtcbmNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZDtcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IGxvZzIgPSBNYXRoLmxvZzI7XG5jb25zdCBsb2cgPSBNYXRoLmxvZztcbmNvbnN0IHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHN1bSBvZiBhIGFuZCBiXG4gKi9cbmNvbnN0IGFkZCA9IChhLCBiKSA9PiBhICsgYjtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc21hbGxlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuY29uc3QgbWluID0gKGEsIGIpID0+IGEgPCBiID8gYSA6IGI7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJpZ2dlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuY29uc3QgbWF4ID0gKGEsIGIpID0+IGEgPiBiID8gYSA6IGI7XG5cbmNvbnN0IGlzTmFOID0gTnVtYmVyLmlzTmFOO1xuXG5jb25zdCBwb3cgPSBNYXRoLnBvdztcbi8qKlxuICogQmFzZSAxMCBleHBvbmVudGlhbCBmdW5jdGlvbi4gUmV0dXJucyB0aGUgdmFsdWUgb2YgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZiBwb3cuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBleHAxMCA9IGV4cCA9PiBNYXRoLnBvdygxMCwgZXhwKTtcblxuY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybiB7Ym9vbGVhbn0gV2V0aGVyIG4gaXMgbmVnYXRpdmUuIFRoaXMgZnVuY3Rpb24gYWxzbyBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIC0wIGFuZCArMFxuICovXG5jb25zdCBpc05lZ2F0aXZlWmVybyA9IG4gPT4gbiAhPT0gMCA/IG4gPCAwIDogMSAvIG4gPCAwO1xuXG52YXIgbWF0aCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRmbG9vcjogZmxvb3IsXG5cdGNlaWw6IGNlaWwsXG5cdGFiczogYWJzLFxuXHRpbXVsOiBpbXVsLFxuXHRyb3VuZDogcm91bmQsXG5cdGxvZzEwOiBsb2cxMCxcblx0bG9nMjogbG9nMixcblx0bG9nOiBsb2csXG5cdHNxcnQ6IHNxcnQsXG5cdGFkZDogYWRkLFxuXHRtaW46IG1pbixcblx0bWF4OiBtYXgsXG5cdGlzTmFOOiBpc05hTixcblx0cG93OiBwb3csXG5cdGV4cDEwOiBleHAxMCxcblx0c2lnbjogc2lnbixcblx0aXNOZWdhdGl2ZVplcm86IGlzTmVnYXRpdmVaZXJvXG59KTtcblxuZXhwb3J0cy5hYnMgPSBhYnM7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuY2VpbCA9IGNlaWw7XG5leHBvcnRzLmV4cDEwID0gZXhwMTA7XG5leHBvcnRzLmZsb29yID0gZmxvb3I7XG5leHBvcnRzLmltdWwgPSBpbXVsO1xuZXhwb3J0cy5pc05hTiA9IGlzTmFOO1xuZXhwb3J0cy5pc05lZ2F0aXZlWmVybyA9IGlzTmVnYXRpdmVaZXJvO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmxvZzEwID0gbG9nMTA7XG5leHBvcnRzLmxvZzIgPSBsb2cyO1xuZXhwb3J0cy5tYXRoID0gbWF0aDtcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLnBvdyA9IHBvdztcbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5leHBvcnRzLnNxcnQgPSBzcXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC0wOGUwNjhmOS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/math-08e068f9.cjs\n")},"./node_modules/lib0/dist/math.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\n\n\n\nexports.abs = math.abs;\nexports.add = math.add;\nexports.ceil = math.ceil;\nexports.exp10 = math.exp10;\nexports.floor = math.floor;\nexports.imul = math.imul;\nexports.isNaN = math.isNaN;\nexports.isNegativeZero = math.isNegativeZero;\nexports.log = math.log;\nexports.log10 = math.log10;\nexports.log2 = math.log2;\nexports.max = math.max;\nexports.min = math.min;\nexports.pow = math.pow;\nexports.round = math.round;\nexports.sign = math.sign;\nexports.sqrt = math.sqrt;\n//# sourceMappingURL=math.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tYXRoLmNqcz8yYTFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxDQUFDLGNBQWMsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLHVFQUFxQjs7OztBQUl4QyxXQUFXO0FBQ1gsV0FBVztBQUNYLFlBQVk7QUFDWixhQUFhO0FBQ2IsYUFBYTtBQUNiLFlBQVk7QUFDWixhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYLGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWTtBQUNaIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tYXRoLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG1hdGggPSByZXF1aXJlKCcuL21hdGgtMDhlMDY4ZjkuY2pzJyk7XG5cblxuXG5leHBvcnRzLmFicyA9IG1hdGguYWJzO1xuZXhwb3J0cy5hZGQgPSBtYXRoLmFkZDtcbmV4cG9ydHMuY2VpbCA9IG1hdGguY2VpbDtcbmV4cG9ydHMuZXhwMTAgPSBtYXRoLmV4cDEwO1xuZXhwb3J0cy5mbG9vciA9IG1hdGguZmxvb3I7XG5leHBvcnRzLmltdWwgPSBtYXRoLmltdWw7XG5leHBvcnRzLmlzTmFOID0gbWF0aC5pc05hTjtcbmV4cG9ydHMuaXNOZWdhdGl2ZVplcm8gPSBtYXRoLmlzTmVnYXRpdmVaZXJvO1xuZXhwb3J0cy5sb2cgPSBtYXRoLmxvZztcbmV4cG9ydHMubG9nMTAgPSBtYXRoLmxvZzEwO1xuZXhwb3J0cy5sb2cyID0gbWF0aC5sb2cyO1xuZXhwb3J0cy5tYXggPSBtYXRoLm1heDtcbmV4cG9ydHMubWluID0gbWF0aC5taW47XG5leHBvcnRzLnBvdyA9IG1hdGgucG93O1xuZXhwb3J0cy5yb3VuZCA9IG1hdGgucm91bmQ7XG5leHBvcnRzLnNpZ24gPSBtYXRoLnNpZ247XG5leHBvcnRzLnNxcnQgPSBtYXRoLnNxcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/math.cjs\n')},"./node_modules/lib0/dist/metric.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ \"./node_modules/lib0/dist/math-08e068f9.cjs\");\n\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\nconst yotta = 1e24;\nconst zetta = 1e21;\nconst exa = 1e18;\nconst peta = 1e15;\nconst tera = 1e12;\nconst giga = 1e9;\nconst mega = 1e6;\nconst kilo = 1e3;\nconst hecto = 1e2;\nconst deca = 10;\nconst deci = 0.1;\nconst centi = 0.01;\nconst milli = 1e-3;\nconst micro = 1e-6;\nconst nano = 1e-9;\nconst pico = 1e-12;\nconst femto = 1e-15;\nconst atto = 1e-18;\nconst zepto = 1e-21;\nconst yocto = 1e-24;\n\nconst prefixUp = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\nconst prefixDown = ['', 'm', 'μ', 'n', 'p', 'f', 'a', 'z', 'y'];\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: 'k' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : math.log10(n);\n  let mult = 0;\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--;\n    mult--;\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++;\n    mult++;\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];\n  return {\n    n: math.round((mult > 0 ? n / math.exp10(mult * 3) : n * math.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n};\n\nexports.atto = atto;\nexports.centi = centi;\nexports.deca = deca;\nexports.deci = deci;\nexports.exa = exa;\nexports.femto = femto;\nexports.giga = giga;\nexports.hecto = hecto;\nexports.kilo = kilo;\nexports.mega = mega;\nexports.micro = micro;\nexports.milli = milli;\nexports.nano = nano;\nexports.peta = peta;\nexports.pico = pico;\nexports.prefix = prefix;\nexports.tera = tera;\nexports.yocto = yocto;\nexports.yotta = yotta;\nexports.zepto = zepto;\nexports.zetta = zetta;\n//# sourceMappingURL=metric.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9tZXRyaWMuY2pzPzAxZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsdUVBQXFCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxvQkFBb0I7QUFDL0Y7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaLGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWTtBQUNaLFdBQVc7QUFDWCxhQUFhO0FBQ2IsWUFBWTtBQUNaLGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWTtBQUNaLGFBQWE7QUFDYixhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLFlBQVk7QUFDWixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L21ldHJpYy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoLTA4ZTA2OGY5LmNqcycpO1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIGNvbnZlcnQgbWV0cmljIHZhbHVlcy5cbiAqXG4gKiBAbW9kdWxlIG1ldHJpY1xuICovXG5cbmNvbnN0IHlvdHRhID0gMWUyNDtcbmNvbnN0IHpldHRhID0gMWUyMTtcbmNvbnN0IGV4YSA9IDFlMTg7XG5jb25zdCBwZXRhID0gMWUxNTtcbmNvbnN0IHRlcmEgPSAxZTEyO1xuY29uc3QgZ2lnYSA9IDFlOTtcbmNvbnN0IG1lZ2EgPSAxZTY7XG5jb25zdCBraWxvID0gMWUzO1xuY29uc3QgaGVjdG8gPSAxZTI7XG5jb25zdCBkZWNhID0gMTA7XG5jb25zdCBkZWNpID0gMC4xO1xuY29uc3QgY2VudGkgPSAwLjAxO1xuY29uc3QgbWlsbGkgPSAxZS0zO1xuY29uc3QgbWljcm8gPSAxZS02O1xuY29uc3QgbmFubyA9IDFlLTk7XG5jb25zdCBwaWNvID0gMWUtMTI7XG5jb25zdCBmZW10byA9IDFlLTE1O1xuY29uc3QgYXR0byA9IDFlLTE4O1xuY29uc3QgemVwdG8gPSAxZS0yMTtcbmNvbnN0IHlvY3RvID0gMWUtMjQ7XG5cbmNvbnN0IHByZWZpeFVwID0gWycnLCAnaycsICdNJywgJ0cnLCAnVCcsICdQJywgJ0UnLCAnWicsICdZJ107XG5jb25zdCBwcmVmaXhEb3duID0gWycnLCAnbScsICfOvCcsICduJywgJ3AnLCAnZicsICdhJywgJ3onLCAneSddO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbWV0cmljIHByZWZpeCBmb3IgYSBudW1iZXIuIEFzc3VtZXMgRS5nLiBgcHJlZml4KDEwMDApID0geyBuOiAxLCBwcmVmaXg6ICdrJyB9YFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Jhc2VNdWx0aXBsaWVyXSBNdWx0aXBsaWVyIG9mIHRoZSBiYXNlICgxMF4oMypiYXNlTXVsdGlwbGllcikpLiBFLmcuIGBjb252ZXJ0KHRpbWUsIC0zKWAgaWYgdGltZSBpcyBhbHJlYWR5IGluIG1pbGxpIHNlY29uZHNcbiAqIEByZXR1cm4ge3tuOm51bWJlcixwcmVmaXg6c3RyaW5nfX1cbiAqL1xuY29uc3QgcHJlZml4ID0gKG4sIGJhc2VNdWx0aXBsaWVyID0gMCkgPT4ge1xuICBjb25zdCBuUG93ID0gbiA9PT0gMCA/IDAgOiBtYXRoLmxvZzEwKG4pO1xuICBsZXQgbXVsdCA9IDA7XG4gIHdoaWxlIChuUG93IDwgbXVsdCAqIDMgJiYgYmFzZU11bHRpcGxpZXIgPiAtOCkge1xuICAgIGJhc2VNdWx0aXBsaWVyLS07XG4gICAgbXVsdC0tO1xuICB9XG4gIHdoaWxlIChuUG93ID49IDMgKyBtdWx0ICogMyAmJiBiYXNlTXVsdGlwbGllciA8IDgpIHtcbiAgICBiYXNlTXVsdGlwbGllcisrO1xuICAgIG11bHQrKztcbiAgfVxuICBjb25zdCBwcmVmaXggPSBiYXNlTXVsdGlwbGllciA8IDAgPyBwcmVmaXhEb3duWy1iYXNlTXVsdGlwbGllcl0gOiBwcmVmaXhVcFtiYXNlTXVsdGlwbGllcl07XG4gIHJldHVybiB7XG4gICAgbjogbWF0aC5yb3VuZCgobXVsdCA+IDAgPyBuIC8gbWF0aC5leHAxMChtdWx0ICogMykgOiBuICogbWF0aC5leHAxMChtdWx0ICogLTMpKSAqIDFlMTIpIC8gMWUxMixcbiAgICBwcmVmaXhcbiAgfVxufTtcblxuZXhwb3J0cy5hdHRvID0gYXR0bztcbmV4cG9ydHMuY2VudGkgPSBjZW50aTtcbmV4cG9ydHMuZGVjYSA9IGRlY2E7XG5leHBvcnRzLmRlY2kgPSBkZWNpO1xuZXhwb3J0cy5leGEgPSBleGE7XG5leHBvcnRzLmZlbXRvID0gZmVtdG87XG5leHBvcnRzLmdpZ2EgPSBnaWdhO1xuZXhwb3J0cy5oZWN0byA9IGhlY3RvO1xuZXhwb3J0cy5raWxvID0ga2lsbztcbmV4cG9ydHMubWVnYSA9IG1lZ2E7XG5leHBvcnRzLm1pY3JvID0gbWljcm87XG5leHBvcnRzLm1pbGxpID0gbWlsbGk7XG5leHBvcnRzLm5hbm8gPSBuYW5vO1xuZXhwb3J0cy5wZXRhID0gcGV0YTtcbmV4cG9ydHMucGljbyA9IHBpY287XG5leHBvcnRzLnByZWZpeCA9IHByZWZpeDtcbmV4cG9ydHMudGVyYSA9IHRlcmE7XG5leHBvcnRzLnlvY3RvID0geW9jdG87XG5leHBvcnRzLnlvdHRhID0geW90dGE7XG5leHBvcnRzLnplcHRvID0gemVwdG87XG5leHBvcnRzLnpldHRhID0gemV0dGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRyaWMuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/metric.cjs\n")},"./node_modules/lib0/dist/number-24f1eabe.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\nvar binary = __webpack_require__(/*! ./binary-ac8e39e2.cjs */ "./node_modules/lib0/dist/binary-ac8e39e2.cjs");\n\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\n\nconst LOWEST_INT32 = 1 << 31;\n/**\n * @type {number}\n */\nconst HIGHEST_INT32 = binary.BITS31;\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === \'number\' && isFinite(num) && math.floor(num) === num);\nconst isNaN = Number.isNaN;\n\nvar number = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tMAX_SAFE_INTEGER: MAX_SAFE_INTEGER,\n\tMIN_SAFE_INTEGER: MIN_SAFE_INTEGER,\n\tLOWEST_INT32: LOWEST_INT32,\n\tHIGHEST_INT32: HIGHEST_INT32,\n\tisInteger: isInteger,\n\tisNaN: isNaN\n});\n\nexports.HIGHEST_INT32 = HIGHEST_INT32;\nexports.LOWEST_INT32 = LOWEST_INT32;\nexports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;\nexports.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;\nexports.isInteger = isInteger;\nexports.isNaN = isNaN;\nexports.number = number;\n//# sourceMappingURL=number-24f1eabe.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9udW1iZXItMjRmMWVhYmUuY2pzPzgwZGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHVFQUFxQjtBQUN4QyxhQUFhLG1CQUFPLENBQUMsMkVBQXVCOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsY0FBYztBQUNkIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9udW1iZXItMjRmMWVhYmUuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aC0wOGUwNjhmOS5janMnKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeS1hYzhlMzllMi5janMnKTtcblxuLyoqXG4gKiBVdGlsaXR5IGhlbHBlcnMgZm9yIHdvcmtpbmcgd2l0aCBudW1iZXJzLlxuICpcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuY29uc3QgTUlOX1NBRkVfSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuXG5jb25zdCBMT1dFU1RfSU5UMzIgPSAxIDw8IDMxO1xuLyoqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5jb25zdCBISUdIRVNUX0lOVDMyID0gYmluYXJ5LkJJVFMzMTtcblxuLyoqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBpc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IChudW0gPT4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUobnVtKSAmJiBtYXRoLmZsb29yKG51bSkgPT09IG51bSk7XG5jb25zdCBpc05hTiA9IE51bWJlci5pc05hTjtcblxudmFyIG51bWJlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRNQVhfU0FGRV9JTlRFR0VSOiBNQVhfU0FGRV9JTlRFR0VSLFxuXHRNSU5fU0FGRV9JTlRFR0VSOiBNSU5fU0FGRV9JTlRFR0VSLFxuXHRMT1dFU1RfSU5UMzI6IExPV0VTVF9JTlQzMixcblx0SElHSEVTVF9JTlQzMjogSElHSEVTVF9JTlQzMixcblx0aXNJbnRlZ2VyOiBpc0ludGVnZXIsXG5cdGlzTmFOOiBpc05hTlxufSk7XG5cbmV4cG9ydHMuSElHSEVTVF9JTlQzMiA9IEhJR0hFU1RfSU5UMzI7XG5leHBvcnRzLkxPV0VTVF9JTlQzMiA9IExPV0VTVF9JTlQzMjtcbmV4cG9ydHMuTUFYX1NBRkVfSU5URUdFUiA9IE1BWF9TQUZFX0lOVEVHRVI7XG5leHBvcnRzLk1JTl9TQUZFX0lOVEVHRVIgPSBNSU5fU0FGRV9JTlRFR0VSO1xuZXhwb3J0cy5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG5leHBvcnRzLmlzTmFOID0gaXNOYU47XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci0yNGYxZWFiZS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/number-24f1eabe.cjs\n')},"./node_modules/lib0/dist/object-dcdd6eed.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null);\n\n/**\n * Object.assign\n */\nconst assign = Object.assign;\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys;\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key);\n  }\n};\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = [];\n  for (const key in obj) {\n    results.push(f(obj[key], key));\n  }\n  return results\n};\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length;\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n};\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val));\n\nvar object = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  create: create,\n  assign: assign,\n  keys: keys,\n  forEach: forEach,\n  map: map,\n  length: length,\n  some: some,\n  every: every,\n  hasProperty: hasProperty,\n  equalFlat: equalFlat\n});\n\nexports.assign = assign;\nexports.create = create;\nexports.equalFlat = equalFlat;\nexports.every = every;\nexports.forEach = forEach;\nexports.hasProperty = hasProperty;\nexports.keys = keys;\nexports.length = length;\nexports.map = map;\nexports.object = object;\nexports.some = some;\n//# sourceMappingURL=object-dcdd6eed.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9vYmplY3QtZGNkZDZlZWQuY2pzP2Q0YjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyw2QkFBNkI7QUFDeEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsNkJBQTZCO0FBQ3hDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjO0FBQ2QsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQixZQUFZO0FBQ1osY0FBYztBQUNkLFdBQVc7QUFDWCxjQUFjO0FBQ2QsWUFBWTtBQUNaIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9vYmplY3QtZGNkZDZlZWQuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRWNtYVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBtb2R1bGUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICovXG5jb25zdCBjcmVhdGUgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIE9iamVjdC5hc3NpZ25cbiAqL1xuY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmFueX0gZlxuICovXG5jb25zdCBmb3JFYWNoID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBmKG9ialtrZXldLCBrZXkpO1xuICB9XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBSXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOlJ9IGZcbiAqIEByZXR1cm4ge0FycmF5PFI+fVxuICovXG5jb25zdCBtYXAgPSAob2JqLCBmKSA9PiB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmVzdWx0cy5wdXNoKGYob2JqW2tleV0sIGtleSkpO1xuICB9XG4gIHJldHVybiByZXN1bHRzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgbGVuZ3RoID0gb2JqID0+IGtleXMob2JqKS5sZW5ndGg7XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBzb21lID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXZlcnkgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmICghZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIENhbGxzIGBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge2FueX0gb2JqXG4gKiBAcGFyYW0ge3N0cmluZ3xzeW1ib2x9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaGFzUHJvcGVydHkgPSAob2JqLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGFcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAobGVuZ3RoKGEpID09PSBsZW5ndGgoYikgJiYgZXZlcnkoYSwgKHZhbCwga2V5KSA9PiAodmFsICE9PSB1bmRlZmluZWQgfHwgaGFzUHJvcGVydHkoYiwga2V5KSkgJiYgYltrZXldID09PSB2YWwpKTtcblxudmFyIG9iamVjdCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGU6IGNyZWF0ZSxcbiAgYXNzaWduOiBhc3NpZ24sXG4gIGtleXM6IGtleXMsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1hcDogbWFwLFxuICBsZW5ndGg6IGxlbmd0aCxcbiAgc29tZTogc29tZSxcbiAgZXZlcnk6IGV2ZXJ5LFxuICBoYXNQcm9wZXJ0eTogaGFzUHJvcGVydHksXG4gIGVxdWFsRmxhdDogZXF1YWxGbGF0XG59KTtcblxuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuZXF1YWxGbGF0ID0gZXF1YWxGbGF0O1xuZXhwb3J0cy5ldmVyeSA9IGV2ZXJ5O1xuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDtcbmV4cG9ydHMuaGFzUHJvcGVydHkgPSBoYXNQcm9wZXJ0eTtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5vYmplY3QgPSBvYmplY3Q7XG5leHBvcnRzLnNvbWUgPSBzb21lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWRjZGQ2ZWVkLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/object-dcdd6eed.cjs\n")},"./node_modules/lib0/dist/object.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar object = __webpack_require__(/*! ./object-dcdd6eed.cjs */ "./node_modules/lib0/dist/object-dcdd6eed.cjs");\n\n\n\nexports.assign = object.assign;\nexports.create = object.create;\nexports.equalFlat = object.equalFlat;\nexports.every = object.every;\nexports.forEach = object.forEach;\nexports.hasProperty = object.hasProperty;\nexports.keys = object.keys;\nexports.length = object.length;\nexports.map = object.map;\nexports.some = object.some;\n//# sourceMappingURL=object.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9vYmplY3QuY2pzPzNmM2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxhQUFhLG1CQUFPLENBQUMsMkVBQXVCOzs7O0FBSTVDLGNBQWM7QUFDZCxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLFlBQVk7QUFDWixjQUFjO0FBQ2QsV0FBVztBQUNYLFlBQVk7QUFDWiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3Qvb2JqZWN0LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0LWRjZGQ2ZWVkLmNqcycpO1xuXG5cblxuZXhwb3J0cy5hc3NpZ24gPSBvYmplY3QuYXNzaWduO1xuZXhwb3J0cy5jcmVhdGUgPSBvYmplY3QuY3JlYXRlO1xuZXhwb3J0cy5lcXVhbEZsYXQgPSBvYmplY3QuZXF1YWxGbGF0O1xuZXhwb3J0cy5ldmVyeSA9IG9iamVjdC5ldmVyeTtcbmV4cG9ydHMuZm9yRWFjaCA9IG9iamVjdC5mb3JFYWNoO1xuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IG9iamVjdC5oYXNQcm9wZXJ0eTtcbmV4cG9ydHMua2V5cyA9IG9iamVjdC5rZXlzO1xuZXhwb3J0cy5sZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuZXhwb3J0cy5tYXAgPSBvYmplY3QubWFwO1xuZXhwb3J0cy5zb21lID0gb2JqZWN0LnNvbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYmplY3QuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/object.cjs\n')},"./node_modules/lib0/dist/observable.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar map = __webpack_require__(/*! ./map-28a001c9.cjs */ "./node_modules/lib0/dist/map-28a001c9.cjs");\nvar set = __webpack_require__(/*! ./set-7ae96d21.cjs */ "./node_modules/lib0/dist/set-7ae96d21.cjs");\nvar array = __webpack_require__(/*! ./array-b2d24238.cjs */ "./node_modules/lib0/dist/array-b2d24238.cjs");\n\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n/**\n * Handles named events.\n *\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create();\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f);\n      f(...args);\n    };\n    this.on(name, _f);\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name);\n    if (observers !== undefined) {\n      observers.delete(f);\n      if (observers.size === 0) {\n        this._observers.delete(name);\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create();\n  }\n}\n\nexports.Observable = Observable;\n//# sourceMappingURL=observable.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9vYnNlcnZhYmxlLmNqcz9kNDNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxDQUFDLGNBQWMsRUFBQzs7QUFFN0QsVUFBVSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN0QyxVQUFVLG1CQUFPLENBQUMscUVBQW9CO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyx5RUFBc0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L29ic2VydmFibGUuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi9tYXAtMjhhMDAxYzkuY2pzJyk7XG52YXIgc2V0ID0gcmVxdWlyZSgnLi9zZXQtN2FlOTZkMjEuY2pzJyk7XG52YXIgYXJyYXkgPSByZXF1aXJlKCcuL2FycmF5LWIyZDI0MjM4LmNqcycpO1xuXG4vKipcbiAqIE9ic2VydmFibGUgY2xhc3MgcHJvdG90eXBlLlxuICpcbiAqIEBtb2R1bGUgb2JzZXJ2YWJsZVxuICovXG5cbi8qKlxuICogSGFuZGxlcyBuYW1lZCBldmVudHMuXG4gKlxuICogQHRlbXBsYXRlIE5cbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBTb21lIGRlc2MuXG4gICAgICogQHR5cGUge01hcDxOLCBhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBzZXQuY3JlYXRlKS5hZGQoZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9uY2UgKG5hbWUsIGYpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcbiAgICAgKi9cbiAgICBjb25zdCBfZiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICB0aGlzLm9mZihuYW1lLCBfZik7XG4gICAgICBmKC4uLmFyZ3MpO1xuICAgIH07XG4gICAgdGhpcy5vbihuYW1lLCBfZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAobmFtZSwgZikge1xuICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5nZXQobmFtZSk7XG4gICAgaWYgKG9ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpO1xuICAgICAgaWYgKG9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgbmFtZSB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAdG9kbyBUaGlzIHNob3VsZCBjYXRjaCBleGNlcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBlbWl0IChuYW1lLCBhcmdzKSB7XG4gICAgLy8gY29weSBhbGwgbGlzdGVuZXJzIHRvIGFuIGFycmF5IGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IG5vIGV2ZW50IGlzIGVtaXR0ZWQgdG8gbGlzdGVuZXJzIHRoYXQgYXJlIHN1YnNjcmliZWQgd2hpbGUgdGhlIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLlxuICAgIHJldHVybiBhcnJheS5mcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IG1hcC5jcmVhdGUoKSkudmFsdWVzKCkpLmZvckVhY2goZiA9PiBmKC4uLmFyZ3MpKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gbWFwLmNyZWF0ZSgpO1xuICB9XG59XG5cbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/observable.cjs\n')},"./node_modules/lib0/dist/pair-ab022bc3.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left;\n    this.right = right;\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right);\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right);\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right));\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right));\n\nvar pair = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Pair: Pair,\n  create: create,\n  createReversed: createReversed,\n  forEach: forEach,\n  map: map\n});\n\nexports.Pair = Pair;\nexports.create = create;\nexports.createReversed = createReversed;\nexports.forEach = forEach;\nexports.map = map;\nexports.pair = pair;\n//# sourceMappingURL=pair-ab022bc3.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9wYWlyLWFiMDIyYmMzLmNqcz84YzA3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLG1CQUFtQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWTtBQUNaLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEIsZUFBZTtBQUNmLFdBQVc7QUFDWCxZQUFZO0FBQ1oiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L3BhaXItYWIwMjJiYzMuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdvcmtpbmcgd2l0aCB2YWx1ZSBwYWlycy5cbiAqXG4gKiBAbW9kdWxlIHBhaXJcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqL1xuY2xhc3MgUGFpciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0x9IGxlZnRcbiAgICogQHBhcmFtIHtSfSByaWdodFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge0x9IGxlZnRcbiAqIEBwYXJhbSB7Un0gcmlnaHRcbiAqIEByZXR1cm4ge1BhaXI8TCxSPn1cbiAqL1xuY29uc3QgY3JlYXRlID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtSfSByaWdodFxuICogQHBhcmFtIHtMfSBsZWZ0XG4gKiBAcmV0dXJuIHtQYWlyPEwsUj59XG4gKi9cbmNvbnN0IGNyZWF0ZVJldmVyc2VkID0gKHJpZ2h0LCBsZWZ0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtBcnJheTxQYWlyPEwsUj4+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oTCwgUik6YW55fSBmXG4gKi9cbmNvbnN0IGZvckVhY2ggPSAoYXJyLCBmKSA9PiBhcnIuZm9yRWFjaChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSk7XG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUixYXG4gKiBAcGFyYW0ge0FycmF5PFBhaXI8TCxSPj59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihMLCBSKTpYfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxYPn1cbiAqL1xuY29uc3QgbWFwID0gKGFyciwgZikgPT4gYXJyLm1hcChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSk7XG5cbnZhciBwYWlyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFBhaXI6IFBhaXIsXG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjcmVhdGVSZXZlcnNlZDogY3JlYXRlUmV2ZXJzZWQsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1hcDogbWFwXG59KTtcblxuZXhwb3J0cy5QYWlyID0gUGFpcjtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jcmVhdGVSZXZlcnNlZCA9IGNyZWF0ZVJldmVyc2VkO1xuZXhwb3J0cy5mb3JFYWNoID0gZm9yRWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5wYWlyID0gcGFpcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhaXItYWIwMjJiYzMuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/pair-ab022bc3.cjs\n")},"./node_modules/lib0/dist/random.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\nvar isomorphic_js = __webpack_require__(/*! isomorphic.js */ "./node_modules/isomorphic.js/browser.js");\n\nconst rand = Math.random;\n\n/* istanbul ignore next */\nconst uint32 = () => new Uint32Array(isomorphic_js.cryptoRandomBuffer(4))[0];\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[math.floor(rand() * arr.length)];\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n);\n\nexports.oneOf = oneOf;\nexports.rand = rand;\nexports.uint32 = uint32;\nexports.uuidv4 = uuidv4;\n//# sourceMappingURL=random.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9yYW5kb20uY2pzPzUxNjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsdUVBQXFCO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLDhEQUFlOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtFQUFrRSxPQUFPO0FBQ3pFO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLFlBQVk7QUFDWixjQUFjO0FBQ2QsY0FBYztBQUNkIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9yYW5kb20uY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aC0wOGUwNjhmOS5janMnKTtcbnZhciBpc29tb3JwaGljX2pzID0gcmVxdWlyZSgnaXNvbW9ycGhpYy5qcycpO1xuXG5jb25zdCByYW5kID0gTWF0aC5yYW5kb207XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1aW50MzIgPSAoKSA9PiBuZXcgVWludDMyQXJyYXkoaXNvbW9ycGhpY19qcy5jcnlwdG9SYW5kb21CdWZmZXIoNCkpWzBdO1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmNvbnN0IG9uZU9mID0gYXJyID0+IGFyclttYXRoLmZsb29yKHJhbmQoKSAqIGFyci5sZW5ndGgpXTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdXVpZHY0VGVtcGxhdGUgPSBbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExO1xuY29uc3QgdXVpZHY0ID0gKCkgPT4gdXVpZHY0VGVtcGxhdGUucmVwbGFjZSgvWzAxOF0vZywgLyoqIEBwYXJhbSB7bnVtYmVyfSBjICovIGMgPT5cbiAgKGMgXiB1aW50MzIoKSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbik7XG5cbmV4cG9ydHMub25lT2YgPSBvbmVPZjtcbmV4cG9ydHMucmFuZCA9IHJhbmQ7XG5leHBvcnRzLnVpbnQzMiA9IHVpbnQzMjtcbmV4cG9ydHMudXVpZHY0ID0gdXVpZHY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZG9tLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/random.cjs\n')},"./node_modules/lib0/dist/set-7ae96d21.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set();\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set);\n\nvar set = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcreate: create,\n\ttoArray: toArray\n});\n\nexports.create = create;\nexports.set = set;\nexports.toArray = toArray;\n//# sourceMappingURL=set-7ae96d21.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9zZXQtN2FlOTZkMjEuY2pzP2U4YmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjO0FBQ2QsV0FBVztBQUNYLGVBQWU7QUFDZiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3Qvc2V0LTdhZTk2ZDIxLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc2V0cy5cbiAqXG4gKiBAbW9kdWxlIHNldFxuICovXG5cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTZXQ8VD59IHNldFxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSBzZXQgPT4gQXJyYXkuZnJvbShzZXQpO1xuXG52YXIgc2V0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGNyZWF0ZTogY3JlYXRlLFxuXHR0b0FycmF5OiB0b0FycmF5XG59KTtcblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLnNldCA9IHNldDtcbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtN2FlOTZkMjEuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/set-7ae96d21.cjs\n")},"./node_modules/lib0/dist/set.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar set = __webpack_require__(/*! ./set-7ae96d21.cjs */ "./node_modules/lib0/dist/set-7ae96d21.cjs");\n\n\n\nexports.create = set.create;\nexports.toArray = set.toArray;\n//# sourceMappingURL=set.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9zZXQuY2pzPzBlODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RCxVQUFVLG1CQUFPLENBQUMscUVBQW9COzs7O0FBSXRDLGNBQWM7QUFDZCxlQUFlO0FBQ2YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L3NldC5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBzZXQgPSByZXF1aXJlKCcuL3NldC03YWU5NmQyMS5janMnKTtcblxuXG5cbmV4cG9ydHMuY3JlYXRlID0gc2V0LmNyZWF0ZTtcbmV4cG9ydHMudG9BcnJheSA9IHNldC50b0FycmF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/set.cjs\n')},"./node_modules/lib0/dist/storage.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map();\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue);\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill();\nlet usePolyfill = true;\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage;\n    usePolyfill = false;\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nconst varStorage = _localStorage;\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler));\n\nexports.onChange = onChange;\nexports.varStorage = varStorage;\n//# sourceMappingURL=storage.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9zdG9yYWdlLmNqcz9mN2FhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxDQUFDLGNBQWMsRUFBQzs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsR0FBRztBQUM1RDtBQUNBLFdBQVcsVUFBVSxrREFBa0QsUUFBUTtBQUMvRTtBQUNBO0FBQ0EsdUZBQXVGLElBQUk7O0FBRTNGLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L3N0b3JhZ2UuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKiBnbG9iYWwgbG9jYWxTdG9yYWdlLCBhZGRFdmVudExpc3RlbmVyICovXG5cbi8qKlxuICogSXNvbW9ycGhpYyB2YXJpYWJsZSBzdG9yYWdlLlxuICpcbiAqIFVzZXMgTG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGFuZCBmYWxscyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlLlxuICpcbiAqIEBtb2R1bGUgc3RvcmFnZVxuICovXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jbGFzcyBWYXJTdG9yYWdlUG9seWZpbGwge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWVcbiAgICovXG4gIHNldEl0ZW0gKGtleSwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLm1hcC5zZXQoa2V5LCBuZXdWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgZ2V0SXRlbSAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpXG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHR5cGUge2FueX1cbiAqL1xubGV0IF9sb2NhbFN0b3JhZ2UgPSBuZXcgVmFyU3RvcmFnZVBvbHlmaWxsKCk7XG5sZXQgdXNlUG9seWZpbGwgPSB0cnVlO1xuXG50cnkge1xuICAvLyBpZiB0aGUgc2FtZS1vcmlnaW4gcnVsZSBpcyB2aW9sYXRlZCwgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZSBtaWdodCB0aHJvd24gYW4gZXJyb3JcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2xvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZTtcbiAgICB1c2VQb2x5ZmlsbCA9IGZhbHNlO1xuICB9XG59IGNhdGNoIChlKSB7IH1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogVGhpcyBpcyBiYXNpY2FsbHkgbG9jYWxTdG9yYWdlIGluIGJyb3dzZXIsIG9yIGEgcG9seWZpbGwgaW4gbm9kZWpzXG4gKi9cbmNvbnN0IHZhclN0b3JhZ2UgPSBfbG9jYWxTdG9yYWdlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGV2ZW50ID0+IHsuLn0pYCB0aGF0IGRvZXMgbm90aGluZyBpZiB0aGUgcG9seWZpbGwgaXMgYmVpbmcgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHsga2V5OiBzdHJpbmcsIG5ld1ZhbHVlOiBzdHJpbmcsIG9sZFZhbHVlOiBzdHJpbmcgfSk6IHZvaWR9IGV2ZW50SGFuZGxlclxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG9uQ2hhbmdlID0gZXZlbnRIYW5kbGVyID0+IHVzZVBvbHlmaWxsIHx8IGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAvKiogQHR5cGUge2FueX0gKi8gKGV2ZW50SGFuZGxlcikpO1xuXG5leHBvcnRzLm9uQ2hhbmdlID0gb25DaGFuZ2U7XG5leHBvcnRzLnZhclN0b3JhZ2UgPSB2YXJTdG9yYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RvcmFnZS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/storage.cjs\n")},"./node_modules/lib0/dist/string-f3c3d805.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode;\nconst fromCodePoint = String.fromCodePoint;\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase();\n\nconst trimLeftRegex = /^\\s*/g;\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, '');\n\nconst fromCamelCaseRegex = /([A-Z])/g;\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`));\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length;\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str));\n  const len = encodedString.length;\n  const buf = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i));\n  }\n  return buf\n};\n\n/* istanbul ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str);\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length;\n  let encodedString = '';\n  let bufPos = 0;\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n    const bytes = buf.subarray(bufPos, bufPos + nextLen);\n    bufPos += nextLen;\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes));\n    remainingLen -= nextLen;\n  }\n  return decodeURIComponent(escape(encodedString))\n};\n\n/* istanbul ignore next */\nexports.utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true });\n\n/* istanbul ignore next */\nif (exports.utf8TextDecoder && exports.utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  exports.utf8TextDecoder = null;\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (exports.utf8TextDecoder).decode(buf);\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nconst decodeUtf8 = exports.utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;\n\nvar string = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  fromCharCode: fromCharCode,\n  fromCodePoint: fromCodePoint,\n  trimLeft: trimLeft,\n  fromCamelCase: fromCamelCase,\n  utf8ByteLength: utf8ByteLength,\n  _encodeUtf8Polyfill: _encodeUtf8Polyfill,\n  utf8TextEncoder: utf8TextEncoder,\n  _encodeUtf8Native: _encodeUtf8Native,\n  encodeUtf8: encodeUtf8,\n  _decodeUtf8Polyfill: _decodeUtf8Polyfill,\n  get utf8TextDecoder () { return exports.utf8TextDecoder; },\n  _decodeUtf8Native: _decodeUtf8Native,\n  decodeUtf8: decodeUtf8\n});\n\nexports._decodeUtf8Native = _decodeUtf8Native;\nexports._decodeUtf8Polyfill = _decodeUtf8Polyfill;\nexports._encodeUtf8Native = _encodeUtf8Native;\nexports._encodeUtf8Polyfill = _encodeUtf8Polyfill;\nexports.decodeUtf8 = decodeUtf8;\nexports.encodeUtf8 = encodeUtf8;\nexports.fromCamelCase = fromCamelCase;\nexports.fromCharCode = fromCharCode;\nexports.fromCodePoint = fromCodePoint;\nexports.string = string;\nexports.trimLeft = trimLeft;\nexports.utf8ByteLength = utf8ByteLength;\nexports.utf8TextEncoder = utf8TextEncoder;\n//# sourceMappingURL=string-f3c3d805.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9zdHJpbmctZjNjM2Q4MDUuY2pzPzhmMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQSwyRkFBMkYsVUFBVSxFQUFFLG1CQUFtQjs7QUFFMUg7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxZQUFZOztBQUUvQztBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxJQUFJO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHlFQUF5RSwrQkFBK0I7O0FBRS9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHVCQUF1QjtBQUN6Qjs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQSw0Q0FBNEMsWUFBWTs7QUFFeEQ7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZ0NBQWdDLEVBQUU7QUFDNUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9zdHJpbmctZjNjM2Q4MDUuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzdHJpbmdzLlxuICpcbiAqIEBtb2R1bGUgc3RyaW5nXG4gKi9cblxuY29uc3QgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbmNvbnN0IGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0xvd2VyQ2FzZSA9IHMgPT4gcy50b0xvd2VyQ2FzZSgpO1xuXG5jb25zdCB0cmltTGVmdFJlZ2V4ID0gL15cXHMqL2c7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdHJpbUxlZnQgPSBzID0+IHMucmVwbGFjZSh0cmltTGVmdFJlZ2V4LCAnJyk7XG5cbmNvbnN0IGZyb21DYW1lbENhc2VSZWdleCA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZXBhcmF0b3JcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgZnJvbUNhbWVsQ2FzZSA9IChzLCBzZXBhcmF0b3IpID0+IHRyaW1MZWZ0KHMucmVwbGFjZShmcm9tQ2FtZWxDYXNlUmVnZXgsIG1hdGNoID0+IGAke3NlcGFyYXRvcn0ke3RvTG93ZXJDYXNlKG1hdGNoKX1gKSk7XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgdXRmOEJ5dGVMZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgdXRmOEJ5dGVMZW5ndGggPSBzdHIgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLmxlbmd0aDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBfZW5jb2RlVXRmOFBvbHlmaWxsID0gc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpO1xuICB9XG4gIHJldHVybiBidWZcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1dGY4VGV4dEVuY29kZXIgPSAvKiogQHR5cGUge1RleHRFbmNvZGVyfSAqLyAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RW5jb2RlcigpIDogbnVsbCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgX2VuY29kZVV0ZjhOYXRpdmUgPSBzdHIgPT4gdXRmOFRleHRFbmNvZGVyLmVuY29kZShzdHIpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBlbmNvZGVVdGY4ID0gdXRmOFRleHRFbmNvZGVyID8gX2VuY29kZVV0ZjhOYXRpdmUgOiBfZW5jb2RlVXRmOFBvbHlmaWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IF9kZWNvZGVVdGY4UG9seWZpbGwgPSBidWYgPT4ge1xuICBsZXQgcmVtYWluaW5nTGVuID0gYnVmLmxlbmd0aDtcbiAgbGV0IGVuY29kZWRTdHJpbmcgPSAnJztcbiAgbGV0IGJ1ZlBvcyA9IDA7XG4gIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgY29uc3QgbmV4dExlbiA9IHJlbWFpbmluZ0xlbiA8IDEwMDAwID8gcmVtYWluaW5nTGVuIDogMTAwMDA7XG4gICAgY29uc3QgYnl0ZXMgPSBidWYuc3ViYXJyYXkoYnVmUG9zLCBidWZQb3MgKyBuZXh0TGVuKTtcbiAgICBidWZQb3MgKz0gbmV4dExlbjtcbiAgICAvLyBTdGFydGluZyB3aXRoIEVTNS4xIHdlIGNhbiBzdXBwbHkgYSBnZW5lcmljIGFycmF5LWxpa2Ugb2JqZWN0IGFzIGFyZ3VtZW50c1xuICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChieXRlcykpO1xuICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuO1xuICB9XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydHMudXRmOFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSwgaWdub3JlQk9NOiB0cnVlIH0pO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGV4cG9ydHMudXRmOFRleHREZWNvZGVyICYmIGV4cG9ydHMudXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBleHBvcnRzLnV0ZjhUZXh0RGVjb2RlciA9IG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgX2RlY29kZVV0ZjhOYXRpdmUgPSBidWYgPT4gLyoqIEB0eXBlIHtUZXh0RGVjb2Rlcn0gKi8gKGV4cG9ydHMudXRmOFRleHREZWNvZGVyKS5kZWNvZGUoYnVmKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgZGVjb2RlVXRmOCA9IGV4cG9ydHMudXRmOFRleHREZWNvZGVyID8gX2RlY29kZVV0ZjhOYXRpdmUgOiBfZGVjb2RlVXRmOFBvbHlmaWxsO1xuXG52YXIgc3RyaW5nID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGZyb21DaGFyQ29kZTogZnJvbUNoYXJDb2RlLFxuICBmcm9tQ29kZVBvaW50OiBmcm9tQ29kZVBvaW50LFxuICB0cmltTGVmdDogdHJpbUxlZnQsXG4gIGZyb21DYW1lbENhc2U6IGZyb21DYW1lbENhc2UsXG4gIHV0ZjhCeXRlTGVuZ3RoOiB1dGY4Qnl0ZUxlbmd0aCxcbiAgX2VuY29kZVV0ZjhQb2x5ZmlsbDogX2VuY29kZVV0ZjhQb2x5ZmlsbCxcbiAgdXRmOFRleHRFbmNvZGVyOiB1dGY4VGV4dEVuY29kZXIsXG4gIF9lbmNvZGVVdGY4TmF0aXZlOiBfZW5jb2RlVXRmOE5hdGl2ZSxcbiAgZW5jb2RlVXRmODogZW5jb2RlVXRmOCxcbiAgX2RlY29kZVV0ZjhQb2x5ZmlsbDogX2RlY29kZVV0ZjhQb2x5ZmlsbCxcbiAgZ2V0IHV0ZjhUZXh0RGVjb2RlciAoKSB7IHJldHVybiBleHBvcnRzLnV0ZjhUZXh0RGVjb2RlcjsgfSxcbiAgX2RlY29kZVV0ZjhOYXRpdmU6IF9kZWNvZGVVdGY4TmF0aXZlLFxuICBkZWNvZGVVdGY4OiBkZWNvZGVVdGY4XG59KTtcblxuZXhwb3J0cy5fZGVjb2RlVXRmOE5hdGl2ZSA9IF9kZWNvZGVVdGY4TmF0aXZlO1xuZXhwb3J0cy5fZGVjb2RlVXRmOFBvbHlmaWxsID0gX2RlY29kZVV0ZjhQb2x5ZmlsbDtcbmV4cG9ydHMuX2VuY29kZVV0ZjhOYXRpdmUgPSBfZW5jb2RlVXRmOE5hdGl2ZTtcbmV4cG9ydHMuX2VuY29kZVV0ZjhQb2x5ZmlsbCA9IF9lbmNvZGVVdGY4UG9seWZpbGw7XG5leHBvcnRzLmRlY29kZVV0ZjggPSBkZWNvZGVVdGY4O1xuZXhwb3J0cy5lbmNvZGVVdGY4ID0gZW5jb2RlVXRmODtcbmV4cG9ydHMuZnJvbUNhbWVsQ2FzZSA9IGZyb21DYW1lbENhc2U7XG5leHBvcnRzLmZyb21DaGFyQ29kZSA9IGZyb21DaGFyQ29kZTtcbmV4cG9ydHMuZnJvbUNvZGVQb2ludCA9IGZyb21Db2RlUG9pbnQ7XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmV4cG9ydHMudHJpbUxlZnQgPSB0cmltTGVmdDtcbmV4cG9ydHMudXRmOEJ5dGVMZW5ndGggPSB1dGY4Qnl0ZUxlbmd0aDtcbmV4cG9ydHMudXRmOFRleHRFbmNvZGVyID0gdXRmOFRleHRFbmNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLWYzYzNkODA1LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/string-f3c3d805.cjs\n")},"./node_modules/lib0/dist/symbol-c5caa724.cjs":(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nconst create = Symbol;\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === 'symbol';\n\nvar symbol = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcreate: create,\n\tisSymbol: isSymbol\n});\n\nexports.create = create;\nexports.isSymbol = isSymbol;\nexports.symbol = symbol;\n//# sourceMappingURL=symbol-c5caa724.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC9zeW1ib2wtYzVjYWE3MjQuY2pzPzJlOTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Rpc3Qvc3ltYm9sLWM1Y2FhNzI0LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggRWNtYVNjcmlwdCBTeW1ib2xzLlxuICpcbiAqIEBtb2R1bGUgc3ltYm9sXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gZnJlc2ggc3ltYm9sLlxuICpcbiAqIEByZXR1cm4ge1N5bWJvbH1cbiAqL1xuY29uc3QgY3JlYXRlID0gU3ltYm9sO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1N5bWJvbCA9IHMgPT4gdHlwZW9mIHMgPT09ICdzeW1ib2wnO1xuXG52YXIgc3ltYm9sID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGNyZWF0ZTogY3JlYXRlLFxuXHRpc1N5bWJvbDogaXNTeW1ib2xcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcbmV4cG9ydHMuc3ltYm9sID0gc3ltYm9sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ltYm9sLWM1Y2FhNzI0LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/symbol-c5caa724.cjs\n")},"./node_modules/lib0/dist/time-e00067da.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar metric = __webpack_require__(/*! ./metric.cjs */ \"./node_modules/lib0/dist/metric.cjs\");\nvar math = __webpack_require__(/*! ./math-08e068f9.cjs */ \"./node_modules/lib0/dist/math-08e068f9.cjs\");\n\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date();\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now;\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1);\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000);\n  const seconds = d % 60;\n  const minutes = math.floor(d / 60) % 60;\n  const hours = math.floor(d / 3600) % 24;\n  const days = math.floor(d / 86400);\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n};\n\nvar time = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  getDate: getDate,\n  getUnixTime: getUnixTime,\n  humanizeDuration: humanizeDuration\n});\n\nexports.getDate = getDate;\nexports.getUnixTime = getUnixTime;\nexports.humanizeDuration = humanizeDuration;\nexports.time = time;\n//# sourceMappingURL=time-e00067da.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC90aW1lLWUwMDA2N2RhLmNqcz85ZmRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyx5REFBYztBQUNuQyxXQUFXLG1CQUFPLENBQUMsdUVBQXFCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4QixZQUFZO0FBQ1oiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9kaXN0L3RpbWUtZTAwMDY3ZGEuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWV0cmljID0gcmVxdWlyZSgnLi9tZXRyaWMuY2pzJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4vbWF0aC0wOGUwNjhmOS5janMnKTtcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGltZS5cbiAqXG4gKiBAbW9kdWxlIHRpbWVcbiAqL1xuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IHRpbWUuXG4gKlxuICogQHJldHVybiB7RGF0ZX1cbiAqL1xuY29uc3QgZ2V0RGF0ZSA9ICgpID0+IG5ldyBEYXRlKCk7XG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdW5peCB0aW1lLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuY29uc3QgZ2V0VW5peFRpbWUgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGltZSAoaW4gbXMpIHRvIGEgaHVtYW4gcmVhZGFibGUgZm9ybWF0LiBFLmcuIDExMDAgPT4gMS4xcy4gNjBzID0+IDFtaW4uIC4wMDEgPT4gMTDOvHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGh1bWFuaXplZCBhcHByb3hpbWF0aW9uIG9mIHRpbWVcbiAqL1xuY29uc3QgaHVtYW5pemVEdXJhdGlvbiA9IGQgPT4ge1xuICBpZiAoZCA8IDYwMDAwKSB7XG4gICAgY29uc3QgcCA9IG1ldHJpYy5wcmVmaXgoZCwgLTEpO1xuICAgIHJldHVybiBtYXRoLnJvdW5kKHAubiAqIDEwMCkgLyAxMDAgKyBwLnByZWZpeCArICdzJ1xuICB9XG4gIGQgPSBtYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgY29uc3Qgc2Vjb25kcyA9IGQgJSA2MDtcbiAgY29uc3QgbWludXRlcyA9IG1hdGguZmxvb3IoZCAvIDYwKSAlIDYwO1xuICBjb25zdCBob3VycyA9IG1hdGguZmxvb3IoZCAvIDM2MDApICUgMjQ7XG4gIGNvbnN0IGRheXMgPSBtYXRoLmZsb29yKGQgLyA4NjQwMCk7XG4gIGlmIChkYXlzID4gMCkge1xuICAgIHJldHVybiBkYXlzICsgJ2QnICsgKChob3VycyA+IDAgfHwgbWludXRlcyA+IDMwKSA/ICcgJyArIChtaW51dGVzID4gMzAgPyBob3VycyArIDEgOiBob3VycykgKyAnaCcgOiAnJylcbiAgfVxuICBpZiAoaG91cnMgPiAwKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gaG91cnMgKyAnaCcgKyAoKG1pbnV0ZXMgPiAwIHx8IHNlY29uZHMgPiAzMCkgPyAnICcgKyAoc2Vjb25kcyA+IDMwID8gbWludXRlcyArIDEgOiBtaW51dGVzKSArICdtaW4nIDogJycpXG4gIH1cbiAgcmV0dXJuIG1pbnV0ZXMgKyAnbWluJyArIChzZWNvbmRzID4gMCA/ICcgJyArIHNlY29uZHMgKyAncycgOiAnJylcbn07XG5cbnZhciB0aW1lID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldERhdGU6IGdldERhdGUsXG4gIGdldFVuaXhUaW1lOiBnZXRVbml4VGltZSxcbiAgaHVtYW5pemVEdXJhdGlvbjogaHVtYW5pemVEdXJhdGlvblxufSk7XG5cbmV4cG9ydHMuZ2V0RGF0ZSA9IGdldERhdGU7XG5leHBvcnRzLmdldFVuaXhUaW1lID0gZ2V0VW5peFRpbWU7XG5leHBvcnRzLmh1bWFuaXplRHVyYXRpb24gPSBodW1hbml6ZUR1cmF0aW9uO1xuZXhwb3J0cy50aW1lID0gdGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUtZTAwMDY3ZGEuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/time-e00067da.cjs\n")},"./node_modules/lib0/dist/time.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n__webpack_require__(/*! ./metric.cjs */ "./node_modules/lib0/dist/metric.cjs");\n__webpack_require__(/*! ./math-08e068f9.cjs */ "./node_modules/lib0/dist/math-08e068f9.cjs");\nvar time = __webpack_require__(/*! ./time-e00067da.cjs */ "./node_modules/lib0/dist/time-e00067da.cjs");\n\n\n\nexports.getDate = time.getDate;\nexports.getUnixTime = time.getUnixTime;\nexports.humanizeDuration = time.humanizeDuration;\n//# sourceMappingURL=time.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC90aW1lLmNqcz85ZDRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxDQUFDLGNBQWMsRUFBQzs7QUFFN0QsbUJBQU8sQ0FBQyx5REFBYztBQUN0QixtQkFBTyxDQUFDLHVFQUFxQjtBQUM3QixXQUFXLG1CQUFPLENBQUMsdUVBQXFCOzs7O0FBSXhDLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZGlzdC90aW1lLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnLi9tZXRyaWMuY2pzJyk7XG5yZXF1aXJlKCcuL21hdGgtMDhlMDY4ZjkuY2pzJyk7XG52YXIgdGltZSA9IHJlcXVpcmUoJy4vdGltZS1lMDAwNjdkYS5janMnKTtcblxuXG5cbmV4cG9ydHMuZ2V0RGF0ZSA9IHRpbWUuZ2V0RGF0ZTtcbmV4cG9ydHMuZ2V0VW5peFRpbWUgPSB0aW1lLmdldFVuaXhUaW1lO1xuZXhwb3J0cy5odW1hbml6ZUR1cmF0aW9uID0gdGltZS5odW1hbml6ZUR1cmF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/dist/time.cjs\n')},"./node_modules/lib0/dom.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "doc": () => (/* binding */ doc),\n/* harmony export */   "createElement": () => (/* binding */ createElement),\n/* harmony export */   "createDocumentFragment": () => (/* binding */ createDocumentFragment),\n/* harmony export */   "createTextNode": () => (/* binding */ createTextNode),\n/* harmony export */   "domParser": () => (/* binding */ domParser),\n/* harmony export */   "emitCustomEvent": () => (/* binding */ emitCustomEvent),\n/* harmony export */   "setAttributes": () => (/* binding */ setAttributes),\n/* harmony export */   "setAttributesMap": () => (/* binding */ setAttributesMap),\n/* harmony export */   "fragment": () => (/* binding */ fragment),\n/* harmony export */   "append": () => (/* binding */ append),\n/* harmony export */   "remove": () => (/* binding */ remove),\n/* harmony export */   "addEventListener": () => (/* binding */ addEventListener),\n/* harmony export */   "removeEventListener": () => (/* binding */ removeEventListener),\n/* harmony export */   "addEventListeners": () => (/* binding */ addEventListeners),\n/* harmony export */   "removeEventListeners": () => (/* binding */ removeEventListeners),\n/* harmony export */   "element": () => (/* binding */ element),\n/* harmony export */   "canvas": () => (/* binding */ canvas),\n/* harmony export */   "text": () => (/* binding */ text),\n/* harmony export */   "pairToStyleString": () => (/* binding */ pairToStyleString),\n/* harmony export */   "pairsToStyleString": () => (/* binding */ pairsToStyleString),\n/* harmony export */   "mapToStyleString": () => (/* binding */ mapToStyleString),\n/* harmony export */   "querySelector": () => (/* binding */ querySelector),\n/* harmony export */   "querySelectorAll": () => (/* binding */ querySelectorAll),\n/* harmony export */   "getElementById": () => (/* binding */ getElementById),\n/* harmony export */   "parseFragment": () => (/* binding */ parseFragment),\n/* harmony export */   "parseElement": () => (/* binding */ parseElement),\n/* harmony export */   "replaceWith": () => (/* binding */ replaceWith),\n/* harmony export */   "insertBefore": () => (/* binding */ insertBefore),\n/* harmony export */   "appendChild": () => (/* binding */ appendChild),\n/* harmony export */   "ELEMENT_NODE": () => (/* binding */ ELEMENT_NODE),\n/* harmony export */   "TEXT_NODE": () => (/* binding */ TEXT_NODE),\n/* harmony export */   "CDATA_SECTION_NODE": () => (/* binding */ CDATA_SECTION_NODE),\n/* harmony export */   "COMMENT_NODE": () => (/* binding */ COMMENT_NODE),\n/* harmony export */   "DOCUMENT_NODE": () => (/* binding */ DOCUMENT_NODE),\n/* harmony export */   "DOCUMENT_TYPE_NODE": () => (/* binding */ DOCUMENT_TYPE_NODE),\n/* harmony export */   "DOCUMENT_FRAGMENT_NODE": () => (/* binding */ DOCUMENT_FRAGMENT_NODE),\n/* harmony export */   "checkNodeType": () => (/* binding */ checkNodeType),\n/* harmony export */   "isParentOf": () => (/* binding */ isParentOf)\n/* harmony export */ });\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pair.js */ "./node_modules/lib0/pair.js");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ "./node_modules/lib0/map.js");\n/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\n\n\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== \'undefined\' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nconst createTextNode = text => doc.createTextNode(text)\n\n/* istanbul ignore next */\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== \'undefined\' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributes = (el, attrs) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, \'\')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nconst remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst addEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nconst removeEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement(\'canvas\'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nconst text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join(\'\')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nconst mapToStyleString = m => _map_js__WEBPACK_IMPORTED_MODULE_1__.map(m, (value, key) => `${key}:${value};`).join(\'\')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nconst querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, \'text/html\').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nconst appendChild = (parent, child) => parent.appendChild(child)\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE\nconst TEXT_NODE = doc.TEXT_NODE\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nconst COMMENT_NODE = doc.COMMENT_NODE\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZG9tLmpzP2I2ZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDO0FBQ0Y7O0FBRS9CO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTyx1QkFBdUIsU0FBUyxvREFBb0Q7O0FBRTNGO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDTyw2QkFBNkIsVUFBVTs7QUFFOUM7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyx3Q0FBd0M7QUFDbkQsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQLEVBQUUsNkNBQVk7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsOEJBQThCO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLHVDQUF1QztBQUNsRCxZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1AsRUFBRSw2Q0FBWTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyx1Q0FBdUM7QUFDbEQsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQLEVBQUUsNkNBQVk7QUFDZDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsMERBQTBEO0FBQ3JFLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDTyxxQ0FBcUMsVUFBVSxHQUFHLFlBQVk7O0FBRXJFO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNBO0FBQ08sOEJBQThCLHdDQUFPLHVCQUF1QixJQUFJLEdBQUcsT0FBTzs7QUFFakY7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPLHdDQUF3QyxZQUFZOztBQUUzRDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGdFQUFnRSxLQUFLOztBQUVyRTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPLGtEQUFrRCxJQUFJOztBQUU3RDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLE9BQU87QUFDbEI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLFlBQVk7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2RvbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIEBtb2R1bGUgZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgcGFpciBmcm9tICcuL3BhaXIuanMnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEB0eXBlIHtEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlRWxlbWVudCA9IG5hbWUgPT4gZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSlcblxuLyoqXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoKSA9PiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dE5vZGUgPSB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRvbVBhcnNlciA9IC8qKiBAdHlwZSB7RE9NUGFyc2VyfSAqLyAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRE9NUGFyc2VyKCkgOiBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBlbWl0Q3VzdG9tRXZlbnQgPSAoZWwsIG5hbWUsIG9wdHMpID0+IGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIG9wdHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmd8Ym9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlcyA9IChlbCwgYXR0cnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGF0dHJzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgJycpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlc01hcCA9IChlbCwgYXR0cnMpID0+IHtcbiAgYXR0cnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4geyBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSkgfSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxOb2RlPnxIVE1MQ29sbGVjdGlvbn0gY2hpbGRyZW5cbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSBjaGlsZHJlbiA9PiB7XG4gIGNvbnN0IGZyYWdtZW50ID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRDaGlsZChmcmFnbWVudCwgY2hpbGRyZW5baV0pXG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZCA9IChwYXJlbnQsIG5vZGVzKSA9PiB7XG4gIGFwcGVuZENoaWxkKHBhcmVudCwgZnJhZ21lbnQobm9kZXMpKVxuICByZXR1cm4gcGFyZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCByZW1vdmUgPSBlbCA9PiBlbC5yZW1vdmUoKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLEV2ZW50TGlzdGVuZXI+Pn0gbGlzdGVuZXJzXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50TGlzdGVuZXJzID0gKG5vZGUsIGxpc3RlbmVycykgPT4ge1xuICBwYWlyLmZvckVhY2gobGlzdGVuZXJzLCAobmFtZSwgZikgPT4gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBmKSlcbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxFdmVudExpc3RlbmVyPj59IGxpc3RlbmVyc1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+fHBhaXIuUGFpcjxzdHJpbmcsYm9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGVsZW1lbnQgPSAobmFtZSwgYXR0cnMgPSBbXSwgY2hpbGRyZW4gPSBbXSkgPT5cbiAgYXBwZW5kKHNldEF0dHJpYnV0ZXMoY3JlYXRlRWxlbWVudChuYW1lKSwgYXR0cnMpLCBjaGlsZHJlbilcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjYW52YXMgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICBjb25zdCBjID0gLyoqIEB0eXBlIHtIVE1MQ2FudmFzRWxlbWVudH0gKi8gKGNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKVxuICBjLmhlaWdodCA9IGhlaWdodFxuICBjLndpZHRoID0gd2lkdGhcbiAgcmV0dXJuIGNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdFxuICogQHJldHVybiB7VGV4dH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB0ZXh0ID0gY3JlYXRlVGV4dE5vZGVcblxuLyoqXG4gKiBAcGFyYW0ge3BhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPn0gcGFpclxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHBhaXJUb1N0eWxlU3RyaW5nID0gcGFpciA9PiBgJHtwYWlyLmxlZnR9OiR7cGFpci5yaWdodH07YFxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn0gcGFpcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwYWlyc1RvU3R5bGVTdHJpbmcgPSBwYWlycyA9PiBwYWlycy5tYXAocGFpclRvU3R5bGVTdHJpbmcpLmpvaW4oJycpXG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLHN0cmluZz59IG1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBtYXBUb1N0eWxlU3RyaW5nID0gbSA9PiBtYXAubWFwKG0sICh2YWx1ZSwga2V5KSA9PiBgJHtrZXl9OiR7dmFsdWV9O2ApLmpvaW4oJycpXG5cbi8qKlxuICogQHRvZG8gc2hvdWxkIGFsd2F5cyBxdWVyeSBvbiBhIGRvbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcXVlcnlTZWxlY3RvciA9IChlbCwgcXVlcnkpID0+IGVsLnF1ZXJ5U2VsZWN0b3IocXVlcnkpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yQWxsID0gKGVsLCBxdWVyeSkgPT4gZWwucXVlcnlTZWxlY3RvckFsbChxdWVyeSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRCeUlkID0gaWQgPT4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvYy5nZXRFbGVtZW50QnlJZChpZCkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgX3BhcnNlID0gaHRtbCA9PiBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKGA8aHRtbD48Ym9keT4ke2h0bWx9PC9ib2R5PjwvaHRtbD5gLCAndGV4dC9odG1sJykuYm9keVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlRnJhZ21lbnQgPSBodG1sID0+IGZyYWdtZW50KC8qKiBAdHlwZSB7YW55fSAqLyAoX3BhcnNlKGh0bWwpLmNoaWxkTm9kZXMpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBwYXJzZUVsZW1lbnQgPSBodG1sID0+IC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqLyAoX3BhcnNlKGh0bWwpLmZpcnN0RWxlbWVudENoaWxkKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9sZEVsXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5ld0VsXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcmVwbGFjZVdpdGggPSAob2xkRWwsIG5ld0VsKSA9PiBvbGRFbC5yZXBsYWNlV2l0aChuZXdFbClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge05vZGV8bnVsbH0gcmVmXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpbnNlcnRCZWZvcmUgPSAocGFyZW50LCBlbCwgcmVmKSA9PiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLCByZWYpXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7Tm9kZX0gY2hpbGRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgYXBwZW5kQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gZG9jLkVMRU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IGRvYy5URVhUX05PREVcbmV4cG9ydCBjb25zdCBDREFUQV9TRUNUSU9OX05PREUgPSBkb2MuQ0RBVEFfU0VDVElPTl9OT0RFXG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gZG9jLkNPTU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX05PREUgPSBkb2MuRE9DVU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1RZUEVfTk9ERSA9IGRvYy5ET0NVTUVOVF9UWVBFX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTm9kZVR5cGUgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gdHlwZVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZFxuICovXG5leHBvcnQgY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGxldCBwID0gY2hpbGQucGFyZW50Tm9kZVxuICB3aGlsZSAocCAmJiBwICE9PSBwYXJlbnQpIHtcbiAgICBwID0gcC5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIHAgPT09IHBhcmVudFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/dom.js\n')},"./node_modules/lib0/encoding.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Encoder": () => (/* binding */ Encoder),\n/* harmony export */   "createEncoder": () => (/* binding */ createEncoder),\n/* harmony export */   "length": () => (/* binding */ length),\n/* harmony export */   "toUint8Array": () => (/* binding */ toUint8Array),\n/* harmony export */   "write": () => (/* binding */ write),\n/* harmony export */   "set": () => (/* binding */ set),\n/* harmony export */   "writeUint8": () => (/* binding */ writeUint8),\n/* harmony export */   "setUint8": () => (/* binding */ setUint8),\n/* harmony export */   "writeUint16": () => (/* binding */ writeUint16),\n/* harmony export */   "setUint16": () => (/* binding */ setUint16),\n/* harmony export */   "writeUint32": () => (/* binding */ writeUint32),\n/* harmony export */   "writeUint32BigEndian": () => (/* binding */ writeUint32BigEndian),\n/* harmony export */   "setUint32": () => (/* binding */ setUint32),\n/* harmony export */   "writeVarUint": () => (/* binding */ writeVarUint),\n/* harmony export */   "writeVarInt": () => (/* binding */ writeVarInt),\n/* harmony export */   "writeVarString": () => (/* binding */ writeVarString),\n/* harmony export */   "writeBinaryEncoder": () => (/* binding */ writeBinaryEncoder),\n/* harmony export */   "writeUint8Array": () => (/* binding */ writeUint8Array),\n/* harmony export */   "writeVarUint8Array": () => (/* binding */ writeVarUint8Array),\n/* harmony export */   "writeOnDataView": () => (/* binding */ writeOnDataView),\n/* harmony export */   "writeFloat32": () => (/* binding */ writeFloat32),\n/* harmony export */   "writeFloat64": () => (/* binding */ writeFloat64),\n/* harmony export */   "writeBigInt64": () => (/* binding */ writeBigInt64),\n/* harmony export */   "writeBigUint64": () => (/* binding */ writeBigUint64),\n/* harmony export */   "writeAny": () => (/* binding */ writeAny),\n/* harmony export */   "RleEncoder": () => (/* binding */ RleEncoder),\n/* harmony export */   "IntDiffEncoder": () => (/* binding */ IntDiffEncoder),\n/* harmony export */   "RleIntDiffEncoder": () => (/* binding */ RleIntDiffEncoder),\n/* harmony export */   "UintOptRleEncoder": () => (/* binding */ UintOptRleEncoder),\n/* harmony export */   "IncUintOptRleEncoder": () => (/* binding */ IncUintOptRleEncoder),\n/* harmony export */   "IntDiffOptRleEncoder": () => (/* binding */ IntDiffOptRleEncoder),\n/* harmony export */   "StringEncoder": () => (/* binding */ StringEncoder)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/lib0/buffer.js");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./number.js */ "./node_modules/lib0/number.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary.js */ "./node_modules/lib0/binary.js");\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang\'s binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, \'Hello world!\')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => \'Hello world!\'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n\n\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  write(encoder, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) {\n    write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don\'t use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (isNegative ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 & num))\n  num >>>= 6\n  // We don\'t need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = _math_js__WEBPACK_IMPORTED_MODULE_1__.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n * • Transforms data to a binary format (not to a string)\n * • Encodes undefined, NaN, and ArrayBuffer (these can\'t be represented in JSON)\n * • Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case \'string\':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case \'number\':\n      if (_number_js__WEBPACK_IMPORTED_MODULE_3__.isInteger(data) && data <= _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case \'bigint\':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case \'object\':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case \'boolean\':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1]) ⇒ RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = \'\'\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = \'\'\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = \'\'\n    writeVarString(encoder, this.sarr.join(\'\'))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZW5jb2RpbmcuanM/ZGJkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0o7QUFDSTtBQUNBOztBQUVyQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFdBQVc7QUFDdkI7QUFDTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMEM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQTBDO0FBQ2hFLGtDQUFrQyx5Q0FBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9lbmNvZGluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBlbmNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZW5jb2RpbmddIHdpdGggW2xpYjAvZGVjb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBuZXcgZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gKiBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMjU2KVxuICogZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgJ0hlbGxvIHdvcmxkIScpXG4gKiBjb25zdCBidWYgPSBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBkZWNvZGluZyBzdGVwXG4gKiBjb25zdCBkZWNvZGVyID0gbmV3IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgbnVtYmVyIGZyb20gJy4vbnVtYmVyLmpzJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJy4vYmluYXJ5LmpzJ1xuXG4vKipcbiAqIEEgQmluYXJ5RW5jb2RlciBoYW5kbGVzIHRoZSBlbmNvZGluZyB0byBhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmNwb3MgPSAwXG4gICAgdGhpcy5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoMTAwKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZnMgPSBbXVxuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtFbmNvZGVyfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRW5jb2RlciA9ICgpID0+IG5ldyBFbmNvZGVyKClcblxuLyoqXG4gKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gZW5jb2RlciA9PiB7XG4gIGxldCBsZW4gPSBlbmNvZGVyLmNwb3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gZW5jb2Rlci5idWZzW2ldLmxlbmd0aFxuICB9XG4gIHJldHVybiBsZW5cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdG8gVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX0gVGhlIGNyZWF0ZWQgQXJyYXlCdWZmZXIuXG4gKi9cbmV4cG9ydCBjb25zdCB0b1VpbnQ4QXJyYXkgPSBlbmNvZGVyID0+IHtcbiAgY29uc3QgdWludDhhcnIgPSBuZXcgVWludDhBcnJheShsZW5ndGgoZW5jb2RlcikpXG4gIGxldCBjdXJQb3MgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGVuY29kZXIuYnVmc1tpXVxuICAgIHVpbnQ4YXJyLnNldChkLCBjdXJQb3MpXG4gICAgY3VyUG9zICs9IGQubGVuZ3RoXG4gIH1cbiAgdWludDhhcnIuc2V0KGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpLCBjdXJQb3MpXG4gIHJldHVybiB1aW50OGFyclxufVxuXG4vKipcbiAqIFZlcmlmeSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIHdyaXRlIGBsZW5gIGJ5dGVzIHd0aWhvdXQgY2hlY2tpbmcuIElmXG4gKiBuZWNlc3NhcnksIGEgbmV3IEJ1ZmZlciB3aXRoIHRoZSByZXF1aXJlZCBsZW5ndGggaXMgYXR0YWNoZWQuXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKi9cbmNvbnN0IHZlcmlmeUxlbiA9IChlbmNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBpZiAoYnVmZmVyTGVuIC0gZW5jb2Rlci5jcG9zIDwgbGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goYnVmZmVyLmNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyKGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcykpXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuLCBsZW4pICogMilcbiAgICBlbmNvZGVyLmNwb3MgPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYnl0ZSB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBpZiAoZW5jb2Rlci5jcG9zID09PSBidWZmZXJMZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuICogMilcbiAgICBlbmNvZGVyLmNwb3MgPSAwXG4gIH1cbiAgZW5jb2Rlci5jYnVmW2VuY29kZXIuY3BvcysrXSA9IG51bVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gKiBQb3NpdGlvbiBtdXN0IGFscmVhZHkgYmUgd3JpdHRlbiAoaS5lLiBlbmNvZGVyLmxlbmd0aCA+IHBvcylcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBQb3NpdGlvbiB0byB3aGljaCB0byB3cml0ZSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHNldCA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBsZXQgYnVmZmVyID0gbnVsbFxuICAvLyBpdGVyYXRlIGFsbCBidWZmZXJzIGFuZCBhZGp1c3QgcG9zaXRpb25cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoICYmIGJ1ZmZlciA9PT0gbnVsbDsgaSsrKSB7XG4gICAgY29uc3QgYiA9IGVuY29kZXIuYnVmc1tpXVxuICAgIGlmIChwb3MgPCBiLmxlbmd0aCkge1xuICAgICAgYnVmZmVyID0gYiAvLyBmb3VuZCBidWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zIC09IGIubGVuZ3RoXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIgPT09IG51bGwpIHtcbiAgICAvLyB1c2UgY3VycmVudCBidWZmZXJcbiAgICBidWZmZXIgPSBlbmNvZGVyLmNidWZcbiAgfVxuICBidWZmZXJbcG9zXSA9IG51bVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQ4ID0gd3JpdGVcblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBJbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50OCA9IHNldFxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50MTYgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgd3JpdGUoZW5jb2RlciwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpXG59XG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50MTYgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgc2V0KGVuY29kZXIsIHBvcywgbnVtICYgYmluYXJ5LkJJVFM4KVxuICBzZXQoZW5jb2RlciwgcG9zICsgMSwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpXG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDMyID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgICBudW0gPj4+PSA4XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDMyQmlnRW5kaWFuID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICB3cml0ZShlbmNvZGVyLCAobnVtID4+PiAoOCAqIGkpKSAmIGJpbmFyeS5CSVRTOClcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50MzIgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZXQoZW5jb2RlciwgcG9zICsgaSwgbnVtICYgYmluYXJ5LkJJVFM4KVxuICAgIG51bSA+Pj49IDhcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogRW5jb2RlcyBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgZnJvbSBbMCwgNDI5NDk2NzI5NV0gLyBbMCwgMHhmZmZmZmZmZl0uIChtYXggMzIgYml0IHVuc2lnbmVkIGludGVnZXIpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhclVpbnQgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdoaWxlIChudW0gPiBiaW5hcnkuQklUUzcpIHtcbiAgICB3cml0ZShlbmNvZGVyLCBiaW5hcnkuQklUOCB8IChiaW5hcnkuQklUUzcgJiBudW0pKVxuICAgIG51bSA+Pj49IDdcbiAgfVxuICB3cml0ZShlbmNvZGVyLCBiaW5hcnkuQklUUzcgJiBudW0pXG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlci5cbiAqXG4gKiBFbmNvZGVzIGludGVnZXJzIGluIHRoZSByYW5nZSBmcm9tIFstMjE0NzQ4MzY0OCwgLTIxNDc0ODM2NDddLlxuICpcbiAqIFdlIGRvbid0IHVzZSB6aWctemFnIGVuY29kaW5nIGJlY2F1c2Ugd2Ugd2FudCB0byBrZWVwIHRoZSBvcHRpb24gb3BlblxuICogdG8gdXNlIHRoZSBzYW1lIGZ1bmN0aW9uIGZvciBCaWdJbnQgYW5kIDUzYml0IGludGVnZXJzIChkb3VibGVzKS5cbiAqXG4gKiBXZSB1c2UgdGhlIDd0aCBiaXQgaW5zdGVhZCBmb3Igc2lnbmFsaW5nIHRoYXQgdGhpcyBpcyBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFySW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyhudW0pXG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgbnVtID0gLW51bVxuICB9XG4gIC8vICAgICAgICAgICAgIHwtIHdoZXRoZXIgdG8gY29udGludWUgcmVhZGluZyAgICAgICAgIHwtIHdoZXRoZXIgaXMgbmVnYXRpdmUgICAgIHwtIG51bWJlclxuICB3cml0ZShlbmNvZGVyLCAobnVtID4gYmluYXJ5LkJJVFM2ID8gYmluYXJ5LkJJVDggOiAwKSB8IChpc05lZ2F0aXZlID8gYmluYXJ5LkJJVDcgOiAwKSB8IChiaW5hcnkuQklUUzYgJiBudW0pKVxuICBudW0gPj4+PSA2XG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgdGhlIGNhc2Ugb2YgbnVtID09PSAwIHNvIHdlIGNhbiB1c2UgYSBkaWZmZXJlbnRcbiAgLy8gcGF0dGVybiBoZXJlIHRoYW4gYWJvdmUuXG4gIHdoaWxlIChudW0gPiAwKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgKG51bSA+IGJpbmFyeS5CSVRTNyA/IGJpbmFyeS5CSVQ4IDogMCkgfCAoYmluYXJ5LkJJVFM3ICYgbnVtKSlcbiAgICBudW0gPj4+PSA3XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhclN0cmluZyA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKVxuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aFxuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSlcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIHRoZSBjb250ZW50IG9mIGFub3RoZXIgRW5jb2Rlci5cbiAqXG4gKiBAVE9ETzogY2FuIGJlIGltcHJvdmVkIVxuICogICAgICAgIC0gTm90ZTogU2hvdWxkIGNvbnNpZGVyIHRoYXQgd2hlbiBhcHBlbmRpbmcgYSBsb3Qgb2Ygc21hbGwgRW5jb2RlcnMsIHdlIHNob3VsZCByYXRoZXIgY2xvbmUgdGhhbiByZWZlcmVuY2luZyB0aGUgb2xkIHN0cnVjdHVyZS5cbiAqICAgICAgICAgICAgICAgIEVuY29kZXJzIHN0YXJ0IHdpdGggYSByYXRoZXIgYmlnIGluaXRpYWwgYnVmZmVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIFRoZSBlblVpbnQ4QXJyXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGFwcGVuZCBUaGUgQmluYXJ5RW5jb2RlciB0byBiZSB3cml0dGVuLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVCaW5hcnlFbmNvZGVyID0gKGVuY29kZXIsIGFwcGVuZCkgPT4gd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHRvVWludDhBcnJheShhcHBlbmQpKVxuXG4vKipcbiAqIEFwcGVuZCBmaXhlZC1sZW5ndGggVWludDhBcnJheSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICBjb25zdCBidWZmZXJMZW4gPSBlbmNvZGVyLmNidWYubGVuZ3RoXG4gIGNvbnN0IGNwb3MgPSBlbmNvZGVyLmNwb3NcbiAgY29uc3QgbGVmdENvcHlMZW4gPSBtYXRoLm1pbihidWZmZXJMZW4gLSBjcG9zLCB1aW50OEFycmF5Lmxlbmd0aClcbiAgY29uc3QgcmlnaHRDb3B5TGVuID0gdWludDhBcnJheS5sZW5ndGggLSBsZWZ0Q29weUxlblxuICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkoMCwgbGVmdENvcHlMZW4pLCBjcG9zKVxuICBlbmNvZGVyLmNwb3MgKz0gbGVmdENvcHlMZW5cbiAgaWYgKHJpZ2h0Q29weUxlbiA+IDApIHtcbiAgICAvLyBTdGlsbCBzb21ldGhpbmcgdG8gd3JpdGUsIHdyaXRlIHJpZ2h0IGhhbGYuLlxuICAgIC8vIEFwcGVuZCBuZXcgYnVmZmVyXG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKVxuICAgIC8vIG11c3QgaGF2ZSBhdCBsZWFzdCBzaXplIG9mIHJlbWFpbmluZyBidWZmZXJcbiAgICBlbmNvZGVyLmNidWYgPSBuZXcgVWludDhBcnJheShtYXRoLm1heChidWZmZXJMZW4gKiAyLCByaWdodENvcHlMZW4pKVxuICAgIC8vIGNvcHkgYXJyYXlcbiAgICBlbmNvZGVyLmNidWYuc2V0KHVpbnQ4QXJyYXkuc3ViYXJyYXkobGVmdENvcHlMZW4pKVxuICAgIGVuY29kZXIuY3BvcyA9IHJpZ2h0Q29weUxlblxuICB9XG59XG5cbi8qKlxuICogQXBwZW5kIGFuIFVpbnQ4QXJyYXkgdG8gRW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhclVpbnQ4QXJyYXkgPSAoZW5jb2RlciwgdWludDhBcnJheSkgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgdWludDhBcnJheS5ieXRlTGVuZ3RoKVxuICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdWludDhBcnJheSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gRGF0YVZpZXcgb2YgdGhlIG5leHQgYGxlbmAgYnl0ZXMuIFVzZSBpdCB0byB3cml0ZSBkYXRhIGFmdGVyXG4gKiBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gKlxuICogYGBganNcbiAqIC8vIHdyaXRlIGZsb2F0MzIgdXNpbmcgRGF0YVZpZXdcbiAqIGNvbnN0IGR2ID0gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDQpXG4gKiBkdi5zZXRGbG9hdDMyKDAsIDEuMSlcbiAqIC8vIHJlYWQgZmxvYXQzMiB1c2luZyBEYXRhVmlld1xuICogY29uc3QgZHYgPSByZWFkRnJvbURhdGFWaWV3KGVuY29kZXIsIDQpXG4gKiBkdi5nZXRGbG9hdDMyKDApIC8vID0+IDEuMTAwMDAwMDIzODQxODU4IChsZWF2aW5nIGl0IHRvIHRoZSByZWFkZXIgdG8gZmluZCBvdXQgd2h5IHRoaXMgaXMgdGhlIGNvcnJlY3QgcmVzdWx0KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcmV0dXJuIHtEYXRhVmlld31cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlT25EYXRhVmlldyA9IChlbmNvZGVyLCBsZW4pID0+IHtcbiAgdmVyaWZ5TGVuKGVuY29kZXIsIGxlbilcbiAgY29uc3QgZHZpZXcgPSBuZXcgRGF0YVZpZXcoZW5jb2Rlci5jYnVmLmJ1ZmZlciwgZW5jb2Rlci5jcG9zLCBsZW4pXG4gIGVuY29kZXIuY3BvcyArPSBsZW5cbiAgcmV0dXJuIGR2aWV3XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUZsb2F0MzIgPSAoZW5jb2RlciwgbnVtKSA9PiB3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgNCkuc2V0RmxvYXQzMigwLCBudW0sIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVGbG9hdDY0ID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpLnNldEZsb2F0NjQoMCwgbnVtLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7YmlnaW50fSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQmlnSW50NjQgPSAoZW5jb2RlciwgbnVtKSA9PiAvKiogQHR5cGUge2FueX0gKi8gKHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KSkuc2V0QmlnSW50NjQoMCwgbnVtLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7YmlnaW50fSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQmlnVWludDY0ID0gKGVuY29kZXIsIG51bSkgPT4gLyoqIEB0eXBlIHthbnl9ICovICh3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkpLnNldEJpZ1VpbnQ2NCgwLCBudW0sIGZhbHNlKVxuXG5jb25zdCBmbG9hdFRlc3RCZWQgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDQpKVxuLyoqXG4gKiBDaGVjayBpZiBhIG51bWJlciBjYW4gYmUgZW5jb2RlZCBhcyBhIDMyIGJpdCBmbG9hdC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc0Zsb2F0MzIgPSBudW0gPT4ge1xuICBmbG9hdFRlc3RCZWQuc2V0RmxvYXQzMigwLCBudW0pXG4gIHJldHVybiBmbG9hdFRlc3RCZWQuZ2V0RmxvYXQzMigwKSA9PT0gbnVtXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCBlZmZpY2llbnQgYmluYXJ5IGZvcm1hdC5cbiAqXG4gKiBEaWZmZXJlbmNlcyB0byBKU09OOlxuICog4oCiIFRyYW5zZm9ybXMgZGF0YSB0byBhIGJpbmFyeSBmb3JtYXQgKG5vdCB0byBhIHN0cmluZylcbiAqIOKAoiBFbmNvZGVzIHVuZGVmaW5lZCwgTmFOLCBhbmQgQXJyYXlCdWZmZXIgKHRoZXNlIGNhbid0IGJlIHJlcHJlc2VudGVkIGluIEpTT04pXG4gKiDigKIgTnVtYmVycyBhcmUgZWZmaWNpZW50bHkgZW5jb2RlZCBlaXRoZXIgYXMgYSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlciwgYXMgYVxuICogICAzMiBiaXQgZmxvYXQsIGFzIGEgNjQgYml0IGZsb2F0LCBvciBhcyBhIDY0IGJpdCBiaWdpbnQuXG4gKlxuICogRW5jb2RpbmcgdGFibGU6XG4gKlxuICogfCBEYXRhIFR5cGUgICAgICAgICAgIHwgUHJlZml4ICAgfCBFbmNvZGluZyBNZXRob2QgICAgfCBDb21tZW50IHxcbiAqIHwgLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLSB8XG4gKiB8IHVuZGVmaW5lZCAgICAgICAgICAgfCAxMjcgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IEZ1bmN0aW9ucywgc3ltYm9sLCBhbmQgZXZlcnl0aGluZyB0aGF0IGNhbm5vdCBiZSBpZGVudGlmaWVkIGlzIGVuY29kZWQgYXMgdW5kZWZpbmVkIHxcbiAqIHwgbnVsbCAgICAgICAgICAgICAgICB8IDEyNiAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgfFxuICogfCBpbnRlZ2VyICAgICAgICAgICAgIHwgMTI1ICAgICAgfCB3cml0ZVZhckludCAgICAgICAgfCBPbmx5IGVuY29kZXMgMzIgYml0IHNpZ25lZCBpbnRlZ2VycyB8XG4gKiB8IGZsb2F0MzIgICAgICAgICAgICAgfCAxMjQgICAgICB8IHdyaXRlRmxvYXQzMiAgICAgICB8IHxcbiAqIHwgZmxvYXQ2NCAgICAgICAgICAgICB8IDEyMyAgICAgIHwgd3JpdGVGbG9hdDY0ICAgICAgIHwgfFxuICogfCBiaWdpbnQgICAgICAgICAgICAgIHwgMTIyICAgICAgfCB3cml0ZUJpZ0ludDY0ICAgICAgfCB8XG4gKiB8IGJvb2xlYW4gKGZhbHNlKSAgICAgfCAxMjEgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IFRydWUgYW5kIGZhbHNlIGFyZSBkaWZmZXJlbnQgZGF0YSB0eXBlcyBzbyB3ZSBzYXZlIHRoZSBmb2xsb3dpbmcgYnl0ZSB8XG4gKiB8IGJvb2xlYW4gKHRydWUpICAgICAgfCAxMjAgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IC0gMGIwMTExMTAwMCBzbyB0aGUgbGFzdCBiaXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRydWUgb3IgZmFsc2UgfFxuICogfCBzdHJpbmcgICAgICAgICAgICAgIHwgMTE5ICAgICAgfCB3cml0ZVZhclN0cmluZyAgICAgfCB8XG4gKiB8IG9iamVjdDxzdHJpbmcsYW55PiAgfCAxMTggICAgICB8IGN1c3RvbSAgICAgICAgICAgICB8IFdyaXRlcyB7bGVuZ3RofSB0aGVuIHtsZW5ndGh9IGtleS12YWx1ZSBwYWlycyB8XG4gKiB8IGFycmF5PGFueT4gICAgICAgICAgfCAxMTcgICAgICB8IGN1c3RvbSAgICAgICAgICAgICB8IFdyaXRlcyB7bGVuZ3RofSB0aGVuIHtsZW5ndGh9IGpzb24gdmFsdWVzIHxcbiAqIHwgVWludDhBcnJheSAgICAgICAgICB8IDExNiAgICAgIHwgd3JpdGVWYXJVaW50OEFycmF5IHwgV2UgdXNlIFVpbnQ4QXJyYXkgZm9yIGFueSBraW5kIG9mIGJpbmFyeSBkYXRhIHxcbiAqXG4gKiBSZWFzb25zIGZvciB0aGUgZGVjcmVhc2luZyBwcmVmaXg6XG4gKiBXZSBuZWVkIHRoZSBmaXJzdCBiaXQgZm9yIGV4dGVuZGFiaWxpdHkgKGxhdGVyIHdlIG1heSB3YW50IHRvIGVuY29kZSB0aGVcbiAqIHByZWZpeCB3aXRoIHdyaXRlVmFyVWludCkuIFRoZSByZW1haW5pbmcgNyBiaXRzIGFyZSBkaXZpZGVkIGFzIGZvbGxvd3M6XG4gKiBbMC0zMF0gICB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXRhIHJhbmdlIGlzIHVzZWQgZm9yIGN1c3RvbSBwdXJwb3Nlc1xuICogICAgICAgICAgKGRlZmluZWQgYnkgdGhlIGZ1bmN0aW9uIHRoYXQgdXNlcyB0aGlzIGxpYnJhcnkpXG4gKiBbMzEtMTI3XSB0aGUgZW5kIG9mIHRoZSBkYXRhIHJhbmdlIGlzIHVzZWQgZm9yIGRhdGEgZW5jb2RpbmcgYnlcbiAqICAgICAgICAgIGxpYjAvZW5jb2RpbmcuanNcbiAqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7dW5kZWZpbmVkfG51bGx8bnVtYmVyfGJpZ2ludHxib29sZWFufHN0cmluZ3xPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxVaW50OEFycmF5fSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUFueSA9IChlbmNvZGVyLCBkYXRhKSA9PiB7XG4gIHN3aXRjaCAodHlwZW9mIGRhdGEpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgLy8gVFlQRSAxMTk6IFNUUklOR1xuICAgICAgd3JpdGUoZW5jb2RlciwgMTE5KVxuICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGlmIChudW1iZXIuaXNJbnRlZ2VyKGRhdGEpICYmIGRhdGEgPD0gYmluYXJ5LkJJVFMzMSkge1xuICAgICAgICAvLyBUWVBFIDEyNTogSU5URUdFUlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjUpXG4gICAgICAgIHdyaXRlVmFySW50KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2UgaWYgKGlzRmxvYXQzMihkYXRhKSkge1xuICAgICAgICAvLyBUWVBFIDEyNDogRkxPQVQzMlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjQpXG4gICAgICAgIHdyaXRlRmxvYXQzMihlbmNvZGVyLCBkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVFlQRSAxMjM6IEZMT0FUNjRcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTIzKVxuICAgICAgICB3cml0ZUZsb2F0NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIC8vIFRZUEUgMTIyOiBCaWdJbnRcbiAgICAgIHdyaXRlKGVuY29kZXIsIDEyMilcbiAgICAgIHdyaXRlQmlnSW50NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRZUEUgMTI2OiBudWxsXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNilcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIC8vIFRZUEUgMTE3OiBBcnJheVxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMTcpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVBbnkoZW5jb2RlciwgZGF0YVtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBUWVBFIDExNjogQXJyYXlCdWZmZXJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE2KVxuICAgICAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRZUEUgMTE4OiBPYmplY3RcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE4KVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGtleXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwga2V5KVxuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFba2V5XSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIC8vIFRZUEUgMTIwLzEyMTogYm9vbGVhbiAodHJ1ZS9mYWxzZSlcbiAgICAgIHdyaXRlKGVuY29kZXIsIGRhdGEgPyAxMjAgOiAxMjEpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUWVBFIDEyNzogdW5kZWZpbmVkXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMjcpXG4gIH1cbn1cblxuLyoqXG4gKiBOb3cgY29tZSBhIGZldyBzdGF0ZWZ1bCBlbmNvZGVyIHRoYXQgaGF2ZSB0aGVpciBvd24gY2xhc3Nlcy5cbiAqL1xuXG4vKipcbiAqIEJhc2ljIFJ1biBMZW5ndGggRW5jb2RlciAtIGEgYmFzaWMgY29tcHJlc3Npb24gaW1wbGVtZW50YXRpb24uXG4gKlxuICogRW5jb2RlcyBbMSwxLDEsN10gdG8gWzEsMyw3LDFdICgzIHRpbWVzIDEsIDEgdGltZSA3KS4gVGhpcyBlbmNvZGVyIG1pZ2h0IGRvIG1vcmUgaGFybSB0aGFuIGdvb2QgaWYgdGhlcmUgYXJlIGEgbG90IG9mIHZhbHVlcyB0aGF0IGFyZSBub3QgcmVwZWF0ZWQuXG4gKlxuICogSXQgd2FzIG9yaWdpbmFsbHkgdXNlZCBmb3IgaW1hZ2UgY29tcHJlc3Npb24uIENvb2wgLi4gYXJ0aWNsZSBodHRwOi8vY3NicnVjZS5jb20vY2JtL3RyYW5zYWN0b3IvcGRmcy90cmFuc192N19pMDYucGRmXG4gKlxuICogQG5vdGUgVCBtdXN0IG5vdCBiZSBudWxsIVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVuY29kZXIsIFQpOnZvaWR9IHdyaXRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdyaXRlcikge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBUaGUgd3JpdGVyXG4gICAgICovXG4gICAgdGhpcy53ID0gd3JpdGVyXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgdGhpcy53KHRoaXMsIHYpXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzaWMgZGlmZiBkZWNvZGVyIHVzaW5nIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzMsIDExMDAsIDExMDEsIDEwNTAsIDBdIHRvIFszLCAxMDk3LCAxLCAtNTEsIC0xMDUwXSB1c2luZyB3cml0ZVZhckludC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIHdyaXRlVmFySW50KHRoaXMsIHYgLSB0aGlzLnMpXG4gICAgdGhpcy5zID0gdlxuICB9XG59XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiBJbnREaWZmRW5jb2RlciBhbmQgUmxlRW5jb2Rlci5cbiAqXG4gKiBCYXNpY2FsbHkgZmlyc3Qgd3JpdGVzIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlbiBjb3VudHMgZHVwbGljYXRlIGRpZmZzIHVzaW5nIFJsZUVuY29kaW5nLlxuICpcbiAqIEVuY29kZXMgdGhlIHZhbHVlcyBbMSwxLDEsMiwzLDQsNSw2XSBhcyBbMSwxLDAsMiwxLDVdIChSTEUoWzEsMCwwLDEsMSwxLDEsMV0pIOKHkiBSbGVJbnREaWZmWzEsMSwwLDIsMSw1XSlcbiAqL1xuZXhwb3J0IGNsYXNzIFJsZUludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyA9PT0gdiAmJiB0aGlzLmNvdW50ID4gMCkge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNvdW50ID4gMCkge1xuICAgICAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMsIHRoaXMuY291bnQgLSAxKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAwLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgICAgfVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIC8vIHdyaXRlIGZpcnN0IHZhbHVlXG4gICAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludE9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hVaW50T3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBzaWduIHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IHNpZ24gdG8gbmVnYXRpdmUgdG8gaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBhIGxlbmd0aCBjb21pbmdcbiAgICB3cml0ZVZhckludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgPT09IDEgPyBlbmNvZGVyLnMgOiAtZW5jb2Rlci5zKVxuICAgIGlmIChlbmNvZGVyLmNvdW50ID4gMSkge1xuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCAtIDIpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDEsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFJsZSBlbmNvZGVyIHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb20gdGhlIG1lbnRpb25lZCBwcm9ibGVtIG9mIHRoZSBiYXNpYyBSbGUgZW5jb2Rlci5cbiAqXG4gKiBJbnRlcm5hbGx5IHVzZXMgVmFySW50IGVuY29kZXIgdG8gd3JpdGUgdW5zaWduZWQgaW50ZWdlcnMuIElmIHRoZSBpbnB1dCBvY2N1cnMgbXVsdGlwbGUgdGltZXMsIHdlIHdyaXRlXG4gKiB3cml0ZSBpdCBhcyBhIG5lZ2F0aXZlIG51bWJlci4gVGhlIFVpbnRPcHRSbGVEZWNvZGVyIHRoZW4gdW5kZXJzdGFuZHMgdGhhdCBpdCBuZWVkcyB0byByZWFkIGEgY291bnQuXG4gKlxuICogRW5jb2RlcyBbMSwyLDMsMywzXSBhcyBbMSwyLC0zLDNdIChvbmNlIDEsIG9uY2UgMiwgdGhyZWUgdGltZXMgMylcbiAqL1xuZXhwb3J0IGNsYXNzIFVpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogSW5jcmVhc2luZyBVaW50IE9wdGltaXplZCBSTEUgRW5jb2RlclxuICpcbiAqIFRoZSBSTEUgZW5jb2RlciBjb3VudHMgdGhlIG51bWJlciBvZiBzYW1lIG9jY3VyZW5jZXMgb2YgdGhlIHNhbWUgdmFsdWUuXG4gKiBUaGUgSW5jVWludE9wdFJsZSBlbmNvZGVyIGNvdW50cyBpZiB0aGUgdmFsdWUgaW5jcmVhc2VzLlxuICogSS5lLiA3LCA4LCA5LCAxMCB3aWxsIGJlIGVuY29kZWQgYXMgWy03LCA0XS4gMSwgMywgNSB3aWxsIGJlIGVuY29kZWRcbiAqIGFzIFsxLCAzLCA1XS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgKyB0aGlzLmNvdW50ID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW50RGlmZk9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyAgICAgICAgICAzMSBiaXQgbWFraW5nIHVwIHRoZSBkaWZmIHwgd2V0aGVyIHRvIHdyaXRlIHRoZSBjb3VudGVyXG4gICAgY29uc3QgZW5jb2RlZERpZmYgPSBlbmNvZGVyLmRpZmYgPDwgMSB8IChlbmNvZGVyLmNvdW50ID09PSAxID8gMCA6IDEpXG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgZmlyc3QgYml0IHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IGZpcnN0IGJpdCB0byBuZWdhdGl2ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZXJlIGlzIGEgbGVuZ3RoIGNvbWluZ1xuICAgIHdyaXRlVmFySW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2RlZERpZmYpXG4gICAgaWYgKGVuY29kZXIuY291bnQgPiAxKSB7XG4gICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50IC0gMikgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMSwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlIFVpbnRPcHRSbGVFbmNvZGVyLlxuICpcbiAqIFRoZSBjb3VudCBhcHByb2FjaCBpcyBzaW1pbGFyIHRvIHRoZSBVaW50RGlmZk9wdFJsZUVuY29kZXIsIGJ1dCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBuZWdhdGl2ZSBiaXRmbGFnLCBpdCBlbmNvZGVzXG4gKiBpbiB0aGUgTFNCIHdoZXRoZXIgYSBjb3VudCBpcyB0byBiZSByZWFkLiBUaGVyZWZvcmUgdGhpcyBFbmNvZGVyIG9ubHkgc3VwcG9ydHMgMzEgYml0IGludGVnZXJzIVxuICpcbiAqIEVuY29kZXMgWzEsIDIsIDMsIDJdIGFzIFszLCAxLCA2LCAtMV0gKG1vcmUgc3BlY2lmaWNhbGx5IFsoMSA8PCAxKSB8IDEsICgzIDw8IDApIHwgMCwgLTFdKVxuICpcbiAqIEludGVybmFsbHkgdXNlcyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuIENvbnRyYXJ5IHRvIG5vcm1hbCBVaW50VmFyIGVuY29kaW5nLCB0aGUgZmlyc3QgYnl0ZSBjb250YWluczpcbiAqICogMSBiaXQgdGhhdCBkZW5vdGVzIHdoZXRoZXIgdGhlIG5leHQgdmFsdWUgaXMgYSBjb3VudCAoTFNCKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGlzIHZhbHVlIGlzIG5lZ2F0aXZlIChNU0IgLSAxKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0byBjb250aW51ZSByZWFkaW5nIHRoZSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlciAoTVNCKVxuICpcbiAqIFRoZXJlZm9yZSwgb25seSBmaXZlIGJpdHMgcmVtYWluIHRvIGVuY29kZSBkaWZmIHJhbmdlcy5cbiAqXG4gKiBVc2UgdGhpcyBFbmNvZGVyIG9ubHkgd2hlbiBhcHByb3ByaWF0ZS4gSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBwcm9iYWJseSBhIGJhZCBpZGVhLlxuICovXG5leHBvcnQgY2xhc3MgSW50RGlmZk9wdFJsZUVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gICAgdGhpcy5kaWZmID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLmRpZmYgPT09IHYgLSB0aGlzLnMpIHtcbiAgICAgIHRoaXMucyA9IHZcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5kaWZmID0gdiAtIHRoaXMuc1xuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFN0cmluZyBFbmNvZGVyLlxuICpcbiAqIEVuY29kaW5nIG1hbnkgc21hbGwgc3RyaW5ncyBpbiBhIHNpbXBsZSBFbmNvZGVyIGlzIG5vdCB2ZXJ5IGVmZmljaWVudC4gVGhlIGZ1bmN0aW9uIGNhbGwgdG8gZGVjb2RlIGEgc3RyaW5nIHRha2VzIHNvbWUgdGltZSBhbmQgY3JlYXRlcyByZWZlcmVuY2VzIHRoYXQgbXVzdCBiZSBldmVudHVhbGx5IGRlbGV0ZWQuXG4gKiBJbiBwcmFjdGljZSwgd2hlbiBkZWNvZGluZyBzZXZlcmFsIG1pbGxpb24gc21hbGwgc3RyaW5ncywgdGhlIEdDIHdpbGwga2ljayBpbiBtb3JlIGFuZCBtb3JlIG9mdGVuIHRvIGNvbGxlY3Qgb3JwaGFuZWQgc3RyaW5nIG9iamVjdHMgKG9yIG1heWJlIHRoZXJlIGlzIGFub3RoZXIgcmVhc29uPykuXG4gKlxuICogVGhpcyBzdHJpbmcgZW5jb2RlciBzb2x2ZXMgdGhlIGFib3ZlIHByb2JsZW0uIEFsbCBzdHJpbmdzIGFyZSBjb25jYXRlbmF0ZWQgYW5kIHdyaXR0ZW4gYXMgYSBzaW5nbGUgc3RyaW5nIHVzaW5nIGEgc2luZ2xlIGVuY29kaW5nIGNhbGwuXG4gKlxuICogVGhlIGxlbmd0aHMgYXJlIGVuY29kZWQgdXNpbmcgYSBVaW50T3B0UmxlRW5jb2Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0VuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5zYXJyID0gW11cbiAgICB0aGlzLnMgPSAnJ1xuICAgIHRoaXMubGVuc0UgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICovXG4gIHdyaXRlIChzdHJpbmcpIHtcbiAgICB0aGlzLnMgKz0gc3RyaW5nXG4gICAgaWYgKHRoaXMucy5sZW5ndGggPiAxOSkge1xuICAgICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKVxuICAgICAgdGhpcy5zID0gJydcbiAgICB9XG4gICAgdGhpcy5sZW5zRS53cml0ZShzdHJpbmcubGVuZ3RoKVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIHRoaXMuc2Fyci5wdXNoKHRoaXMucylcbiAgICB0aGlzLnMgPSAnJ1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRoaXMuc2Fyci5qb2luKCcnKSlcbiAgICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5zRS50b1VpbnQ4QXJyYXkoKSlcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KGVuY29kZXIpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/encoding.js\n')},"./node_modules/lib0/environment.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isMac\": () => (/* binding */ isMac),\n/* harmony export */   \"hasParam\": () => (/* binding */ hasParam),\n/* harmony export */   \"getParam\": () => (/* binding */ getParam),\n/* harmony export */   \"getVariable\": () => (/* binding */ getVariable),\n/* harmony export */   \"getConf\": () => (/* binding */ getConf),\n/* harmony export */   \"hasConf\": () => (/* binding */ hasConf),\n/* harmony export */   \"production\": () => (/* binding */ production)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"./node_modules/lib0/string.js\");\n/* harmony import */ var _conditions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conditions.js */ \"./node_modules/lib0/conditions.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ \"./node_modules/lib0/storage.js\");\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n\n\n\n\n\n/* istanbul ignore next */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name)\n/* istanbul ignore next */\nconst isBrowser = typeof window !== 'undefined' && !isNode\n/* istanbul ignore next */\nconst isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      const pargs = process.argv\n      let currParamName = null\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n          params.set(`-${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n    }\n  }\n  return params\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasParam = name => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nconst getParam = (name, defaultVal) => computeParams().get(name) || defaultVal\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nconst getVariable = name => isNode ? _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(process.env[name.toUpperCase()]) : _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(_storage_js__WEBPACK_IMPORTED_MODULE_3__.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nconst getConf = name => computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nconst hasConf = name => hasParam('--' + name) || getVariable(name) !== null\n\n/* istanbul ignore next */\nconst production = hasConf('production')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZW52aXJvbm1lbnQuanM/MWQ4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDTTtBQUNRO0FBQ047O0FBRXZDO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPOztBQUVQO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkNBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFvQixXQUFXO0FBQ3pELHlCQUF5QixxREFBb0IsV0FBVztBQUN4RDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTyxxQ0FBcUMsMkRBQTBCLG9DQUFvQywyREFBMEIsQ0FBQywyREFBMEI7O0FBRS9KO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2Vudmlyb25tZW50LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJc29tb3JwaGljIG1vZHVsZSB0byB3b3JrIGFjY2VzcyB0aGUgZW52aXJvbm1lbnQgKHF1ZXJ5IHBhcmFtcywgZW52IHZhcmlhYmxlcykuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBjb25kaXRpb25zIGZyb20gJy4vY29uZGl0aW9ucy5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnJlbGVhc2UgJiYgL25vZGV8aW9cXC5qcy8udGVzdChwcm9jZXNzLnJlbGVhc2UubmFtZSlcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTm9kZVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc01hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogZmFsc2VcblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZyxzdHJpbmc+fVxuICovXG5sZXQgcGFyYW1zXG5jb25zdCBhcmdzID0gW11cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGNvbXB1dGVQYXJhbXMgPSAoKSA9PiB7XG4gIGlmIChwYXJhbXMgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc05vZGUpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgY29uc3QgcGFyZ3MgPSBwcm9jZXNzLmFyZ3ZcbiAgICAgIGxldCBjdXJyUGFyYW1OYW1lID0gbnVsbFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyZyA9IHBhcmdzW2ldXG4gICAgICAgIGlmIChwYXJnWzBdID09PSAnLScpIHtcbiAgICAgICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCAnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyclBhcmFtTmFtZSA9IHBhcmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCBwYXJnKVxuICAgICAgICAgICAgY3VyclBhcmFtTmFtZSA9IG51bGxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcmcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKVxuICAgICAgfVxuICAgIC8vIGluIFJlYWN0TmF0aXZlIGZvciBleGFtcGxlIHRoaXMgd291bGQgbm90IGJlIHRydWUgKHVubGVzcyBjb25uZWN0ZWQgdG8gdGhlIFJlbW90ZSBEZWJ1Z2dlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICA7KGxvY2F0aW9uLnNlYXJjaCB8fCAnPycpLnNsaWNlKDEpLnNwbGl0KCcmJykuZm9yRWFjaChrdiA9PiB7XG4gICAgICAgIGlmIChrdi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBrdi5zcGxpdCgnPScpXG4gICAgICAgICAgcGFyYW1zLnNldChgLS0ke3N0cmluZy5mcm9tQ2FtZWxDYXNlKGtleSwgJy0nKX1gLCB2YWx1ZSlcbiAgICAgICAgICBwYXJhbXMuc2V0KGAtJHtzdHJpbmcuZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaGFzUGFyYW0gPSBuYW1lID0+IGNvbXB1dGVQYXJhbXMoKS5oYXMobmFtZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRWYWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRQYXJhbSA9IChuYW1lLCBkZWZhdWx0VmFsKSA9PiBjb21wdXRlUGFyYW1zKCkuZ2V0KG5hbWUpIHx8IGRlZmF1bHRWYWxcbi8vIGV4cG9ydCBjb25zdCBnZXRBcmdzID0gbmFtZSA9PiBjb21wdXRlUGFyYW1zKCkgJiYgYXJnc1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRWYXJpYWJsZSA9IG5hbWUgPT4gaXNOb2RlID8gY29uZGl0aW9ucy51bmRlZmluZWRUb051bGwocHJvY2Vzcy5lbnZbbmFtZS50b1VwcGVyQ2FzZSgpXSkgOiBjb25kaXRpb25zLnVuZGVmaW5lZFRvTnVsbChzdG9yYWdlLnZhclN0b3JhZ2UuZ2V0SXRlbShuYW1lKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDb25mID0gbmFtZSA9PiBjb21wdXRlUGFyYW1zKCkuZ2V0KCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbmYgPSBuYW1lID0+IGhhc1BhcmFtKCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKSAhPT0gbnVsbFxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3Rpb24gPSBoYXNDb25mKCdwcm9kdWN0aW9uJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/environment.js\n")},"./node_modules/lib0/error.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "methodUnimplemented": () => (/* binding */ methodUnimplemented),\n/* harmony export */   "unexpectedCase": () => (/* binding */ unexpectedCase)\n/* harmony export */ });\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nconst create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst methodUnimplemented = () => {\n  throw create(\'Method unimplemented\')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nconst unexpectedCase = () => {\n  throw create(\'Unexpected case\')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZXJyb3IuanM/MWU1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9lcnJvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXJyb3IgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGVycm9yXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7RXJyb3J9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gcyA9PiBuZXcgRXJyb3IocylcblxuLyoqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge25ldmVyfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IG1ldGhvZFVuaW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnTWV0aG9kIHVuaW1wbGVtZW50ZWQnKVxufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7bmV2ZXJ9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdW5leHBlY3RlZENhc2UgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnVW5leHBlY3RlZCBjYXNlJylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/error.js\n')},"./node_modules/lib0/eventloop.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "enqueue": () => (/* binding */ enqueue),\n/* harmony export */   "timeout": () => (/* binding */ timeout),\n/* harmony export */   "interval": () => (/* binding */ interval),\n/* harmony export */   "Animation": () => (/* binding */ Animation),\n/* harmony export */   "animationFrame": () => (/* binding */ animationFrame),\n/* harmony export */   "idleCallback": () => (/* binding */ idleCallback),\n/* harmony export */   "createDebouncer": () => (/* binding */ createDebouncer)\n/* harmony export */ });\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript\'s event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* istanbul ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== \'undefined\' && cancelAnimationFrame(arg))\n\n/* istanbul ignore next */\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\nconst animationFrame = cb => typeof requestAnimationFrame === \'undefined\' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* istanbul ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== \'undefined\' && cancelIdleCallback(arg))\n\n/* istanbul ignore next */\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== \'undefined\' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nconst createDebouncer = timeout => {\n  let timer = -1\n  return f => {\n    clearTimeout(timer)\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZXZlbnRsb29wLmpzPzA1OGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFNBQVM7QUFDdkI7O0FBRUE7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPOztBQUVQOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZXZlbnRsb29wLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIHJlcXVlc3RJZGxlQ2FsbGJhY2ssIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsSWRsZUNhbGxiYWNrLCBjYW5jZWxBbmltYXRpb25GcmFtZSAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBFY21hU2NyaXB0J3MgZXZlbnQgbG9vcC5cbiAqXG4gKiBAbW9kdWxlIGV2ZW50bG9vcFxuICovXG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn1cbiAqL1xubGV0IHF1ZXVlID0gW11cblxuY29uc3QgX3J1blF1ZXVlID0gKCkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0oKVxuICB9XG4gIHF1ZXVlID0gW11cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6dm9pZH0gZlxuICovXG5leHBvcnQgY29uc3QgZW5xdWV1ZSA9IGYgPT4ge1xuICBxdWV1ZS5wdXNoKGYpXG4gIGlmIChxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICBzZXRUaW1lb3V0KF9ydW5RdWV1ZSwgMClcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRpbWVvdXRPYmplY3RcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFRpbWVvdXRPYmplY3QuZGVzdHJveVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIpOnZvaWR9IGNsZWFyRnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlVGltZW91dENsYXNzID0gY2xlYXJGdW5jdGlvbiA9PiBjbGFzcyBUVCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dElkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGltZW91dElkKSB7XG4gICAgdGhpcy5fID0gdGltZW91dElkXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBjbGVhckZ1bmN0aW9uKHRoaXMuXylcbiAgfVxufVxuXG5jb25zdCBUaW1lb3V0ID0gY3JlYXRlVGltZW91dENsYXNzKGNsZWFyVGltZW91dClcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCB0aW1lb3V0ID0gKHRpbWVvdXQsIGNhbGxiYWNrKSA9PiBuZXcgVGltZW91dChzZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KSlcblxuY29uc3QgSW50ZXJ2YWwgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoY2xlYXJJbnRlcnZhbClcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcnZhbCA9ICh0aW1lb3V0LCBjYWxsYmFjaykgPT4gbmV3IEludGVydmFsKHNldEludGVydmFsKGNhbGxiYWNrLCB0aW1lb3V0KSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBBbmltYXRpb24gPSBjcmVhdGVUaW1lb3V0Q2xhc3MoYXJnID0+IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICd1bmRlZmluZWQnICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFyZykpXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyKTp2b2lkfSBjYlxuICogQHJldHVybiB7VGltZW91dE9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkZyYW1lID0gY2IgPT4gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCcgPyB0aW1lb3V0KDAsIGNiKSA6IG5ldyBBbmltYXRpb24ocmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IElkbGUgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoYXJnID0+IHR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGNhbmNlbElkbGVDYWxsYmFjayhhcmcpKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBOb3RlOiB0aGlzIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXMgcHJvYmFibHkgb25seSB1c2VmdWwgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2JcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpZGxlQ2FsbGJhY2sgPSBjYiA9PiB0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgSWRsZShyZXF1ZXN0SWRsZUNhbGxiYWNrKGNiKSkgOiB0aW1lb3V0KDEwMDAsIGNiKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgb2YgdGhlIGRlYm91bmNlIGFjdGlvblxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKTp2b2lkKTp2b2lkfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVib3VuY2VyID0gdGltZW91dCA9PiB7XG4gIGxldCB0aW1lciA9IC0xXG4gIHJldHVybiBmID0+IHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgaWYgKGYpIHtcbiAgICAgIHRpbWVyID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRUaW1lb3V0KGYsIHRpbWVvdXQpKVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/eventloop.js\n')},"./node_modules/lib0/function.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "callAll": () => (/* binding */ callAll),\n/* harmony export */   "nop": () => (/* binding */ nop),\n/* harmony export */   "apply": () => (/* binding */ apply),\n/* harmony export */   "id": () => (/* binding */ id),\n/* harmony export */   "equalityStrict": () => (/* binding */ equalityStrict),\n/* harmony export */   "equalityFlat": () => (/* binding */ equalityFlat),\n/* harmony export */   "equalityDeep": () => (/* binding */ equalityDeep)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ "./node_modules/lib0/array.js");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object.js */ "./node_modules/lib0/object.js");\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nconst nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && _array_js__WEBPACK_IMPORTED_MODULE_0__.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === \'object\' && _object_js__WEBPACK_IMPORTED_MODULE_1__.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (_object_js__WEBPACK_IMPORTED_MODULE_1__.length(a) !== _object_js__WEBPACK_IMPORTED_MODULE_1__.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!_object_js__WEBPACK_IMPORTED_MODULE_1__.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvZnVuY3Rpb24uanM/MjE2MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtQztBQUNFOztBQUVyQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixXQUFXLFdBQVc7QUFDdEI7QUFDTztBQUNQO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsZ0JBQWdCO0FBQzNCLFlBQVk7QUFDWjtBQUNPLGdJQUFnSSxnREFBZSxlQUFlLFNBQVMsdUNBQXVDLGlEQUFnQjs7QUFFck87QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUFhLFFBQVEsOENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvZnVuY3Rpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIGBmc2Agd2l0aCBhcmdzLiBPbmx5IHRocm93cyBhZnRlciBhbGwgZnVuY3Rpb25zIHdlcmUgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24+fSBmc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsQWxsID0gKGZzLCBhcmdzLCBpID0gMCkgPT4ge1xuICB0cnkge1xuICAgIGZvciAoOyBpIDwgZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZzW2ldKC4uLmFyZ3MpXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpIDwgZnMubGVuZ3RoKSB7XG4gICAgICBjYWxsQWxsKGZzLCBhcmdzLCBpICsgMSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBmXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBmID0+IGYoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKlxuICogQHBhcmFtIHtBfSBhXG4gKiBAcmV0dXJuIHtBfVxuICovXG5leHBvcnQgY29uc3QgaWQgPSBhID0+IGFcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxvYmplY3R9IGFcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlGbGF0ID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gYi5jb25zdHJ1Y3RvciAmJiAoKGEgaW5zdGFuY2VvZiBBcnJheSAmJiBhcnJheS5lcXVhbEZsYXQoYSwgLyoqIEB0eXBlIHtBcnJheTxUPn0gKi8gKGIpKSkgfHwgKHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBvYmplY3QuZXF1YWxGbGF0KGEsIGIpKSkpXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlEZWVwID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZXF1YWxpdHlTdHJpY3QoYSwgYilcbiAgfVxuICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzd2l0Y2ggKGEuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgYSA9IG5ldyBVaW50OEFycmF5KGEpXG4gICAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYilcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBjYXNlIFVpbnQ4QXJyYXk6IHtcbiAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIFNldDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgTWFwOiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWVxdWFsaXR5RGVlcChhLmdldChrZXkpLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmIChvYmplY3QubGVuZ3RoKGEpICE9PSBvYmplY3QubGVuZ3RoKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoIW9iamVjdC5oYXNQcm9wZXJ0eShhLCBrZXkpIHx8ICFlcXVhbGl0eURlZXAoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBBcnJheTpcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/function.js\n')},"./node_modules/lib0/indexeddb.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rtop": () => (/* binding */ rtop),\n/* harmony export */   "openDB": () => (/* binding */ openDB),\n/* harmony export */   "deleteDB": () => (/* binding */ deleteDB),\n/* harmony export */   "createStores": () => (/* binding */ createStores),\n/* harmony export */   "transact": () => (/* binding */ transact),\n/* harmony export */   "count": () => (/* binding */ count),\n/* harmony export */   "get": () => (/* binding */ get),\n/* harmony export */   "del": () => (/* binding */ del),\n/* harmony export */   "put": () => (/* binding */ put),\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "addAutoKey": () => (/* binding */ addAutoKey),\n/* harmony export */   "getAll": () => (/* binding */ getAll),\n/* harmony export */   "getAllKeys": () => (/* binding */ getAllKeys),\n/* harmony export */   "queryFirst": () => (/* binding */ queryFirst),\n/* harmony export */   "getLastKey": () => (/* binding */ getLastKey),\n/* harmony export */   "getFirstKey": () => (/* binding */ getFirstKey),\n/* harmony export */   "getAllKeysValues": () => (/* binding */ getAllKeysValues),\n/* harmony export */   "iterate": () => (/* binding */ iterate),\n/* harmony export */   "iterateKeys": () => (/* binding */ iterateKeys),\n/* harmony export */   "getStore": () => (/* binding */ getStore),\n/* harmony export */   "createIDBKeyRangeBound": () => (/* binding */ createIDBKeyRangeBound),\n/* harmony export */   "createIDBKeyRangeUpperBound": () => (/* binding */ createIDBKeyRangeUpperBound),\n/* harmony export */   "createIDBKeyRangeLowerBound": () => (/* binding */ createIDBKeyRangeLowerBound)\n/* harmony export */ });\n/* harmony import */ var _promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./promise.js */ "./node_modules/lib0/promise.js");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.js */ "./node_modules/lib0/error.js");\n/* eslint-env browser */\n\n/**\n * Helpers to work with IndexedDB.\n *\n * @module idb\n */\n\n\n\n\n/**\n * IDB Request to Promise transformer\n *\n * @param {IDBRequest} request\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nconst rtop = request => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onerror = event => reject(new Error(event.target.error))\n  /* istanbul ignore next */\n  // @ts-ignore\n  request.onblocked = () => location.reload()\n  // @ts-ignore\n  request.onsuccess = event => resolve(event.target.result)\n})\n\n/**\n * @param {string} name\n * @param {function(IDBDatabase):any} initDB Called when the database is first created\n * @return {Promise<IDBDatabase>}\n */\n/* istanbul ignore next */\nconst openDB = (name, initDB) => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  const request = indexedDB.open(name)\n  /**\n   * @param {any} event\n   */\n  request.onupgradeneeded = event => initDB(event.target.result)\n  /* istanbul ignore next */\n  /**\n   * @param {any} event\n   */\n  request.onerror = event => reject(_error_js__WEBPACK_IMPORTED_MODULE_1__.create(event.target.error))\n  /* istanbul ignore next */\n  request.onblocked = () => location.reload()\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    /**\n     * @type {IDBDatabase}\n     */\n    const db = event.target.result\n    /* istanbul ignore next */\n    db.onversionchange = () => { db.close() }\n    /* istanbul ignore if */\n    if (typeof addEventListener !== \'undefined\') {\n      addEventListener(\'unload\', () => db.close())\n    }\n    resolve(db)\n  }\n})\n\n/**\n * @param {string} name\n */\n/* istanbul ignore next */\nconst deleteDB = name => rtop(indexedDB.deleteDatabase(name))\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<Array<string>|Array<string|IDBObjectStoreParameters|undefined>>} definitions\n */\n/* istanbul ignore next */\nconst createStores = (db, definitions) => definitions.forEach(d =>\n  // @ts-ignore\n  db.createObjectStore.apply(db, d)\n)\n\n/**\n * @param {IDBDatabase} db\n * @param {Array<string>} stores\n * @param {"readwrite"|"readonly"} [access]\n * @return {Array<IDBObjectStore>}\n */\nconst transact = (db, stores, access = \'readwrite\') => {\n  const transaction = db.transaction(stores, access)\n  return stores.map(store => getStore(transaction, store))\n}\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<number>}\n */\n/* istanbul ignore next */\nconst count = (store, range) =>\n  rtop(store.count(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | Array<any> } key\n * @return {Promise<String | number | ArrayBuffer | Date | Array<any>>}\n */\n/* istanbul ignore next */\nconst get = (store, key) =>\n  rtop(store.get(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | IDBKeyRange | Array<any> } key\n */\n/* istanbul ignore next */\nconst del = (store, key) =>\n  rtop(store.delete(key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean} item\n * @param {String | number | ArrayBuffer | Date | Array<any>} [key]\n */\n/* istanbul ignore next */\nconst put = (store, item, key) =>\n  rtop(store.put(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date | boolean}  item\n * @param {String | number | ArrayBuffer | Date | Array<any>}  key\n * @return {Promise<any>}\n */\n/* istanbul ignore next */\nconst add = (store, item, key) =>\n  rtop(store.add(item, key))\n\n/**\n * @param {IDBObjectStore} store\n * @param {String | number | ArrayBuffer | Date}  item\n * @return {Promise<number>} Returns the generated key\n */\n/* istanbul ignore next */\nconst addAutoKey = (store, item) =>\n  rtop(store.add(item))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nconst getAll = (store, range) =>\n  rtop(store.getAll(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<any>>}\n */\n/* istanbul ignore next */\nconst getAllKeys = (store, range) =>\n  rtop(store.getAllKeys(range))\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} query\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n * @return {Promise<any>}\n */\nconst queryFirst = (store, query, direction) => {\n  /**\n   * @type {any}\n   */\n  let first = null\n  return iterateKeys(store, query, key => {\n    first = key\n    return false\n  }, direction).then(() => first)\n}\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nconst getLastKey = store => queryFirst(store, null, \'prev\')\n\n/**\n * @param {IDBObjectStore} store\n * @return {Promise<any>}\n */\nconst getFirstKey = store => queryFirst(store, null, \'prev\')\n\n/**\n * @typedef KeyValuePair\n * @type {Object}\n * @property {any} k key\n * @property {any} v Value\n */\n\n/**\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange} [range]\n * @return {Promise<Array<KeyValuePair>>}\n */\n/* istanbul ignore next */\nconst getAllKeysValues = (store, range) =>\n  // @ts-ignore\n  _promise_js__WEBPACK_IMPORTED_MODULE_0__.all([getAllKeys(store, range), getAll(store, range)]).then(([ks, vs]) => ks.map((k, i) => ({ k, v: vs[i] })))\n\n/**\n * @param {any} request\n * @param {function(IDBCursorWithValue):void|boolean} f\n * @return {Promise<void>}\n */\n/* istanbul ignore next */\nconst iterateOnRequest = (request, f) => _promise_js__WEBPACK_IMPORTED_MODULE_0__.create((resolve, reject) => {\n  /* istanbul ignore next */\n  request.onerror = reject\n  /**\n   * @param {any} event\n   */\n  request.onsuccess = event => {\n    const cursor = event.target.result\n    if (cursor === null || f(cursor) === false) {\n      return resolve()\n    }\n    cursor.continue()\n  }\n})\n\n/**\n * Iterate on keys and values\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any,any):void|boolean} f Callback that receives (value, key)\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n */\n/* istanbul ignore next */\nconst iterate = (store, keyrange, f, direction = \'next\') =>\n  iterateOnRequest(store.openCursor(keyrange, direction), cursor => f(cursor.value, cursor.key))\n\n/**\n * Iterate on the keys (no values)\n *\n * @param {IDBObjectStore} store\n * @param {IDBKeyRange|null} keyrange\n * @param {function(any):void|boolean} f callback that receives the key\n * @param {\'next\'|\'prev\'|\'nextunique\'|\'prevunique\'} direction\n */\n/* istanbul ignore next */\nconst iterateKeys = (store, keyrange, f, direction = \'next\') =>\n  iterateOnRequest(store.openKeyCursor(keyrange, direction), cursor => f(cursor.key))\n\n/**\n * Open store from transaction\n * @param {IDBTransaction} t\n * @param {String} store\n * @returns {IDBObjectStore}\n */\n/* istanbul ignore next */\nconst getStore = (t, store) => t.objectStore(store)\n\n/**\n * @param {any} lower\n * @param {any} upper\n * @param {boolean} lowerOpen\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeBound = (lower, upper, lowerOpen, upperOpen) => IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen)\n\n/**\n * @param {any} upper\n * @param {boolean} upperOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen)\n\n/**\n * @param {any} lower\n * @param {boolean} lowerOpen\n */\n/* istanbul ignore next */\nconst createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvaW5kZXhlZGRiLmpzPzYyYTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ0o7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNPLHdCQUF3QiwrQ0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLDBCQUEwQjtBQUNyQyxZQUFZO0FBQ1o7QUFDQTtBQUNPLGlDQUFpQywrQ0FBYztBQUN0RDtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0Esb0NBQW9DLDZDQUFZO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsc0VBQXNFO0FBQ2pGO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLGNBQWM7QUFDekIsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLG1EQUFtRDtBQUM5RCxZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxpRUFBaUU7QUFDNUU7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVyxrREFBa0Q7QUFDN0Q7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVywrQ0FBK0M7QUFDMUQsV0FBVyxrREFBa0Q7QUFDN0QsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcscUNBQXFDO0FBQ2hELFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLHdDQUF3QztBQUNuRCxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVixjQUFjLElBQUk7QUFDbEIsY0FBYyxJQUFJO0FBQ2xCOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7QUFDQSxFQUFFLDRDQUFXLHlGQUF5RixjQUFjOztBQUVwSDtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsMENBQTBDO0FBQ3JELFlBQVk7QUFDWjtBQUNBO0FBQ0EseUNBQXlDLCtDQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsK0JBQStCO0FBQzFDLFdBQVcsd0NBQXdDO0FBQ25EO0FBQ0E7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLHdDQUF3QztBQUNuRDtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxJQUFJO0FBQ2YsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL2luZGV4ZWRkYi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEhlbHBlcnMgdG8gd29yayB3aXRoIEluZGV4ZWREQi5cbiAqXG4gKiBAbW9kdWxlIGlkYlxuICovXG5cbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnLi9wcm9taXNlLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnLi9lcnJvci5qcydcblxuLyoqXG4gKiBJREIgUmVxdWVzdCB0byBQcm9taXNlIHRyYW5zZm9ybWVyXG4gKlxuICogQHBhcmFtIHtJREJSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcnRvcCA9IHJlcXVlc3QgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAvLyBAdHMtaWdub3JlXG4gIHJlcXVlc3Qub25lcnJvciA9IGV2ZW50ID0+IHJlamVjdChuZXcgRXJyb3IoZXZlbnQudGFyZ2V0LmVycm9yKSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQkRhdGFiYXNlKTphbnl9IGluaXREQiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgaXMgZmlyc3QgY3JlYXRlZFxuICogQHJldHVybiB7UHJvbWlzZTxJREJEYXRhYmFzZT59XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgb3BlbkRCID0gKG5hbWUsIGluaXREQikgPT4gcHJvbWlzZS5jcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSlcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBldmVudCA9PiBpbml0REIoZXZlbnQudGFyZ2V0LnJlc3VsdClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBldmVudFxuICAgKi9cbiAgcmVxdWVzdC5vbmVycm9yID0gZXZlbnQgPT4gcmVqZWN0KGVycm9yLmNyZWF0ZShldmVudC50YXJnZXQuZXJyb3IpKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXF1ZXN0Lm9uYmxvY2tlZCA9ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub25zdWNjZXNzID0gZXZlbnQgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJREJEYXRhYmFzZX1cbiAgICAgKi9cbiAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGRiLm9udmVyc2lvbmNoYW5nZSA9ICgpID0+IHsgZGIuY2xvc2UoKSB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgKCkgPT4gZGIuY2xvc2UoKSlcbiAgICB9XG4gICAgcmVzb2x2ZShkYilcbiAgfVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZURCID0gbmFtZSA9PiBydG9wKGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQkRhdGFiYXNlfSBkYlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxzdHJpbmc+fEFycmF5PHN0cmluZ3xJREJPYmplY3RTdG9yZVBhcmFtZXRlcnN8dW5kZWZpbmVkPj59IGRlZmluaXRpb25zXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlU3RvcmVzID0gKGRiLCBkZWZpbml0aW9ucykgPT4gZGVmaW5pdGlvbnMuZm9yRWFjaChkID0+XG4gIC8vIEB0cy1pZ25vcmVcbiAgZGIuY3JlYXRlT2JqZWN0U3RvcmUuYXBwbHkoZGIsIGQpXG4pXG5cbi8qKlxuICogQHBhcmFtIHtJREJEYXRhYmFzZX0gZGJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3RvcmVzXG4gKiBAcGFyYW0ge1wicmVhZHdyaXRlXCJ8XCJyZWFkb25seVwifSBbYWNjZXNzXVxuICogQHJldHVybiB7QXJyYXk8SURCT2JqZWN0U3RvcmU+fVxuICovXG5leHBvcnQgY29uc3QgdHJhbnNhY3QgPSAoZGIsIHN0b3JlcywgYWNjZXNzID0gJ3JlYWR3cml0ZScpID0+IHtcbiAgY29uc3QgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihzdG9yZXMsIGFjY2VzcylcbiAgcmV0dXJuIHN0b3Jlcy5tYXAoc3RvcmUgPT4gZ2V0U3RvcmUodHJhbnNhY3Rpb24sIHN0b3JlKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNvdW50ID0gKHN0b3JlLCByYW5nZSkgPT5cbiAgcnRvcChzdG9yZS5jb3VudChyYW5nZSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55PiB9IGtleVxuICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBBcnJheTxhbnk+Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXQgPSAoc3RvcmUsIGtleSkgPT5cbiAgcnRvcChzdG9yZS5nZXQoa2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBJREJLZXlSYW5nZSB8IEFycmF5PGFueT4gfSBrZXlcbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBkZWwgPSAoc3RvcmUsIGtleSkgPT5cbiAgcnRvcChzdG9yZS5kZWxldGUoa2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBib29sZWFufSBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT59IFtrZXldXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcHV0ID0gKHN0b3JlLCBpdGVtLCBrZXkpID0+XG4gIHJ0b3Aoc3RvcmUucHV0KGl0ZW0sIGtleSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYm9vbGVhbn0gIGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55Pn0gIGtleVxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IChzdG9yZSwgaXRlbSwga2V5KSA9PlxuICBydG9wKHN0b3JlLmFkZChpdGVtLCBrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0gIGl0ZW1cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGtleVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGFkZEF1dG9LZXkgPSAoc3RvcmUsIGl0ZW0pID0+XG4gIHJ0b3Aoc3RvcmUuYWRkKGl0ZW0pKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGFueT4+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbCA9IChzdG9yZSwgcmFuZ2UpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0QWxsKHJhbmdlKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZX0gW3JhbmdlXVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxhbnk+Pn1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRBbGxLZXlzID0gKHN0b3JlLCByYW5nZSkgPT5cbiAgcnRvcChzdG9yZS5nZXRBbGxLZXlzKHJhbmdlKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZXxudWxsfSBxdWVyeVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgcXVlcnlGaXJzdCA9IChzdG9yZSwgcXVlcnksIGRpcmVjdGlvbikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBmaXJzdCA9IG51bGxcbiAgcmV0dXJuIGl0ZXJhdGVLZXlzKHN0b3JlLCBxdWVyeSwga2V5ID0+IHtcbiAgICBmaXJzdCA9IGtleVxuICAgIHJldHVybiBmYWxzZVxuICB9LCBkaXJlY3Rpb24pLnRoZW4oKCkgPT4gZmlyc3QpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldExhc3RLZXkgPSBzdG9yZSA9PiBxdWVyeUZpcnN0KHN0b3JlLCBudWxsLCAncHJldicpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZpcnN0S2V5ID0gc3RvcmUgPT4gcXVlcnlGaXJzdChzdG9yZSwgbnVsbCwgJ3ByZXYnKVxuXG4vKipcbiAqIEB0eXBlZGVmIEtleVZhbHVlUGFpclxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7YW55fSBrIGtleVxuICogQHByb3BlcnR5IHthbnl9IHYgVmFsdWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PEtleVZhbHVlUGFpcj4+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbEtleXNWYWx1ZXMgPSAoc3RvcmUsIHJhbmdlKSA9PlxuICAvLyBAdHMtaWdub3JlXG4gIHByb21pc2UuYWxsKFtnZXRBbGxLZXlzKHN0b3JlLCByYW5nZSksIGdldEFsbChzdG9yZSwgcmFuZ2UpXSkudGhlbigoW2tzLCB2c10pID0+IGtzLm1hcCgoaywgaSkgPT4gKHsgaywgdjogdnNbaV0gfSkpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQkN1cnNvcldpdGhWYWx1ZSk6dm9pZHxib29sZWFufSBmXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaXRlcmF0ZU9uUmVxdWVzdCA9IChyZXF1ZXN0LCBmKSA9PiBwcm9taXNlLmNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgaWYgKGN1cnNvciA9PT0gbnVsbCB8fCBmKGN1cnNvcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpXG4gICAgfVxuICAgIGN1cnNvci5jb250aW51ZSgpXG4gIH1cbn0pXG5cbi8qKlxuICogSXRlcmF0ZSBvbiBrZXlzIGFuZCB2YWx1ZXNcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfG51bGx9IGtleXJhbmdlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxhbnkpOnZvaWR8Ym9vbGVhbn0gZiBDYWxsYmFjayB0aGF0IHJlY2VpdmVzICh2YWx1ZSwga2V5KVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdGUgPSAoc3RvcmUsIGtleXJhbmdlLCBmLCBkaXJlY3Rpb24gPSAnbmV4dCcpID0+XG4gIGl0ZXJhdGVPblJlcXVlc3Qoc3RvcmUub3BlbkN1cnNvcihrZXlyYW5nZSwgZGlyZWN0aW9uKSwgY3Vyc29yID0+IGYoY3Vyc29yLnZhbHVlLCBjdXJzb3Iua2V5KSlcblxuLyoqXG4gKiBJdGVyYXRlIG9uIHRoZSBrZXlzIChubyB2YWx1ZXMpXG4gKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V8bnVsbH0ga2V5cmFuZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTp2b2lkfGJvb2xlYW59IGYgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUga2V5XG4gKiBAcGFyYW0geyduZXh0J3wncHJldid8J25leHR1bmlxdWUnfCdwcmV2dW5pcXVlJ30gZGlyZWN0aW9uXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZUtleXMgPSAoc3RvcmUsIGtleXJhbmdlLCBmLCBkaXJlY3Rpb24gPSAnbmV4dCcpID0+XG4gIGl0ZXJhdGVPblJlcXVlc3Qoc3RvcmUub3BlbktleUN1cnNvcihrZXlyYW5nZSwgZGlyZWN0aW9uKSwgY3Vyc29yID0+IGYoY3Vyc29yLmtleSkpXG5cbi8qKlxuICogT3BlbiBzdG9yZSBmcm9tIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEQlRyYW5zYWN0aW9ufSB0XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RvcmVcbiAqIEByZXR1cm5zIHtJREJPYmplY3RTdG9yZX1cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBnZXRTdG9yZSA9ICh0LCBzdG9yZSkgPT4gdC5vYmplY3RTdG9yZShzdG9yZSlcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbG93ZXJcbiAqIEBwYXJhbSB7YW55fSB1cHBlclxuICogQHBhcmFtIHtib29sZWFufSBsb3dlck9wZW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBwZXJPcGVuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VCb3VuZCA9IChsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSA9PiBJREJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB1cHBlclxuICogQHBhcmFtIHtib29sZWFufSB1cHBlck9wZW5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZVVwcGVyQm91bmQgPSAodXBwZXIsIHVwcGVyT3BlbikgPT4gSURCS2V5UmFuZ2UudXBwZXJCb3VuZCh1cHBlciwgdXBwZXJPcGVuKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBsb3dlclxuICogQHBhcmFtIHtib29sZWFufSBsb3dlck9wZW5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJREJLZXlSYW5nZUxvd2VyQm91bmQgPSAobG93ZXIsIGxvd2VyT3BlbikgPT4gSURCS2V5UmFuZ2UubG93ZXJCb3VuZChsb3dlciwgbG93ZXJPcGVuKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/indexeddb.js\n')},"./node_modules/lib0/iterator.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "mapIterator": () => (/* binding */ mapIterator),\n/* harmony export */   "createIterator": () => (/* binding */ createIterator),\n/* harmony export */   "iteratorFilter": () => (/* binding */ iteratorFilter),\n/* harmony export */   "iteratorMap": () => (/* binding */ iteratorMap)\n/* harmony export */ });\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvaXRlcmF0b3IuanM/NDExMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxjQUFjO0FBQ3pCO0FBQ087QUFDUCxTQUFTLGNBQWM7QUFDdkIsVUFBVTtBQUNWLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9pdGVyYXRvci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gY3JlYXRlIGFuZCBtYW5pcHVsYXRlIEl0ZXJhdG9ycy5cbiAqXG4gKiBAbW9kdWxlIGl0ZXJhdG9yXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCxSXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpSfSBmXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwSXRlcmF0b3IgPSAoaXRlcmF0b3IsIGYpID0+ICh7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOlJ9IGZcbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvLyBAdHMtaWdub3JlXG4gIG5leHQgKCkge1xuICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcbiAgICByZXR1cm4geyB2YWx1ZTogci5kb25lID8gdW5kZWZpbmVkIDogZihyLnZhbHVlKSwgZG9uZTogci5kb25lIH1cbiAgfVxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOkl0ZXJhdG9yUmVzdWx0PFQ+fSBuZXh0XG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSXRlcmF0b3IgPSBuZXh0ID0+ICh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8vIEB0cy1pZ25vcmVcbiAgbmV4dFxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gZmlsdGVyXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRvckZpbHRlciA9IChpdGVyYXRvciwgZmlsdGVyKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGxldCByZXNcbiAgZG8ge1xuICAgIHJlcyA9IGl0ZXJhdG9yLm5leHQoKVxuICB9IHdoaWxlICghcmVzLmRvbmUgJiYgIWZpbHRlcihyZXMudmFsdWUpKVxuICByZXR1cm4gcmVzXG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULE1cbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IGZtYXBcbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yTWFwID0gKGl0ZXJhdG9yLCBmbWFwKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0ZXJhdG9yLm5leHQoKVxuICByZXR1cm4geyBkb25lLCB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IGZtYXAodmFsdWUpIH1cbn0pXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/iterator.js\n')},"./node_modules/lib0/json.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "stringify": () => (/* binding */ stringify),\n/* harmony export */   "parse": () => (/* binding */ parse)\n/* harmony export */ });\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvanNvbi5qcz9jYmQxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9qc29uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKU09OIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBtb2R1bGUganNvblxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgb2JqZWN0IHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnlcblxuLyoqXG4gKiBQYXJzZSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvblxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSBKU09OLnBhcnNlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/json.js\n')},"./node_modules/lib0/logging.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BOLD\": () => (/* binding */ BOLD),\n/* harmony export */   \"UNBOLD\": () => (/* binding */ UNBOLD),\n/* harmony export */   \"BLUE\": () => (/* binding */ BLUE),\n/* harmony export */   \"GREY\": () => (/* binding */ GREY),\n/* harmony export */   \"GREEN\": () => (/* binding */ GREEN),\n/* harmony export */   \"RED\": () => (/* binding */ RED),\n/* harmony export */   \"PURPLE\": () => (/* binding */ PURPLE),\n/* harmony export */   \"ORANGE\": () => (/* binding */ ORANGE),\n/* harmony export */   \"UNCOLOR\": () => (/* binding */ UNCOLOR),\n/* harmony export */   \"print\": () => (/* binding */ print),\n/* harmony export */   \"warn\": () => (/* binding */ warn),\n/* harmony export */   \"printError\": () => (/* binding */ printError),\n/* harmony export */   \"printImg\": () => (/* binding */ printImg),\n/* harmony export */   \"printImgBase64\": () => (/* binding */ printImgBase64),\n/* harmony export */   \"group\": () => (/* binding */ group),\n/* harmony export */   \"groupCollapsed\": () => (/* binding */ groupCollapsed),\n/* harmony export */   \"groupEnd\": () => (/* binding */ groupEnd),\n/* harmony export */   \"printDom\": () => (/* binding */ printDom),\n/* harmony export */   \"printCanvas\": () => (/* binding */ printCanvas),\n/* harmony export */   \"vconsoles\": () => (/* binding */ vconsoles),\n/* harmony export */   \"VConsole\": () => (/* binding */ VConsole),\n/* harmony export */   \"createVConsole\": () => (/* binding */ createVConsole),\n/* harmony export */   \"createModuleLogger\": () => (/* binding */ createModuleLogger)\n/* harmony export */ });\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment.js */ \"./node_modules/lib0/environment.js\");\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol.js */ \"./node_modules/lib0/symbol.js\");\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pair.js */ \"./node_modules/lib0/pair.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ \"./node_modules/lib0/dom.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./json.js */ \"./node_modules/lib0/json.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var _eventloop_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./eventloop.js */ \"./node_modules/lib0/eventloop.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./math.js */ \"./node_modules/lib0/math.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./time.js */ \"./node_modules/lib0/time.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./function.js */ \"./node_modules/lib0/function.js\");\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\n\n\n\n\n\n\n\n\n\n\n\nconst BOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNBOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst BLUE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREY = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREEN = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst RED = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst PURPLE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst ORANGE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNCOLOR = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'bold'),\n  [UNBOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'normal'),\n  [BLUE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'blue'),\n  [GREEN]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'green'),\n  [GREY]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'grey'),\n  [RED]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'red'),\n  [PURPLE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'purple'),\n  [ORANGE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'black')\n}\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = []\n  const styles = []\n  const currentStyle = _map_js__WEBPACK_IMPORTED_MODULE_2__.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = []\n  const logArgs = []\n\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _nodeStyleMap[arg]\n    if (style !== undefined) {\n      strBuilder.push(style)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg)\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m')\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/* istanbul ignore next */\nconst computeLoggingArgs = _environment_js__WEBPACK_IMPORTED_MODULE_4__.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(ORANGE)\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nconst printError = err => {\n  console.error(err)\n  vconsoles.forEach(vc => vc.printError(err))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nconst printImg = (url, height) => {\n  if (_environment_js__WEBPACK_IMPORTED_MODULE_4__.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`)\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nconst printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args))\n}\n\nconst groupEnd = () => {\n  console.groupEnd()\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd())\n}\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nconst printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()))\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nconst printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height)\n\nconst vconsoles = new Set()\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle))], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(arg)])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + _json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(content) + ' '\n      }\n      spans.push(_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(/** @type {string} */ (content))]))\n    }\n  }\n  return spans\n}\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* istanbul ignore next */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      const triangleDown = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:120%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('▼')])\n      const triangleRight = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', !collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:125%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('▶')])\n      const content = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, _dom_js__WEBPACK_IMPORTED_MODULE_3__.text(' ')].concat(_computeLineSpans(args)))\n      const nextContainer = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed)])\n      const nextLine = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [], [content, nextContainer])\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('img', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('src', url), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('height', `${_math_js__WEBPACK_IMPORTED_MODULE_7__.round(height * 1.5)}px`)])])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_6__.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nconst createVConsole = dom => new VConsole(dom)\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = _time_js__WEBPACK_IMPORTED_MODULE_8__.getUnixTime()\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = _environment_js__WEBPACK_IMPORTED_MODULE_4__.getVariable('log')\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n\n  return !doLogging ? _function_js__WEBPACK_IMPORTED_MODULE_9__.nop : (...args) => {\n    const timeNow = _time_js__WEBPACK_IMPORTED_MODULE_8__.getUnixTime()\n    const timeDiff = timeNow - lastLoggingTime\n    lastLoggingTime = timeNow\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms')\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5qcz82NzlkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVDO0FBQ0Y7QUFDSjtBQUNGO0FBQ0U7QUFDRjtBQUNZO0FBQ1Y7QUFDQTtBQUNJOztBQUU5QixhQUFhLDhDQUFhO0FBQzFCLGVBQWUsOENBQWE7QUFDNUIsYUFBYSw4Q0FBYTtBQUMxQixhQUFhLDhDQUFhO0FBQzFCLGNBQWMsOENBQWE7QUFDM0IsWUFBWSw4Q0FBYTtBQUN6QixlQUFlLDhDQUFhO0FBQzVCLGVBQWUsOENBQWE7QUFDNUIsZ0JBQWdCLDhDQUFhOztBQUVwQztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSw0Q0FBVztBQUNyQixZQUFZLDRDQUFXO0FBQ3ZCLFVBQVUsNENBQVc7QUFDckIsV0FBVyw0Q0FBVztBQUN0QixVQUFVLDRDQUFXO0FBQ3JCLFNBQVMsNENBQVc7QUFDcEIsWUFBWSw0Q0FBVztBQUN2QixZQUFZLDRDQUFXO0FBQ3ZCLGFBQWEsNENBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUNBQW1DO0FBQzlDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQ0FBVTtBQUNqQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCLHFEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFF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cyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSXNvbW9ycGhpYyBsb2dnaW5nIG1vZHVsZSB3aXRoIHN1cHBvcnQgZm9yIGNvbG9ycyFcbiAqXG4gKiBAbW9kdWxlIGxvZ2dpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbnYgZnJvbSAnLi9lbnZpcm9ubWVudC5qcydcbmltcG9ydCAqIGFzIHN5bWJvbCBmcm9tICcuL3N5bWJvbC5qcydcbmltcG9ydCAqIGFzIHBhaXIgZnJvbSAnLi9wYWlyLmpzJ1xuaW1wb3J0ICogYXMgZG9tIGZyb20gJy4vZG9tLmpzJ1xuaW1wb3J0ICogYXMganNvbiBmcm9tICcuL2pzb24uanMnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnLi9ldmVudGxvb3AuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnLi90aW1lLmpzJ1xuaW1wb3J0ICogYXMgZnVuYyBmcm9tICcuL2Z1bmN0aW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IFVOQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEJMVUUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBHUkVZID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFRU4gPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBSRUQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBQVVJQTEUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBPUkFOR0UgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkNPTE9SID0gc3ltYm9sLmNyZWF0ZSgpXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxTeW1ib2wscGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn1cbiAqL1xuY29uc3QgX2Jyb3dzZXJTdHlsZU1hcCA9IHtcbiAgW0JPTERdOiBwYWlyLmNyZWF0ZSgnZm9udC13ZWlnaHQnLCAnYm9sZCcpLFxuICBbVU5CT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ25vcm1hbCcpLFxuICBbQkxVRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibHVlJyksXG4gIFtHUkVFTl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdncmVlbicpLFxuICBbR1JFWV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdncmV5JyksXG4gIFtSRURdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncmVkJyksXG4gIFtQVVJQTEVdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncHVycGxlJyksXG4gIFtPUkFOR0VdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnb3JhbmdlJyksIC8vIG5vdCB3ZWxsIHN1cHBvcnRlZCBpbiBjaHJvbWUgd2hlbiBkZWJ1Z2dpbmcgbm9kZSB3aXRoIGluc3BlY3RvciAtIFRPRE86IGRlcHJlY2F0ZVxuICBbVU5DT0xPUl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibGFjaycpXG59XG5cbmNvbnN0IF9ub2RlU3R5bGVNYXAgPSB7XG4gIFtCT0xEXTogJ1xcdTAwMWJbMW0nLFxuICBbVU5CT0xEXTogJ1xcdTAwMWJbMm0nLFxuICBbQkxVRV06ICdcXHgxYlszNG0nLFxuICBbR1JFRU5dOiAnXFx4MWJbMzJtJyxcbiAgW0dSRVldOiAnXFx1MDAxYlszN20nLFxuICBbUkVEXTogJ1xceDFiWzMxbScsXG4gIFtQVVJQTEVdOiAnXFx4MWJbMzVtJyxcbiAgW09SQU5HRV06ICdcXHgxYlszODs1OzIwOG0nLFxuICBbVU5DT0xPUl06ICdcXHgxYlswbSdcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbmNvbnN0IGNvbXB1dGVCcm93c2VyTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IHN0eWxlcyA9IFtdXG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG1hcC5jcmVhdGUoKVxuICAvKipcbiAgICogQHR5cGUge0FycmF5PHN0cmluZ3xPYmplY3R8bnVtYmVyPn1cbiAgICovXG4gIGxldCBsb2dBcmdzID0gW11cbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDBcblxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0eWxlID0gX2Jyb3dzZXJTdHlsZU1hcFthcmddXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnRTdHlsZS5zZXQoc3R5bGUubGVmdCwgc3R5bGUucmlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvbS5tYXBUb1N0eWxlU3RyaW5nKGN1cnJlbnRTdHlsZSlcbiAgICAgICAgaWYgKGkgPiAwIHx8IHN0eWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goJyVjJyArIGFyZylcbiAgICAgICAgICBzdHlsZXMucHVzaChzdHlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIGxvZ0FyZ3MgPSBzdHlsZXNcbiAgICBsb2dBcmdzLnVuc2hpZnQoc3RyQnVpbGRlci5qb2luKCcnKSlcbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbmNvbnN0IGNvbXB1dGVOb2RlTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXVxuXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG5cbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9ub2RlU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJCdWlsZGVyLnB1c2goc3R5bGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPiAwKSB7XG4gICAgLy8gY3JlYXRlIGxvZ0FyZ3Mgd2l0aCB3aGF0IHdlIGhhdmUgc28gZmFyXG4gICAgc3RyQnVpbGRlci5wdXNoKCdcXHgxYlswbScpXG4gICAgbG9nQXJncy5wdXNoKHN0ckJ1aWxkZXIuam9pbignJykpXG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBjb21wdXRlTG9nZ2luZ0FyZ3MgPSBlbnYuaXNOb2RlID8gY29tcHV0ZU5vZGVMb2dnaW5nQXJncyA6IGNvbXB1dGVCcm93c2VyTG9nZ2luZ0FyZ3NcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5sb2coLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludChhcmdzKSlcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCB3YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS53YXJuKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgYXJncy51bnNoaWZ0KE9SQU5HRSlcbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnQoYXJncykpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICovXG5leHBvcnQgY29uc3QgcHJpbnRFcnJvciA9IGVyciA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKVxuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludEVycm9yKGVycikpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgaW1hZ2UgbG9jYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBpbWFnZSBpbiBwaXhlbFxuICovXG5leHBvcnQgY29uc3QgcHJpbnRJbWcgPSAodXJsLCBoZWlnaHQpID0+IHtcbiAgaWYgKGVudi5pc0Jyb3dzZXIpIHtcbiAgICBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgICAgICAgJywgYGZvbnQtc2l6ZTogJHtoZWlnaHR9cHg7IGJhY2tncm91bmQtc2l6ZTogY29udGFpbjsgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDsgYmFja2dyb3VuZC1pbWFnZTogdXJsKCR7dXJsfSlgKVxuICAgIC8vIGNvbnNvbGUubG9nKCclYyAgICAgICAgICAgICAgICAnLCBgZm9udC1zaXplOiAke2hlaWdodH14OyBiYWNrZ3JvdW5kOiB1cmwoJHt1cmx9KSBuby1yZXBlYXQ7YClcbiAgfVxuICB2Y29uc29sZXMuZm9yRWFjaCh2YyA9PiB2Yy5wcmludEltZyh1cmwsIGhlaWdodCkpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nQmFzZTY0ID0gKGJhc2U2NCwgaGVpZ2h0KSA9PiBwcmludEltZyhgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YmFzZTY0fWAsIGhlaWdodClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5ncm91cCguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwKGFyZ3MpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgZ3JvdXBDb2xsYXBzZWQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMuZ3JvdXBDb2xsYXBzZWQoYXJncykpXG59XG5cbmV4cG9ydCBjb25zdCBncm91cEVuZCA9ICgpID0+IHtcbiAgY29uc29sZS5ncm91cEVuZCgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKHZjID0+IHZjLmdyb3VwRW5kKCkpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpOb2RlfSBjcmVhdGVOb2RlXG4gKi9cbmV4cG9ydCBjb25zdCBwcmludERvbSA9IGNyZWF0ZU5vZGUgPT5cbiAgdmNvbnNvbGVzLmZvckVhY2godmMgPT4gdmMucHJpbnREb20oY3JlYXRlTm9kZSgpKSlcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbmV4cG9ydCBjb25zdCBwcmludENhbnZhcyA9IChjYW52YXMsIGhlaWdodCkgPT4gcHJpbnRJbWcoY2FudmFzLnRvRGF0YVVSTCgpLCBoZWlnaHQpXG5cbmV4cG9ydCBjb25zdCB2Y29uc29sZXMgPSBuZXcgU2V0KClcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxFbGVtZW50Pn1cbiAqL1xuY29uc3QgX2NvbXB1dGVMaW5lU3BhbnMgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3BhbnMgPSBbXVxuICBjb25zdCBjdXJyZW50U3R5bGUgPSBuZXcgTWFwKClcbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDBcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50U3R5bGUuc2V0KHN0eWxlLmxlZnQsIHN0eWxlLnJpZ2h0KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgfHwgYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBzcGFuID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ3N0eWxlJywgZG9tLm1hcFRvU3R5bGVTdHJpbmcoY3VycmVudFN0eWxlKSldLCBbZG9tLnRleHQoYXJnKV0pXG4gICAgICAgIGlmIChzcGFuLmlubmVySFRNTCA9PT0gJycpIHtcbiAgICAgICAgICBzcGFuLmlubmVySFRNTCA9ICcmbmJzcDsnXG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaChzcGFuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBjb250ZW50ID0gYXJnc1tpXVxuICAgIGlmICghKGNvbnRlbnQgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBpZiAoY29udGVudC5jb25zdHJ1Y3RvciAhPT0gU3RyaW5nICYmIGNvbnRlbnQuY29uc3RydWN0b3IgIT09IE51bWJlcikge1xuICAgICAgICBjb250ZW50ID0gJyAnICsganNvbi5zdHJpbmdpZnkoY29udGVudCkgKyAnICdcbiAgICAgIH1cbiAgICAgIHNwYW5zLnB1c2goZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXSwgW2RvbS50ZXh0KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY29udGVudCkpXSkpXG4gICAgfVxuICB9XG4gIHJldHVybiBzcGFuc1xufVxuXG5jb25zdCBsaW5lU3R5bGUgPSAnZm9udC1mYW1pbHk6bW9ub3NwYWNlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMmUyZTI7cGFkZGluZzoycHg7J1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNsYXNzIFZDb25zb2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9tKSB7XG4gICAgdGhpcy5kb20gPSBkb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNjb250YWluZXIgPSB0aGlzLmRvbVxuICAgIHRoaXMuZGVwdGggPSAwXG4gICAgdmNvbnNvbGVzLmFkZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNlZFxuICAgKi9cbiAgZ3JvdXAgKGFyZ3MsIGNvbGxhcHNlZCA9IGZhbHNlKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgY29uc3QgdHJpYW5nbGVEb3duID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ2hpZGRlbicsIGNvbGxhcHNlZCksIHBhaXIuY3JlYXRlKCdzdHlsZScsICdjb2xvcjpncmV5O2ZvbnQtc2l6ZToxMjAlOycpXSwgW2RvbS50ZXh0KCfilrwnKV0pXG4gICAgICBjb25zdCB0cmlhbmdsZVJpZ2h0ID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbcGFpci5jcmVhdGUoJ2hpZGRlbicsICFjb2xsYXBzZWQpLCBwYWlyLmNyZWF0ZSgnc3R5bGUnLCAnY29sb3I6Z3JleTtmb250LXNpemU6MTI1JTsnKV0sIFtkb20udGV4dCgn4pa2JyldKVxuICAgICAgY29uc3QgY29udGVudCA9IGRvbS5lbGVtZW50KCdkaXYnLCBbcGFpci5jcmVhdGUoJ3N0eWxlJywgYCR7bGluZVN0eWxlfTtwYWRkaW5nLWxlZnQ6JHt0aGlzLmRlcHRoICogMTB9cHhgKV0sIFt0cmlhbmdsZURvd24sIHRyaWFuZ2xlUmlnaHQsIGRvbS50ZXh0KCcgJyldLmNvbmNhdChfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSkpXG4gICAgICBjb25zdCBuZXh0Q29udGFpbmVyID0gZG9tLmVsZW1lbnQoJ2RpdicsIFtwYWlyLmNyZWF0ZSgnaGlkZGVuJywgY29sbGFwc2VkKV0pXG4gICAgICBjb25zdCBuZXh0TGluZSA9IGRvbS5lbGVtZW50KCdkaXYnLCBbXSwgW2NvbnRlbnQsIG5leHRDb250YWluZXJdKVxuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtuZXh0TGluZV0pXG4gICAgICB0aGlzLmNjb250YWluZXIgPSBuZXh0Q29udGFpbmVyXG4gICAgICB0aGlzLmRlcHRoKytcbiAgICAgIC8vIHdoZW4gaGVhZGVyIGlzIGNsaWNrZWQsIGNvbGxhcHNlL3VuY29sbGFwc2UgY29udGFpbmVyXG4gICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihjb250ZW50LCAnY2xpY2snLCBldmVudCA9PiB7XG4gICAgICAgIG5leHRDb250YWluZXIudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICB0cmlhbmdsZURvd24udG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgICB0cmlhbmdsZVJpZ2h0LnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIGdyb3VwQ29sbGFwc2VkIChhcmdzKSB7XG4gICAgdGhpcy5ncm91cChhcmdzLCB0cnVlKVxuICB9XG5cbiAgZ3JvdXBFbmQgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmRlcHRoID4gMCkge1xuICAgICAgICB0aGlzLmRlcHRoLS1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmNjb250YWluZXIgPSB0aGlzLmNjb250YWluZXIucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICovXG4gIHByaW50IChhcmdzKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtkb20uZWxlbWVudCgnZGl2JywgW3BhaXIuY3JlYXRlKCdzdHlsZScsIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YCldLCBfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSldKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICB0aGlzLnByaW50KFtSRUQsIEJPTEQsIGVyci50b1N0cmluZygpXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHByaW50SW1nICh1cmwsIGhlaWdodCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbZG9tLmVsZW1lbnQoJ2ltZycsIFtwYWlyLmNyZWF0ZSgnc3JjJywgdXJsKSwgcGFpci5jcmVhdGUoJ2hlaWdodCcsIGAke21hdGgucm91bmQoaGVpZ2h0ICogMS41KX1weGApXSldKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBwcmludERvbSAobm9kZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbbm9kZV0pXG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIHZjb25zb2xlcy5kZWxldGUodGhpcylcbiAgICB9KVxuICB9XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVWQ29uc29sZSA9IGRvbSA9PiBuZXcgVkNvbnNvbGUoZG9tKVxuXG5jb25zdCBsb2dnaW5nQ29sb3JzID0gW0dSRUVOLCBQVVJQTEUsIE9SQU5HRSwgQkxVRV1cbmxldCBuZXh0Q29sb3IgPSAwXG5sZXQgbGFzdExvZ2dpbmdUaW1lID0gdGltZS5nZXRVbml4VGltZSgpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vZHVsZUxvZ2dlciA9IG1vZHVsZU5hbWUgPT4ge1xuICBjb25zdCBjb2xvciA9IGxvZ2dpbmdDb2xvcnNbbmV4dENvbG9yXVxuICBjb25zdCBkZWJ1Z1JlZ2V4VmFyID0gZW52LmdldFZhcmlhYmxlKCdsb2cnKVxuICBjb25zdCBkb0xvZ2dpbmcgPSBkZWJ1Z1JlZ2V4VmFyICE9PSBudWxsICYmIChkZWJ1Z1JlZ2V4VmFyID09PSAnKicgfHwgZGVidWdSZWdleFZhciA9PT0gJ3RydWUnIHx8IG5ldyBSZWdFeHAoZGVidWdSZWdleFZhciwgJ2dpJykudGVzdChtb2R1bGVOYW1lKSlcbiAgbmV4dENvbG9yID0gKG5leHRDb2xvciArIDEpICUgbG9nZ2luZ0NvbG9ycy5sZW5ndGhcbiAgbW9kdWxlTmFtZSArPSAnOiAnXG5cbiAgcmV0dXJuICFkb0xvZ2dpbmcgPyBmdW5jLm5vcCA6ICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgdGltZU5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgIGNvbnN0IHRpbWVEaWZmID0gdGltZU5vdyAtIGxhc3RMb2dnaW5nVGltZVxuICAgIGxhc3RMb2dnaW5nVGltZSA9IHRpbWVOb3dcbiAgICBwcmludChjb2xvciwgbW9kdWxlTmFtZSwgVU5DT0xPUiwgLi4uYXJncy5tYXAoYXJnID0+ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXJnID09PSAnc3ltYm9sJykgPyBhcmcgOiBKU09OLnN0cmluZ2lmeShhcmcpKSwgY29sb3IsICcgKycgKyB0aW1lRGlmZiArICdtcycpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/logging.js\n")},"./node_modules/lib0/map.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "copy": () => (/* binding */ copy),\n/* harmony export */   "setIfUndefined": () => (/* binding */ setIfUndefined),\n/* harmony export */   "map": () => (/* binding */ map),\n/* harmony export */   "any": () => (/* binding */ any),\n/* harmony export */   "all": () => (/* binding */ all)\n/* harmony export */ });\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nconst copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, \'eventName\', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzPzIzMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiLFdBQVcsYUFBYTtBQUN4QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGdCQUFnQjtBQUMzQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsc0JBQXNCO0FBQ2pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9tYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgTWFwKClcblxuLyoqXG4gKiBDb3B5IGEgTWFwIG9iamVjdCBpbnRvIGEgZnJlc2ggTWFwIG9iamVjdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBYLFlcbiAqIEBwYXJhbSB7TWFwPFgsWT59IG1cbiAqIEByZXR1cm4ge01hcDxYLFk+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IG0gPT4ge1xuICBjb25zdCByID0gY3JlYXRlKClcbiAgbS5mb3JFYWNoKCh2LCBrKSA9PiB7IHIuc2V0KGssIHYpIH0pXG4gIHJldHVybiByXG59XG5cbi8qKlxuICogR2V0IG1hcCBwcm9wZXJ0eS4gQ3JlYXRlIFQgaWYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCBzZXQgVCBvbiBtYXAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3RlbmVycyA9IG1hcC5zZXRJZlVuZGVmaW5lZChldmVudHMsICdldmVudE5hbWUnLCBzZXQuY3JlYXRlKVxuICogbGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQsS1xuICogQHBhcmFtIHtNYXA8SywgVD59IG1hcFxuICogQHBhcmFtIHtLfSBrZXlcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBjcmVhdGVUXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3Qgc2V0SWZVbmRlZmluZWQgPSAobWFwLCBrZXksIGNyZWF0ZVQpID0+IHtcbiAgbGV0IHNldCA9IG1hcC5nZXQoa2V5KVxuICBpZiAoc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXAuc2V0KGtleSwgc2V0ID0gY3JlYXRlVCgpKVxuICB9XG4gIHJldHVybiBzZXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIEFycmF5IGFuZCBwb3B1bGF0ZXMgaXQgd2l0aCB0aGUgY29udGVudCBvZiBhbGwga2V5LXZhbHVlIHBhaXJzIHVzaW5nIHRoZSBgZih2YWx1ZSwga2V5KWAgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEB0ZW1wbGF0ZSBSXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFYsSyk6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAobSwgZikgPT4ge1xuICBjb25zdCByZXMgPSBbXVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgcmVzLnB1c2goZih2YWx1ZSwga2V5KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBhbnkga2V5LXZhbHVlIHBhaXJzIHBhc3MgdGhlIHRlc3QgaW1wbGVtZW50ZWQgYnkgYGYodmFsdWUsIGtleSlgLlxuICpcbiAqIEB0b2RvIHNob3VsZCByZW5hbWUgdG8gc29tZSAtIHNpbWlsYXJseSB0byBBcnJheS5zb21lXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgYW55ID0gKG0sIGYpID0+IHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIGlmIChmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFsbCBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgS1xuICogQHRlbXBsYXRlIFZcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgYWxsID0gKG0sIGYpID0+IHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbSkge1xuICAgIGlmICghZih2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/map.js\n')},"./node_modules/lib0/math.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "floor": () => (/* binding */ floor),\n/* harmony export */   "ceil": () => (/* binding */ ceil),\n/* harmony export */   "abs": () => (/* binding */ abs),\n/* harmony export */   "imul": () => (/* binding */ imul),\n/* harmony export */   "round": () => (/* binding */ round),\n/* harmony export */   "log10": () => (/* binding */ log10),\n/* harmony export */   "log2": () => (/* binding */ log2),\n/* harmony export */   "log": () => (/* binding */ log),\n/* harmony export */   "sqrt": () => (/* binding */ sqrt),\n/* harmony export */   "add": () => (/* binding */ add),\n/* harmony export */   "min": () => (/* binding */ min),\n/* harmony export */   "max": () => (/* binding */ max),\n/* harmony export */   "isNaN": () => (/* binding */ isNaN),\n/* harmony export */   "pow": () => (/* binding */ pow),\n/* harmony export */   "exp10": () => (/* binding */ exp10),\n/* harmony export */   "sign": () => (/* binding */ sign),\n/* harmony export */   "isNegativeZero": () => (/* binding */ isNegativeZero)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor\nconst ceil = Math.ceil\nconst abs = Math.abs\nconst imul = Math.imul\nconst round = Math.round\nconst log10 = Math.log10\nconst log2 = Math.log2\nconst log = Math.log\nconst sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b\n\nconst isNaN = Number.isNaN\n\nconst pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp)\n\nconst sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvbWF0aC5qcz9jYTBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ087O0FBRUE7O0FBRUE7QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRUE7O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9tYXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb21tb24gTWF0aCBleHByZXNzaW9ucy5cbiAqXG4gKiBAbW9kdWxlIG1hdGhcbiAqL1xuXG5leHBvcnQgY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yXG5leHBvcnQgY29uc3QgY2VpbCA9IE1hdGguY2VpbFxuZXhwb3J0IGNvbnN0IGFicyA9IE1hdGguYWJzXG5leHBvcnQgY29uc3QgaW11bCA9IE1hdGguaW11bFxuZXhwb3J0IGNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZFxuZXhwb3J0IGNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMFxuZXhwb3J0IGNvbnN0IGxvZzIgPSBNYXRoLmxvZzJcbmV4cG9ydCBjb25zdCBsb2cgPSBNYXRoLmxvZ1xuZXhwb3J0IGNvbnN0IHNxcnQgPSBNYXRoLnNxcnRcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc3VtIG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IChhLCBiKSA9PiBhICsgYlxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzbWFsbGVyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgbWluID0gKGEsIGIpID0+IGEgPCBiID8gYSA6IGJcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYmlnZ2VyIGVsZW1lbnQgb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgbWF4ID0gKGEsIGIpID0+IGEgPiBiID8gYSA6IGJcblxuZXhwb3J0IGNvbnN0IGlzTmFOID0gTnVtYmVyLmlzTmFOXG5cbmV4cG9ydCBjb25zdCBwb3cgPSBNYXRoLnBvd1xuLyoqXG4gKiBCYXNlIDEwIGV4cG9uZW50aWFsIGZ1bmN0aW9uLiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiAxMCByYWlzZWQgdG8gdGhlIHBvd2VyIG9mIHBvdy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBleHAxMCA9IGV4cCA9PiBNYXRoLnBvdygxMCwgZXhwKVxuXG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXZXRoZXIgbiBpcyBuZWdhdGl2ZS4gVGhpcyBmdW5jdGlvbiBhbHNvIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gLTAgYW5kICswXG4gKi9cbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlWmVybyA9IG4gPT4gbiAhPT0gMCA/IG4gPCAwIDogMSAvIG4gPCAwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/math.js\n')},"./node_modules/lib0/metric.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "yotta": () => (/* binding */ yotta),\n/* harmony export */   "zetta": () => (/* binding */ zetta),\n/* harmony export */   "exa": () => (/* binding */ exa),\n/* harmony export */   "peta": () => (/* binding */ peta),\n/* harmony export */   "tera": () => (/* binding */ tera),\n/* harmony export */   "giga": () => (/* binding */ giga),\n/* harmony export */   "mega": () => (/* binding */ mega),\n/* harmony export */   "kilo": () => (/* binding */ kilo),\n/* harmony export */   "hecto": () => (/* binding */ hecto),\n/* harmony export */   "deca": () => (/* binding */ deca),\n/* harmony export */   "deci": () => (/* binding */ deci),\n/* harmony export */   "centi": () => (/* binding */ centi),\n/* harmony export */   "milli": () => (/* binding */ milli),\n/* harmony export */   "micro": () => (/* binding */ micro),\n/* harmony export */   "nano": () => (/* binding */ nano),\n/* harmony export */   "pico": () => (/* binding */ pico),\n/* harmony export */   "femto": () => (/* binding */ femto),\n/* harmony export */   "atto": () => (/* binding */ atto),\n/* harmony export */   "zepto": () => (/* binding */ zepto),\n/* harmony export */   "yocto": () => (/* binding */ yocto),\n/* harmony export */   "prefix": () => (/* binding */ prefix)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\n\n\nconst yotta = 1e24\nconst zetta = 1e21\nconst exa = 1e18\nconst peta = 1e15\nconst tera = 1e12\nconst giga = 1e9\nconst mega = 1e6\nconst kilo = 1e3\nconst hecto = 1e2\nconst deca = 10\nconst deci = 0.1\nconst centi = 0.01\nconst milli = 1e-3\nconst micro = 1e-6\nconst nano = 1e-9\nconst pico = 1e-12\nconst femto = 1e-15\nconst atto = 1e-18\nconst zepto = 1e-21\nconst yocto = 1e-24\n\nconst prefixUp = [\'\', \'k\', \'M\', \'G\', \'T\', \'P\', \'E\', \'Z\', \'Y\']\nconst prefixDown = [\'\', \'m\', \'μ\', \'n\', \'p\', \'f\', \'a\', \'z\', \'y\']\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: \'k\' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : _math_js__WEBPACK_IMPORTED_MODULE_0__.log10(n)\n  let mult = 0\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--\n    mult--\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++\n    mult++\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier]\n  return {\n    n: _math_js__WEBPACK_IMPORTED_MODULE_0__.round((mult > 0 ? n / _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * 3) : n * _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvbWV0cmljLmpzP2EwODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsb0JBQW9CO0FBQy9GO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDTztBQUNQLDZCQUE2QiwyQ0FBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywyQ0FBVSxpQkFBaUIsMkNBQVUsaUJBQWlCLDJDQUFVO0FBQ3ZFO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL21ldHJpYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gY29udmVydCBtZXRyaWMgdmFsdWVzLlxuICpcbiAqIEBtb2R1bGUgbWV0cmljXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5cbmV4cG9ydCBjb25zdCB5b3R0YSA9IDFlMjRcbmV4cG9ydCBjb25zdCB6ZXR0YSA9IDFlMjFcbmV4cG9ydCBjb25zdCBleGEgPSAxZTE4XG5leHBvcnQgY29uc3QgcGV0YSA9IDFlMTVcbmV4cG9ydCBjb25zdCB0ZXJhID0gMWUxMlxuZXhwb3J0IGNvbnN0IGdpZ2EgPSAxZTlcbmV4cG9ydCBjb25zdCBtZWdhID0gMWU2XG5leHBvcnQgY29uc3Qga2lsbyA9IDFlM1xuZXhwb3J0IGNvbnN0IGhlY3RvID0gMWUyXG5leHBvcnQgY29uc3QgZGVjYSA9IDEwXG5leHBvcnQgY29uc3QgZGVjaSA9IDAuMVxuZXhwb3J0IGNvbnN0IGNlbnRpID0gMC4wMVxuZXhwb3J0IGNvbnN0IG1pbGxpID0gMWUtM1xuZXhwb3J0IGNvbnN0IG1pY3JvID0gMWUtNlxuZXhwb3J0IGNvbnN0IG5hbm8gPSAxZS05XG5leHBvcnQgY29uc3QgcGljbyA9IDFlLTEyXG5leHBvcnQgY29uc3QgZmVtdG8gPSAxZS0xNVxuZXhwb3J0IGNvbnN0IGF0dG8gPSAxZS0xOFxuZXhwb3J0IGNvbnN0IHplcHRvID0gMWUtMjFcbmV4cG9ydCBjb25zdCB5b2N0byA9IDFlLTI0XG5cbmNvbnN0IHByZWZpeFVwID0gWycnLCAnaycsICdNJywgJ0cnLCAnVCcsICdQJywgJ0UnLCAnWicsICdZJ11cbmNvbnN0IHByZWZpeERvd24gPSBbJycsICdtJywgJ868JywgJ24nLCAncCcsICdmJywgJ2EnLCAneicsICd5J11cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1ldHJpYyBwcmVmaXggZm9yIGEgbnVtYmVyLiBBc3N1bWVzIEUuZy4gYHByZWZpeCgxMDAwKSA9IHsgbjogMSwgcHJlZml4OiAnaycgfWBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHBhcmFtIHtudW1iZXJ9IFtiYXNlTXVsdGlwbGllcl0gTXVsdGlwbGllciBvZiB0aGUgYmFzZSAoMTBeKDMqYmFzZU11bHRpcGxpZXIpKS4gRS5nLiBgY29udmVydCh0aW1lLCAtMylgIGlmIHRpbWUgaXMgYWxyZWFkeSBpbiBtaWxsaSBzZWNvbmRzXG4gKiBAcmV0dXJuIHt7bjpudW1iZXIscHJlZml4OnN0cmluZ319XG4gKi9cbmV4cG9ydCBjb25zdCBwcmVmaXggPSAobiwgYmFzZU11bHRpcGxpZXIgPSAwKSA9PiB7XG4gIGNvbnN0IG5Qb3cgPSBuID09PSAwID8gMCA6IG1hdGgubG9nMTAobilcbiAgbGV0IG11bHQgPSAwXG4gIHdoaWxlIChuUG93IDwgbXVsdCAqIDMgJiYgYmFzZU11bHRpcGxpZXIgPiAtOCkge1xuICAgIGJhc2VNdWx0aXBsaWVyLS1cbiAgICBtdWx0LS1cbiAgfVxuICB3aGlsZSAoblBvdyA+PSAzICsgbXVsdCAqIDMgJiYgYmFzZU11bHRpcGxpZXIgPCA4KSB7XG4gICAgYmFzZU11bHRpcGxpZXIrK1xuICAgIG11bHQrK1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGJhc2VNdWx0aXBsaWVyIDwgMCA/IHByZWZpeERvd25bLWJhc2VNdWx0aXBsaWVyXSA6IHByZWZpeFVwW2Jhc2VNdWx0aXBsaWVyXVxuICByZXR1cm4ge1xuICAgIG46IG1hdGgucm91bmQoKG11bHQgPiAwID8gbiAvIG1hdGguZXhwMTAobXVsdCAqIDMpIDogbiAqIG1hdGguZXhwMTAobXVsdCAqIC0zKSkgKiAxZTEyKSAvIDFlMTIsXG4gICAgcHJlZml4XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/metric.js\n')},"./node_modules/lib0/mutex.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "createMutex": () => (/* binding */ createMutex)\n/* harmony export */ });\n/**\n * Mutual exclude for JavaScript.\n *\n * @module mutex\n */\n\n/**\n * @callback mutex\n * @param {function():void} cb Only executed when this mutex is not in the current stack\n * @param {function():void} [elseCb] Executed when this mutex is in the current stack\n */\n\n/**\n * Creates a mutual exclude function with the following property:\n *\n * ```js\n * const mutex = createMutex()\n * mutex(() => {\n *   // This function is immediately executed\n *   mutex(() => {\n *     // This function is not executed, as the mutex is already active.\n *   })\n * })\n * ```\n *\n * @return {mutex} A mutual exclude function\n * @public\n */\nconst createMutex = () => {\n  let token = true\n  return (f, g) => {\n    if (token) {\n      token = false\n      try {\n        f()\n      } finally {\n        token = true\n      }\n    } else if (g !== undefined) {\n      g()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanM/M2VkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE11dHVhbCBleGNsdWRlIGZvciBKYXZhU2NyaXB0LlxuICpcbiAqIEBtb2R1bGUgbXV0ZXhcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBtdXRleFxuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IGNiIE9ubHkgZXhlY3V0ZWQgd2hlbiB0aGlzIG11dGV4IGlzIG5vdCBpbiB0aGUgY3VycmVudCBzdGFja1xuICogQHBhcmFtIHtmdW5jdGlvbigpOnZvaWR9IFtlbHNlQ2JdIEV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBpbiB0aGUgY3VycmVudCBzdGFja1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXV0ZXggPSBjcmVhdGVNdXRleCgpXG4gKiBtdXRleCgoKSA9PiB7XG4gKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAqICAgbXV0ZXgoKCkgPT4ge1xuICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhcyB0aGUgbXV0ZXggaXMgYWxyZWFkeSBhY3RpdmUuXG4gKiAgIH0pXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHJldHVybiB7bXV0ZXh9IEEgbXV0dWFsIGV4Y2x1ZGUgZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU11dGV4ID0gKCkgPT4ge1xuICBsZXQgdG9rZW4gPSB0cnVlXG4gIHJldHVybiAoZiwgZykgPT4ge1xuICAgIGlmICh0b2tlbikge1xuICAgICAgdG9rZW4gPSBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZigpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0b2tlbiA9IHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZygpXG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/mutex.js\n')},"./node_modules/lib0/number.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "MAX_SAFE_INTEGER": () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   "MIN_SAFE_INTEGER": () => (/* binding */ MIN_SAFE_INTEGER),\n/* harmony export */   "LOWEST_INT32": () => (/* binding */ LOWEST_INT32),\n/* harmony export */   "HIGHEST_INT32": () => (/* binding */ HIGHEST_INT32),\n/* harmony export */   "isInteger": () => (/* binding */ isInteger),\n/* harmony export */   "isNaN": () => (/* binding */ isNaN)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary.js */ "./node_modules/lib0/binary.js");\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nconst LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nconst HIGHEST_INT32 = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === \'number\' && isFinite(num) && _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num) === num)\nconst isNaN = Number.isNaN\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzP2UxNzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNJOztBQUU5QjtBQUNBOztBQUVBO0FBQ1A7QUFDQSxVQUFVO0FBQ1Y7QUFDTyxzQkFBc0IsOENBQWE7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLDBGQUEwRiwyQ0FBVTtBQUNwRyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL251bWJlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBoZWxwZXJzIGZvciB3b3JraW5nIHdpdGggbnVtYmVycy5cbiAqXG4gKiBAbW9kdWxlIG51bWJlclxuICovXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJy4vYmluYXJ5LmpzJ1xuXG5leHBvcnQgY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG5leHBvcnQgY29uc3QgTUlOX1NBRkVfSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSXG5cbmV4cG9ydCBjb25zdCBMT1dFU1RfSU5UMzIgPSAxIDw8IDMxXG4vKipcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBISUdIRVNUX0lOVDMyID0gYmluYXJ5LkJJVFMzMVxuXG4vKipcbiAqIEBtb2R1bGUgbnVtYmVyXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IChudW0gPT4gdHlwZW9mIG51bSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUobnVtKSAmJiBtYXRoLmZsb29yKG51bSkgPT09IG51bSlcbmV4cG9ydCBjb25zdCBpc05hTiA9IE51bWJlci5pc05hTlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/number.js\n')},"./node_modules/lib0/object.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "assign": () => (/* binding */ assign),\n/* harmony export */   "keys": () => (/* binding */ keys),\n/* harmony export */   "forEach": () => (/* binding */ forEach),\n/* harmony export */   "map": () => (/* binding */ map),\n/* harmony export */   "length": () => (/* binding */ length),\n/* harmony export */   "some": () => (/* binding */ some),\n/* harmony export */   "every": () => (/* binding */ every),\n/* harmony export */   "hasProperty": () => (/* binding */ hasProperty),\n/* harmony export */   "equalFlat": () => (/* binding */ equalFlat)\n/* harmony export */ });\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nconst assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvb2JqZWN0LmpzPzFkMmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsNkJBQTZCO0FBQ3hDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLDZCQUE2QjtBQUN4QyxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvb2JqZWN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIEVjbWFTY3JpcHQgb2JqZWN0cy5cbiAqXG4gKiBAbW9kdWxlIG9iamVjdFxuICovXG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IE9iamVjdC5jcmVhdGUobnVsbClcblxuLyoqXG4gKiBPYmplY3QuYXNzaWduXG4gKi9cbmV4cG9ydCBjb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICovXG5leHBvcnQgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGYob2JqW2tleV0sIGtleSlcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBSXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOlJ9IGZcbiAqIEByZXR1cm4ge0FycmF5PFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwID0gKG9iaiwgZikgPT4ge1xuICBjb25zdCByZXN1bHRzID0gW11cbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgcmVzdWx0cy5wdXNoKGYob2JqW2tleV0sIGtleSkpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBvYmogPT4ga2V5cyhvYmopLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChmKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBldmVyeSA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFmKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBDYWxscyBgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHthbnl9IG9ialxuICogQHBhcmFtIHtzdHJpbmd8c3ltYm9sfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNQcm9wZXJ0eSA9IChvYmosIGtleSkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsRmxhdCA9IChhLCBiKSA9PiBhID09PSBiIHx8IChsZW5ndGgoYSkgPT09IGxlbmd0aChiKSAmJiBldmVyeShhLCAodmFsLCBrZXkpID0+ICh2YWwgIT09IHVuZGVmaW5lZCB8fCBoYXNQcm9wZXJ0eShiLCBrZXkpKSAmJiBiW2tleV0gPT09IHZhbCkpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/object.js\n')},"./node_modules/lib0/observable.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Observable": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ "./node_modules/lib0/map.js");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set.js */ "./node_modules/lib0/set.js");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ "./node_modules/lib0/array.js");\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n\n\n\n/**\n * Handles named events.\n *\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qcz9lNmM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrQjtBQUNBO0FBQ0k7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHNCQUFzQiwyQ0FBVTtBQUNoQzs7QUFFQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsSUFBSSxtREFBa0Isd0JBQXdCLDJDQUFVO0FBQ3hEOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUFVLCtCQUErQiwyQ0FBVTtBQUM5RDs7QUFFQTtBQUNBLHNCQUFzQiwyQ0FBVTtBQUNoQztBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgTlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBTb21lIGRlc2MuXG4gICAgICogQHR5cGUge01hcDxOLCBhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbiAobmFtZSwgZikge1xuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLl9vYnNlcnZlcnMsIG5hbWUsIHNldC5jcmVhdGUpLmFkZChmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbmNlIChuYW1lLCBmKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICovXG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpXG4gICAgICBmKC4uLmFyZ3MpXG4gICAgfVxuICAgIHRoaXMub24obmFtZSwgX2YpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAobmFtZSwgZikge1xuICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5nZXQobmFtZSlcbiAgICBpZiAob2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVycy5kZWxldGUoZilcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgbmFtZSB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAdG9kbyBUaGlzIHNob3VsZCBjYXRjaCBleGNlcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBlbWl0IChuYW1lLCBhcmdzKSB7XG4gICAgLy8gY29weSBhbGwgbGlzdGVuZXJzIHRvIGFuIGFycmF5IGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IG5vIGV2ZW50IGlzIGVtaXR0ZWQgdG8gbGlzdGVuZXJzIHRoYXQgYXJlIHN1YnNjcmliZWQgd2hpbGUgdGhlIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLlxuICAgIHJldHVybiBhcnJheS5mcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IG1hcC5jcmVhdGUoKSkudmFsdWVzKCkpLmZvckVhY2goZiA9PiBmKC4uLmFyZ3MpKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gbWFwLmNyZWF0ZSgpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/observable.js\n')},"./node_modules/lib0/pair.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Pair": () => (/* binding */ Pair),\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "createReversed": () => (/* binding */ createReversed),\n/* harmony export */   "forEach": () => (/* binding */ forEach),\n/* harmony export */   "map": () => (/* binding */ map)\n/* harmony export */ });\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcz83NzQ5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogV29ya2luZyB3aXRoIHZhbHVlIHBhaXJzLlxuICpcbiAqIEBtb2R1bGUgcGFpclxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICovXG5leHBvcnQgY2xhc3MgUGFpciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0x9IGxlZnRcbiAgICogQHBhcmFtIHtSfSByaWdodFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlZnQsIHJpZ2h0KSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdFxuICAgIHRoaXMucmlnaHQgPSByaWdodFxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtMfSBsZWZ0XG4gKiBAcGFyYW0ge1J9IHJpZ2h0XG4gKiBAcmV0dXJuIHtQYWlyPEwsUj59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAobGVmdCwgcmlnaHQpID0+IG5ldyBQYWlyKGxlZnQsIHJpZ2h0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7Un0gcmlnaHRcbiAqIEBwYXJhbSB7TH0gbGVmdFxuICogQHJldHVybiB7UGFpcjxMLFI+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmV2ZXJzZWQgPSAocmlnaHQsIGxlZnQpID0+IG5ldyBQYWlyKGxlZnQsIHJpZ2h0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7QXJyYXk8UGFpcjxMLFI+Pn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEwsIFIpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChhcnIsIGYpID0+IGFyci5mb3JFYWNoKHAgPT4gZihwLmxlZnQsIHAucmlnaHQpKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFIsWFxuICogQHBhcmFtIHtBcnJheTxQYWlyPEwsUj4+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oTCwgUik6WH0gZlxuICogQHJldHVybiB7QXJyYXk8WD59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoYXJyLCBmKSA9PiBhcnIubWFwKHAgPT4gZihwLmxlZnQsIHAucmlnaHQpKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lib0/pair.js\n')},"./node_modules/lib0/promise.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "createEmpty": () => (/* binding */ createEmpty),\n/* harmony export */   "all": () => (/* binding */ all),\n/* harmony export */   "reject": () => (/* binding */ reject),\n/* harmony export */   "resolve": () => (/* binding */ resolve),\n/* harmony export */   "until": () => (/* binding */ until),\n/* harmony export */   "wait": () => (/* binding */ wait),\n/* harmony export */   "isPromise": () => (/* binding */ isPromise)\n/* harmony export */ });\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "./node_modules/lib0/time.js");\n/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\n\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nconst create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nconst createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template T\n * @param {Array<Promise<T>>} arrp\n * @return {Promise<Array<T>>}\n */\nconst all = arrp => Promise.all(arrp)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nconst reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nconst resolve = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nconst until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* istanbul ignore else */\n      if (_time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error(\'Timeout\'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nconst wait = timeout => create((resolve, reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nconst isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvcHJvbWlzZS5qcz85YzJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxxREFBcUQ7QUFDaEUsWUFBWTtBQUNaO0FBQ08sK0JBQStCLFdBQVc7O0FBRWpEO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0QsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNPO0FBQ1Asb0JBQW9CLGlEQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsVUFBVSxpREFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZO0FBQ1o7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL3Byb21pc2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgaGVscGVycyB0byB3b3JrIHdpdGggcHJvbWlzZXMuXG4gKlxuICogQG1vZHVsZSBwcm9taXNlXG4gKi9cblxuaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUuanMnXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBQcm9taXNlUmVzb2x2ZVxuICogQHBhcmFtIHtUfFByb21pc2VMaWtlPFQ+fSBbcmVzdWx0XVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUHJvbWlzZVJlc29sdmU8VD4sZnVuY3Rpb24oRXJyb3IpOnZvaWQpOmFueX0gZlxuICogQHJldHVybiB7UHJvbWlzZTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGYgPT4gLyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqLyAobmV3IFByb21pc2UoZikpXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbigpOnZvaWQsZnVuY3Rpb24oRXJyb3IpOnZvaWQpOnZvaWR9IGZcbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbXB0eSA9IGYgPT4gbmV3IFByb21pc2UoZilcblxuLyoqXG4gKiBgUHJvbWlzZS5hbGxgIHdhaXQgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgYXJyYXkgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFByb21pc2U8VD4+fSBhcnJwXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFQ+Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFsbCA9IGFycnAgPT4gUHJvbWlzZS5hbGwoYXJycClcblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBbcmVhc29uXVxuICogQHJldHVybiB7UHJvbWlzZTxuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCByZWplY3QgPSByZWFzb24gPT4gUHJvbWlzZS5yZWplY3QocmVhc29uKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8dm9pZH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFR8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlID0gcmVzID0+IFByb21pc2UucmVzb2x2ZShyZXMpXG5cbi8qKlxuICogQHRvZG8gTmV4dCB2ZXJzaW9uLCByZW9yZGVyIHBhcmFtZXRlcnM6IGNoZWNrLCBbdGltZW91dCwgW2ludGVydmFsUmVzb2x1dGlvbl1dXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpib29sZWFufSBjaGVja1xuICogQHBhcmFtIHtudW1iZXJ9IFtpbnRlcnZhbFJlc29sdXRpb25dXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3QgdW50aWwgPSAodGltZW91dCwgY2hlY2ssIGludGVydmFsUmVzb2x1dGlvbiA9IDEwKSA9PiBjcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICBjb25zdCBzdGFydFRpbWUgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgY29uc3QgaGFzVGltZW91dCA9IHRpbWVvdXQgPiAwXG4gIGNvbnN0IHVudGlsSW50ZXJ2YWwgPSAoKSA9PiB7XG4gICAgaWYgKGNoZWNrKCkpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpXG4gICAgICByZXNvbHZlKClcbiAgICB9IGVsc2UgaWYgKGhhc1RpbWVvdXQpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodGltZS5nZXRVbml4VGltZSgpIC0gc3RhcnRUaW1lID4gdGltZW91dCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKVxuICAgICAgICByZWplY3QobmV3IEVycm9yKCdUaW1lb3V0JykpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwodW50aWxJbnRlcnZhbCwgaW50ZXJ2YWxSZXNvbHV0aW9uKVxufSlcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHJldHVybiB7UHJvbWlzZTx1bmRlZmluZWQ+fVxuICovXG5leHBvcnQgY29uc3Qgd2FpdCA9IHRpbWVvdXQgPT4gY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCkpXG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhIHByb21pc2UgdXNpbmcgZHVja3R5cGluZy5cbiAqXG4gKiBQcm9taXNlcyBhcmUgb2Z0ZW4gcG9seWZpbGxlZCwgc28gaXQgbWFrZXMgc2Vuc2UgdG8gYWRkIHNvbWUgYWRkaXRpb25hbCBndWFyYW50ZWVzIGlmIHRoZSB1c2VyIG9mIHRoaXNcbiAqIGxpYnJhcnkgaGFzIHNvbWUgaW5zYW5lIGVudmlyb25tZW50IHdoZXJlIGdsb2JhbCBQcm9taXNlIG9iamVjdHMgYXJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7YW55fSBwXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNQcm9taXNlID0gcCA9PiBwIGluc3RhbmNlb2YgUHJvbWlzZSB8fCAocCAmJiBwLnRoZW4gJiYgcC5jYXRjaCAmJiBwLmZpbmFsbHkpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/promise.js\n')},"./node_modules/lib0/random.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "rand": () => (/* binding */ rand),\n/* harmony export */   "uint32": () => (/* binding */ uint32),\n/* harmony export */   "oneOf": () => (/* binding */ oneOf),\n/* harmony export */   "uuidv4": () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var _isomorphic_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isomorphic.js */ "./node_modules/isomorphic.js/browser.mjs");\n\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\n\n\n\nconst rand = Math.random\n\n/* istanbul ignore next */\nconst uint32 = () => new Uint32Array((0,_isomorphic_js__WEBPACK_IMPORTED_MODULE_0__.cryptoRandomBuffer)(4))[0]\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[_math_js__WEBPACK_IMPORTED_MODULE_1__.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzP2M4OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNtQjs7QUFFN0M7O0FBRVA7QUFDTyxxQ0FBcUMsa0VBQWtCOztBQUU5RDtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVk7QUFDWjtBQUNPLHlCQUF5QiwyQ0FBVTs7QUFFMUM7QUFDQTtBQUNPLGtFQUFrRSxPQUFPO0FBQ2hGO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9yYW5kb20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgZm9yIHRydWUgcmFuZG9tIG51bWJlcnMgLyBidWZmZXJzIC8gdXVpZHMuXG4gKlxuICogQXR0ZW50aW9uOiBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3J5cHRvLlxuICpcbiAqIEBtb2R1bGUgcmFuZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgeyBjcnlwdG9SYW5kb21CdWZmZXIgfSBmcm9tICcuL2lzb21vcnBoaWMuanMnXG5cbmV4cG9ydCBjb25zdCByYW5kID0gTWF0aC5yYW5kb21cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB1aW50MzIgPSAoKSA9PiBuZXcgVWludDMyQXJyYXkoY3J5cHRvUmFuZG9tQnVmZmVyKDQpKVswXVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBvbmVPZiA9IGFyciA9PiBhcnJbbWF0aC5mbG9vcihyYW5kKCkgKiBhcnIubGVuZ3RoKV1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdXVpZHY0VGVtcGxhdGUgPSBbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExXG5leHBvcnQgY29uc3QgdXVpZHY0ID0gKCkgPT4gdXVpZHY0VGVtcGxhdGUucmVwbGFjZSgvWzAxOF0vZywgLyoqIEBwYXJhbSB7bnVtYmVyfSBjICovIGMgPT5cbiAgKGMgXiB1aW50MzIoKSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbilcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/random.js\n')},"./node_modules/lib0/set.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "toArray": () => (/* binding */ toArray)\n/* harmony export */ });\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvc2V0LmpzPzRhYTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9zZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBTZXQoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NldDxUPn0gc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSBzZXQgPT4gQXJyYXkuZnJvbShzZXQpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/set.js\n')},"./node_modules/lib0/storage.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"varStorage\": () => (/* binding */ varStorage),\n/* harmony export */   \"onChange\": () => (/* binding */ onChange)\n/* harmony export */ });\n/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nconst varStorage = _localStorage\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvc3RvcmFnZS5qcz9jODIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsWUFBWTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQSx5REFBeUQsR0FBRztBQUM1RDtBQUNBLFdBQVcsVUFBVSxrREFBa0QsUUFBUTtBQUMvRTtBQUNBO0FBQ08sdUZBQXVGLElBQUkiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9zdG9yYWdlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIGxvY2FsU3RvcmFnZSwgYWRkRXZlbnRMaXN0ZW5lciAqL1xuXG4vKipcbiAqIElzb21vcnBoaWMgdmFyaWFibGUgc3RvcmFnZS5cbiAqXG4gKiBVc2VzIExvY2FsU3RvcmFnZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsbHMgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZS5cbiAqXG4gKiBAbW9kdWxlIHN0b3JhZ2VcbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY2xhc3MgVmFyU3RvcmFnZVBvbHlmaWxsIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWVcbiAgICovXG4gIHNldEl0ZW0gKGtleSwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLm1hcC5zZXQoa2V5LCBuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBnZXRJdGVtIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSlcbiAgfVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBAdHlwZSB7YW55fVxuICovXG5sZXQgX2xvY2FsU3RvcmFnZSA9IG5ldyBWYXJTdG9yYWdlUG9seWZpbGwoKVxubGV0IHVzZVBvbHlmaWxsID0gdHJ1ZVxuXG50cnkge1xuICAvLyBpZiB0aGUgc2FtZS1vcmlnaW4gcnVsZSBpcyB2aW9sYXRlZCwgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZSBtaWdodCB0aHJvd24gYW4gZXJyb3JcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX2xvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZVxuICAgIHVzZVBvbHlmaWxsID0gZmFsc2VcbiAgfVxufSBjYXRjaCAoZSkgeyB9XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFRoaXMgaXMgYmFzaWNhbGx5IGxvY2FsU3RvcmFnZSBpbiBicm93c2VyLCBvciBhIHBvbHlmaWxsIGluIG5vZGVqc1xuICovXG5leHBvcnQgY29uc3QgdmFyU3RvcmFnZSA9IF9sb2NhbFN0b3JhZ2VcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogQSBwb2x5ZmlsbCBmb3IgYGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCBldmVudCA9PiB7Li59KWAgdGhhdCBkb2VzIG5vdGhpbmcgaWYgdGhlIHBvbHlmaWxsIGlzIGJlaW5nIHVzZWQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih7IGtleTogc3RyaW5nLCBuZXdWYWx1ZTogc3RyaW5nLCBvbGRWYWx1ZTogc3RyaW5nIH0pOiB2b2lkfSBldmVudEhhbmRsZXJcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgb25DaGFuZ2UgPSBldmVudEhhbmRsZXIgPT4gdXNlUG9seWZpbGwgfHwgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIC8qKiBAdHlwZSB7YW55fSAqLyAoZXZlbnRIYW5kbGVyKSlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/storage.js\n")},"./node_modules/lib0/string.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "fromCharCode": () => (/* binding */ fromCharCode),\n/* harmony export */   "fromCodePoint": () => (/* binding */ fromCodePoint),\n/* harmony export */   "trimLeft": () => (/* binding */ trimLeft),\n/* harmony export */   "fromCamelCase": () => (/* binding */ fromCamelCase),\n/* harmony export */   "utf8ByteLength": () => (/* binding */ utf8ByteLength),\n/* harmony export */   "_encodeUtf8Polyfill": () => (/* binding */ _encodeUtf8Polyfill),\n/* harmony export */   "utf8TextEncoder": () => (/* binding */ utf8TextEncoder),\n/* harmony export */   "_encodeUtf8Native": () => (/* binding */ _encodeUtf8Native),\n/* harmony export */   "encodeUtf8": () => (/* binding */ encodeUtf8),\n/* harmony export */   "_decodeUtf8Polyfill": () => (/* binding */ _decodeUtf8Polyfill),\n/* harmony export */   "utf8TextDecoder": () => (/* binding */ utf8TextDecoder),\n/* harmony export */   "_decodeUtf8Native": () => (/* binding */ _decodeUtf8Native),\n/* harmony export */   "decodeUtf8": () => (/* binding */ decodeUtf8)\n/* harmony export */ });\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode\nconst fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, \'\')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== \'undefined\' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = \'\'\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nlet utf8TextDecoder = typeof TextDecoder === \'undefined\' ? null : new TextDecoder(\'utf-8\', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn\'t handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nconst decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzPzVkYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTs7QUFFUDtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ08sMkZBQTJGLFVBQVUsRUFBRSxtQkFBbUI7O0FBRWpJO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQix3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDTyxtQ0FBbUMsWUFBWTs7QUFFdEQ7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsSUFBSTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLDRGQUE0RiwrQkFBK0I7O0FBRWxJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNPLDRDQUE0QyxZQUFZOztBQUUvRDtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNPIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc3RyaW5ncy5cbiAqXG4gKiBAbW9kdWxlIHN0cmluZ1xuICovXG5cbmV4cG9ydCBjb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5leHBvcnQgY29uc3QgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9Mb3dlckNhc2UgPSBzID0+IHMudG9Mb3dlckNhc2UoKVxuXG5jb25zdCB0cmltTGVmdFJlZ2V4ID0gL15cXHMqL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdHJpbUxlZnQgPSBzID0+IHMucmVwbGFjZSh0cmltTGVmdFJlZ2V4LCAnJylcblxuY29uc3QgZnJvbUNhbWVsQ2FzZVJlZ2V4ID0gLyhbQS1aXSkvZ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VwYXJhdG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQ2FtZWxDYXNlID0gKHMsIHNlcGFyYXRvcikgPT4gdHJpbUxlZnQocy5yZXBsYWNlKGZyb21DYW1lbENhc2VSZWdleCwgbWF0Y2ggPT4gYCR7c2VwYXJhdG9yfSR7dG9Mb3dlckNhc2UobWF0Y2gpfWApKVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHV0ZjhCeXRlTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4Qnl0ZUxlbmd0aCA9IHN0ciA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkubGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpXG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSlcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBfZGVjb2RlVXRmOFBvbHlmaWxsID0gYnVmID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IGJ1Zi5sZW5ndGhcbiAgbGV0IGVuY29kZWRTdHJpbmcgPSAnJ1xuICBsZXQgYnVmUG9zID0gMFxuICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgY29uc3QgYnl0ZXMgPSBidWYuc3ViYXJyYXkoYnVmUG9zLCBidWZQb3MgKyBuZXh0TGVuKVxuICAgIGJ1ZlBvcyArPSBuZXh0TGVuXG4gICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKVxuICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuXG4gIH1cbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5leHBvcnQgbGV0IHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKHV0ZjhUZXh0RGVjb2RlciAmJiB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSkge1xuICAvLyBTYWZhcmkgZG9lc24ndCBoYW5kbGUgQk9NIGNvcnJlY3RseS5cbiAgLy8gVGhpcyBmaXhlcyBhIGJ1ZyBpbiBTYWZhcmkgMTMuMC41IHdoZXJlIGl0IHByb2R1Y2VzIGEgQk9NIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGNhbGxlZC5cbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIGZpcnN0IGNhbGwgYW5kXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBzZWNvbmQgY2FsbFxuICAvLyBBbm90aGVyIGlzc3VlIGlzIHRoYXQgZnJvbSB0aGVuIG9uIG5vIEJPTSBjaGFycyBhcmUgcmVjb2duaXplZCBhbnltb3JlXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHV0ZjhUZXh0RGVjb2RlciA9IG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhOYXRpdmUgPSBidWYgPT4gLyoqIEB0eXBlIHtUZXh0RGVjb2Rlcn0gKi8gKHV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKGJ1ZilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVV0ZjggPSB1dGY4VGV4dERlY29kZXIgPyBfZGVjb2RlVXRmOE5hdGl2ZSA6IF9kZWNvZGVVdGY4UG9seWZpbGxcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lib0/string.js\n')},"./node_modules/lib0/symbol.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "create": () => (/* binding */ create),\n/* harmony export */   "isSymbol": () => (/* binding */ isSymbol)\n/* harmony export */ });\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nconst create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === \'symbol\'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvc3ltYm9sLmpzPzVmMDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsWUFBWTtBQUNaO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC9zeW1ib2wuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBFY21hU2NyaXB0IFN5bWJvbHMuXG4gKlxuICogQG1vZHVsZSBzeW1ib2xcbiAqL1xuXG4vKipcbiAqIFJldHVybiBmcmVzaCBzeW1ib2wuXG4gKlxuICogQHJldHVybiB7U3ltYm9sfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gU3ltYm9sXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IHMgPT4gdHlwZW9mIHMgPT09ICdzeW1ib2wnXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/symbol.js\n')},"./node_modules/lib0/time.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDate\": () => (/* binding */ getDate),\n/* harmony export */   \"getUnixTime\": () => (/* binding */ getUnixTime),\n/* harmony export */   \"humanizeDuration\": () => (/* binding */ humanizeDuration)\n/* harmony export */ });\n/* harmony import */ var _metric_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metric.js */ \"./node_modules/lib0/metric.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"./node_modules/lib0/math.js\");\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10μs.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = _metric_js__WEBPACK_IMPORTED_MODULE_0__.prefix(d, -1)\n    return _math_js__WEBPACK_IMPORTED_MODULE_1__.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 60) % 60\n  const hours = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 3600) % 24\n  const days = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvdGltZS5qcz82OWE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDSjs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNPO0FBQ1A7QUFDQSxjQUFjLDhDQUFhO0FBQzNCLFdBQVcsMkNBQVU7QUFDckI7QUFDQSxNQUFNLDJDQUFVO0FBQ2hCO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLGdCQUFnQiwyQ0FBVTtBQUMxQixlQUFlLDJDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9saWIwL3RpbWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB0aW1lLlxuICpcbiAqIEBtb2R1bGUgdGltZVxuICovXG5cbmltcG9ydCAqIGFzIG1ldHJpYyBmcm9tICcuL21ldHJpYy5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuXG4vKipcbiAqIFJldHVybiBjdXJyZW50IHRpbWUuXG4gKlxuICogQHJldHVybiB7RGF0ZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldERhdGUgPSAoKSA9PiBuZXcgRGF0ZSgpXG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdW5peCB0aW1lLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFVuaXhUaW1lID0gRGF0ZS5ub3dcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGltZSAoaW4gbXMpIHRvIGEgaHVtYW4gcmVhZGFibGUgZm9ybWF0LiBFLmcuIDExMDAgPT4gMS4xcy4gNjBzID0+IDFtaW4uIC4wMDEgPT4gMTDOvHMuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGh1bWFuaXplZCBhcHByb3hpbWF0aW9uIG9mIHRpbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGh1bWFuaXplRHVyYXRpb24gPSBkID0+IHtcbiAgaWYgKGQgPCA2MDAwMCkge1xuICAgIGNvbnN0IHAgPSBtZXRyaWMucHJlZml4KGQsIC0xKVxuICAgIHJldHVybiBtYXRoLnJvdW5kKHAubiAqIDEwMCkgLyAxMDAgKyBwLnByZWZpeCArICdzJ1xuICB9XG4gIGQgPSBtYXRoLmZsb29yKGQgLyAxMDAwKVxuICBjb25zdCBzZWNvbmRzID0gZCAlIDYwXG4gIGNvbnN0IG1pbnV0ZXMgPSBtYXRoLmZsb29yKGQgLyA2MCkgJSA2MFxuICBjb25zdCBob3VycyA9IG1hdGguZmxvb3IoZCAvIDM2MDApICUgMjRcbiAgY29uc3QgZGF5cyA9IG1hdGguZmxvb3IoZCAvIDg2NDAwKVxuICBpZiAoZGF5cyA+IDApIHtcbiAgICByZXR1cm4gZGF5cyArICdkJyArICgoaG91cnMgPiAwIHx8IG1pbnV0ZXMgPiAzMCkgPyAnICcgKyAobWludXRlcyA+IDMwID8gaG91cnMgKyAxIDogaG91cnMpICsgJ2gnIDogJycpXG4gIH1cbiAgaWYgKGhvdXJzID4gMCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGhvdXJzICsgJ2gnICsgKChtaW51dGVzID4gMCB8fCBzZWNvbmRzID4gMzApID8gJyAnICsgKHNlY29uZHMgPiAzMCA/IG1pbnV0ZXMgKyAxIDogbWludXRlcykgKyAnbWluJyA6ICcnKVxuICB9XG4gIHJldHVybiBtaW51dGVzICsgJ21pbicgKyAoc2Vjb25kcyA+IDAgPyAnICcgKyBzZWNvbmRzICsgJ3MnIDogJycpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/time.js\n")},"./node_modules/lib0/url.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decodeQueryParams\": () => (/* binding */ decodeQueryParams),\n/* harmony export */   \"encodeQueryParams\": () => (/* binding */ encodeQueryParams)\n/* harmony export */ });\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object.js */ \"./node_modules/lib0/object.js\");\n/**\n * Utility module to work with urls.\n *\n * @module url\n */\n\n\n\n/**\n * Parse query parameters from an url.\n *\n * @param {string} url\n * @return {Object<string,string>}\n */\nconst decodeQueryParams = url => {\n  /**\n   * @type {Object<string,string>}\n   */\n  const query = {}\n  const urlQuerySplit = url.split('?')\n  const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&')\n  for (var i = 0; i < pairs.length; i++) {\n    const item = pairs[i]\n    if (item.length > 0) {\n      const pair = item.split('=')\n      query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '')\n    }\n  }\n  return query\n}\n\n/**\n * @param {Object<string,string>} params\n * @return {string}\n */\nconst encodeQueryParams = params =>\n  _object_js__WEBPACK_IMPORTED_MODULE_0__.map(params, (val, key) => `${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2xpYjAvdXJsLmpzP2M3NTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsWUFBWTtBQUNaO0FBQ087QUFDUCxFQUFFLDJDQUFVLDBCQUEwQix3QkFBd0IsR0FBRyx3QkFBd0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGliMC91cmwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCB1cmxzLlxuICpcbiAqIEBtb2R1bGUgdXJsXG4gKi9cblxuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJy4vb2JqZWN0LmpzJ1xuXG4vKipcbiAqIFBhcnNlIHF1ZXJ5IHBhcmFtZXRlcnMgZnJvbSBhbiB1cmwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxzdHJpbmc+fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlUXVlcnlQYXJhbXMgPSB1cmwgPT4ge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsc3RyaW5nPn1cbiAgICovXG4gIGNvbnN0IHF1ZXJ5ID0ge31cbiAgY29uc3QgdXJsUXVlcnlTcGxpdCA9IHVybC5zcGxpdCgnPycpXG4gIGNvbnN0IHBhaXJzID0gdXJsUXVlcnlTcGxpdFt1cmxRdWVyeVNwbGl0Lmxlbmd0aCAtIDFdLnNwbGl0KCcmJylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZW0gPSBwYWlyc1tpXVxuICAgIGlmIChpdGVtLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhaXIgPSBpdGVtLnNwbGl0KCc9JylcbiAgICAgIHF1ZXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSB8fCAnJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IHBhcmFtc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlUXVlcnlQYXJhbXMgPSBwYXJhbXMgPT5cbiAgb2JqZWN0Lm1hcChwYXJhbXMsICh2YWwsIGtleSkgPT4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbCl9YCkuam9pbignJicpXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lib0/url.js\n")},"./node_modules/@cocreate/cursors/src/CoCreate-cursors.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoLinkTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _file_loader_dist_cjs_js_CoCreate_cursors_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../file-loader/dist/cjs.js!./CoCreate-cursors.css */ "./node_modules/file-loader/dist/cjs.js!./node_modules/@cocreate/cursors/src/CoCreate-cursors.css");\n\n            \n\nvar options = {"injectType":"linkTag"};\n\noptions.insert = "head";\n\nvar update = _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_file_loader_dist_cjs_js_CoCreate_cursors_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL0Bjb2NyZWF0ZS9jdXJzb3JzL3NyYy9Db0NyZWF0ZS1jdXJzb3JzLmNzcz9jZTIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUY7QUFDakYsWUFBNEY7O0FBRTVGLGVBQWU7O0FBRWY7O0FBRUEsYUFBYSw0RkFBRyxDQUFDLGtGQUFPOzs7O0FBSXhCLGlFQUFlLEUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNvY3JlYXRlL2N1cnNvcnMvc3JjL0NvQ3JlYXRlLWN1cnNvcnMuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b0xpbmtUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uLy4uL2ZpbGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vQ29DcmVhdGUtY3Vyc29ycy5jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7XCJpbmplY3RUeXBlXCI6XCJsaW5rVGFnXCJ9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQge30iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@cocreate/cursors/src/CoCreate-cursors.css\n')},"./node_modules/codemirror/lib/codemirror.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoLinkTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _file_loader_dist_cjs_js_codemirror_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../file-loader/dist/cjs.js!./codemirror.css */ "./node_modules/file-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css");\n\n            \n\nvar options = {"injectType":"linkTag"};\n\noptions.insert = "head";\n\nvar update = _style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_file_loader_dist_cjs_js_codemirror_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL2NvZGVtaXJyb3IvbGliL2NvZGVtaXJyb3IuY3NzPzE0NjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4RTtBQUM5RSxZQUFtRjs7QUFFbkYsZUFBZTs7QUFFZjs7QUFFQSxhQUFhLDRGQUFHLENBQUMsNEVBQU87Ozs7QUFJeEIsaUVBQWUsRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jb2RlbWlycm9yL2xpYi9jb2RlbWlycm9yLmNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9MaW5rVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi9maWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2NvZGVtaXJyb3IuY3NzXCI7XG5cbnZhciBvcHRpb25zID0ge1wiaW5qZWN0VHlwZVwiOlwibGlua1RhZ1wifTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IHt9Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/codemirror/lib/codemirror.css\n')},"./src/css/index.css":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_file_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/file-loader/dist/cjs.js!./index.css */ "./node_modules/file-loader/dist/cjs.js!./src/css/index.css");\n\n            \n\nvar options = {"injectType":"linkTag"};\n\noptions.insert = "head";\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoLinkTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_file_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vc3JjL2Nzcy9pbmRleC5jc3M/YTI5ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJGO0FBQzNGLFlBQTJGOztBQUUzRixlQUFlOztBQUVmOztBQUVBLGFBQWEseUdBQUcsQ0FBQyxvRkFBTzs7OztBQUl4QixpRUFBZSxFIiwiZmlsZSI6Ii4vc3JjL2Nzcy9pbmRleC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b0xpbmtUYWcuanNcIjtcbiAgICAgICAgICAgIGltcG9ydCBjb250ZW50IGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9maWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4LmNzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHtcImluamVjdFR5cGVcIjpcImxpbmtUYWdcIn07XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCB7fSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/css/index.css\n')},"./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nmodule.exports = function (url, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {};\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  var link = document.createElement('link');\n  link.rel = 'stylesheet';\n  link.href = url;\n  Object.keys(options.attributes).forEach(function (key) {\n    link.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(link);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(link);\n  }\n\n  return function (newUrl) {\n    if (typeof newUrl === 'string') {\n      link.href = newUrl;\n    } else {\n      link.parentNode.removeChild(link);\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b0xpbmtUYWcuanM/Njc0ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b0xpbmtUYWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMuYXR0cmlidXRlcyA9IHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMgPT09ICdvYmplY3QnID8gb3B0aW9ucy5hdHRyaWJ1dGVzIDoge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gIGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuICBsaW5rLmhyZWYgPSB1cmw7XG4gIE9iamVjdC5rZXlzKG9wdGlvbnMuYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChsaW5rKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG5ld1VybCkge1xuICAgIGlmICh0eXBlb2YgbmV3VXJsID09PSAnc3RyaW5nJykge1xuICAgICAgbGluay5ocmVmID0gbmV3VXJsO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxuICB9O1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/runtime/injectStylesIntoLinkTag.js\n")},"./node_modules/y-indexeddb/src/y-indexeddb.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PREFERRED_TRIM_SIZE\": () => (/* binding */ PREFERRED_TRIM_SIZE),\n/* harmony export */   \"fetchUpdates\": () => (/* binding */ fetchUpdates),\n/* harmony export */   \"storeState\": () => (/* binding */ storeState),\n/* harmony export */   \"clearDocument\": () => (/* binding */ clearDocument),\n/* harmony export */   \"IndexeddbPersistence\": () => (/* binding */ IndexeddbPersistence)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/indexeddb.js */ \"./node_modules/lib0/indexeddb.js\");\n/* harmony import */ var lib0_mutex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/mutex.js */ \"./node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/observable.js */ \"./node_modules/lib0/observable.js\");\n\n\n\n\n\nconst customStoreName = 'custom'\nconst updatesStoreName = 'updates'\n\nconst PREFERRED_TRIM_SIZE = 500\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n */\nconst fetchUpdates = idbPersistence => {\n  const [updatesStore] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(/** @type {IDBDatabase} */ (idbPersistence.db), [updatesStoreName]) // , 'readonly')\n  return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.getAll(updatesStore, lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then(updates =>\n    idbPersistence._mux(() =>\n      idbPersistence.doc.transact(() =>\n        updates.forEach(val => yjs__WEBPACK_IMPORTED_MODULE_1__.applyUpdate(idbPersistence.doc, val))\n      )\n    )\n  )\n    .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.getLastKey(updatesStore).then(lastKey => { idbPersistence._dbref = lastKey + 1 }))\n    .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n    .then(() => updatesStore)\n}\n\n/**\n * @param {IndexeddbPersistence} idbPersistence\n * @param {boolean} forceStore\n */\nconst storeState = (idbPersistence, forceStore = true) =>\n  fetchUpdates(idbPersistence)\n    .then(updatesStore => {\n      if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {\n        lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(idbPersistence.doc))\n          .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.del(updatesStore, lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createIDBKeyRangeUpperBound(idbPersistence._dbref, true)))\n          .then(() => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.count(updatesStore).then(cnt => { idbPersistence._dbsize = cnt }))\n      }\n    })\n\n/**\n * @param {string} name\n */\nconst clearDocument = name => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.deleteDB(name)\n\n/**\n * @extends Observable<string>\n */\nclass IndexeddbPersistence extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_2__.Observable {\n  /**\n   * @param {string} name\n   * @param {Y.Doc} doc\n   */\n  constructor (name, doc) {\n    super()\n    this.doc = doc\n    this.name = name\n    this._mux = lib0_mutex_js__WEBPACK_IMPORTED_MODULE_3__.createMutex()\n    this._dbref = 0\n    this._dbsize = 0\n    /**\n     * @type {IDBDatabase|null}\n     */\n    this.db = null\n    this.synced = false\n    this._db = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.openDB(name, db =>\n      lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.createStores(db, [\n        ['updates', { autoIncrement: true }],\n        ['custom']\n      ])\n    )\n    /**\n     * @type {Promise<IndexeddbPersistence>}\n     */\n    this.whenSynced = this._db.then(db => {\n      this.db = db\n      const currState = yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(doc)\n      return fetchUpdates(this).then(updatesStore => lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, currState)).then(() => {\n        this.emit('synced', [this])\n        this.synced = true\n        return this\n      })\n    })\n    /**\n     * Timeout in ms untill data is merged and persisted in idb.\n     */\n    this._storeTimeout = 1000\n    /**\n     * @type {any}\n     */\n    this._storeTimeoutId = null\n    /**\n     * @param {Uint8Array} update\n     */\n    this._storeUpdate = update =>\n      this._mux(() => {\n        if (this.db) {\n          const [updatesStore] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(/** @type {IDBDatabase} */ (this.db), [updatesStoreName])\n          lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.addAutoKey(updatesStore, update)\n          if (++this._dbsize >= PREFERRED_TRIM_SIZE) {\n            // debounce store call\n            if (this._storeTimeoutId !== null) {\n              clearTimeout(this._storeTimeoutId)\n            }\n            this._storeTimeoutId = setTimeout(() => {\n              storeState(this, false)\n              this._storeTimeoutId = null\n            }, this._storeTimeout)\n          }\n        }\n      })\n    doc.on('update', this._storeUpdate)\n    this.destroy = this.destroy.bind(this)\n    doc.on('destroy', this.destroy)\n  }\n\n  destroy () {\n    if (this._storeTimeoutId) {\n      clearTimeout(this._storeTimeoutId)\n    }\n    this.doc.off('update', this._storeUpdate)\n    this.doc.off('destroy', this.destroy)\n    return this._db.then(db => {\n      db.close()\n    })\n  }\n\n  /**\n   * Destroys this instance and removes all data from indexeddb.\n   *\n   * @return {Promise<void>}\n   */\n  clearData () {\n    return this.destroy().then(() => {\n      lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.deleteDB(this.name)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<String | number | ArrayBuffer | Date | any>}\n   */\n  get (key) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName], 'readonly')\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.get(custom, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @param {String | number | ArrayBuffer | Date} value\n   * @return {Promise<String | number | ArrayBuffer | Date>}\n   */\n  set (key, value) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName])\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.put(custom, value, key)\n    })\n  }\n\n  /**\n   * @param {String | number | ArrayBuffer | Date} key\n   * @return {Promise<undefined>}\n   */\n  del (key) {\n    return this._db.then(db => {\n      const [custom] = lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.transact(db, [customStoreName])\n      return lib0_indexeddb_js__WEBPACK_IMPORTED_MODULE_0__.del(custom, key)\n    })\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3ktaW5kZXhlZGRiL3NyYy95LWluZGV4ZWRkYi5qcz84M2NlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNnQjtBQUNGO0FBQ1M7O0FBRS9DO0FBQ0E7O0FBRU87O0FBRVA7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNPO0FBQ1AseUJBQXlCLHVEQUFZLFlBQVksWUFBWTtBQUM3RCxTQUFTLHFEQUFVLGVBQWUsMEVBQStCO0FBQ2pFO0FBQ0E7QUFDQSwrQkFBK0IsNENBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFjLGdDQUFnQyxzQ0FBc0M7QUFDcEcsZ0JBQWdCLG9EQUFTLDRCQUE0QiwrQkFBK0I7QUFDcEY7QUFDQTs7QUFFQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYyxlQUFlLG9EQUFxQjtBQUMxRCxzQkFBc0Isa0RBQU8sZUFBZSwwRUFBK0I7QUFDM0Usc0JBQXNCLG9EQUFTLDRCQUE0QiwrQkFBK0I7QUFDMUY7QUFDQSxLQUFLOztBQUVMO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ08sOEJBQThCLHVEQUFZOztBQUVqRDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsMERBQVU7QUFDcEQ7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFVO0FBQ3pCLE1BQU0sMkRBQWdCO0FBQ3RCLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9EQUFxQjtBQUM3QyxxREFBcUQseURBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBWSxZQUFZLFlBQVk7QUFDckUsVUFBVSx5REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBWTtBQUNsQixLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLHFDQUFxQztBQUNsRCxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUFZO0FBQ25DLGFBQWEsa0RBQU87QUFDcEIsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQsYUFBYSxxQ0FBcUM7QUFDbEQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBWTtBQUNuQyxhQUFhLGtEQUFPO0FBQ3BCLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEscUNBQXFDO0FBQ2xELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQVk7QUFDbkMsYUFBYSxrREFBTztBQUNwQixLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy95LWluZGV4ZWRkYi9zcmMveS1pbmRleGVkZGIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCAqIGFzIGlkYiBmcm9tICdsaWIwL2luZGV4ZWRkYi5qcydcbmltcG9ydCAqIGFzIG11dGV4IGZyb20gJ2xpYjAvbXV0ZXguanMnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJ1xuXG5jb25zdCBjdXN0b21TdG9yZU5hbWUgPSAnY3VzdG9tJ1xuY29uc3QgdXBkYXRlc1N0b3JlTmFtZSA9ICd1cGRhdGVzJ1xuXG5leHBvcnQgY29uc3QgUFJFRkVSUkVEX1RSSU1fU0laRSA9IDUwMFxuXG4vKipcbiAqIEBwYXJhbSB7SW5kZXhlZGRiUGVyc2lzdGVuY2V9IGlkYlBlcnNpc3RlbmNlXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFVwZGF0ZXMgPSBpZGJQZXJzaXN0ZW5jZSA9PiB7XG4gIGNvbnN0IFt1cGRhdGVzU3RvcmVdID0gaWRiLnRyYW5zYWN0KC8qKiBAdHlwZSB7SURCRGF0YWJhc2V9ICovIChpZGJQZXJzaXN0ZW5jZS5kYiksIFt1cGRhdGVzU3RvcmVOYW1lXSkgLy8gLCAncmVhZG9ubHknKVxuICByZXR1cm4gaWRiLmdldEFsbCh1cGRhdGVzU3RvcmUsIGlkYi5jcmVhdGVJREJLZXlSYW5nZUxvd2VyQm91bmQoaWRiUGVyc2lzdGVuY2UuX2RicmVmLCBmYWxzZSkpLnRoZW4odXBkYXRlcyA9PlxuICAgIGlkYlBlcnNpc3RlbmNlLl9tdXgoKCkgPT5cbiAgICAgIGlkYlBlcnNpc3RlbmNlLmRvYy50cmFuc2FjdCgoKSA9PlxuICAgICAgICB1cGRhdGVzLmZvckVhY2godmFsID0+IFkuYXBwbHlVcGRhdGUoaWRiUGVyc2lzdGVuY2UuZG9jLCB2YWwpKVxuICAgICAgKVxuICAgIClcbiAgKVxuICAgIC50aGVuKCgpID0+IGlkYi5nZXRMYXN0S2V5KHVwZGF0ZXNTdG9yZSkudGhlbihsYXN0S2V5ID0+IHsgaWRiUGVyc2lzdGVuY2UuX2RicmVmID0gbGFzdEtleSArIDEgfSkpXG4gICAgLnRoZW4oKCkgPT4gaWRiLmNvdW50KHVwZGF0ZXNTdG9yZSkudGhlbihjbnQgPT4geyBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID0gY250IH0pKVxuICAgIC50aGVuKCgpID0+IHVwZGF0ZXNTdG9yZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0luZGV4ZWRkYlBlcnNpc3RlbmNlfSBpZGJQZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtib29sZWFufSBmb3JjZVN0b3JlXG4gKi9cbmV4cG9ydCBjb25zdCBzdG9yZVN0YXRlID0gKGlkYlBlcnNpc3RlbmNlLCBmb3JjZVN0b3JlID0gdHJ1ZSkgPT5cbiAgZmV0Y2hVcGRhdGVzKGlkYlBlcnNpc3RlbmNlKVxuICAgIC50aGVuKHVwZGF0ZXNTdG9yZSA9PiB7XG4gICAgICBpZiAoZm9yY2VTdG9yZSB8fCBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID49IFBSRUZFUlJFRF9UUklNX1NJWkUpIHtcbiAgICAgICAgaWRiLmFkZEF1dG9LZXkodXBkYXRlc1N0b3JlLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoaWRiUGVyc2lzdGVuY2UuZG9jKSlcbiAgICAgICAgICAudGhlbigoKSA9PiBpZGIuZGVsKHVwZGF0ZXNTdG9yZSwgaWRiLmNyZWF0ZUlEQktleVJhbmdlVXBwZXJCb3VuZChpZGJQZXJzaXN0ZW5jZS5fZGJyZWYsIHRydWUpKSlcbiAgICAgICAgICAudGhlbigoKSA9PiBpZGIuY291bnQodXBkYXRlc1N0b3JlKS50aGVuKGNudCA9PiB7IGlkYlBlcnNpc3RlbmNlLl9kYnNpemUgPSBjbnQgfSkpXG4gICAgICB9XG4gICAgfSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5leHBvcnQgY29uc3QgY2xlYXJEb2N1bWVudCA9IG5hbWUgPT4gaWRiLmRlbGV0ZURCKG5hbWUpXG5cbi8qKlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmRleGVkZGJQZXJzaXN0ZW5jZSBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuX211eCA9IG11dGV4LmNyZWF0ZU11dGV4KClcbiAgICB0aGlzLl9kYnJlZiA9IDBcbiAgICB0aGlzLl9kYnNpemUgPSAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEQkRhdGFiYXNlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kYiA9IG51bGxcbiAgICB0aGlzLnN5bmNlZCA9IGZhbHNlXG4gICAgdGhpcy5fZGIgPSBpZGIub3BlbkRCKG5hbWUsIGRiID0+XG4gICAgICBpZGIuY3JlYXRlU3RvcmVzKGRiLCBbXG4gICAgICAgIFsndXBkYXRlcycsIHsgYXV0b0luY3JlbWVudDogdHJ1ZSB9XSxcbiAgICAgICAgWydjdXN0b20nXVxuICAgICAgXSlcbiAgICApXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8SW5kZXhlZGRiUGVyc2lzdGVuY2U+fVxuICAgICAqL1xuICAgIHRoaXMud2hlblN5bmNlZCA9IHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgdGhpcy5kYiA9IGRiXG4gICAgICBjb25zdCBjdXJyU3RhdGUgPSBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jKVxuICAgICAgcmV0dXJuIGZldGNoVXBkYXRlcyh0aGlzKS50aGVuKHVwZGF0ZXNTdG9yZSA9PiBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIGN1cnJTdGF0ZSkpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIFt0aGlzXSlcbiAgICAgICAgdGhpcy5zeW5jZWQgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9KVxuICAgIH0pXG4gICAgLyoqXG4gICAgICogVGltZW91dCBpbiBtcyB1bnRpbGwgZGF0YSBpcyBtZXJnZWQgYW5kIHBlcnNpc3RlZCBpbiBpZGIuXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVUaW1lb3V0ID0gMTAwMFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVUaW1lb3V0SWQgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZVVwZGF0ZSA9IHVwZGF0ZSA9PlxuICAgICAgdGhpcy5fbXV4KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGIpIHtcbiAgICAgICAgICBjb25zdCBbdXBkYXRlc1N0b3JlXSA9IGlkYi50cmFuc2FjdCgvKiogQHR5cGUge0lEQkRhdGFiYXNlfSAqLyAodGhpcy5kYiksIFt1cGRhdGVzU3RvcmVOYW1lXSlcbiAgICAgICAgICBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIHVwZGF0ZSlcbiAgICAgICAgICBpZiAoKyt0aGlzLl9kYnNpemUgPj0gUFJFRkVSUkVEX1RSSU1fU0laRSkge1xuICAgICAgICAgICAgLy8gZGVib3VuY2Ugc3RvcmUgY2FsbFxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3JlVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdG9yZVRpbWVvdXRJZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHN0b3JlU3RhdGUodGhpcywgZmFsc2UpXG4gICAgICAgICAgICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gbnVsbFxuICAgICAgICAgICAgfSwgdGhpcy5fc3RvcmVUaW1lb3V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBkb2Mub24oJ3VwZGF0ZScsIHRoaXMuX3N0b3JlVXBkYXRlKVxuICAgIHRoaXMuZGVzdHJveSA9IHRoaXMuZGVzdHJveS5iaW5kKHRoaXMpXG4gICAgZG9jLm9uKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcmVUaW1lb3V0SWQpXG4gICAgfVxuICAgIHRoaXMuZG9jLm9mZigndXBkYXRlJywgdGhpcy5fc3RvcmVVcGRhdGUpXG4gICAgdGhpcy5kb2Mub2ZmKCdkZXN0cm95JywgdGhpcy5kZXN0cm95KVxuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGRiLmNsb3NlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgaW5zdGFuY2UgYW5kIHJlbW92ZXMgYWxsIGRhdGEgZnJvbSBpbmRleGVkZGIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBjbGVhckRhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKS50aGVuKCgpID0+IHtcbiAgICAgIGlkYi5kZWxldGVEQih0aGlzLm5hbWUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYW55Pn1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdLCAncmVhZG9ubHknKVxuICAgICAgcmV0dXJuIGlkYi5nZXQoY3VzdG9tLCBrZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZT59XG4gICAqL1xuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBjb25zdCBbY3VzdG9tXSA9IGlkYi50cmFuc2FjdChkYiwgW2N1c3RvbVN0b3JlTmFtZV0pXG4gICAgICByZXR1cm4gaWRiLnB1dChjdXN0b20sIHZhbHVlLCBrZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEByZXR1cm4ge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICovXG4gIGRlbCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdKVxuICAgICAgcmV0dXJuIGlkYi5kZWwoY3VzdG9tLCBrZXkpXG4gICAgfSlcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/y-indexeddb/src/y-indexeddb.js\n")},"./node_modules/y-protocols/auth.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "messagePermissionDenied": () => (/* binding */ messagePermissionDenied),\n/* harmony export */   "writePermissionDenied": () => (/* binding */ writePermissionDenied),\n/* harmony export */   "readAuthMessage": () => (/* binding */ readAuthMessage)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/decoding.js */ "./node_modules/lib0/decoding.js");\n\n // eslint-disable-line\n\n\n\nconst messagePermissionDenied = 0\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {string} reason\n */\nconst writePermissionDenied = (encoder, reason) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messagePermissionDenied)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarString(encoder, reason)\n}\n\n/**\n * @callback PermissionDeniedHandler\n * @param {any} y\n * @param {string} reason\n */\n\n/**\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} y\n * @param {PermissionDeniedHandler} permissionDeniedHandler\n */\nconst readAuthMessage = (decoder, y, permissionDeniedHandler) => {\n  switch (lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__.readVarUint(decoder)) {\n    case messagePermissionDenied: permissionDeniedHandler(y, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_1__.readVarString(decoder))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F1dGguanM/NmRkZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDd0I7QUFDb0I7QUFDQTs7QUFFckM7O0FBRVA7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE9BQU87QUFDbEI7QUFDTztBQUNQLEVBQUUsMERBQXFCO0FBQ3ZCLEVBQUUsNERBQXVCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLElBQUk7QUFDZixXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLHdCQUF3QjtBQUNuQztBQUNPO0FBQ1AsVUFBVSx5REFBb0I7QUFDOUIsNkRBQTZELDJEQUFzQjtBQUNuRjtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F1dGguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZy5qcydcblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkID0gMFxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVQZXJtaXNzaW9uRGVuaWVkID0gKGVuY29kZXIsIHJlYXNvbikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVBlcm1pc3Npb25EZW5pZWQpXG4gIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHJlYXNvbilcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgUGVybWlzc2lvbkRlbmllZEhhbmRsZXJcbiAqIEBwYXJhbSB7YW55fSB5XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gKi9cblxuLyoqXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSB5XG4gKiBAcGFyYW0ge1Blcm1pc3Npb25EZW5pZWRIYW5kbGVyfSBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEF1dGhNZXNzYWdlID0gKGRlY29kZXIsIHksIHBlcm1pc3Npb25EZW5pZWRIYW5kbGVyKSA9PiB7XG4gIHN3aXRjaCAoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICBjYXNlIG1lc3NhZ2VQZXJtaXNzaW9uRGVuaWVkOiBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlcih5LCBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/y-protocols/auth.js\n')},"./node_modules/y-protocols/awareness.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "outdatedTimeout": () => (/* binding */ outdatedTimeout),\n/* harmony export */   "Awareness": () => (/* binding */ Awareness),\n/* harmony export */   "removeAwarenessStates": () => (/* binding */ removeAwarenessStates),\n/* harmony export */   "encodeAwarenessUpdate": () => (/* binding */ encodeAwarenessUpdate),\n/* harmony export */   "modifyAwarenessUpdate": () => (/* binding */ modifyAwarenessUpdate),\n/* harmony export */   "applyAwarenessUpdate": () => (/* binding */ applyAwarenessUpdate)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding.js */ "./node_modules/lib0/decoding.js");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/time.js */ "./node_modules/lib0/time.js");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/math.js */ "./node_modules/lib0/math.js");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable.js */ "./node_modules/lib0/observable.js");\n/* harmony import */ var lib0_function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/function.js */ "./node_modules/lib0/function.js");\n/**\n * @module awareness-protocol\n */\n\n\n\n\n\n\n\n // eslint-disable-line\n\nconst outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, \'timeout\')\n      }\n    }, lib0_math_js__WEBPACK_IMPORTED_MODULE_2__.floor(outdatedTimeout / 10)))\n    doc.on(\'destroy\', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit(\'destroy\', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!lib0_function_js__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit(\'change\', [{ added, updated: filteredUpdated, removed }, \'local\'])\n    }\n    this.emit(\'update\', [{ added, updated, removed }, \'local\'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      state[field] = value\n      this.setLocalState(state)\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit(\'change\', [{ added: [], updated: [], removed }, origin])\n    awareness.emit(\'update\', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(state))\n  }\n  return lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nconst modifyAwarenessUpdate = (update, modify) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  const len = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const clock = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const modifiedState = modify(state)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const timestamp = lib0_time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    let clock = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!lib0_function_js__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit(\'change\', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit(\'update\', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcz9mMjQ4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFNEM7QUFDQTtBQUNSO0FBQ0E7QUFDVztBQUNWO0FBQ2I7O0FBRWpCOztBQUVQO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrREFBK0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ08sd0JBQXdCLDBEQUFVO0FBQ3pDO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxxQ0FBcUMsSUFBSTtBQUN6QyxrQkFBa0IscURBQWdCO0FBQ2xDLHFGQUFxRixvQkFBb0I7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSwrQ0FBVTtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFnQjtBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVcsMERBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsY0FBYztBQUN6QixXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0EsdUJBQXVCLHFEQUFnQjtBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQ0FBa0M7QUFDakUsK0JBQStCLGtDQUFrQztBQUNqRTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLDJEQUFzQjtBQUN4QyxFQUFFLDBEQUFxQjtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QyxJQUFJLDBEQUFxQjtBQUN6QixJQUFJLDBEQUFxQjtBQUN6QixJQUFJLDREQUF1QjtBQUMzQjtBQUNBLFNBQVMsMERBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLGtCQUFrQjtBQUM3QixZQUFZO0FBQ1o7QUFDTztBQUNQLGtCQUFrQiwyREFBc0I7QUFDeEMsa0JBQWtCLDJEQUFzQjtBQUN4QyxjQUFjLHlEQUFvQjtBQUNsQyxFQUFFLDBEQUFxQjtBQUN2QixpQkFBaUIsU0FBUztBQUMxQixxQkFBcUIseURBQW9CO0FBQ3pDLGtCQUFrQix5REFBb0I7QUFDdEMsNkJBQTZCLDJEQUFzQjtBQUNuRDtBQUNBLElBQUksMERBQXFCO0FBQ3pCLElBQUksMERBQXFCO0FBQ3pCLElBQUksNERBQXVCO0FBQzNCO0FBQ0EsU0FBUywwREFBcUI7QUFDOUI7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUCxrQkFBa0IsMkRBQXNCO0FBQ3hDLG9CQUFvQixxREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFvQjtBQUNsQyxpQkFBaUIsU0FBUztBQUMxQixxQkFBcUIseURBQW9CO0FBQ3pDLGdCQUFnQix5REFBb0I7QUFDcEMsNkJBQTZCLDJEQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxhQUFhLDBEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBhd2FyZW5lc3MtcHJvdG9jb2xcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nLmpzJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZy5qcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGguanMnXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlLmpzJ1xuaW1wb3J0ICogYXMgZiBmcm9tICdsaWIwL2Z1bmN0aW9uLmpzJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuZXhwb3J0IGNvbnN0IG91dGRhdGVkVGltZW91dCA9IDMwMDAwXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTWV0YUNsaWVudFN0YXRlXG4gKiBAcHJvcGVydHkge251bWJlcn0gTWV0YUNsaWVudFN0YXRlLmNsb2NrXG4gKiBAcHJvcGVydHkge251bWJlcn0gTWV0YUNsaWVudFN0YXRlLmxhc3RVcGRhdGVkIHVuaXggdGltZXN0YW1wXG4gKi9cblxuLyoqXG4gKiBUaGUgQXdhcmVuZXNzIGNsYXNzIGltcGxlbWVudHMgYSBzaW1wbGUgc2hhcmVkIHN0YXRlIHByb3RvY29sIHRoYXQgY2FuIGJlIHVzZWQgZm9yIG5vbi1wZXJzaXN0ZW50IGRhdGEgbGlrZSBhd2FyZW5lc3MgaW5mb3JtYXRpb25cbiAqIChjdXJzb3IsIHVzZXJuYW1lLCBzdGF0dXMsIC4uKS4gRWFjaCBjbGllbnQgY2FuIHVwZGF0ZSBpdHMgb3duIGxvY2FsIHN0YXRlIGFuZCBsaXN0ZW4gdG8gc3RhdGUgY2hhbmdlcyBvZlxuICogcmVtb3RlIGNsaWVudHMuIEV2ZXJ5IGNsaWVudCBtYXkgc2V0IGEgc3RhdGUgb2YgYSByZW1vdGUgcGVlciB0byBgbnVsbGAgdG8gbWFyayB0aGUgY2xpZW50IGFzIG9mZmxpbmUuXG4gKlxuICogRWFjaCBjbGllbnQgaXMgaWRlbnRpZmllZCBieSBhIHVuaXF1ZSBjbGllbnQgaWQgKHNvbWV0aGluZyB3ZSBib3Jyb3cgZnJvbSBgZG9jLmNsaWVudElEYCkuIEEgY2xpZW50IGNhbiBvdmVycmlkZVxuICogaXRzIG93biBzdGF0ZSBieSBwcm9wYWdhdGluZyBhIG1lc3NhZ2Ugd2l0aCBhbiBpbmNyZWFzaW5nIHRpbWVzdGFtcCAoYGNsb2NrYCkuIElmIHN1Y2ggYSBtZXNzYWdlIGlzIHJlY2VpdmVkLCBpdCBpc1xuICogYXBwbGllZCBpZiB0aGUga25vd24gc3RhdGUgb2YgdGhhdCBjbGllbnQgaXMgb2xkZXIgdGhhbiB0aGUgbmV3IHN0YXRlIChgY2xvY2sgPCBuZXdDbG9ja2ApLiBJZiBhIGNsaWVudCB0aGlua3MgdGhhdFxuICogYSByZW1vdGUgY2xpZW50IGlzIG9mZmxpbmUsIGl0IG1heSBwcm9wYWdhdGUgYSBtZXNzYWdlIHdpdGhcbiAqIGB7IGNsb2NrOiBjdXJyZW50Q2xpZW50Q2xvY2ssIHN0YXRlOiBudWxsLCBjbGllbnQ6IHJlbW90ZUNsaWVudCB9YC4gSWYgc3VjaCBhXG4gKiBtZXNzYWdlIGlzIHJlY2VpdmVkLCBhbmQgdGhlIGtub3duIGNsb2NrIG9mIHRoYXQgY2xpZW50IGVxdWFscyB0aGUgcmVjZWl2ZWQgY2xvY2ssIGl0IHdpbGwgb3ZlcnJpZGUgdGhlIHN0YXRlIHdpdGggYG51bGxgLlxuICpcbiAqIEJlZm9yZSBhIGNsaWVudCBkaXNjb25uZWN0cywgaXQgc2hvdWxkIHByb3BhZ2F0ZSBhIGBudWxsYCBzdGF0ZSB3aXRoIGFuIHVwZGF0ZWQgY2xvY2suXG4gKlxuICogQXdhcmVuZXNzIHN0YXRlcyBtdXN0IGJlIHVwZGF0ZWQgZXZlcnkgMzAgc2Vjb25kcy4gT3RoZXJ3aXNlIHRoZSBBd2FyZW5lc3MgaW5zdGFuY2Ugd2lsbCBkZWxldGUgdGhlIGNsaWVudCBzdGF0ZS5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxzdHJpbmc+fVxuICovXG5leHBvcnQgY2xhc3MgQXdhcmVuZXNzIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50SUQgPSBkb2MuY2xpZW50SURcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50IGlkIHRvIGNsaWVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBPYmplY3Q8c3RyaW5nLCBhbnk+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBNZXRhQ2xpZW50U3RhdGU+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgaWYgKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpICE9PSBudWxsICYmIChvdXRkYXRlZFRpbWVvdXQgLyAyIDw9IG5vdyAtIC8qKiBAdHlwZSB7e2xhc3RVcGRhdGVkOm51bWJlcn19ICovICh0aGlzLm1ldGEuZ2V0KHRoaXMuY2xpZW50SUQpKS5sYXN0VXBkYXRlZCkpIHtcbiAgICAgICAgLy8gcmVuZXcgbG9jYWwgY2xvY2tcbiAgICAgICAgdGhpcy5zZXRMb2NhbFN0YXRlKHRoaXMuZ2V0TG9jYWxTdGF0ZSgpKVxuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVtb3ZlID0gW11cbiAgICAgIHRoaXMubWV0YS5mb3JFYWNoKChtZXRhLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICBpZiAoY2xpZW50aWQgIT09IHRoaXMuY2xpZW50SUQgJiYgb3V0ZGF0ZWRUaW1lb3V0IDw9IG5vdyAtIG1ldGEubGFzdFVwZGF0ZWQgJiYgdGhpcy5zdGF0ZXMuaGFzKGNsaWVudGlkKSkge1xuICAgICAgICAgIHJlbW92ZS5wdXNoKGNsaWVudGlkKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYgKHJlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlbW92ZUF3YXJlbmVzc1N0YXRlcyh0aGlzLCByZW1vdmUsICd0aW1lb3V0JylcbiAgICAgIH1cbiAgICB9LCBtYXRoLmZsb29yKG91dGRhdGVkVGltZW91dCAvIDEwKSkpXG4gICAgZG9jLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgdGhpcy5kZXN0cm95KClcbiAgICB9KVxuICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh7fSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIFt0aGlzXSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUobnVsbClcbiAgICBzdXBlci5kZXN0cm95KClcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2NoZWNrSW50ZXJ2YWwpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bGx9XG4gICAqL1xuICBnZXRMb2NhbFN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXMuZ2V0KHRoaXMuY2xpZW50SUQpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfSBzdGF0ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZSAoc3RhdGUpIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IHRoaXMuY2xpZW50SURcbiAgICBjb25zdCBjdXJyTG9jYWxNZXRhID0gdGhpcy5tZXRhLmdldChjbGllbnRJRClcbiAgICBjb25zdCBjbG9jayA9IGN1cnJMb2NhbE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjdXJyTG9jYWxNZXRhLmNsb2NrICsgMVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGVzLmdldChjbGllbnRJRClcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZXMuc2V0KGNsaWVudElELCBzdGF0ZSlcbiAgICB9XG4gICAgdGhpcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgY2xvY2ssXG4gICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgfSlcbiAgICBjb25zdCBhZGRlZCA9IFtdXG4gICAgY29uc3QgdXBkYXRlZCA9IFtdXG4gICAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgICBjb25zdCByZW1vdmVkID0gW11cbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJlbW92ZWQucHVzaChjbGllbnRJRClcbiAgICB9IGVsc2UgaWYgKHByZXZTdGF0ZSA9PSBudWxsKSB7XG4gICAgICBpZiAoc3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBhZGRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICBpZiAoIWYuZXF1YWxpdHlEZWVwKHByZXZTdGF0ZSwgc3RhdGUpKSB7XG4gICAgICAgIGZpbHRlcmVkVXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCB8fCBmaWx0ZXJlZFVwZGF0ZWQubGVuZ3RoID4gMCB8fCByZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSlcbiAgICB9XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCAnbG9jYWwnXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmllbGRcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBzZXRMb2NhbFN0YXRlRmllbGQgKGZpZWxkLCB2YWx1ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRMb2NhbFN0YXRlKClcbiAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHN0YXRlW2ZpZWxkXSA9IHZhbHVlXG4gICAgICB0aGlzLnNldExvY2FsU3RhdGUoc3RhdGUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzID0gKGF3YXJlbmVzcywgY2xpZW50cywgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBpZiAoYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgIGNvbnN0IGN1ck1ldGEgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpXG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBzdGF0ZXMgPSBhd2FyZW5lc3Muc3RhdGVzKSA9PiB7XG4gIGNvbnN0IGxlbiA9IGNsaWVudHMubGVuZ3RoXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbFxuICAgIGNvbnN0IGNsb2NrID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKS5jbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvbnRlbnQgb2YgYW4gYXdhcmVuZXNzIHVwZGF0ZSBiZWZvcmUgcmUtZW5jb2RpbmcgaXQgdG8gYW4gYXdhcmVuZXNzIHVwZGF0ZS5cbiAqXG4gKiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGEgY2VudHJhbCBzZXJ2ZXIgdGhhdCB3YW50cyB0byBlbnN1cmUgdGhhdCBjbGllbnRzXG4gKiBjYW50IGhpamFjayBzb21lYm9keSBlbHNlcyBpZGVudGl0eS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gbW9kaWZ5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5QXdhcmVuZXNzVXBkYXRlID0gKHVwZGF0ZSwgbW9kaWZ5KSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBtb2RpZmllZFN0YXRlID0gbW9kaWZ5KHN0YXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkobW9kaWZpZWRTdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW1pdHRlZCBjaGFuZ2UgZXZlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgY29uc3QgYWRkZWQgPSBbXVxuICBjb25zdCB1cGRhdGVkID0gW11cbiAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBjbGllbnRNZXRhID0gYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGN1cnJDbG9jayA9IGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjbGllbnRNZXRhLmNsb2NrXG4gICAgaWYgKGN1cnJDbG9jayA8IGNsb2NrIHx8IChjdXJyQ2xvY2sgPT09IGNsb2NrICYmIHN0YXRlID09PSBudWxsICYmIGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBuZXZlciBsZXQgYSByZW1vdGUgY2xpZW50IHJlbW92ZSB0aGlzIGxvY2FsIHN0YXRlXG4gICAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEICYmIGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW90ZSBjbGllbnQgcmVtb3ZlZCB0aGUgbG9jYWwgc3RhdGUuIERvIG5vdCByZW1vdGUgc3RhdGUuIEJyb2FkY2FzdCBhIG1lc3NhZ2UgaW5kaWNhdGluZ1xuICAgICAgICAgIC8vIHRoYXQgdGhpcyBjbGllbnQgc3RpbGwgZXhpc3RzIGJ5IGluY3JlYXNpbmcgdGhlIGNsb2NrXG4gICAgICAgICAgY2xvY2srK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgICB9XG4gICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgY2xvY2ssXG4gICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lc3RhbXBcbiAgICAgIH0pXG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudE1ldGEgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZi5lcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/y-protocols/awareness.js\n')},"./node_modules/y-protocols/sync.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "messageYjsSyncStep1": () => (/* binding */ messageYjsSyncStep1),\n/* harmony export */   "messageYjsSyncStep2": () => (/* binding */ messageYjsSyncStep2),\n/* harmony export */   "messageYjsUpdate": () => (/* binding */ messageYjsUpdate),\n/* harmony export */   "writeSyncStep1": () => (/* binding */ writeSyncStep1),\n/* harmony export */   "writeSyncStep2": () => (/* binding */ writeSyncStep2),\n/* harmony export */   "readSyncStep1": () => (/* binding */ readSyncStep1),\n/* harmony export */   "readSyncStep2": () => (/* binding */ readSyncStep2),\n/* harmony export */   "writeUpdate": () => (/* binding */ writeUpdate),\n/* harmony export */   "readUpdate": () => (/* binding */ readUpdate),\n/* harmony export */   "readSyncMessage": () => (/* binding */ readSyncMessage)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/encoding.js */ "./node_modules/lib0/encoding.js");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/decoding.js */ "./node_modules/lib0/decoding.js");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ "./node_modules/yjs/dist/yjs.mjs");\n/**\n * @module sync-protocol\n */\n\n\n\n\n\n/**\n * @typedef {Map<number, number>} StateMap\n */\n\n/**\n * Core Yjs defines two message types:\n * • YjsSyncStep1: Includes the State Set of the sending client. When received, the client should reply with YjsSyncStep2.\n * • YjsSyncStep2: Includes all missing structs and the complete delete set. When received, the client is assured that it\n *   received all information from the remote client.\n *\n * In a peer-to-peer network, you may want to introduce a SyncDone message type. Both parties should initiate the connection\n * with SyncStep1. When a client received SyncStep2, it should reply with SyncDone. When the local client received both\n * SyncStep2 and SyncDone, it is assured that it is synced to the remote client.\n *\n * In a client-server model, you want to handle this differently: The client should initiate the connection with SyncStep1.\n * When the server receives SyncStep1, it should reply with SyncStep2 immediately followed by SyncStep1. The client replies\n * with SyncStep2 when it receives SyncStep1. Optionally the server may send a SyncDone after it received SyncStep2, so the\n * client knows that the sync is finished.  There are two reasons for this more elaborated sync model: 1. This protocol can\n * easily be implemented on top of http and websockets. 2. The server shoul only reply to requests, and not initiate them.\n * Therefore it is necesarry that the client initiates the sync.\n *\n * Construction of a message:\n * [messageType : varUint, message definition..]\n *\n * Note: A message does not include information about the room name. This must to be handled by the upper layer protocol!\n *\n * stringify[messageType] stringifies a message definition (messageType is already read from the bufffer)\n */\n\nconst messageYjsSyncStep1 = 0\nconst messageYjsSyncStep2 = 1\nconst messageYjsUpdate = 2\n\n/**\n * Create a sync step 1 message based on the state of the current shared document.\n *\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n */\nconst writeSyncStep1 = (encoder, doc) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsSyncStep1)\n  const sv = yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateVector(doc)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, sv)\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Y.Doc} doc\n * @param {Uint8Array} [encodedStateVector]\n */\nconst writeSyncStep2 = (encoder, doc, encodedStateVector) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsSyncStep2)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, yjs__WEBPACK_IMPORTED_MODULE_1__.encodeStateAsUpdate(doc, encodedStateVector))\n}\n\n/**\n * Read SyncStep1 message and reply with SyncStep2.\n *\n * @param {decoding.Decoder} decoder The reply to the received message\n * @param {encoding.Encoder} encoder The received message\n * @param {Y.Doc} doc\n */\nconst readSyncStep1 = (decoder, encoder, doc) =>\n  writeSyncStep2(encoder, doc, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder))\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncStep2 = (decoder, doc, transactionOrigin) => {\n  try {\n    yjs__WEBPACK_IMPORTED_MODULE_1__.applyUpdate(doc, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint8Array(decoder), transactionOrigin)\n  } catch (error) {\n    // This catches errors that are thrown by event handlers\n    console.error(\'Caught error while handling a Yjs update\', error)\n  }\n}\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {Uint8Array} update\n */\nconst writeUpdate = (encoder, update) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint(encoder, messageYjsUpdate)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_0__.writeVarUint8Array(encoder, update)\n}\n\n/**\n * Read and apply Structs and then DeleteStore to a y instance.\n *\n * @param {decoding.Decoder} decoder\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readUpdate = readSyncStep2\n\n/**\n * @param {decoding.Decoder} decoder A message received from another client\n * @param {encoding.Encoder} encoder The reply message. Will not be sent if empty.\n * @param {Y.Doc} doc\n * @param {any} transactionOrigin\n */\nconst readSyncMessage = (decoder, encoder, doc, transactionOrigin) => {\n  const messageType = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_2__.readVarUint(decoder)\n  switch (messageType) {\n    case messageYjsSyncStep1:\n      readSyncStep1(decoder, encoder, doc)\n      break\n    case messageYjsSyncStep2:\n      readSyncStep2(decoder, doc, transactionOrigin)\n      break\n    case messageYjsUpdate:\n      readUpdate(decoder, doc, transactionOrigin)\n      break\n    default:\n      throw new Error(\'Unknown message type\')\n  }\n  return messageType\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL3N5bmMuanM/NTVhOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBOztBQUU0QztBQUNBO0FBQ3BCOztBQUV4QjtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCO0FBQ087QUFDUCxFQUFFLDBEQUFxQjtBQUN2QixhQUFhLGtEQUFtQjtBQUNoQyxFQUFFLGdFQUEyQjtBQUM3Qjs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFdBQVc7QUFDdEI7QUFDTztBQUNQLEVBQUUsMERBQXFCO0FBQ3ZCLEVBQUUsZ0VBQTJCLFVBQVUsb0RBQXFCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1AsK0JBQStCLCtEQUEwQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsSUFBSTtBQUNmO0FBQ087QUFDUDtBQUNBLElBQUksNENBQWEsTUFBTSwrREFBMEI7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxXQUFXO0FBQ3RCO0FBQ087QUFDUCxFQUFFLDBEQUFxQjtBQUN2QixFQUFFLGdFQUEyQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLE1BQU07QUFDakIsV0FBVyxJQUFJO0FBQ2Y7QUFDTzs7QUFFUDtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsTUFBTTtBQUNqQixXQUFXLElBQUk7QUFDZjtBQUNPO0FBQ1Asc0JBQXNCLHlEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvc3luYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBzeW5jLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7TWFwPG51bWJlciwgbnVtYmVyPn0gU3RhdGVNYXBcbiAqL1xuXG4vKipcbiAqIENvcmUgWWpzIGRlZmluZXMgdHdvIG1lc3NhZ2UgdHlwZXM6XG4gKiDigKIgWWpzU3luY1N0ZXAxOiBJbmNsdWRlcyB0aGUgU3RhdGUgU2V0IG9mIHRoZSBzZW5kaW5nIGNsaWVudC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBzaG91bGQgcmVwbHkgd2l0aCBZanNTeW5jU3RlcDIuXG4gKiDigKIgWWpzU3luY1N0ZXAyOiBJbmNsdWRlcyBhbGwgbWlzc2luZyBzdHJ1Y3RzIGFuZCB0aGUgY29tcGxldGUgZGVsZXRlIHNldC4gV2hlbiByZWNlaXZlZCwgdGhlIGNsaWVudCBpcyBhc3N1cmVkIHRoYXQgaXRcbiAqICAgcmVjZWl2ZWQgYWxsIGluZm9ybWF0aW9uIGZyb20gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBwZWVyLXRvLXBlZXIgbmV0d29yaywgeW91IG1heSB3YW50IHRvIGludHJvZHVjZSBhIFN5bmNEb25lIG1lc3NhZ2UgdHlwZS4gQm90aCBwYXJ0aWVzIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICogd2l0aCBTeW5jU3RlcDEuIFdoZW4gYSBjbGllbnQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jRG9uZS4gV2hlbiB0aGUgbG9jYWwgY2xpZW50IHJlY2VpdmVkIGJvdGhcbiAqIFN5bmNTdGVwMiBhbmQgU3luY0RvbmUsIGl0IGlzIGFzc3VyZWQgdGhhdCBpdCBpcyBzeW5jZWQgdG8gdGhlIHJlbW90ZSBjbGllbnQuXG4gKlxuICogSW4gYSBjbGllbnQtc2VydmVyIG1vZGVsLCB5b3Ugd2FudCB0byBoYW5kbGUgdGhpcyBkaWZmZXJlbnRseTogVGhlIGNsaWVudCBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb24gd2l0aCBTeW5jU3RlcDEuXG4gKiBXaGVuIHRoZSBzZXJ2ZXIgcmVjZWl2ZXMgU3luY1N0ZXAxLCBpdCBzaG91bGQgcmVwbHkgd2l0aCBTeW5jU3RlcDIgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgU3luY1N0ZXAxLiBUaGUgY2xpZW50IHJlcGxpZXNcbiAqIHdpdGggU3luY1N0ZXAyIHdoZW4gaXQgcmVjZWl2ZXMgU3luY1N0ZXAxLiBPcHRpb25hbGx5IHRoZSBzZXJ2ZXIgbWF5IHNlbmQgYSBTeW5jRG9uZSBhZnRlciBpdCByZWNlaXZlZCBTeW5jU3RlcDIsIHNvIHRoZVxuICogY2xpZW50IGtub3dzIHRoYXQgdGhlIHN5bmMgaXMgZmluaXNoZWQuICBUaGVyZSBhcmUgdHdvIHJlYXNvbnMgZm9yIHRoaXMgbW9yZSBlbGFib3JhdGVkIHN5bmMgbW9kZWw6IDEuIFRoaXMgcHJvdG9jb2wgY2FuXG4gKiBlYXNpbHkgYmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mIGh0dHAgYW5kIHdlYnNvY2tldHMuIDIuIFRoZSBzZXJ2ZXIgc2hvdWwgb25seSByZXBseSB0byByZXF1ZXN0cywgYW5kIG5vdCBpbml0aWF0ZSB0aGVtLlxuICogVGhlcmVmb3JlIGl0IGlzIG5lY2VzYXJyeSB0aGF0IHRoZSBjbGllbnQgaW5pdGlhdGVzIHRoZSBzeW5jLlxuICpcbiAqIENvbnN0cnVjdGlvbiBvZiBhIG1lc3NhZ2U6XG4gKiBbbWVzc2FnZVR5cGUgOiB2YXJVaW50LCBtZXNzYWdlIGRlZmluaXRpb24uLl1cbiAqXG4gKiBOb3RlOiBBIG1lc3NhZ2UgZG9lcyBub3QgaW5jbHVkZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vbSBuYW1lLiBUaGlzIG11c3QgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXBwZXIgbGF5ZXIgcHJvdG9jb2whXG4gKlxuICogc3RyaW5naWZ5W21lc3NhZ2VUeXBlXSBzdHJpbmdpZmllcyBhIG1lc3NhZ2UgZGVmaW5pdGlvbiAobWVzc2FnZVR5cGUgaXMgYWxyZWFkeSByZWFkIGZyb20gdGhlIGJ1ZmZmZXIpXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNTeW5jU3RlcDEgPSAwXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMiA9IDFcbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzVXBkYXRlID0gMlxuXG4vKipcbiAqIENyZWF0ZSBhIHN5bmMgc3RlcCAxIG1lc3NhZ2UgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IHNoYXJlZCBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTeW5jU3RlcDEgPSAoZW5jb2RlciwgZG9jKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAxKVxuICBjb25zdCBzdiA9IFkuZW5jb2RlU3RhdGVWZWN0b3IoZG9jKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2Rlciwgc3YpXG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRTdGF0ZVZlY3Rvcl1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3luY1N0ZXAyID0gKGVuY29kZXIsIGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzU3luY1N0ZXAyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYywgZW5jb2RlZFN0YXRlVmVjdG9yKSlcbn1cblxuLyoqXG4gKiBSZWFkIFN5bmNTdGVwMSBtZXNzYWdlIGFuZCByZXBseSB3aXRoIFN5bmNTdGVwMi5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXIgVGhlIHJlcGx5IHRvIHRoZSByZWNlaXZlZCBtZXNzYWdlXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNTdGVwMSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MpID0+XG4gIHdyaXRlU3luY1N0ZXAyKGVuY29kZXIsIGRvYywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgU3RydWN0cyBhbmQgdGhlbiBEZWxldGVTdG9yZSB0byBhIHkgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7YW55fSB0cmFuc2FjdGlvbk9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN5bmNTdGVwMiA9IChkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIHRyeSB7XG4gICAgWS5hcHBseVVwZGF0ZShkb2MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGNhdGNoZXMgZXJyb3JzIHRoYXQgYXJlIHRocm93biBieSBldmVudCBoYW5kbGVyc1xuICAgIGNvbnNvbGUuZXJyb3IoJ0NhdWdodCBlcnJvciB3aGlsZSBoYW5kbGluZyBhIFlqcyB1cGRhdGUnLCBlcnJvcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVXBkYXRlID0gKGVuY29kZXIsIHVwZGF0ZSkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVlqc1VwZGF0ZSlcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHVwZGF0ZSlcbn1cblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBTdHJ1Y3RzIGFuZCB0aGVuIERlbGV0ZVN0b3JlIHRvIGEgeSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVXBkYXRlID0gcmVhZFN5bmNTdGVwMlxuXG4vKipcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlciBBIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIGNsaWVudFxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyIFRoZSByZXBseSBtZXNzYWdlLiBXaWxsIG5vdCBiZSBzZW50IGlmIGVtcHR5LlxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRTeW5jTWVzc2FnZSA9IChkZWNvZGVyLCBlbmNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgc3dpdGNoIChtZXNzYWdlVHlwZSkge1xuICAgIGNhc2UgbWVzc2FnZVlqc1N5bmNTdGVwMTpcbiAgICAgIHJlYWRTeW5jU3RlcDEoZGVjb2RlciwgZW5jb2RlciwgZG9jKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VZanNTeW5jU3RlcDI6XG4gICAgICByZWFkU3luY1N0ZXAyKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pXG4gICAgICBicmVha1xuICAgIGNhc2UgbWVzc2FnZVlqc1VwZGF0ZTpcbiAgICAgIHJlYWRVcGRhdGUoZGVjb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbilcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBtZXNzYWdlIHR5cGUnKVxuICB9XG4gIHJldHVybiBtZXNzYWdlVHlwZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/y-protocols/sync.js\n')},"./node_modules/y-websocket/src/y-websocket.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebsocketProvider\": () => (/* binding */ WebsocketProvider)\n/* harmony export */ });\n/* harmony import */ var lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/broadcastchannel.js */ \"./node_modules/lib0/broadcastchannel.js\");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/time.js */ \"./node_modules/lib0/time.js\");\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/encoding.js */ \"./node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/decoding.js */ \"./node_modules/lib0/decoding.js\");\n/* harmony import */ var y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/sync.js */ \"./node_modules/y-protocols/sync.js\");\n/* harmony import */ var y_protocols_auth_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-protocols/auth.js */ \"./node_modules/y-protocols/auth.js\");\n/* harmony import */ var y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness.js */ \"./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var lib0_mutex_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/mutex.js */ \"./node_modules/lib0/mutex.js\");\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/observable.js */ \"./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/math.js */ \"./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_url_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/url.js */ \"./node_modules/lib0/url.js\");\n/*\nUnlike stated in the LICENSE file, it is not necessary to include the copyright notice and permission notice when you copy code from this file.\n*/\n\n/**\n * @module provider/websocket\n */\n\n/* eslint-env browser */\n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\nconst messageSync = 0\nconst messageQueryAwareness = 3\nconst messageAwareness = 1\nconst messageAuth = 2\n\n/**\n *                       encoder,          decoder,          provider,          emitSynced, messageType\n * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}\n */\nconst messageHandlers = []\n\nmessageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, messageType) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n  const syncMessageType = y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.readSyncMessage(decoder, encoder, provider.doc, provider)\n  if (emitSynced && syncMessageType === y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.messageYjsSyncStep2 && !provider.synced) {\n    provider.synced = true\n  }\n}\n\nmessageHandlers[messageQueryAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageAwareness)\n  lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())))\n}\n\nmessageHandlers[messageAwareness] = (encoder, decoder, provider, emitSynced, messageType) => {\n  y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.applyAwarenessUpdate(provider.awareness, lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__.readVarUint8Array(decoder), provider)\n}\n\nmessageHandlers[messageAuth] = (encoder, decoder, provider, emitSynced, messageType) => {\n  y_protocols_auth_js__WEBPACK_IMPORTED_MODULE_1__.readAuthMessage(decoder, provider.doc, permissionDeniedHandler)\n}\n\nconst reconnectTimeoutBase = 1200\nconst maxReconnectTimeout = 2500\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000\n\n/**\n * @param {WebsocketProvider} provider\n * @param {string} reason\n */\nconst permissionDeniedHandler = (provider, reason) => console.warn(`Permission denied to access ${provider.url}.\\n${reason}`)\n\n/**\n * @param {WebsocketProvider} provider\n * @param {Uint8Array} buf\n * @param {boolean} emitSynced\n * @return {encoding.Encoder}\n */\nconst readMessage = (provider, buf, emitSynced) => {\n  const decoder = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__.createDecoder(buf)\n  const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n  const messageType = lib0_decoding_js__WEBPACK_IMPORTED_MODULE_4__.readVarUint(decoder)\n  const messageHandler = provider.messageHandlers[messageType]\n  if (/** @type {any} */ (messageHandler)) {\n    messageHandler(encoder, decoder, provider, emitSynced, messageType)\n  } else {\n    console.error('Unable to compute message')\n  }\n  return encoder\n}\n\n/**\n * @param {WebsocketProvider} provider\n */\nconst setupWS = provider => {\n  if (provider.shouldConnect && provider.ws === null) {\n    const websocket = new provider._WS(provider.url)\n    websocket.binaryType = 'arraybuffer'\n    provider.ws = websocket\n    provider.wsconnecting = true\n    provider.wsconnected = false\n    provider.synced = false\n\n    websocket.onmessage = event => {\n      provider.wsLastMessageReceived = lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime()\n      const encoder = readMessage(provider, new Uint8Array(event.data), true)\n      if (lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.length(encoder) > 1) {\n        websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n      }\n    }\n    websocket.onclose = () => {\n      provider.ws = null\n      provider.wsconnecting = false\n      if (provider.wsconnected) {\n        provider.wsconnected = false\n        provider.synced = false\n        // update awareness (all users except local left)\n        y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter(client => client !== provider.doc.clientID), provider)\n        provider.emit('status', [{\n          status: 'disconnected'\n        }])\n      } else {\n        provider.wsUnsuccessfulReconnects++\n      }\n      // Start with no reconnect timeout and increase timeout by\n      // log10(wsUnsuccessfulReconnects).\n      // The idea is to increase reconnect timeout slowly and have no reconnect\n      // timeout at the beginning (log(1) = 0)\n      setTimeout(setupWS, lib0_math_js__WEBPACK_IMPORTED_MODULE_6__.min(lib0_math_js__WEBPACK_IMPORTED_MODULE_6__.log10(provider.wsUnsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), provider)\n    }\n    websocket.onopen = () => {\n      provider.wsLastMessageReceived = lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime()\n      provider.wsconnecting = false\n      provider.wsconnected = true\n      provider.wsUnsuccessfulReconnects = 0\n      provider.emit('status', [{\n        status: 'connected'\n      }])\n      // always send sync step 1 when connected\n      const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoder, provider.doc)\n      websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n      // broadcast local awareness state\n      if (provider.awareness.getLocalState() !== null) {\n        const encoderAwarenessState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderAwarenessState, messageAwareness)\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(provider.awareness, [provider.doc.clientID]))\n        websocket.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderAwarenessState))\n      }\n    }\n\n    provider.emit('status', [{\n      status: 'connecting'\n    }])\n  }\n}\n\n/**\n * @param {WebsocketProvider} provider\n * @param {ArrayBuffer} buf\n */\nconst broadcastMessage = (provider, buf) => {\n  if (provider.wsconnected) {\n    // @ts-ignore We know that wsconnected = true\n    provider.ws.send(buf)\n  }\n  if (provider.bcconnected) {\n    provider.mux(() => {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(provider.bcChannel, buf)\n    })\n  }\n}\n\n/**\n * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.\n * The document name is attached to the provided url. I.e. the following example\n * creates a websocket connection to http://localhost:1234/my-document-name\n *\n * @example\n *   import * as Y from 'yjs'\n *   import { WebsocketProvider } from 'y-websocket'\n *   const doc = new Y.Doc()\n *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)\n *\n * @extends {Observable<string>}\n */\nclass WebsocketProvider extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_8__.Observable {\n  /**\n   * @param {string} serverUrl\n   * @param {string} roomname\n   * @param {Y.Doc} doc\n   * @param {object} [opts]\n   * @param {boolean} [opts.connect]\n   * @param {awarenessProtocol.Awareness} [opts.awareness]\n   * @param {Object<string,string>} [opts.params]\n   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill\n   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds\n   */\n  constructor (serverUrl, roomname, doc, { connect = true, awareness = new y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1 } = {}) {\n    super()\n    // ensure that url is always ends with /\n    while (serverUrl[serverUrl.length - 1] === '/') {\n      serverUrl = serverUrl.slice(0, serverUrl.length - 1)\n    }\n    const encodedParams = lib0_url_js__WEBPACK_IMPORTED_MODULE_9__.encodeQueryParams(params)\n    this.bcChannel = serverUrl + '/' + roomname\n    this.url = serverUrl + '/' + roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams)\n    this.roomname = roomname\n    this.doc = doc\n    this._WS = WebSocketPolyfill\n    this.awareness = awareness\n    this.wsconnected = false\n    this.wsconnecting = false\n    this.bcconnected = false\n    this.wsUnsuccessfulReconnects = 0\n    this.messageHandlers = messageHandlers.slice()\n    this.mux = lib0_mutex_js__WEBPACK_IMPORTED_MODULE_10__.createMutex()\n    /**\n     * @type {boolean}\n     */\n    this._synced = false\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null\n    this.wsLastMessageReceived = 0\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = connect\n\n    /**\n     * @type {number}\n     */\n    this._resyncInterval = 0\n    if (resyncInterval > 0) {\n      this._resyncInterval = /** @type {any} */ (setInterval(() => {\n        if (this.ws) {\n          // resend sync step 1\n          const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n          lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n          y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoder, doc)\n          this.ws.send(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n        }\n      }, resyncInterval))\n    }\n\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => {\n      this.mux(() => {\n        const encoder = readMessage(this, new Uint8Array(data), false)\n        if (lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.length(encoder) > 1) {\n          lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n        }\n      })\n    }\n    /**\n     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)\n     * @param {Uint8Array} update\n     * @param {any} origin\n     */\n    this._updateHandler = (update, origin) => {\n      if (origin !== this || origin === null) {\n        const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n        lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageSync)\n        y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeUpdate(encoder, update)\n        broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n      }\n    }\n    this.doc.on('update', this._updateHandler)\n    /**\n     * @param {any} changed\n     * @param {any} origin\n     */\n    this._awarenessUpdateHandler = ({ added, updated, removed }, origin) => {\n      const changedClients = added.concat(updated).concat(removed)\n      const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(awareness, changedClients))\n      broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n    }\n    window.addEventListener('beforeunload', () => {\n      y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload')\n    })\n    awareness.on('update', this._awarenessUpdateHandler)\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      if (this.wsconnected && messageReconnectTimeout < lib0_time_js__WEBPACK_IMPORTED_MODULE_5__.getUnixTime() - this.wsLastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */ (this.ws).close()\n      }\n    }, messageReconnectTimeout / 10))\n    if (connect) {\n      this.connect()\n    }\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get synced () {\n    return this._synced\n  }\n\n  set synced (state) {\n    if (this._synced !== state) {\n      this._synced = state\n      this.emit('synced', [state])\n      this.emit('sync', [state])\n    }\n  }\n\n  destroy () {\n    if (this._resyncInterval !== 0) {\n      clearInterval(this._resyncInterval)\n    }\n    clearInterval(this._checkInterval)\n    this.disconnect()\n    this.awareness.off('update', this._awarenessUpdateHandler)\n    this.doc.off('update', this._updateHandler)\n    super.destroy()\n  }\n\n  connectBc () {\n    if (!this.bcconnected) {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.subscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = true\n    }\n    // send sync step1 to bc\n    this.mux(() => {\n      // write sync step 1\n      const encoderSync = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderSync, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep1(encoderSync, this.doc)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderSync))\n      // broadcast local state\n      const encoderState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderState, messageSync)\n      y_protocols_sync_js__WEBPACK_IMPORTED_MODULE_0__.writeSyncStep2(encoderState, this.doc)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderState))\n      // write queryAwareness\n      const encoderAwarenessQuery = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderAwarenessQuery, messageQueryAwareness)\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderAwarenessQuery))\n      // broadcast local awareness state\n      const encoderAwarenessState = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoderAwarenessState, messageAwareness)\n      lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoderAwarenessState, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]))\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.publish(this.bcChannel, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoderAwarenessState))\n    })\n  }\n\n  disconnectBc () {\n    // broadcast message with local awareness state set to null (indicating disconnect)\n    const encoder = lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.createEncoder()\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint(encoder, messageAwareness)\n    lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.writeVarUint8Array(encoder, y_protocols_awareness_js__WEBPACK_IMPORTED_MODULE_2__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], new Map()))\n    broadcastMessage(this, lib0_encoding_js__WEBPACK_IMPORTED_MODULE_3__.toUint8Array(encoder))\n    if (this.bcconnected) {\n      lib0_broadcastchannel_js__WEBPACK_IMPORTED_MODULE_7__.unsubscribe(this.bcChannel, this._bcSubscriber)\n      this.bcconnected = false\n    }\n  }\n\n  disconnect () {\n    this.shouldConnect = false\n    this.disconnectBc()\n    if (this.ws !== null) {\n      this.ws.close()\n    }\n  }\n\n  connect () {\n    this.shouldConnect = true\n    if (!this.wsconnected && this.ws === null) {\n      setupWS(this)\n      this.connectBc()\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3ktd2Vic29ja2V0L3NyYy95LXdlYnNvY2tldC5qcz8yZTMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRXdCO0FBQ3NCO0FBQ1Y7QUFDUTtBQUNBO0FBQ087QUFDQTtBQUNVO0FBQ3ZCO0FBQ1M7QUFDWDtBQUNGOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDBEQUFxQjtBQUN2QiwwQkFBMEIsZ0VBQTRCO0FBQ3RELHdDQUF3QyxvRUFBZ0M7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwREFBcUI7QUFDdkIsRUFBRSxnRUFBMkIsVUFBVSwyRUFBdUM7QUFDOUU7O0FBRUE7QUFDQSxFQUFFLDBFQUFzQyxxQkFBcUIsK0RBQTBCO0FBQ3ZGOztBQUVBO0FBQ0EsRUFBRSxnRUFBNEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLE9BQU87QUFDbEI7QUFDQSxrR0FBa0csYUFBYSxLQUFLLE9BQU87O0FBRTNIO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGtCQUFrQiwyREFBc0I7QUFDeEMsa0JBQWtCLDJEQUFzQjtBQUN4QyxzQkFBc0IseURBQW9CO0FBQzFDO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMscURBQWdCO0FBQ3ZEO0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLCtEQUFZO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQXNCO0FBQ2hELE1BQU0sMERBQXFCO0FBQzNCLE1BQU0sK0RBQTJCO0FBQ2pDLE1BQU0sNkRBQVUsaUJBQWlCLDBEQUFxQjtBQUN0RDtBQUNBLDJCQUEyQiwyREFBc0I7QUFDakQsTUFBTSwwREFBcUI7QUFDM0IsTUFBTSwrREFBMkI7QUFDakMsTUFBTSw2REFBVSxpQkFBaUIsMERBQXFCO0FBQ3REO0FBQ0Esb0NBQW9DLDJEQUFzQjtBQUMxRCxNQUFNLDBEQUFxQjtBQUMzQixNQUFNLDZEQUFVLGlCQUFpQiwwREFBcUI7QUFDdEQ7QUFDQSxvQ0FBb0MsMkRBQXNCO0FBQzFELE1BQU0sMERBQXFCO0FBQzNCLE1BQU0sZ0VBQTJCLHdCQUF3QiwyRUFBdUM7QUFDaEcsTUFBTSw2REFBVSxpQkFBaUIsMERBQXFCO0FBQ3RELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUFzQjtBQUMxQyxJQUFJLDBEQUFxQjtBQUN6QixJQUFJLGdFQUEyQixVQUFVLDJFQUF1QztBQUNoRiwyQkFBMkIsMERBQXFCO0FBQ2hEO0FBQ0EsTUFBTSxpRUFBYztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy95LXdlYnNvY2tldC9zcmMveS13ZWJzb2NrZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuVW5saWtlIHN0YXRlZCBpbiB0aGUgTElDRU5TRSBmaWxlLCBpdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGluY2x1ZGUgdGhlIGNvcHlyaWdodCBub3RpY2UgYW5kIHBlcm1pc3Npb24gbm90aWNlIHdoZW4geW91IGNvcHkgY29kZSBmcm9tIHRoaXMgZmlsZS5cbiovXG5cbi8qKlxuICogQG1vZHVsZSBwcm92aWRlci93ZWJzb2NrZXRcbiAqL1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIGJjIGZyb20gJ2xpYjAvYnJvYWRjYXN0Y2hhbm5lbC5qcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lLmpzJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZy5qcydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBzeW5jUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvc3luYy5qcydcbmltcG9ydCAqIGFzIGF1dGhQcm90b2NvbCBmcm9tICd5LXByb3RvY29scy9hdXRoLmpzJ1xuaW1wb3J0ICogYXMgYXdhcmVuZXNzUHJvdG9jb2wgZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzLmpzJ1xuaW1wb3J0ICogYXMgbXV0ZXggZnJvbSAnbGliMC9tdXRleC5qcydcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aC5qcydcbmltcG9ydCAqIGFzIHVybCBmcm9tICdsaWIwL3VybC5qcydcblxuY29uc3QgbWVzc2FnZVN5bmMgPSAwXG5jb25zdCBtZXNzYWdlUXVlcnlBd2FyZW5lc3MgPSAzXG5jb25zdCBtZXNzYWdlQXdhcmVuZXNzID0gMVxuY29uc3QgbWVzc2FnZUF1dGggPSAyXG5cbi8qKlxuICogICAgICAgICAgICAgICAgICAgICAgIGVuY29kZXIsICAgICAgICAgIGRlY29kZXIsICAgICAgICAgIHByb3ZpZGVyLCAgICAgICAgICBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZVxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKGVuY29kaW5nLkVuY29kZXIsIGRlY29kaW5nLkRlY29kZXIsIFdlYnNvY2tldFByb3ZpZGVyLCBib29sZWFuLCAgICBudW1iZXIpOnZvaWQ+fVxuICovXG5jb25zdCBtZXNzYWdlSGFuZGxlcnMgPSBbXVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZVN5bmNdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gIGNvbnN0IHN5bmNNZXNzYWdlVHlwZSA9IHN5bmNQcm90b2NvbC5yZWFkU3luY01lc3NhZ2UoZGVjb2RlciwgZW5jb2RlciwgcHJvdmlkZXIuZG9jLCBwcm92aWRlcilcbiAgaWYgKGVtaXRTeW5jZWQgJiYgc3luY01lc3NhZ2VUeXBlID09PSBzeW5jUHJvdG9jb2wubWVzc2FnZVlqc1N5bmNTdGVwMiAmJiAhcHJvdmlkZXIuc3luY2VkKSB7XG4gICAgcHJvdmlkZXIuc3luY2VkID0gdHJ1ZVxuICB9XG59XG5cbm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlUXVlcnlBd2FyZW5lc3NdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZUF3YXJlbmVzcylcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIEFycmF5LmZyb20ocHJvdmlkZXIuYXdhcmVuZXNzLmdldFN0YXRlcygpLmtleXMoKSkpKVxufVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZUF3YXJlbmVzc10gPSAoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKSA9PiB7XG4gIGF3YXJlbmVzc1Byb3RvY29sLmFwcGx5QXdhcmVuZXNzVXBkYXRlKHByb3ZpZGVyLmF3YXJlbmVzcywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHByb3ZpZGVyKVxufVxuXG5tZXNzYWdlSGFuZGxlcnNbbWVzc2FnZUF1dGhdID0gKGVuY29kZXIsIGRlY29kZXIsIHByb3ZpZGVyLCBlbWl0U3luY2VkLCBtZXNzYWdlVHlwZSkgPT4ge1xuICBhdXRoUHJvdG9jb2wucmVhZEF1dGhNZXNzYWdlKGRlY29kZXIsIHByb3ZpZGVyLmRvYywgcGVybWlzc2lvbkRlbmllZEhhbmRsZXIpXG59XG5cbmNvbnN0IHJlY29ubmVjdFRpbWVvdXRCYXNlID0gMTIwMFxuY29uc3QgbWF4UmVjb25uZWN0VGltZW91dCA9IDI1MDBcbi8vIEB0b2RvIC0gdGhpcyBzaG91bGQgZGVwZW5kIG9uIGF3YXJlbmVzcy5vdXRkYXRlZFRpbWVcbmNvbnN0IG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICovXG5jb25zdCBwZXJtaXNzaW9uRGVuaWVkSGFuZGxlciA9IChwcm92aWRlciwgcmVhc29uKSA9PiBjb25zb2xlLndhcm4oYFBlcm1pc3Npb24gZGVuaWVkIHRvIGFjY2VzcyAke3Byb3ZpZGVyLnVybH0uXFxuJHtyZWFzb259YClcblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW1pdFN5bmNlZFxuICogQHJldHVybiB7ZW5jb2RpbmcuRW5jb2Rlcn1cbiAqL1xuY29uc3QgcmVhZE1lc3NhZ2UgPSAocHJvdmlkZXIsIGJ1ZiwgZW1pdFN5bmNlZCkgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgY29uc3QgbWVzc2FnZVR5cGUgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IHByb3ZpZGVyLm1lc3NhZ2VIYW5kbGVyc1ttZXNzYWdlVHlwZV1cbiAgaWYgKC8qKiBAdHlwZSB7YW55fSAqLyAobWVzc2FnZUhhbmRsZXIpKSB7XG4gICAgbWVzc2FnZUhhbmRsZXIoZW5jb2RlciwgZGVjb2RlciwgcHJvdmlkZXIsIGVtaXRTeW5jZWQsIG1lc3NhZ2VUeXBlKVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBjb21wdXRlIG1lc3NhZ2UnKVxuICB9XG4gIHJldHVybiBlbmNvZGVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJzb2NrZXRQcm92aWRlcn0gcHJvdmlkZXJcbiAqL1xuY29uc3Qgc2V0dXBXUyA9IHByb3ZpZGVyID0+IHtcbiAgaWYgKHByb3ZpZGVyLnNob3VsZENvbm5lY3QgJiYgcHJvdmlkZXIud3MgPT09IG51bGwpIHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgcHJvdmlkZXIuX1dTKHByb3ZpZGVyLnVybClcbiAgICB3ZWJzb2NrZXQuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgICBwcm92aWRlci53cyA9IHdlYnNvY2tldFxuICAgIHByb3ZpZGVyLndzY29ubmVjdGluZyA9IHRydWVcbiAgICBwcm92aWRlci53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgcHJvdmlkZXIuc3luY2VkID0gZmFsc2VcblxuICAgIHdlYnNvY2tldC5vbm1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBwcm92aWRlci53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGNvbnN0IGVuY29kZXIgPSByZWFkTWVzc2FnZShwcm92aWRlciwgbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSksIHRydWUpXG4gICAgICBpZiAoZW5jb2RpbmcubGVuZ3RoKGVuY29kZXIpID4gMSkge1xuICAgICAgICB3ZWJzb2NrZXQuc2VuZChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICB9XG4gICAgfVxuICAgIHdlYnNvY2tldC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3MgPSBudWxsXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgaWYgKHByb3ZpZGVyLndzY29ubmVjdGVkKSB7XG4gICAgICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgcHJvdmlkZXIuc3luY2VkID0gZmFsc2VcbiAgICAgICAgLy8gdXBkYXRlIGF3YXJlbmVzcyAoYWxsIHVzZXJzIGV4Y2VwdCBsb2NhbCBsZWZ0KVxuICAgICAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXMocHJvdmlkZXIuYXdhcmVuZXNzLCBBcnJheS5mcm9tKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5rZXlzKCkpLmZpbHRlcihjbGllbnQgPT4gY2xpZW50ICE9PSBwcm92aWRlci5kb2MuY2xpZW50SUQpLCBwcm92aWRlcilcbiAgICAgICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgICBzdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH1dKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IHdpdGggbm8gcmVjb25uZWN0IHRpbWVvdXQgYW5kIGluY3JlYXNlIHRpbWVvdXQgYnlcbiAgICAgIC8vIGxvZzEwKHdzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykuXG4gICAgICAvLyBUaGUgaWRlYSBpcyB0byBpbmNyZWFzZSByZWNvbm5lY3QgdGltZW91dCBzbG93bHkgYW5kIGhhdmUgbm8gcmVjb25uZWN0XG4gICAgICAvLyB0aW1lb3V0IGF0IHRoZSBiZWdpbm5pbmcgKGxvZygxKSA9IDApXG4gICAgICBzZXRUaW1lb3V0KHNldHVwV1MsIG1hdGgubWluKG1hdGgubG9nMTAocHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzICsgMSkgKiByZWNvbm5lY3RUaW1lb3V0QmFzZSwgbWF4UmVjb25uZWN0VGltZW91dCksIHByb3ZpZGVyKVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgICBwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICBzdGF0dXM6ICdjb25uZWN0ZWQnXG4gICAgICB9XSlcbiAgICAgIC8vIGFsd2F5cyBzZW5kIHN5bmMgc3RlcCAxIHdoZW4gY29ubmVjdGVkXG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlciwgcHJvdmlkZXIuZG9jKVxuICAgICAgd2Vic29ja2V0LnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgICAgLy8gYnJvYWRjYXN0IGxvY2FsIGF3YXJlbmVzcyBzdGF0ZVxuICAgICAgaWYgKHByb3ZpZGVyLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1N0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShwcm92aWRlci5hd2FyZW5lc3MsIFtwcm92aWRlci5kb2MuY2xpZW50SURdKSlcbiAgICAgICAgd2Vic29ja2V0LnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RpbmcnXG4gICAgfV0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldFByb3ZpZGVyfSBwcm92aWRlclxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmXG4gKi9cbmNvbnN0IGJyb2FkY2FzdE1lc3NhZ2UgPSAocHJvdmlkZXIsIGJ1ZikgPT4ge1xuICBpZiAocHJvdmlkZXIud3Njb25uZWN0ZWQpIHtcbiAgICAvLyBAdHMtaWdub3JlIFdlIGtub3cgdGhhdCB3c2Nvbm5lY3RlZCA9IHRydWVcbiAgICBwcm92aWRlci53cy5zZW5kKGJ1ZilcbiAgfVxuICBpZiAocHJvdmlkZXIuYmNjb25uZWN0ZWQpIHtcbiAgICBwcm92aWRlci5tdXgoKCkgPT4ge1xuICAgICAgYmMucHVibGlzaChwcm92aWRlci5iY0NoYW5uZWwsIGJ1ZilcbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogV2Vic29ja2V0IFByb3ZpZGVyIGZvciBZanMuIENyZWF0ZXMgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB0byBzeW5jIHRoZSBzaGFyZWQgZG9jdW1lbnQuXG4gKiBUaGUgZG9jdW1lbnQgbmFtZSBpcyBhdHRhY2hlZCB0byB0aGUgcHJvdmlkZWQgdXJsLiBJLmUuIHRoZSBmb2xsb3dpbmcgZXhhbXBsZVxuICogY3JlYXRlcyBhIHdlYnNvY2tldCBjb25uZWN0aW9uIHRvIGh0dHA6Ly9sb2NhbGhvc3Q6MTIzNC9teS1kb2N1bWVudC1uYW1lXG4gKlxuICogQGV4YW1wbGVcbiAqICAgaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG4gKiAgIGltcG9ydCB7IFdlYnNvY2tldFByb3ZpZGVyIH0gZnJvbSAneS13ZWJzb2NrZXQnXG4gKiAgIGNvbnN0IGRvYyA9IG5ldyBZLkRvYygpXG4gKiAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFdlYnNvY2tldFByb3ZpZGVyKCdodHRwOi8vbG9jYWxob3N0OjEyMzQnLCAnbXktZG9jdW1lbnQtbmFtZScsIGRvYylcbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxzdHJpbmc+fVxuICovXG5leHBvcnQgY2xhc3MgV2Vic29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJVcmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb21uYW1lXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdHNdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuY29ubmVjdF1cbiAgICogQHBhcmFtIHthd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3N9IFtvcHRzLmF3YXJlbmVzc11cbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLHN0cmluZz59IFtvcHRzLnBhcmFtc11cbiAgICogQHBhcmFtIHt0eXBlb2YgV2ViU29ja2V0fSBbb3B0cy5XZWJTb2NrZXRQb2x5ZmlsbF0gT3B0aW9uYWxsIHByb3ZpZGUgYSBXZWJTb2NrZXQgcG9seWZpbGxcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlc3luY0ludGVydmFsXSBSZXF1ZXN0IHNlcnZlciBzdGF0ZSBldmVyeSBgcmVzeW5jSW50ZXJ2YWxgIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHNlcnZlclVybCwgcm9vbW5hbWUsIGRvYywgeyBjb25uZWN0ID0gdHJ1ZSwgYXdhcmVuZXNzID0gbmV3IGF3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzcyhkb2MpLCBwYXJhbXMgPSB7fSwgV2ViU29ja2V0UG9seWZpbGwgPSBXZWJTb2NrZXQsIHJlc3luY0ludGVydmFsID0gLTEgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIC8vIGVuc3VyZSB0aGF0IHVybCBpcyBhbHdheXMgZW5kcyB3aXRoIC9cbiAgICB3aGlsZSAoc2VydmVyVXJsW3NlcnZlclVybC5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICBzZXJ2ZXJVcmwgPSBzZXJ2ZXJVcmwuc2xpY2UoMCwgc2VydmVyVXJsLmxlbmd0aCAtIDEpXG4gICAgfVxuICAgIGNvbnN0IGVuY29kZWRQYXJhbXMgPSB1cmwuZW5jb2RlUXVlcnlQYXJhbXMocGFyYW1zKVxuICAgIHRoaXMuYmNDaGFubmVsID0gc2VydmVyVXJsICsgJy8nICsgcm9vbW5hbWVcbiAgICB0aGlzLnVybCA9IHNlcnZlclVybCArICcvJyArIHJvb21uYW1lICsgKGVuY29kZWRQYXJhbXMubGVuZ3RoID09PSAwID8gJycgOiAnPycgKyBlbmNvZGVkUGFyYW1zKVxuICAgIHRoaXMucm9vbW5hbWUgPSByb29tbmFtZVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgdGhpcy5fV1MgPSBXZWJTb2NrZXRQb2x5ZmlsbFxuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzXG4gICAgdGhpcy53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoaXMuYmNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgIHRoaXMubWVzc2FnZUhhbmRsZXJzID0gbWVzc2FnZUhhbmRsZXJzLnNsaWNlKClcbiAgICB0aGlzLm11eCA9IG11dGV4LmNyZWF0ZU11dGV4KClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJTb2NrZXQ/fVxuICAgICAqL1xuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBjb25uZWN0IHRvIG90aGVyIHBlZXJzIG9yIG5vdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IGNvbm5lY3RcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAwXG4gICAgaWYgKHJlc3luY0ludGVydmFsID4gMCkge1xuICAgICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAvKiogQHR5cGUge2FueX0gKi8gKHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAvLyByZXNlbmQgc3luYyBzdGVwIDFcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VTeW5jKVxuICAgICAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyLCBkb2MpXG4gICAgICAgICAgdGhpcy53cy5zZW5kKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgICAgICAgfVxuICAgICAgfSwgcmVzeW5jSW50ZXJ2YWwpKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLl9iY1N1YnNjcmliZXIgPSBkYXRhID0+IHtcbiAgICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IHJlYWRNZXNzYWdlKHRoaXMsIG5ldyBVaW50OEFycmF5KGRhdGEpLCBmYWxzZSlcbiAgICAgICAgaWYgKGVuY29kaW5nLmxlbmd0aChlbmNvZGVyKSA+IDEpIHtcbiAgICAgICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbnMgdG8gWWpzIHVwZGF0ZXMgYW5kIHNlbmRzIHRoZW0gdG8gcmVtb3RlIHBlZXJzICh3cyBhbmQgYnJvYWRjYXN0Y2hhbm5lbClcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICAgKi9cbiAgICB0aGlzLl91cGRhdGVIYW5kbGVyID0gKHVwZGF0ZSwgb3JpZ2luKSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzIHx8IG9yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgICAgc3luY1Byb3RvY29sLndyaXRlVXBkYXRlKGVuY29kZXIsIHVwZGF0ZSlcbiAgICAgICAgYnJvYWRjYXN0TWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZG9jLm9uKCd1cGRhdGUnLCB0aGlzLl91cGRhdGVIYW5kbGVyKVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgICAqL1xuICAgIHRoaXMuX2F3YXJlbmVzc1VwZGF0ZUhhbmRsZXIgPSAoeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCBvcmlnaW4pID0+IHtcbiAgICAgIGNvbnN0IGNoYW5nZWRDbGllbnRzID0gYWRkZWQuY29uY2F0KHVwZGF0ZWQpLmNvbmNhdChyZW1vdmVkKVxuICAgICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKGF3YXJlbmVzcywgY2hhbmdlZENsaWVudHMpKVxuICAgICAgYnJvYWRjYXN0TWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFtkb2MuY2xpZW50SURdLCAnd2luZG93IHVubG9hZCcpXG4gICAgfSlcbiAgICBhd2FyZW5lc3Mub24oJ3VwZGF0ZScsIHRoaXMuX2F3YXJlbmVzc1VwZGF0ZUhhbmRsZXIpXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMud3Njb25uZWN0ZWQgJiYgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgPCB0aW1lLmdldFVuaXhUaW1lKCkgLSB0aGlzLndzTGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAvLyBubyBtZXNzYWdlIHJlY2VpdmVkIGluIGEgbG9uZyB0aW1lIC0gbm90IGV2ZW4geW91ciBvd24gYXdhcmVuZXNzXG4gICAgICAgIC8vIHVwZGF0ZXMgKHdoaWNoIGFyZSB1cGRhdGVkIGV2ZXJ5IDE1IHNlY29uZHMpXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViU29ja2V0fSAqLyAodGhpcy53cykuY2xvc2UoKVxuICAgICAgfVxuICAgIH0sIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IC8gMTApKVxuICAgIGlmIChjb25uZWN0KSB7XG4gICAgICB0aGlzLmNvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzeW5jZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jZWRcbiAgfVxuXG4gIHNldCBzeW5jZWQgKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3N5bmNlZCAhPT0gc3RhdGUpIHtcbiAgICAgIHRoaXMuX3N5bmNlZCA9IHN0YXRlXG4gICAgICB0aGlzLmVtaXQoJ3N5bmNlZCcsIFtzdGF0ZV0pXG4gICAgICB0aGlzLmVtaXQoJ3N5bmMnLCBbc3RhdGVdKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGlmICh0aGlzLl9yZXN5bmNJbnRlcnZhbCAhPT0gMCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9yZXN5bmNJbnRlcnZhbClcbiAgICB9XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICAgIHRoaXMuZGlzY29ubmVjdCgpXG4gICAgdGhpcy5hd2FyZW5lc3Mub2ZmKCd1cGRhdGUnLCB0aGlzLl9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyKVxuICAgIHRoaXMuZG9jLm9mZigndXBkYXRlJywgdGhpcy5fdXBkYXRlSGFuZGxlcilcbiAgICBzdXBlci5kZXN0cm95KClcbiAgfVxuXG4gIGNvbm5lY3RCYyAoKSB7XG4gICAgaWYgKCF0aGlzLmJjY29ubmVjdGVkKSB7XG4gICAgICBiYy5zdWJzY3JpYmUodGhpcy5iY0NoYW5uZWwsIHRoaXMuX2JjU3Vic2NyaWJlcilcbiAgICAgIHRoaXMuYmNjb25uZWN0ZWQgPSB0cnVlXG4gICAgfVxuICAgIC8vIHNlbmQgc3luYyBzdGVwMSB0byBiY1xuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8vIHdyaXRlIHN5bmMgc3RlcCAxXG4gICAgICBjb25zdCBlbmNvZGVyU3luYyA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJTeW5jLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyU3luYywgdGhpcy5kb2MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclN5bmMpKVxuICAgICAgLy8gYnJvYWRjYXN0IGxvY2FsIHN0YXRlXG4gICAgICBjb25zdCBlbmNvZGVyU3RhdGUgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3RhdGUsIG1lc3NhZ2VTeW5jKVxuICAgICAgc3luY1Byb3RvY29sLndyaXRlU3luY1N0ZXAyKGVuY29kZXJTdGF0ZSwgdGhpcy5kb2MpXG4gICAgICBiYy5wdWJsaXNoKHRoaXMuYmNDaGFubmVsLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclN0YXRlKSlcbiAgICAgIC8vIHdyaXRlIHF1ZXJ5QXdhcmVuZXNzXG4gICAgICBjb25zdCBlbmNvZGVyQXdhcmVuZXNzUXVlcnkgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzUXVlcnksIG1lc3NhZ2VRdWVyeUF3YXJlbmVzcylcbiAgICAgIGJjLnB1Ymxpc2godGhpcy5iY0NoYW5uZWwsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzUXVlcnkpKVxuICAgICAgLy8gYnJvYWRjYXN0IGxvY2FsIGF3YXJlbmVzcyBzdGF0ZVxuICAgICAgY29uc3QgZW5jb2RlckF3YXJlbmVzc1N0YXRlID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlckF3YXJlbmVzc1N0YXRlLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdKSlcbiAgICAgIGJjLnB1Ymxpc2godGhpcy5iY0NoYW5uZWwsIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyQXdhcmVuZXNzU3RhdGUpKVxuICAgIH0pXG4gIH1cblxuICBkaXNjb25uZWN0QmMgKCkge1xuICAgIC8vIGJyb2FkY2FzdCBtZXNzYWdlIHdpdGggbG9jYWwgYXdhcmVuZXNzIHN0YXRlIHNldCB0byBudWxsIChpbmRpY2F0aW5nIGRpc2Nvbm5lY3QpXG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0sIG5ldyBNYXAoKSkpXG4gICAgYnJvYWRjYXN0TWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gICAgaWYgKHRoaXMuYmNjb25uZWN0ZWQpIHtcbiAgICAgIGJjLnVuc3Vic2NyaWJlKHRoaXMuYmNDaGFubmVsLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgICB0aGlzLmJjY29ubmVjdGVkID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIHRoaXMuZGlzY29ubmVjdEJjKClcbiAgICBpZiAodGhpcy53cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy53cy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIGlmICghdGhpcy53c2Nvbm5lY3RlZCAmJiB0aGlzLndzID09PSBudWxsKSB7XG4gICAgICBzZXR1cFdTKHRoaXMpXG4gICAgICB0aGlzLmNvbm5lY3RCYygpXG4gICAgfVxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/y-websocket/src/y-websocket.js\n")},"./node_modules/yjs/dist/yjs.cjs":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar observable_js = __webpack_require__(/*! lib0/dist/observable.cjs */ \"./node_modules/lib0/dist/observable.cjs\");\nvar array = __webpack_require__(/*! lib0/dist/array.cjs */ \"./node_modules/lib0/dist/array.cjs\");\nvar math = __webpack_require__(/*! lib0/dist/math.cjs */ \"./node_modules/lib0/dist/math.cjs\");\nvar map = __webpack_require__(/*! lib0/dist/map.cjs */ \"./node_modules/lib0/dist/map.cjs\");\nvar encoding = __webpack_require__(/*! lib0/dist/encoding.cjs */ \"./node_modules/lib0/dist/encoding.cjs\");\nvar decoding = __webpack_require__(/*! lib0/dist/decoding.cjs */ \"./node_modules/lib0/dist/decoding.cjs\");\nvar random = __webpack_require__(/*! lib0/dist/random.cjs */ \"./node_modules/lib0/dist/random.cjs\");\nvar buffer = __webpack_require__(/*! lib0/dist/buffer.cjs */ \"./node_modules/lib0/dist/buffer.cjs\");\nvar error = __webpack_require__(/*! lib0/dist/error.cjs */ \"./node_modules/lib0/dist/error.cjs\");\nvar binary = __webpack_require__(/*! lib0/dist/binary.cjs */ \"./node_modules/lib0/dist/binary.cjs\");\nvar f = __webpack_require__(/*! lib0/dist/function.cjs */ \"./node_modules/lib0/dist/function.cjs\");\nvar set = __webpack_require__(/*! lib0/dist/set.cjs */ \"./node_modules/lib0/dist/set.cjs\");\nvar logging = __webpack_require__(/*! lib0/dist/logging.cjs */ \"./node_modules/lib0/dist/logging.cjs\");\nvar time = __webpack_require__(/*! lib0/dist/time.cjs */ \"./node_modules/lib0/dist/time.cjs\");\nvar iterator = __webpack_require__(/*! lib0/dist/iterator.cjs */ \"./node_modules/lib0/dist/iterator.cjs\");\nvar object = __webpack_require__(/*! lib0/dist/object.cjs */ \"./node_modules/lib0/dist/object.cjs\");\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nclass AbstractConnector extends observable_js.Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i];\n      iterateStructs(transaction, structs, del.clock, del.len, f);\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = math.floor((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = math.max(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          array.appendTo(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  map.setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.id.clock === clock + len && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  encoding.writeVarUint(encoder.restEncoder, ds.clients.size);\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal();\n    encoding.writeVarUint(encoder.restEncoder, client);\n    const len = dsitems.length;\n    encoding.writeVarUint(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = decoding.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = decoding.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = map.setIfUndefined(ds.clients, client, () => []);\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = decoding.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = decoding.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array()\n  }\n  return null\n};\n\n/**\n * @module Y\n */\n\nconst generateNewClientId = random.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nclass Doc extends observable_js.Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = random.uuidv4(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = autoLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin);\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = map.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    array.from(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null;\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts });\n        content.doc._item = item;\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    this.emit('destroyed', [true]);\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f);\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f);\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return decoding.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return decoding.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return decoding.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return buffer.copyUint8Array(decoding.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(decoding.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return decoding.readVarString(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += decoding.readVarUint(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = decoding.readVarUint(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    decoding.readVarUint(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));\n    this.clientDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));\n    this.leftClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));\n    this.rightClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));\n    this.infoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8);\n    this.stringDecoder = new decoding.StringDecoder(decoding.readVarUint8Array(decoder));\n    this.parentInfoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8);\n    this.typeRefDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));\n    this.lenDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return decoding.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder();\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    encoding.writeVarUint(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    encoding.writeVarUint(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client);\n    encoding.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client);\n    encoding.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    encoding.writeVarUint(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    encoding.writeUint8(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    encoding.writeVarString(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    encoding.writeVarUint(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    encoding.writeVarUint(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeVarString(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    encoding.writeVarString(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    encoding.writeVarUint(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      error.unexpectedCase();\n    }\n    encoding.writeVarUint(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new encoding.IntDiffOptRleEncoder();\n    this.clientEncoder = new encoding.UintOptRleEncoder();\n    this.leftClockEncoder = new encoding.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new encoding.IntDiffOptRleEncoder();\n    this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8);\n    this.stringEncoder = new encoding.StringEncoder();\n    this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8);\n    this.typeRefEncoder = new encoding.UintOptRleEncoder();\n    this.lenEncoder = new encoding.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = encoding.createEncoder();\n    encoding.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future\n    encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n    encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n    encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n    encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder));\n    encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder));\n    encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n    encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder));\n    return encoding.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeAny(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(this.keyClock++);\n    }\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = math.max(clock, structs[0].id.clock); // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  encoding.writeVarUint(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  encoding.writeVarUint(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock);\n  });\n};\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = map.create();\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = decoding.readVarUint(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs });\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      switch (binary.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen();\n          refs[i] = new GC(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = decoding.readVarUint(decoder.restDecoder);\n          refs[i] = new Skip(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0;\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          );\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = [];\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore();\n  const missingSV = new Map();\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item]);\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);\n    }\n    stack.length = 0;\n  };\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = map.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing));\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop());\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, new Map());\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    encoding.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    let retry = false;\n    const doc = transaction.doc;\n    const store = doc.store;\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc);\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true;\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(decoding.createDecoder(store.pendingDs));\n      decoding.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest;\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = decoding.createDecoder(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  // also add the pending updates (if there are any)\n  // @todo support diffirent encoders\n  if (encoder.constructor === UpdateEncoderV2) {\n    if (doc.store.pendingDs) {\n      updates.push(doc.store.pendingDs);\n    }\n    if (doc.store.pendingStructs) {\n      updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = decoding.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = decoding.readVarUint(decoder.restDecoder);\n    const clock = decoding.readVarUint(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DSDecoderV1(decoding.createDecoder(decodedState)));\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  encoding.writeVarUint(encoder.restEncoder, sv.size);\n  sv.forEach((clock, client) => {\n    encoding.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    encoding.writeVarUint(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc);\n  } else {\n    writeDocumentStateVector(encoder, doc);\n  }\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  f.callAll(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nconst writeID = (encoder, id) => {\n  encoding.writeVarUint(encoder, id.client);\n  encoding.writeVarUint(encoder, id.clock);\n};\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nconst readID = decoder =>\n  createID(decoding.readVarUint(decoder), decoding.readVarUint(decoder));\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw error.unexpectedCase()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(decoding.createDecoder(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1(decoding.createDecoder(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add intial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} [conf]\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nconst relativePositionToJSON = rpos => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json\n};\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nconst writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    encoding.writeVarUint(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    encoding.writeUint8(encoder, 1);\n    encoding.writeVarString(encoder, tname);\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    encoding.writeUint8(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw error.unexpectedCase()\n  }\n  encoding.writeVarInt(encoder, assoc);\n  return encoder\n};\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nconst encodeRelativePosition = rpos => {\n  const encoder = encoding.createEncoder();\n  writeRelativePosition(encoder, rpos);\n  return encoding.toUint8Array(encoder)\n};\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nconst readRelativePosition = decoder => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch (decoding.readVarUint(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder);\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = decoding.readVarString(decoder);\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder);\n    }\n  }\n  const assoc = decoding.hasContent(decoder) ? decoding.readVarInt(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc)\n};\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nconst decodeRelativePosition = uint8Array => readRelativePosition(decoding.createDecoder(uint8Array));\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw error.unexpectedCase()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1());\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding.createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(decoding.createDecoder(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    encoding.writeVarUint(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      encoding.writeVarUint(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null;\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null;\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw error.unexpectedCase()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = math.floor((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = math.floor((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw error.unexpectedCase()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !map.any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    map.setIfUndefined(transaction.changed, type, set.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1];\n  const right = structs[pos];\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1);\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc._transaction = null;\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                );\n              events\n                .forEach(event => {\n                  event.currentTarget = type;\n                });\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length);\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          })\n        );\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      });\n      f.callAll(fs, []);\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = math.max(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1);\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId();\n        logging.print(logging.ORANGE, logging.BOLD, '[yjs] ', logging.UNBOLD, logging.RED, 'Changed the client-id because another client seems to be using it.');\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc));\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }]);\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy());\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    f(doc._transaction);\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0);\n    }\n  }\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null;\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter whan an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'>}\n */\nclass UndoManager extends observable_js.Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = new Set([null]) } = {}) {\n    super();\n    this.scope = typeScope instanceof Array ? typeScope : [typeScope];\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = /** @type {Doc} */ (this.scope[0].doc);\n    this.lastChange = 0;\n    this.doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      // Only track certain transactions\n      if (!this.scope.some(type => transaction.changedParentTypes.has(type)) || (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.redoStack = [];\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = time.getUnixTime();\n      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true);\n        }\n      });\n      this.emit('stack-item-added', [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this]);\n    });\n  }\n\n  clear () {\n    this.doc.transact(transaction => {\n      /**\n       * @param {StackItem} stackItem\n       */\n      const clearItem = stackItem => {\n        iterateDeletedStructs(transaction, stackItem.deletions, item => {\n          if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n            keepItem(item, false);\n          }\n        });\n      };\n      this.undoStack.forEach(clearItem);\n      this.redoStack.forEach(clearItem);\n    });\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = decoding.readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = decoding.readVarUint(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((binary.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\n\nclass LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst logUpdate = update => logUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(decoding.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  logging.print('Structs: ', structs);\n  const ds = readDeleteSet(updateDecoder);\n  logging.print('DeleteSet: ', ds);\n};\n\nclass LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = [];\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nconst mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), true);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 1;\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    let stopCounting = false;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        size++;\n        // We found a new client\n        // write what we have to the encoder\n        encoding.writeVarUint(encoder.restEncoder, currClient);\n        encoding.writeVarUint(encoder.restEncoder, currClock);\n        currClient = curr.id.client;\n        stopCounting = false;\n      }\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    // write what we have\n    encoding.writeVarUint(encoder.restEncoder, currClient);\n    encoding.writeVarUint(encoder.restEncoder, currClock);\n    // prepend the size of the state vector\n    const enc = encoding.createEncoder();\n    encoding.writeVarUint(enc, size);\n    encoding.writeBinaryEncoder(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array()\n  } else {\n    encoding.writeVarUint(encoder.restEncoder, 0);\n    return encoder.toUint8Array()\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map();\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    // write the beginning to `from`\n    from.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock);\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock);\n        // update currClient\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    // write the end to `to`\n    to.set(currClient, currClock);\n  }\n  return { from, to }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1);\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left);\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n};\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nconst mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const updateDecoders = updates.map(update => new YDecoder(decoding.createDecoder(update)));\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null;\n\n  const updateEncoder = new YEncoder();\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : (\n              dec1.curr.constructor === Skip ? 1 : -1\n            )\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0];\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n      }\n      if (curr === null || curr.id.client !== firstClient) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };\n      currDecoder.next();\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nconst diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder(decoding.createDecoder(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next();\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, math.max(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  // write ds\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nconst diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding.toUint8Array(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = encoding.createEncoder();\n    lazyWriter.written = 0;\n  }\n};\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client);\n    // write startClock\n    encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder;\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    encoding.writeVarUint(restEncoder, partStructs.written);\n    // write the rest of the fragment\n    encoding.writeUint8Array(restEncoder, partStructs.restEncoder);\n  }\n};\n\n/**\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null;\n    /**\n     * @type {null | Array<{ insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map();\n      const target = this.target;\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = array.last(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = array.last(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = array.last(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys;\n    }\n    return this._keys\n  }\n\n  /**\n   * @type {Array<{insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      const target = this.target;\n      const added = set.create();\n      const deleted = set.create();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => math.abs(index - a.index) < math.abs(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && math.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = math.max(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    map.setIfUndefined(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c);\n        break\n      default:\n        packJsonContent();\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n            left.integrate(transaction, 0);\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n            left.integrate(transaction, 0);\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n              left.integrate(transaction, 0);\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  });\n  packJsonContent();\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw error.create('array length exceeded')\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = map => iterator.iteratorFilter(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted);\n\n/**\n * @module YArray\n */\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nclass YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ));\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYArray = decoder => new YArray();\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYMap = decoder => new YMap();\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object.equalFlat(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      error.unexpectedCase();\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let nextFormat = currPos.left;\n  const right = currPos.right;\n  negatedAttributes.forEach((val, key) => {\n    nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), nextFormat, nextFormat && nextFormat.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content));\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = map.create();\n    const currentAttributes = map.copy(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = map.copy(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = map.copy(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, map.copy(currPos.currentAttributes));\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      };\n      this._changes = changes;\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      /**\n       * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = [];\n      transact(y, transaction => {\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op;\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen };\n                deleteLen = 0;\n                break\n              case 'insert':\n                op = { insert };\n                if (currentAttributes.size > 0) {\n                  op.attributes = {};\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value;\n                    }\n                  });\n                }\n                insert = '';\n                break\n              case 'retain':\n                op = { retain };\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {};\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key];\n                  }\n                }\n                retain = 0;\n                break\n            }\n            delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = /** @type {ContentEmbed} */ (item.content).embed;\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      attributes[key] = value;\n                    } else {\n                      delete attributes[key];\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    const doc = transaction.doc;\n    callTypeObservers(this, transaction, event);\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false;\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this);\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot);\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot);\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    }, splitSnapshotAffectedStructs);\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = decoder => new YText();\n\n/**\n * @module YXml\n */\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw error.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = decoder => new YXmlFragment();\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key]);\n    }\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key]);\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw error.methodUnimplemented()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '�';\n      // replace right as well\n      right.str = '�' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n  } else {\n    // Is a map item. Insert as current value\n    left = item;\n    while (left.right !== null) {\n      left = left.right;\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub));\n    }\n    right = null;\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? binary.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & binary.BIT4) > 0) !== isMarked) {\n      this.info ^= binary.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & binary.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & binary.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= binary.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & binary.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & binary.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= binary.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= binary.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw error.unexpectedCase()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & binary.BITS5) |\n      (origin === null ? 0 : binary.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : binary.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : binary.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      if (parent._item !== undefined) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true); // write parentYKey\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false); // write parent id\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parent);\n      } else {\n        error.unexpectedCase();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & binary.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nconst contentRefs = [\n  () => { error.unexpectedCase(); }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { error.unexpectedCase(); } // 10 - Skip is not ItemContent\n];\n\nconst structSkipRefNumber = 10;\n\n/**\n * @private\n */\nclass Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    error.unexpectedCase();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    encoding.writeVarUint(encoder.restEncoder, this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nexports.AbstractConnector = AbstractConnector;\nexports.AbstractStruct = AbstractStruct;\nexports.AbstractType = AbstractType;\nexports.Array = YArray;\nexports.ContentAny = ContentAny;\nexports.ContentBinary = ContentBinary;\nexports.ContentDeleted = ContentDeleted;\nexports.ContentEmbed = ContentEmbed;\nexports.ContentFormat = ContentFormat;\nexports.ContentJSON = ContentJSON;\nexports.ContentString = ContentString;\nexports.ContentType = ContentType;\nexports.Doc = Doc;\nexports.GC = GC;\nexports.ID = ID;\nexports.Item = Item;\nexports.Map = YMap;\nexports.PermanentUserData = PermanentUserData;\nexports.RelativePosition = RelativePosition;\nexports.Snapshot = Snapshot;\nexports.Text = YText;\nexports.Transaction = Transaction;\nexports.UndoManager = UndoManager;\nexports.XmlElement = YXmlElement;\nexports.XmlFragment = YXmlFragment;\nexports.XmlHook = YXmlHook;\nexports.XmlText = YXmlText;\nexports.YArrayEvent = YArrayEvent;\nexports.YEvent = YEvent;\nexports.YMapEvent = YMapEvent;\nexports.YTextEvent = YTextEvent;\nexports.YXmlEvent = YXmlEvent;\nexports.applyUpdate = applyUpdate;\nexports.applyUpdateV2 = applyUpdateV2;\nexports.compareIDs = compareIDs;\nexports.compareRelativePositions = compareRelativePositions;\nexports.createAbsolutePositionFromRelativePosition = createAbsolutePositionFromRelativePosition;\nexports.createDeleteSet = createDeleteSet;\nexports.createDeleteSetFromStructStore = createDeleteSetFromStructStore;\nexports.createDocFromSnapshot = createDocFromSnapshot;\nexports.createID = createID;\nexports.createRelativePositionFromJSON = createRelativePositionFromJSON;\nexports.createRelativePositionFromTypeIndex = createRelativePositionFromTypeIndex;\nexports.createSnapshot = createSnapshot;\nexports.decodeRelativePosition = decodeRelativePosition;\nexports.decodeSnapshot = decodeSnapshot;\nexports.decodeSnapshotV2 = decodeSnapshotV2;\nexports.decodeStateVector = decodeStateVector;\nexports.diffUpdate = diffUpdate;\nexports.diffUpdateV2 = diffUpdateV2;\nexports.emptySnapshot = emptySnapshot;\nexports.encodeRelativePosition = encodeRelativePosition;\nexports.encodeSnapshot = encodeSnapshot;\nexports.encodeSnapshotV2 = encodeSnapshotV2;\nexports.encodeStateAsUpdate = encodeStateAsUpdate;\nexports.encodeStateAsUpdateV2 = encodeStateAsUpdateV2;\nexports.encodeStateVector = encodeStateVector;\nexports.encodeStateVectorFromUpdate = encodeStateVectorFromUpdate;\nexports.encodeStateVectorFromUpdateV2 = encodeStateVectorFromUpdateV2;\nexports.equalSnapshots = equalSnapshots;\nexports.findRootTypeKey = findRootTypeKey;\nexports.getItem = getItem;\nexports.getState = getState;\nexports.getTypeChildren = getTypeChildren;\nexports.isDeleted = isDeleted;\nexports.isParentOf = isParentOf;\nexports.iterateDeletedStructs = iterateDeletedStructs;\nexports.logType = logType;\nexports.logUpdate = logUpdate;\nexports.logUpdateV2 = logUpdateV2;\nexports.mergeUpdates = mergeUpdates;\nexports.mergeUpdatesV2 = mergeUpdatesV2;\nexports.parseUpdateMeta = parseUpdateMeta;\nexports.parseUpdateMetaV2 = parseUpdateMetaV2;\nexports.readUpdate = readUpdate;\nexports.readUpdateV2 = readUpdateV2;\nexports.relativePositionToJSON = relativePositionToJSON;\nexports.snapshot = snapshot;\nexports.transact = transact;\nexports.tryGc = tryGc;\nexports.typeListToArraySnapshot = typeListToArraySnapshot;\nexports.typeMapGetSnapshot = typeMapGetSnapshot;\n//# sourceMappingURL=yjs.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5janM/ZGQ3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7O0FBRTdELG9CQUFvQixtQkFBTyxDQUFDLHlFQUEwQjtBQUN0RCxZQUFZLG1CQUFPLENBQUMsK0RBQXFCO0FBQ3pDLFdBQVcsbUJBQU8sQ0FBQyw2REFBb0I7QUFDdkMsVUFBVSxtQkFBTyxDQUFDLDJEQUFtQjtBQUNyQyxlQUFlLG1CQUFPLENBQUMscUVBQXdCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxxRUFBd0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGlFQUFzQjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsaUVBQXNCO0FBQzNDLFlBQVksbUJBQU8sQ0FBQywrREFBcUI7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGlFQUFzQjtBQUMzQyxRQUFRLG1CQUFPLENBQUMscUVBQXdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQywyREFBbUI7QUFDckMsY0FBYyxtQkFBTyxDQUFDLG1FQUF1QjtBQUM3QyxXQUFXLG1CQUFPLENBQUMsNkRBQW9CO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBd0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLGlFQUFzQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Q3ZCLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYiwrQkFBK0I7QUFDL0IsMEJBQTBCO0FBQzFCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBvYnNlcnZhYmxlX2pzID0gcmVxdWlyZSgnbGliMC9kaXN0L29ic2VydmFibGUuY2pzJyk7XG52YXIgYXJyYXkgPSByZXF1aXJlKCdsaWIwL2Rpc3QvYXJyYXkuY2pzJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJ2xpYjAvZGlzdC9tYXRoLmNqcycpO1xudmFyIG1hcCA9IHJlcXVpcmUoJ2xpYjAvZGlzdC9tYXAuY2pzJyk7XG52YXIgZW5jb2RpbmcgPSByZXF1aXJlKCdsaWIwL2Rpc3QvZW5jb2RpbmcuY2pzJyk7XG52YXIgZGVjb2RpbmcgPSByZXF1aXJlKCdsaWIwL2Rpc3QvZGVjb2RpbmcuY2pzJyk7XG52YXIgcmFuZG9tID0gcmVxdWlyZSgnbGliMC9kaXN0L3JhbmRvbS5janMnKTtcbnZhciBidWZmZXIgPSByZXF1aXJlKCdsaWIwL2Rpc3QvYnVmZmVyLmNqcycpO1xudmFyIGVycm9yID0gcmVxdWlyZSgnbGliMC9kaXN0L2Vycm9yLmNqcycpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJ2xpYjAvZGlzdC9iaW5hcnkuY2pzJyk7XG52YXIgZiA9IHJlcXVpcmUoJ2xpYjAvZGlzdC9mdW5jdGlvbi5janMnKTtcbnZhciBzZXQgPSByZXF1aXJlKCdsaWIwL2Rpc3Qvc2V0LmNqcycpO1xudmFyIGxvZ2dpbmcgPSByZXF1aXJlKCdsaWIwL2Rpc3QvbG9nZ2luZy5janMnKTtcbnZhciB0aW1lID0gcmVxdWlyZSgnbGliMC9kaXN0L3RpbWUuY2pzJyk7XG52YXIgaXRlcmF0b3IgPSByZXF1aXJlKCdsaWIwL2Rpc3QvaXRlcmF0b3IuY2pzJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnbGliMC9kaXN0L29iamVjdC5janMnKTtcblxuLyoqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSB0aGF0IGFsbCBDb25uZWN0b3JzIHNob3VsZCBpbXBsZW1lbnQgdG8ga2VlcCB0aGVtIGludGVyY2hhbmdlYWJsZS5cbiAqXG4gKiBAbm90ZSBUaGlzIGludGVyZmFjZSBpcyBleHBlcmltZW50YWwgYW5kIGl0IGlzIG5vdCBhZHZpc2VkIHRvIGFjdHVhbGx5IGluaGVyaXQgdGhpcyBjbGFzcy5cbiAqICAgICAgIEl0IGp1c3Qgc2VydmVzIGFzIHR5cGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZTxhbnk+fVxuICovXG5jbGFzcyBBYnN0cmFjdENvbm5lY3RvciBleHRlbmRzIG9ic2VydmFibGVfanMuT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geWRvY1xuICAgKiBAcGFyYW0ge2FueX0gYXdhcmVuZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWRvYywgYXdhcmVuZXNzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvYyA9IHlkb2M7XG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3M7XG4gIH1cbn1cblxuY2xhc3MgRGVsZXRlSXRlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNsb2NrLCBsZW4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9jaztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuICB9XG59XG5cbi8qKlxuICogV2Ugbm8gbG9uZ2VyIG1haW50YWluIGEgRGVsZXRlU3RvcmUuIERlbGV0ZVNldCBpcyBhIHRlbXBvcmFyeSBvYmplY3QgdGhhdCBpcyBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICogLSBXaGVuIGNyZWF0ZWQgaW4gYSB0cmFuc2FjdGlvbiwgaXQgbXVzdCBvbmx5IGJlIGFjY2Vzc2VkIGFmdGVyIHNvcnRpbmcsIGFuZCBtZXJnaW5nXG4gKiAgIC0gVGhpcyBEZWxldGVTZXQgaXMgc2VuZCB0byBvdGhlciBjbGllbnRzXG4gKiAtIFdlIGRvIG5vdCBjcmVhdGUgYSBEZWxldGVTZXQgd2hlbiB3ZSBzZW5kIGEgc3luYyBtZXNzYWdlLiBUaGUgRGVsZXRlU2V0IG1lc3NhZ2UgaXMgY3JlYXRlZCBkaXJlY3RseSBmcm9tIFN0cnVjdFN0b3JlXG4gKiAtIFdlIHJlYWQgYSBEZWxldGVTZXQgYXMgcGFydCBvZiBhIHN5bmMvdXBkYXRlIG1lc3NhZ2UuIEluIHRoaXMgY2FzZSB0aGUgRGVsZXRlU2V0IGlzIGFscmVhZHkgc29ydGVkIGFuZCBtZXJnZWQuXG4gKi9cbmNsYXNzIERlbGV0ZVNldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixBcnJheTxEZWxldGVJdGVtPj59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpO1xuICB9XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCBzdHJ1Y3RzIHRoYXQgdGhlIERlbGV0ZVNldCBnYydzLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpdGVyYXRlRGVsZXRlZFN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIGRzLCBmKSA9PlxuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZXMsIGNsaWVudGlkKSA9PiB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovICh0cmFuc2FjdGlvbi5kb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50aWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlbCA9IGRlbGV0ZXNbaV07XG4gICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RydWN0cywgZGVsLmNsb2NrLCBkZWwubGVuLCBmKTtcbiAgICB9XG4gIH0pO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlSXRlbT59IGRpc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRJbmRleERTID0gKGRpcywgY2xvY2spID0+IHtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSBkaXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICBjb25zdCBtaWQgPSBkaXNbbWlkaW5kZXhdO1xuICAgIGNvbnN0IG1pZGNsb2NrID0gbWlkLmNsb2NrO1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRpbmRleCAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpc0RlbGV0ZWQgPSAoZHMsIGlkKSA9PiB7XG4gIGNvbnN0IGRpcyA9IGRzLmNsaWVudHMuZ2V0KGlkLmNsaWVudCk7XG4gIHJldHVybiBkaXMgIT09IHVuZGVmaW5lZCAmJiBmaW5kSW5kZXhEUyhkaXMsIGlkLmNsb2NrKSAhPT0gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHNvcnRBbmRNZXJnZURlbGV0ZVNldCA9IGRzID0+IHtcbiAgZHMuY2xpZW50cy5mb3JFYWNoKGRlbHMgPT4ge1xuICAgIGRlbHMuc29ydCgoYSwgYikgPT4gYS5jbG9jayAtIGIuY2xvY2spO1xuICAgIC8vIG1lcmdlIGl0ZW1zIHdpdGhvdXQgZmlsdGVyaW5nIG9yIHNwbGljaW5nIHRoZSBhcnJheVxuICAgIC8vIGkgaXMgdGhlIGN1cnJlbnQgcG9pbnRlclxuICAgIC8vIGogcmVmZXJzIHRvIHRoZSBjdXJyZW50IGluc2VydCBwb3NpdGlvbiBmb3IgdGhlIHBvaW50ZWQgaXRlbVxuICAgIC8vIHRyeSB0byBtZXJnZSBkZWxzW2ldIGludG8gZGVsc1tqLTFdIG9yIHNldCBkZWxzW2pdPWRlbHNbaV1cbiAgICBsZXQgaSwgajtcbiAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBkZWxzW2ogLSAxXTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZGVsc1tpXTtcbiAgICAgIGlmIChsZWZ0LmNsb2NrICsgbGVmdC5sZW4gPj0gcmlnaHQuY2xvY2spIHtcbiAgICAgICAgbGVmdC5sZW4gPSBtYXRoLm1heChsZWZ0LmxlbiwgcmlnaHQuY2xvY2sgKyByaWdodC5sZW4gLSBsZWZ0LmNsb2NrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChqIDwgaSkge1xuICAgICAgICAgIGRlbHNbal0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbHMubGVuZ3RoID0gajtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlU2V0Pn0gZHNzXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9IEEgZnJlc2ggRGVsZXRlU2V0XG4gKi9cbmNvbnN0IG1lcmdlRGVsZXRlU2V0cyA9IGRzcyA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgZm9yIChsZXQgZHNzSSA9IDA7IGRzc0kgPCBkc3MubGVuZ3RoOyBkc3NJKyspIHtcbiAgICBkc3NbZHNzSV0uY2xpZW50cy5mb3JFYWNoKChkZWxzTGVmdCwgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoIW1lcmdlZC5jbGllbnRzLmhhcyhjbGllbnQpKSB7XG4gICAgICAgIC8vIFdyaXRlIGFsbCBtaXNzaW5nIGtleXMgZnJvbSBjdXJyZW50IGRzIGFuZCBhbGwgZm9sbG93aW5nLlxuICAgICAgICAvLyBJZiBtZXJnZWQgYWxyZWFkeSBjb250YWlucyBgY2xpZW50YCBjdXJyZW50IGRzIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWxzID0gZGVsc0xlZnQuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGRzc0kgKyAxOyBpIDwgZHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkuYXBwZW5kVG8oZGVscywgZHNzW2ldLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW10pO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5jbGllbnRzLnNldChjbGllbnQsIGRlbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldChtZXJnZWQpO1xuICByZXR1cm4gbWVyZ2VkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRUb0RlbGV0ZVNldCA9IChkcywgY2xpZW50LCBjbG9jaywgbGVuZ3RoKSA9PiB7XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IFtdKS5wdXNoKG5ldyBEZWxldGVJdGVtKGNsb2NrLCBsZW5ndGgpKTtcbn07XG5cbmNvbnN0IGNyZWF0ZURlbGV0ZVNldCA9ICgpID0+IG5ldyBEZWxldGVTZXQoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzc1xuICogQHJldHVybiB7RGVsZXRlU2V0fSBNZXJnZWQgYW5kIHNvcnRlZCBEZWxldGVTZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSA9IHNzID0+IHtcbiAgY29uc3QgZHMgPSBjcmVhdGVEZWxldGVTZXQoKTtcbiAgc3MuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICovXG4gICAgY29uc3QgZHNpdGVtcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpXTtcbiAgICAgIGlmIChzdHJ1Y3QuZGVsZXRlZCkge1xuICAgICAgICBjb25zdCBjbG9jayA9IHN0cnVjdC5pZC5jbG9jaztcbiAgICAgICAgbGV0IGxlbiA9IHN0cnVjdC5sZW5ndGg7XG4gICAgICAgIGlmIChpICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgbmV4dCA9IHN0cnVjdHNbaSArIDFdOyBpICsgMSA8IHN0cnVjdHMubGVuZ3RoICYmIG5leHQuaWQuY2xvY2sgPT09IGNsb2NrICsgbGVuICYmIG5leHQuZGVsZXRlZDsgbmV4dCA9IHN0cnVjdHNbKytpICsgMV0pIHtcbiAgICAgICAgICAgIGxlbiArPSBuZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZHNpdGVtcy5wdXNoKG5ldyBEZWxldGVJdGVtKGNsb2NrLCBsZW4pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRzaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgZHMuY2xpZW50cy5zZXQoY2xpZW50LCBkc2l0ZW1zKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZHNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlRGVsZXRlU2V0ID0gKGVuY29kZXIsIGRzKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBkcy5jbGllbnRzLnNpemUpO1xuICBkcy5jbGllbnRzLmZvckVhY2goKGRzaXRlbXMsIGNsaWVudCkgPT4ge1xuICAgIGVuY29kZXIucmVzZXREc0N1clZhbCgpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpO1xuICAgIGNvbnN0IGxlbiA9IGRzaXRlbXMubGVuZ3RoO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkc2l0ZW1zW2ldO1xuICAgICAgZW5jb2Rlci53cml0ZURzQ2xvY2soaXRlbS5jbG9jayk7XG4gICAgICBlbmNvZGVyLndyaXRlRHNMZW4oaXRlbS5sZW4pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7RGVsZXRlU2V0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZERlbGV0ZVNldCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBkcyA9IG5ldyBEZWxldGVTZXQoKTtcbiAgY29uc3QgbnVtQ2xpZW50cyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsaWVudHM7IGkrKykge1xuICAgIGRlY29kZXIucmVzZXREc0N1clZhbCgpO1xuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IG51bWJlck9mRGVsZXRlcyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGlmIChudW1iZXJPZkRlbGV0ZXMgPiAwKSB7XG4gICAgICBjb25zdCBkc0ZpZWxkID0gbWFwLnNldElmVW5kZWZpbmVkKGRzLmNsaWVudHMsIGNsaWVudCwgKCkgPT4gW10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRlbGV0ZXM7IGkrKykge1xuICAgICAgICBkc0ZpZWxkLnB1c2gobmV3IERlbGV0ZUl0ZW0oZGVjb2Rlci5yZWFkRHNDbG9jaygpLCBkZWNvZGVyLnJlYWREc0xlbigpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkc1xufTtcblxuLyoqXG4gKiBAdG9kbyBZRGVjb2RlciBhbHNvIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gU3RyaW5nIGFuZCBvdGhlciBEZWNvZGVycy4gV291bGQgbWFrZSBzZW5zZSB0byBleGNoYW5nZSBZRGVjb2Rlci50b1VpbnQ4QXJyYXkgZm9yIFlEZWNvZGVyLkRzVG9VaW50OEFycmF5KCkuLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl8bnVsbH0gUmV0dXJucyBhIHYyIHVwZGF0ZSBjb250YWluaW5nIGFsbCBkZWxldGVzIHRoYXQgY291bGRuJ3QgYmUgYXBwbGllZCB5ZXQ7IG9yIG51bGwgaWYgYWxsIGRlbGV0ZXMgd2VyZSBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRBbmRBcHBseURlbGV0ZVNldCA9IChkZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpID0+IHtcbiAgY29uc3QgdW5hcHBsaWVkRFMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGNvbnN0IG51bUNsaWVudHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsb2NrID0gZGVjb2Rlci5yZWFkRHNDbG9jaygpO1xuICAgICAgY29uc3QgY2xvY2tFbmQgPSBjbG9jayArIGRlY29kZXIucmVhZERzTGVuKCk7XG4gICAgICBpZiAoY2xvY2sgPCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPCBjbG9ja0VuZCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIHN0YXRlLCBjbG9ja0VuZCAtIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBjYW4gaWdub3JlIHRoZSBjYXNlIG9mIEdDIGFuZCBEZWxldGUgc3RydWN0cywgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gc2tpcCB0aGVtXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gICAgICAgIC8vIHNwbGl0IHRoZSBmaXJzdCBpdGVtIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkICYmIHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrKSB7XG4gICAgICAgICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICBpbmRleCsrOyAvLyBpbmNyZWFzZSB3ZSBub3cgd2FudCB0byB1c2UgdGhlIG5leHQgc3RydWN0XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICAgICAgICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGNsb2NrRW5kIDwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4LCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2tFbmQgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJ1Y3QuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIGNsb2NrLCBjbG9ja0VuZCAtIGNsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHVuYXBwbGllZERTLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBkcyA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZHMucmVzdEVuY29kZXIsIDApOyAvLyBlbmNvZGUgMCBzdHJ1Y3RzXG4gICAgd3JpdGVEZWxldGVTZXQoZHMsIHVuYXBwbGllZERTKTtcbiAgICByZXR1cm4gZHMudG9VaW50OEFycmF5KClcbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAbW9kdWxlIFlcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZU5ld0NsaWVudElkID0gcmFuZG9tLnVpbnQzMjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb2NPcHRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmdjPXRydWVdIERpc2FibGUgZ2FyYmFnZSBjb2xsZWN0aW9uIChkZWZhdWx0OiBnYz10cnVlKVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbRG9jT3B0cy5nY0ZpbHRlcl0gV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIEl0ZW0gaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFJldHVybiBmYWxzZSB0byBrZWVwIHRoZSBJdGVtLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtEb2NPcHRzLmd1aWRdIERlZmluZSBhIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGRvY3VtZW50XG4gKiBAcHJvcGVydHkge2FueX0gW0RvY09wdHMubWV0YV0gQW55IGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvbiB5b3Ugd2FudCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIHN0b3JlIHRoZSBtZXRhIGluZm9ybWF0aW9uIGFzIHdlbGwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmF1dG9Mb2FkXSBJZiBhIHN1YmRvY3VtZW50LCBhdXRvbWF0aWNhbGx5IGxvYWQgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgbG9hZCB0aGUgZG9jdW1lbnQgYXMgd2VsbCBhdXRvbWF0aWNhbGx5LlxuICovXG5cbi8qKlxuICogQSBZanMgaW5zdGFuY2UgaGFuZGxlcyB0aGUgc3RhdGUgb2Ygc2hhcmVkIGRhdGEuXG4gKiBAZXh0ZW5kcyBPYnNlcnZhYmxlPHN0cmluZz5cbiAqL1xuY2xhc3MgRG9jIGV4dGVuZHMgb2JzZXJ2YWJsZV9qcy5PYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jT3B0c30gW29wdHNdIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh7IGd1aWQgPSByYW5kb20udXVpZHY0KCksIGdjID0gdHJ1ZSwgZ2NGaWx0ZXIgPSAoKSA9PiB0cnVlLCBtZXRhID0gbnVsbCwgYXV0b0xvYWQgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2MgPSBnYztcbiAgICB0aGlzLmdjRmlsdGVyID0gZ2NGaWx0ZXI7XG4gICAgdGhpcy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKTtcbiAgICB0aGlzLmd1aWQgPSBndWlkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBBYnN0cmFjdFR5cGU8WUV2ZW50Pj59XG4gICAgICovXG4gICAgdGhpcy5zaGFyZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0b3JlID0gbmV3IFN0cnVjdFN0b3JlKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9uIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jcyA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGRvY3VtZW50IGlzIGEgc3ViZG9jdW1lbnQgLSBhIGRvY3VtZW50IGludGVncmF0ZWQgaW50byBhbm90aGVyIGRvY3VtZW50IC0gdGhlbiBfaXRlbSBpcyBkZWZpbmVkLlxuICAgICAqIEB0eXBlIHtJdGVtP31cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICB0aGlzLnNob3VsZExvYWQgPSBhdXRvTG9hZDtcbiAgICB0aGlzLmF1dG9Mb2FkID0gYXV0b0xvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCBkb2N1bWVudCB0aGF0IHlvdSByZXF1ZXN0IHRvIGxvYWQgZGF0YSBpbnRvIHRoaXMgc3ViZG9jdW1lbnQgKGlmIGl0IGlzIGEgc3ViZG9jdW1lbnQpLlxuICAgKlxuICAgKiBgbG9hZCgpYCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmUgdG8gcmVxdWVzdCBhbnkgcHJvdmlkZXIgdG8gbG9hZCB0aGUgbW9zdCBjdXJyZW50IGRhdGEuXG4gICAqXG4gICAqIEl0IGlzIHNhZmUgdG8gY2FsbCBgbG9hZCgpYCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtO1xuICAgIGlmIChpdGVtICE9PSBudWxsICYmICF0aGlzLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbS5wYXJlbnQpLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZExvYWQgPSB0cnVlO1xuICB9XG5cbiAgZ2V0U3ViZG9jcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViZG9jc1xuICB9XG5cbiAgZ2V0U3ViZG9jR3VpZHMgKCkge1xuICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5tYXAoZG9jID0+IGRvYy5ndWlkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoYXQgaGFwcGVuIGluc2lkZSBvZiBhIHRyYW5zYWN0aW9uIGFyZSBidW5kbGVkLiBUaGlzIG1lYW5zIHRoYXRcbiAgICogdGhlIG9ic2VydmVyIGZpcmVzIF9hZnRlcl8gdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkIGFuZCB0aGF0IGFsbCBjaGFuZ2VzXG4gICAqIHRoYXQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSB0cmFuc2FjdGlvbiBhcmUgc2VudCBhcyBvbmUgbWVzc2FnZSB0byB0aGVcbiAgICogb3RoZXIgcGVlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOnZvaWR9IGYgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHthbnl9IFtvcmlnaW5dIE9yaWdpbiBvZiB3aG8gc3RhcnRlZCB0aGUgdHJhbnNhY3Rpb24uIFdpbGwgYmUgc3RvcmVkIG9uIHRyYW5zYWN0aW9uLm9yaWdpblxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0cmFuc2FjdCAoZiwgb3JpZ2luID0gbnVsbCkge1xuICAgIHRyYW5zYWN0KHRoaXMsIGYsIG9yaWdpbik7XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgc2hhcmVkIGRhdGEgdHlwZS5cbiAgICpcbiAgICogTXVsdGlwbGUgY2FsbHMgb2YgYHkuZ2V0KG5hbWUsIFR5cGVDb25zdHJ1Y3RvcilgIHlpZWxkIHRoZSBzYW1lIHJlc3VsdFxuICAgKiBhbmQgZG8gbm90IG92ZXJ3cml0ZSBlYWNoIG90aGVyLiBJLmUuXG4gICAqIGB5LmRlZmluZShuYW1lLCBZLkFycmF5KSA9PT0geS5kZWZpbmUobmFtZSwgWS5BcnJheSlgXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHR5cGUgaXMgYWxzbyBhdmFpbGFibGUgb24gYHkuc2hhcmUuZ2V0KG5hbWUpYC5cbiAgICpcbiAgICogKkJlc3QgUHJhY3RpY2VzOipcbiAgICogRGVmaW5lIGFsbCB0eXBlcyByaWdodCBhZnRlciB0aGUgWWpzIGluc3RhbmNlIGlzIGNyZWF0ZWQgYW5kIHN0b3JlIHRoZW0gaW4gYSBzZXBhcmF0ZSBvYmplY3QuXG4gICAqIEFsc28gdXNlIHRoZSB0eXBlZCBtZXRob2RzIGBnZXRUZXh0KG5hbWUpYCwgYGdldEFycmF5KG5hbWUpYCwgLi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICBjb25zdCB5ID0gbmV3IFkoLi4pXG4gICAqICAgY29uc3QgYXBwU3RhdGUgPSB7XG4gICAqICAgICBkb2N1bWVudDogeS5nZXRUZXh0KCdkb2N1bWVudCcpXG4gICAqICAgICBjb21tZW50czogeS5nZXRBcnJheSgnY29tbWVudHMnKVxuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gVHlwZUNvbnN0cnVjdG9yIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdHlwZSBkZWZpbml0aW9uLiBFLmcuIFkuVGV4dCwgWS5BcnJheSwgWS5NYXAsIC4uLlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8YW55Pn0gVGhlIGNyZWF0ZWQgdHlwZS4gQ29uc3RydWN0ZWQgd2l0aCBUeXBlQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IChuYW1lLCBUeXBlQ29uc3RydWN0b3IgPSBBYnN0cmFjdFR5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gbWFwLnNldElmVW5kZWZpbmVkKHRoaXMuc2hhcmUsIG5hbWUsICgpID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHQgPSBuZXcgVHlwZUNvbnN0cnVjdG9yKCk7XG4gICAgICB0Ll9pbnRlZ3JhdGUodGhpcywgbnVsbCk7XG4gICAgICByZXR1cm4gdFxuICAgIH0pO1xuICAgIGNvbnN0IENvbnN0ciA9IHR5cGUuY29uc3RydWN0b3I7XG4gICAgaWYgKFR5cGVDb25zdHJ1Y3RvciAhPT0gQWJzdHJhY3RUeXBlICYmIENvbnN0ciAhPT0gVHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoQ29uc3RyID09PSBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpO1xuICAgICAgICB0Ll9tYXAgPSB0eXBlLl9tYXA7XG4gICAgICAgIHR5cGUuX21hcC5mb3JFYWNoKC8qKiBAcGFyYW0ge0l0ZW0/fSBuICovIG4gPT4ge1xuICAgICAgICAgIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5sZWZ0KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBuLnBhcmVudCA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdC5fc3RhcnQgPSB0eXBlLl9zdGFydDtcbiAgICAgICAgZm9yIChsZXQgbiA9IHQuX3N0YXJ0OyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgICAgICAgIG4ucGFyZW50ID0gdDtcbiAgICAgICAgfVxuICAgICAgICB0Ll9sZW5ndGggPSB0eXBlLl9sZW5ndGg7XG4gICAgICAgIHRoaXMuc2hhcmUuc2V0KG5hbWUsIHQpO1xuICAgICAgICB0Ll9pbnRlZ3JhdGUodGhpcywgbnVsbCk7XG4gICAgICAgIHJldHVybiB0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgd2l0aCB0aGUgbmFtZSAke25hbWV9IGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCB3aXRoIGEgZGlmZmVyZW50IGNvbnN0cnVjdG9yYClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXJyYXkgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWUFycmF5KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFRleHQgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVRleHQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZTWFwPGFueT59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldE1hcCAobmFtZSA9ICcnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBZTWFwKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRYbWxGcmFnbWVudCAobmFtZSA9ICcnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBZWG1sRnJhZ21lbnQpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGVudGlyZSBkb2N1bWVudCBpbnRvIGEganMgb2JqZWN0LCByZWN1cnNpdmVseSB0cmF2ZXJzaW5nIGVhY2ggeWpzIHR5cGVcbiAgICogRG9lc24ndCBsb2cgdHlwZXMgdGhhdCBoYXZlIG5vdCBiZWVuIGRlZmluZWQgKHVzaW5nIHlkb2MuZ2V0VHlwZSguLikpLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kIGFuZCByYXRoZXIgY2FsbCB0b0pTT04gZGlyZWN0bHkgb24gdGhlIHNoYXJlZCB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgYW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGFueT59XG4gICAgICovXG4gICAgY29uc3QgZG9jID0ge307XG5cbiAgICB0aGlzLnNoYXJlLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGRvY1trZXldID0gdmFsdWUudG9KU09OKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZG9jXG4gIH1cblxuICAvKipcbiAgICogRW1pdCBgZGVzdHJveWAgZXZlbnQgYW5kIHVucmVnaXN0ZXIgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICAgKi9cbiAgZGVzdHJveSAoKSB7XG4gICAgYXJyYXkuZnJvbSh0aGlzLnN1YmRvY3MpLmZvckVhY2goc3ViZG9jID0+IHN1YmRvYy5kZXN0cm95KCkpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtO1xuICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSAvKiogQHR5cGUge0NvbnRlbnREb2N9ICovIChpdGVtLmNvbnRlbnQpO1xuICAgICAgaWYgKGl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnRlbnQuZG9jID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRlbnQuZG9jID0gbmV3IERvYyh7IGd1aWQ6IHRoaXMuZ3VpZCwgLi4uY29udGVudC5vcHRzIH0pO1xuICAgICAgICBjb250ZW50LmRvYy5faXRlbSA9IGl0ZW07XG4gICAgICB9XG4gICAgICB0cmFuc2FjdCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudC5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuYWRkKGNvbnRlbnQuZG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5hZGQodGhpcyk7XG4gICAgICB9LCBudWxsLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95ZWQnLCBbdHJ1ZV0pO1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIFt0aGlzXSk7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnkpOmFueX0gZlxuICAgKi9cbiAgb24gKGV2ZW50TmFtZSwgZikge1xuICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKGV2ZW50TmFtZSwgZikge1xuICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGYpO1xuICB9XG59XG5cbmNsYXNzIERTRGVjb2RlclYxIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlcjtcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIC8vIG5vcFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0Nsb2NrICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNMZW4gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG59XG5cbmNsYXNzIFVwZGF0ZURlY29kZXJWMSBleHRlbmRzIERTRGVjb2RlclYxIHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZExlZnRJRCAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUlEKGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpLCBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRSaWdodElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIG5leHQgY2xpZW50IGlkLlxuICAgKiBVc2UgdGhpcyBpbiBmYXZvciBvZiByZWFkSUQgd2hlbmV2ZXIgcG9zc2libGUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZENsaWVudCAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRJbmZvICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFVpbnQ4KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpc0tleVxuICAgKi9cbiAgcmVhZFBhcmVudEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSA9PT0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkVHlwZVJlZiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHJlYWRMZW4gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRBbnkgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIHJlYWRCdWYgKCkge1xuICAgIHJldHVybiBidWZmZXIuY29weVVpbnQ4QXJyYXkoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogTGVnYWN5IGltcGxlbWVudGF0aW9uIHVzZXMgSlNPTiBwYXJzZS4gV2UgdXNlIGFueS1kZWNvZGluZyBpbiB2Mi5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5jbGFzcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gICAgdGhpcy5yZXN0RGVjb2RlciA9IGRlY29kZXI7XG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpO1xuICAgIHJldHVybiB0aGlzLmRzQ3VyclZhbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgY29uc3QgZGlmZiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpICsgMTtcbiAgICB0aGlzLmRzQ3VyclZhbCArPSBkaWZmO1xuICAgIHJldHVybiBkaWZmXG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRGVjb2RlclYyIGV4dGVuZHMgRFNEZWNvZGVyVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHN1cGVyKGRlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgY2FjaGVkIGtleXMuIElmIHRoZSBrZXlzW2lkXSBkb2VzIG5vdCBleGlzdCwgd2UgcmVhZCBhIG5ldyBrZXlcbiAgICAgKiBmcm9tIHN0cmluZ0VuY29kZXIgYW5kIHB1c2ggaXQgdG8ga2V5cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpOyAvLyByZWFkIGZlYXR1cmUgZmxhZyAtIGN1cnJlbnRseSB1bnVzZWRcbiAgICB0aGlzLmtleUNsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5jbGllbnREZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmxlZnRDbG9ja0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuSW50RGlmZk9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMucmlnaHRDbG9ja0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuSW50RGlmZk9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMuaW5mb0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuUmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgZGVjb2RpbmcucmVhZFVpbnQ4KTtcbiAgICB0aGlzLnN0cmluZ0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuU3RyaW5nRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5wYXJlbnRJbmZvRGVjb2RlciA9IG5ldyBkZWNvZGluZy5SbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVWludDgpO1xuICAgIHRoaXMudHlwZVJlZkRlY29kZXIgPSBuZXcgZGVjb2RpbmcuVWludE9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMubGVuRGVjb2RlciA9IG5ldyBkZWNvZGluZy5VaW50T3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMubGVmdENsb2NrRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkUmlnaHRJRCAoKSB7XG4gICAgcmV0dXJuIG5ldyBJRCh0aGlzLmNsaWVudERlY29kZXIucmVhZCgpLCB0aGlzLnJpZ2h0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBuZXh0IGNsaWVudCBpZC5cbiAgICogVXNlIHRoaXMgaW4gZmF2b3Igb2YgcmVhZElEIHdoZW5ldmVyIHBvc3NpYmxlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIG9iamVjdHMgY3JlYXRlZC5cbiAgICovXG4gIHJlYWRDbGllbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudERlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRJbmZvICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmluZm9EZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdEZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50SW5mb0RlY29kZXIucmVhZCgpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkVHlwZVJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZVJlZkRlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkQW55ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICByZWFkQnVmICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG1haW5seSBoZXJlIGZvciBsZWdhY3kgcHVycG9zZXMuXG4gICAqXG4gICAqIEluaXRpYWwgd2UgaW5jb2RlZCBvYmplY3RzIHVzaW5nIEpTT04uIE5vdyB3ZSB1c2UgdGhlIG11Y2ggZmFzdGVyIGxpYjAvYW55LWVuY29kZXIuIFRoaXMgbWV0aG9kIG1haW5seSBleGlzdHMgZm9yIGxlZ2FjeSBwdXJwb3NlcyBmb3IgdGhlIHYxIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRKU09OICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRLZXkgKCkge1xuICAgIGNvbnN0IGtleUNsb2NrID0gdGhpcy5rZXlDbG9ja0RlY29kZXIucmVhZCgpO1xuICAgIGlmIChrZXlDbG9jayA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXNba2V5Q2xvY2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKCk7XG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBEU0VuY29kZXJWMSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIHdyaXRlRHNDbG9jayAoY2xvY2spIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlRHNMZW4gKGxlbikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4pO1xuICB9XG59XG5cbmNsYXNzIFVwZGF0ZUVuY29kZXJWMSBleHRlbmRzIERTRW5jb2RlclYxIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZUxlZnRJRCAoaWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZVJpZ2h0SUQgKGlkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsaWVudCk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2Ugd3JpdGVDbGllbnQgYW5kIHdyaXRlQ2xvY2sgaW5zdGVhZCBvZiB3cml0ZUlEIGlmIHBvc3NpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqL1xuICB3cml0ZUNsaWVudCAoY2xpZW50KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGNsaWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVJbmZvIChpbmZvKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OCh0aGlzLnJlc3RFbmNvZGVyLCBpbmZvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgKi9cbiAgd3JpdGVTdHJpbmcgKHMpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaXNZS2V5ID8gMSA6IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlVHlwZVJlZiAoaW5mbykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpbmZvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZUxlbiAobGVuKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGFueVxuICAgKi9cbiAgd3JpdGVBbnkgKGFueSkge1xuICAgIGVuY29kaW5nLndyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGFueSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICovXG4gIHdyaXRlQnVmIChidWYpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlciwgYnVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZW1iZWRcbiAgICovXG4gIHdyaXRlSlNPTiAoZW1iZWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBKU09OLnN0cmluZ2lmeShlbWJlZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBrZXkpO1xuICB9XG59XG5cbmNsYXNzIERTRW5jb2RlclYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7IC8vIGVuY29kZXMgYWxsIHRoZSByZXN0IC8gbm9uLW9wdGltaXplZFxuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKVxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGNvbnN0IGRpZmYgPSBjbG9jayAtIHRoaXMuZHNDdXJyVmFsO1xuICAgIHRoaXMuZHNDdXJyVmFsID0gY2xvY2s7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGRpZmYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlRHNMZW4gKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4gLSAxKTtcbiAgICB0aGlzLmRzQ3VyclZhbCArPSBsZW47XG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRW5jb2RlclYyIGV4dGVuZHMgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFJlZmVycyB0byB0aGUgbmV4dCB1bmlxZSBrZXktaWRlbnRpZmllciB0byBtZSB1c2VkLlxuICAgICAqIFNlZSB3cml0ZUtleSBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMua2V5Q2xvY2sgPSAwO1xuICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2RlciA9IG5ldyBlbmNvZGluZy5JbnREaWZmT3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMuaW5mb0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuUmxlRW5jb2RlcihlbmNvZGluZy53cml0ZVVpbnQ4KTtcbiAgICB0aGlzLnN0cmluZ0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuU3RyaW5nRW5jb2RlcigpO1xuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuUmxlRW5jb2RlcihlbmNvZGluZy53cml0ZVVpbnQ4KTtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5sZW5FbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDApOyAvLyB0aGlzIGlzIGEgZmVhdHVyZSBmbGFnIHRoYXQgd2UgbWlnaHQgdXNlIGluIHRoZSBmdXR1cmVcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5rZXlDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmNsaWVudEVuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlZnRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMuaW5mb0VuY29kZXIpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5zdHJpbmdFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucGFyZW50SW5mb0VuY29kZXIpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy50eXBlUmVmRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgLy8gQG5vdGUgVGhlIHJlc3QgZW5jb2RlciBpcyBhcHBlbmRlZCEgKG5vdGUgdGhlIG1pc3NpbmcgdmFyKVxuICAgIGVuY29kaW5nLndyaXRlVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcikpO1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpO1xuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICB0aGlzLmluZm9FbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyLndyaXRlKGlzWUtleSA/IDEgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICB0aGlzLmxlbkVuY29kZXIud3JpdGUobGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgZW1iZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IGtleXMgYXJlIG9mdGVuIHJldXNlZC4gRm9yIGV4YW1wbGUsIGluIHktcHJvc2VtaXJyb3IgdGhlIGtleSBgYm9sZGAgbWlnaHRcbiAgICogb2NjdXIgdmVyeSBvZnRlbi4gRm9yIGEgM2QgYXBwbGljYXRpb24sIHRoZSBrZXkgYHBvc2l0aW9uYCBtaWdodCBvY2N1ciB2ZXJ5IG9mdGVuLlxuICAgKlxuICAgKiBXZSBjYWNoZSB0aGVzZSBrZXlzIGluIGEgTWFwIGFuZCByZWZlciB0byB0aGVtIHZpYSBhIHVuaXF1ZSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBjb25zdCBjbG9jayA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIGlmIChjbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZSh0aGlzLmtleUNsb2NrKyspO1xuICAgICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyLndyaXRlKHRoaXMua2V5Q2xvY2srKyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7QXJyYXk8R0N8SXRlbT59IHN0cnVjdHMgQWxsIHN0cnVjdHMgYnkgYGNsaWVudGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB3cml0ZSBzdHJ1Y3RzIHN0YXJ0aW5nIHdpdGggYElEKGNsaWVudCxjbG9jaylgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0cyA9IChlbmNvZGVyLCBzdHJ1Y3RzLCBjbGllbnQsIGNsb2NrKSA9PiB7XG4gIC8vIHdyaXRlIGZpcnN0IGlkXG4gIGNsb2NrID0gbWF0aC5tYXgoY2xvY2ssIHN0cnVjdHNbMF0uaWQuY2xvY2spOyAvLyBtYWtlIHN1cmUgdGhlIGZpcnN0IGlkIGV4aXN0c1xuICBjb25zdCBzdGFydE5ld1N0cnVjdHMgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzdHJ1Y3RzLmxlbmd0aCAtIHN0YXJ0TmV3U3RydWN0cyk7XG4gIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsb2NrKTtcbiAgY29uc3QgZmlyc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0YXJ0TmV3U3RydWN0c107XG4gIC8vIHdyaXRlIGZpcnN0IHN0cnVjdCB3aXRoIGFuIG9mZnNldFxuICBmaXJzdFN0cnVjdC53cml0ZShlbmNvZGVyLCBjbG9jayAtIGZpcnN0U3RydWN0LmlkLmNsb2NrKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0TmV3U3RydWN0cyArIDE7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBfc21cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlQ2xpZW50c1N0cnVjdHMgPSAoZW5jb2Rlciwgc3RvcmUsIF9zbSkgPT4ge1xuICAvLyB3ZSBmaWx0ZXIgYWxsIHZhbGlkIF9zbSBlbnRyaWVzIGludG8gc21cbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIF9zbS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgLy8gb25seSB3cml0ZSBpZiBuZXcgc3RydWN0cyBhcmUgYXZhaWxhYmxlXG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCBjbGllbnQpID4gY2xvY2spIHtcbiAgICAgIHNtLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICB9XG4gIH0pO1xuICBnZXRTdGF0ZVZlY3RvcihzdG9yZSkuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIGlmICghX3NtLmhhcyhjbGllbnQpKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCAwKTtcbiAgICB9XG4gIH0pO1xuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZFxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc20uc2l6ZSk7XG4gIC8vIFdyaXRlIGl0ZW1zIHdpdGggaGlnaGVyIGNsaWVudCBpZHMgZmlyc3RcbiAgLy8gVGhpcyBoZWF2aWx5IGltcHJvdmVzIHRoZSBjb25mbGljdCBhbGdvcml0aG0uXG4gIEFycmF5LmZyb20oc20uZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyaXRlU3RydWN0cyhlbmNvZGVyLCBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpLCBjbGllbnQsIGNsb2NrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZENsaWVudHNTdHJ1Y3RSZWZzID0gKGRlY29kZXIsIGRvYykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICAgKi9cbiAgY29uc3QgY2xpZW50UmVmcyA9IG1hcC5jcmVhdGUoKTtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IHJlZnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZTdHJ1Y3RzKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKTtcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAvLyBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY2xpZW50UmVmcy5zZXQoY2xpZW50LCB7IGk6IDAsIHJlZnMgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIHN3aXRjaCAoYmluYXJ5LkJJVFM1ICYgaW5mbykge1xuICAgICAgICBjYXNlIDA6IHsgLy8gR0NcbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHsgLy8gU2tpcCBTdHJ1Y3QgKG5vdGhpbmcgdG8gYXBwbHkpXG4gICAgICAgICAgLy8gQHRvZG8gd2UgY291bGQgcmVkdWNlIHRoZSBhbW91bnQgb2YgY2hlY2tzIGJ5IGFkZGluZyBTa2lwIHN0cnVjdCB0byBjbGllbnRSZWZzIHNvIHdlIGtub3cgdGhhdCBzb21ldGhpbmcgaXMgbWlzc2luZy5cbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogeyAvLyBJdGVtIHdpdGggY29udGVudFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAgICogQmVsb3cgYSBub24tb3B0aW1pemVkIHZlcnNpb24gaXMgc2hvd24gdGhhdCBpbXBsZW1lbnRzIHRoZSBiYXNpYyBhbGdvcml0aG0gd2l0aFxuICAgICAgICAgICAqIGEgZmV3IGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwO1xuICAgICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICAvKiBBIG5vbi1vcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobTpcblxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbFxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICBjb25zdCBoYXNQYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvID8gZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpIDogZmFsc2VcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvICYmIGhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGxcblxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgb3JpZ2luLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICByaWdodE9yaWdpbiwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgIWhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IChwYXJlbnRZS2V5ICE9PSBudWxsID8gZG9jLmdldChwYXJlbnRZS2V5KSA6IG51bGwpLCAvLyBwYXJlbnRcbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgICAqL1xuICAgICAgICAgIHJlZnNbaV0gPSBzdHJ1Y3Q7XG4gICAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgfVxuICByZXR1cm4gY2xpZW50UmVmc1xufTtcblxuLyoqXG4gKiBSZXN1bWUgY29tcHV0aW5nIHN0cnVjdHMgZ2VuZXJhdGVkIGJ5IHN0cnVjdCByZWFkZXJzLlxuICpcbiAqIFdoaWxlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbywgd2UgaW50ZWdyYXRlIHN0cnVjdHMgaW4gdGhpcyBvcmRlclxuICogMS4gdG9wIGVsZW1lbnQgb24gc3RhY2ssIGlmIHN0YWNrIGlzIG5vdCBlbXB0eVxuICogMi4gbmV4dCBlbGVtZW50IGZyb20gY3VycmVudCBzdHJ1Y3QgcmVhZGVyIChpZiBlbXB0eSwgdXNlIG5leHQgc3RydWN0IHJlYWRlcilcbiAqXG4gKiBJZiBzdHJ1Y3QgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHN0cnVjdCAocmVmLm1pc3NpbmcpLCB3ZSBwdXQgbmV4dCByZWFkZXIgb2ZcbiAqIGByZWYuaWQuY2xpZW50YCBvbiB0b3Agb2Ygc3RhY2suXG4gKlxuICogQXQgc29tZSBwb2ludCB3ZSBmaW5kIGEgc3RydWN0IHRoYXQgaGFzIG5vIGNhdXNhbCBkZXBlbmRlbmNpZXMsXG4gKiB0aGVuIHdlIHN0YXJ0IGVtcHR5aW5nIHRoZSBzdGFjay5cbiAqXG4gKiBJdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSBjaXJjbGVzOiBpLmUuIHN0cnVjdDEgKGZyb20gY2xpZW50MSkgZGVwZW5kcyBvbiBzdHJ1Y3QyIChmcm9tIGNsaWVudDIpXG4gKiBkZXBlbmRzIG9uIHN0cnVjdDMgKGZyb20gY2xpZW50MSkuIFRoZXJlZm9yZSB0aGUgbWF4IHN0YWNrIHNpemUgaXMgZXFhdWwgdG8gYHN0cnVjdFJlYWRlcnMubGVuZ3RoYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCBpbiBhIHdheSBzbyB0aGF0IHdlIGNhbiByZXN1bWUgY29tcHV0YXRpb24gaWYgdGhpcyB1cGRhdGVcbiAqIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiAoR0MgfCBJdGVtKVtdIH0+fSBjbGllbnRzU3RydWN0UmVmc1xuICogQHJldHVybiB7IG51bGwgfCB7IHVwZGF0ZTogVWludDhBcnJheSwgbWlzc2luZzogTWFwPG51bWJlcixudW1iZXI+IH0gfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW50ZWdyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGNsaWVudHNTdHJ1Y3RSZWZzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbSB8IEdDPn1cbiAgICovXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIC8vIHNvcnQgdGhlbSBzbyB0aGF0IHdlIHRha2UgdGhlIGhpZ2hlciBpZCBmaXJzdCwgaW4gY2FzZSBvZiBjb25mbGljdHMgdGhlIGxvd2VyIGlkIHdpbGwgcHJvYmFibHkgbm90IGNvbmZsaWN0IHdpdGggdGhlIGlkIGZyb20gdGhlIGhpZ2hlciB1c2VyLlxuICBsZXQgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBBcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBnZXROZXh0U3RydWN0VGFyZ2V0ID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGxldCBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSk7XG4gICAgd2hpbGUgKG5leHRTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoID09PSBuZXh0U3RydWN0c1RhcmdldC5pKSB7XG4gICAgICBjbGllbnRzU3RydWN0UmVmc0lkcy5wb3AoKTtcbiAgICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RydWN0c1RhcmdldFxuICB9O1xuICBsZXQgY3VyU3RydWN0c1RhcmdldCA9IGdldE5leHRTdHJ1Y3RUYXJnZXQoKTtcbiAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwgJiYgc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RydWN0U3RvcmV9XG4gICAqL1xuICBjb25zdCByZXN0U3RydWN0cyA9IG5ldyBTdHJ1Y3RTdG9yZSgpO1xuICBjb25zdCBtaXNzaW5nU1YgPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgY29uc3QgdXBkYXRlTWlzc2luZ1N2ID0gKGNsaWVudCwgY2xvY2spID0+IHtcbiAgICBjb25zdCBtY2xvY2sgPSBtaXNzaW5nU1YuZ2V0KGNsaWVudCk7XG4gICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICBtaXNzaW5nU1Yuc2V0KGNsaWVudCwgY2xvY2spO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEB0eXBlIHtHQ3xJdGVtfVxuICAgKi9cbiAgbGV0IHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoY3VyU3RydWN0c1RhcmdldCkucmVmc1svKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLmkrK107XG4gIC8vIGNhY2hpbmcgdGhlIHN0YXRlIGJlY2F1c2UgaXQgaXMgdXNlZCB2ZXJ5IG9mdGVuXG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0IGFkZFN0YWNrVG9SZXN0U1MgPSAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHN0YWNrKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSBpdGVtLmlkLmNsaWVudDtcbiAgICAgIGNvbnN0IHVuYXBwbGljYWJsZUl0ZW1zID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudCk7XG4gICAgICBpZiAodW5hcHBsaWNhYmxlSXRlbXMpIHtcbiAgICAgICAgLy8gZGVjcmVtZW50IGJlY2F1c2Ugd2Ugd2VyZW4ndCBhYmxlIHRvIGFwcGx5IHByZXZpb3VzIG9wZXJhdGlvblxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pLS07XG4gICAgICAgIHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2V0KGNsaWVudCwgdW5hcHBsaWNhYmxlSXRlbXMucmVmcy5zbGljZSh1bmFwcGxpY2FibGVJdGVtcy5pKSk7XG4gICAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzLmRlbGV0ZShjbGllbnQpO1xuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pID0gMDtcbiAgICAgICAgdW5hcHBsaWNhYmxlSXRlbXMucmVmcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXRlbSB3YXMgdGhlIGxhc3QgaXRlbSBvbiBjbGllbnRzU3RydWN0UmVmcyBhbmQgdGhlIGZpZWxkIHdhcyBhbHJlYWR5IGNsZWFyZWQuIEFkZCBpdGVtIHRvIHJlc3RTdHJ1Y3RzIGFuZCBjb250aW51ZVxuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIFtpdGVtXSk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xpZW50IGZyb20gY2xpZW50c1N0cnVjdFJlZnNJZHMgdG8gcHJldmVudCB1c2VycyBmcm9tIGFwcGx5aW5nIHRoZSBzYW1lIHVwZGF0ZSBhZ2FpblxuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBjbGllbnRzU3RydWN0UmVmc0lkcy5maWx0ZXIoYyA9PiBjICE9PSBjbGllbnQpO1xuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0IHJlYWRlcnMgdW50aWwgd2UgYXJlIGRvbmVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoc3RhY2tIZWFkLmNvbnN0cnVjdG9yICE9PSBTa2lwKSB7XG4gICAgICBjb25zdCBsb2NhbENsb2NrID0gbWFwLnNldElmVW5kZWZpbmVkKHN0YXRlLCBzdGFja0hlYWQuaWQuY2xpZW50LCAoKSA9PiBnZXRTdGF0ZShzdG9yZSwgc3RhY2tIZWFkLmlkLmNsaWVudCkpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbG9jYWxDbG9jayAtIHN0YWNrSGVhZC5pZC5jbG9jaztcbiAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIHRoZSBzYW1lIGNsaWVudCBpcyBtaXNzaW5nXG4gICAgICAgIHN0YWNrLnB1c2goc3RhY2tIZWFkKTtcbiAgICAgICAgdXBkYXRlTWlzc2luZ1N2KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayAtIDEpO1xuICAgICAgICAvLyBoaWQgYSBkZWFkIHdhbGwsIGFkZCBhbGwgaXRlbXMgZnJvbSBzdGFjayB0byByZXN0U1NcbiAgICAgICAgYWRkU3RhY2tUb1Jlc3RTUygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHN0YWNrSGVhZC5nZXRNaXNzaW5nKHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gICAgICAgIGlmIChtaXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgICAgIC8vIGdldCB0aGUgc3RydWN0IHJlYWRlciB0aGF0IGhhcyB0aGUgbWlzc2luZyBzdHJ1Y3RcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7eyByZWZzOiBBcnJheTxHQ3xJdGVtPiwgaTogbnVtYmVyIH19XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3Qgc3RydWN0UmVmcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldCgvKiogQHR5cGUge251bWJlcn0gKi8gKG1pc3NpbmcpKSB8fCB7IHJlZnM6IFtdLCBpOiAwIH07XG4gICAgICAgICAgaWYgKHN0cnVjdFJlZnMucmVmcy5sZW5ndGggPT09IHN0cnVjdFJlZnMuaSkge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgbWVzc2FnZSBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlIG1lc3NhZ2UgdGhhdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICAgICAgdXBkYXRlTWlzc2luZ1N2KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZyksIGdldFN0YXRlKHN0b3JlLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICBhZGRTdGFja1RvUmVzdFNTKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrSGVhZCA9IHN0cnVjdFJlZnMucmVmc1tzdHJ1Y3RSZWZzLmkrK107XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDAgfHwgb2Zmc2V0IDwgc3RhY2tIZWFkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGFsbCBmaW5lLCBhcHBseSB0aGUgc3RhY2toZWFkXG4gICAgICAgICAgc3RhY2tIZWFkLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgICBzdGF0ZS5zZXQoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrICsgc3RhY2tIZWFkLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaXRlcmF0ZSB0byBuZXh0IHN0YWNrSGVhZFxuICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChzdGFjay5wb3AoKSk7XG4gICAgfSBlbHNlIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ICE9PSBudWxsICYmIGN1clN0cnVjdHNUYXJnZXQuaSA8IGN1clN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpO1xuICAgICAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgYXJlIGRvbmUhXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnNbY3VyU3RydWN0c1RhcmdldC5pKytdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICAgIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgcmVzdFN0cnVjdHMsIG5ldyBNYXAoKSk7XG4gICAgLy8gd3JpdGUgZW1wdHkgZGVsZXRlc2V0XG4gICAgLy8gd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgbmV3IERlbGV0ZVNldCgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCAwKTsgLy8gPT4gbm8gbmVlZCBmb3IgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbCwganVzdCB3cml0ZSAwIGRlbGV0ZXNcbiAgICByZXR1cm4geyBtaXNzaW5nOiBtaXNzaW5nU1YsIHVwZGF0ZTogZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24gPSAoZW5jb2RlciwgdHJhbnNhY3Rpb24pID0+IHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBbc3RydWN0RGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZVYyID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBzdHJ1Y3REZWNvZGVyID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGVyKSkgPT5cbiAgdHJhbnNhY3QoeWRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCByZXRyeSA9IGZhbHNlO1xuICAgIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgICAvLyBsZXQgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHNzID0gcmVhZENsaWVudHNTdHJ1Y3RSZWZzKHN0cnVjdERlY29kZXIsIGRvYyk7XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVhZCBzdHJ1Y3RzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gbWVyZ2U6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCByZXN0U3RydWN0cyA9IGludGVncmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0b3JlLCBzcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IHN0b3JlLnBlbmRpbmdTdHJ1Y3RzO1xuICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gYXBwbHkgc29tZXRoaW5nXG4gICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiBwZW5kaW5nLm1pc3NpbmcpIHtcbiAgICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgICByZXRyeSA9IHRydWU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3RTdHJ1Y3RzKSB7XG4gICAgICAgIC8vIG1lcmdlIHJlc3RTdHJ1Y3RzIGludG8gc3RvcmUucGVuZGluZ1xuICAgICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiByZXN0U3RydWN0cy5taXNzaW5nKSB7XG4gICAgICAgICAgY29uc3QgbWNsb2NrID0gcGVuZGluZy5taXNzaW5nLmdldChjbGllbnQpO1xuICAgICAgICAgIGlmIChtY2xvY2sgPT0gbnVsbCB8fCBtY2xvY2sgPiBjbG9jaykge1xuICAgICAgICAgICAgcGVuZGluZy5taXNzaW5nLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZy51cGRhdGUgPSBtZXJnZVVwZGF0ZXNWMihbcGVuZGluZy51cGRhdGUsIHJlc3RTdHJ1Y3RzLnVwZGF0ZV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZS5wZW5kaW5nU3RydWN0cyA9IHJlc3RTdHJ1Y3RzO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBpbnRlZ3JhdGU6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCBkc1Jlc3QgPSByZWFkQW5kQXBwbHlEZWxldGVTZXQoc3RydWN0RGVjb2RlciwgdHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICBpZiAoc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgICAvLyBAdG9kbyB3ZSBjb3VsZCBtYWtlIGEgbG93ZXItYm91bmQgc3RhdGUtdmVjdG9yIGNoZWNrIGFzIHdlIGRvIGFib3ZlXG4gICAgICBjb25zdCBwZW5kaW5nRFNVcGRhdGUgPSBuZXcgVXBkYXRlRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoc3RvcmUucGVuZGluZ0RzKSk7XG4gICAgICBkZWNvZGluZy5yZWFkVmFyVWludChwZW5kaW5nRFNVcGRhdGUucmVzdERlY29kZXIpOyAvLyByZWFkIDAgc3RydWN0cywgYmVjYXVzZSB3ZSBvbmx5IGVuY29kZSBkZWxldGVzIGluIHBlbmRpbmdkc3VwZGF0ZVxuICAgICAgY29uc3QgZHNSZXN0MiA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChwZW5kaW5nRFNVcGRhdGUsIHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gICAgICBpZiAoZHNSZXN0ICYmIGRzUmVzdDIpIHtcbiAgICAgICAgLy8gY2FzZSAxOiBkczEgIT0gbnVsbCAmJiBkczIgIT0gbnVsbFxuICAgICAgICBzdG9yZS5wZW5kaW5nRHMgPSBtZXJnZVVwZGF0ZXNWMihbZHNSZXN0LCBkc1Jlc3QyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYXNlIDI6IGRzMSAhPSBudWxsXG4gICAgICAgIC8vIGNhc2UgMzogZHMyICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSA0OiBkczEgPT0gbnVsbCAmJiBkczIgPT0gbnVsbFxuICAgICAgICBzdG9yZS5wZW5kaW5nRHMgPSBkc1Jlc3QgfHwgZHNSZXN0MjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRWl0aGVyIGRzUmVzdCA9PSBudWxsICYmIHBlbmRpbmdEcyA9PSBudWxsIE9SIGRzUmVzdCAhPSBudWxsXG4gICAgICBzdG9yZS5wZW5kaW5nRHMgPSBkc1Jlc3Q7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGNsZWFudXA6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlc3VtZSBkZWxldGUgcmVhZGVyczogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGlmIChyZXRyeSkge1xuICAgICAgY29uc3QgdXBkYXRlID0gLyoqIEB0eXBlIHt7dXBkYXRlOiBVaW50OEFycmF5fX0gKi8gKHN0b3JlLnBlbmRpbmdTdHJ1Y3RzKS51cGRhdGU7XG4gICAgICBzdG9yZS5wZW5kaW5nU3RydWN0cyA9IG51bGw7XG4gICAgICBhcHBseVVwZGF0ZVYyKHRyYW5zYWN0aW9uLmRvYywgdXBkYXRlKTtcbiAgICB9XG4gIH0sIHRyYW5zYWN0aW9uT3JpZ2luLCBmYWxzZSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZSA9IChkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gcmVhZFVwZGF0ZVYyKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBuZXcgVXBkYXRlRGVjb2RlclYxKGRlY29kZXIpKTtcblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhcHBseVVwZGF0ZVYyID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4sIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSk7XG4gIHJlYWRVcGRhdGVWMihkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgbmV3IFlEZWNvZGVyKGRlY29kZXIpKTtcbn07XG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYXBwbHlVcGRhdGUgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gYXBwbHlVcGRhdGVWMih5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlVmVjdG9yYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gW3RhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RhdGVBc1VwZGF0ZSA9IChlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yID0gbmV3IE1hcCgpKSA9PiB7XG4gIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgZG9jLnN0b3JlLCB0YXJnZXRTdGF0ZVZlY3Rvcik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpKTtcbn07XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVBc1VwZGF0ZVYyID0gKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoWzBdKSwgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKSkgPT4ge1xuICBjb25zdCB0YXJnZXRTdGF0ZVZlY3RvciA9IGRlY29kZVN0YXRlVmVjdG9yKGVuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcik7XG4gIHdyaXRlU3RhdGVBc1VwZGF0ZShlbmNvZGVyLCBkb2MsIHRhcmdldFN0YXRlVmVjdG9yKTtcbiAgY29uc3QgdXBkYXRlcyA9IFtlbmNvZGVyLnRvVWludDhBcnJheSgpXTtcbiAgLy8gYWxzbyBhZGQgdGhlIHBlbmRpbmcgdXBkYXRlcyAoaWYgdGhlcmUgYXJlIGFueSlcbiAgLy8gQHRvZG8gc3VwcG9ydCBkaWZmaXJlbnQgZW5jb2RlcnNcbiAgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMikge1xuICAgIGlmIChkb2Muc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgICB1cGRhdGVzLnB1c2goZG9jLnN0b3JlLnBlbmRpbmdEcyk7XG4gICAgfVxuICAgIGlmIChkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMpIHtcbiAgICAgIHVwZGF0ZXMucHVzaChkaWZmVXBkYXRlVjIoZG9jLnN0b3JlLnBlbmRpbmdTdHJ1Y3RzLnVwZGF0ZSwgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBtZXJnZVVwZGF0ZXNWMih1cGRhdGVzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXBkYXRlc1swXVxufTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlIHRoYXQgY2FuIGJlIGFwcGxpZWQgb24gdGhlIHJlbW90ZSBkb2N1bWVudC4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogVXNlIGB3cml0ZVN0YXRlQXNVcGRhdGVgIGluc3RlYWQgaWYgeW91IGFyZSB3b3JraW5nIHdpdGggbGliMC9lbmNvZGluZy5qcyNFbmNvZGVyXG4gKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlID0gKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSA9PiBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IsIG5ldyBVcGRhdGVFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogUmVhZCBzdGF0ZSB2ZWN0b3IgZnJvbSBEZWNvZGVyIGFuZCByZXR1cm4gYXMgTWFwXG4gKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFN0YXRlVmVjdG9yID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHNzID0gbmV3IE1hcCgpO1xuICBjb25zdCBzc0xlbmd0aCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIHNzLnNldChjbGllbnQsIGNsb2NrKTtcbiAgfVxuICByZXR1cm4gc3Ncbn07XG5cbi8qKlxuICogUmVhZCBkZWNvZGVkU3RhdGUgYW5kIHJldHVybiBTdGF0ZSBhcyBNYXAuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkZWNvZGVkU3RhdGVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG4vLyBleHBvcnQgY29uc3QgZGVjb2RlU3RhdGVWZWN0b3JWMiA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpXG5cbi8qKlxuICogUmVhZCBkZWNvZGVkU3RhdGUgYW5kIHJldHVybiBTdGF0ZSBhcyBNYXAuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkZWNvZGVkU3RhdGVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWNvZGVTdGF0ZVZlY3RvciA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2XG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBzdikgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3Yuc2l6ZSk7XG4gIHN2LmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KTsgLy8gQHRvZG8gdXNlIGEgc3BlY2lhbCBjbGllbnQgZGVjb2RlciB0aGF0IGlzIGJhc2VkIG9uIG1hcHBpbmdcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spO1xuICB9KTtcbiAgcmV0dXJuIGVuY29kZXJcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlRG9jdW1lbnRTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBkb2MpID0+IHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSk7XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvclYyID0gKGRvYywgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yID0gZG9jID0+IGVuY29kZVN0YXRlVmVjdG9yVjIoZG9jLCBuZXcgRFNFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLCBBUkcxXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihBUkcwLCBBUkcxKTp2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLmwgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEByZXR1cm5zIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUV2ZW50SGFuZGxlciA9ICgpID0+IG5ldyBFdmVudEhhbmRsZXIoKTtcblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIHdoZW5cbiAqIHtAbGluayBFdmVudEhhbmRsZXIjY2FsbEV2ZW50TGlzdGVuZXJzfSBpcyBjYWxsZWQuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT5cbiAgZXZlbnRIYW5kbGVyLmwucHVzaChmKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtmdW5jdGlvbihBUkcwLEFSRzEpOnZvaWR9IGYgVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCB3YXMgYWRkZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lciA9IChldmVudEhhbmRsZXIsIGYpID0+IHtcbiAgY29uc3QgbCA9IGV2ZW50SGFuZGxlci5sO1xuICBjb25zdCBsZW4gPSBsLmxlbmd0aDtcbiAgZXZlbnRIYW5kbGVyLmwgPSBsLmZpbHRlcihnID0+IGYgIT09IGcpO1xuICBpZiAobGVuID09PSBldmVudEhhbmRsZXIubC5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbeWpzXSBUcmllZCB0byByZW1vdmUgZXZlbnQgaGFuZGxlciB0aGF0IGRvZXNuXFwndCBleGlzdC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFsbCBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkIHZpYVxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNhZGRFdmVudExpc3RlbmVyfS5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7QVJHMH0gYXJnMFxuICogQHBhcmFtIHtBUkcxfSBhcmcxXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzID0gKGV2ZW50SGFuZGxlciwgYXJnMCwgYXJnMSkgPT5cbiAgZi5jYWxsQWxsKGV2ZW50SGFuZGxlci5sLCBbYXJnMCwgYXJnMV0pO1xuXG5jbGFzcyBJRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50IGNsaWVudCBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBjbG9jaykge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqXG4gICAgICogdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYVxuICogQHBhcmFtIHtJRCB8IG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVJRHMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuY2xpZW50ID09PSBiLmNsaWVudCAmJiBhLmNsb2NrID09PSBiLmNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUlEID0gKGNsaWVudCwgY2xvY2spID0+IG5ldyBJRChjbGllbnQsIGNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZUlEID0gKGVuY29kZXIsIGlkKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbGllbnQpO1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgaWQuY2xvY2spO1xufTtcblxuLyoqXG4gKiBSZWFkIElELlxuICogKiBJZiBmaXJzdCB2YXJVaW50IHJlYWQgaXMgMHhGRkZGRkYgYSBSb290SUQgaXMgcmV0dXJuZWQuXG4gKiAqIE90aGVyd2lzZSBhbiBJRCBpcyByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7SUR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkSUQgPSBkZWNvZGVyID0+XG4gIGNyZWF0ZUlEKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSk7XG5cbi8qKlxuICogVGhlIHRvcCB0eXBlcyBhcmUgbWFwcGVkIGZyb20geS5zaGFyZS5nZXQoa2V5bmFtZSkgPT4gdHlwZS5cbiAqIGB0eXBlYCBkb2VzIG5vdCBzdG9yZSBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGBrZXluYW1lYC5cbiAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGNvcnJlY3QgYGtleW5hbWVgIGZvciBgdHlwZWAgYW5kIHRocm93cyBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFJvb3RUeXBlS2V5ID0gdHlwZSA9PiB7XG4gIC8vIEB0cy1pZ25vcmUgX3kgbXVzdCBiZSBkZWZpbmVkLCBvdGhlcndpc2UgdW5leHBlY3RlZCBjYXNlXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHR5cGUuZG9jLnNoYXJlLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHlwZSkge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxuICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gY2hpbGRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzUGFyZW50T2YgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNoaWxkID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLnBhcmVudCkuX2l0ZW07XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vKipcbiAqIENvbnZlbmllbnQgaGVscGVyIHRvIGxvZyB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqIERvIG5vdCB1c2UgaW4gcHJvZHVjdGl2ZSBzeXN0ZW1zIGFzIHRoZSBvdXRwdXQgY2FuIGJlIGltbWVuc2UhXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICovXG5jb25zdCBsb2dUeXBlID0gdHlwZSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobikge1xuICAgIHJlcy5wdXNoKG4pO1xuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGNvbnNvbGUubG9nKCdDaGlsZHJlbjogJywgcmVzKTtcbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuIGNvbnRlbnQ6ICcsIHJlcy5maWx0ZXIobSA9PiAhbS5kZWxldGVkKS5tYXAobSA9PiBtLmNvbnRlbnQpKTtcbn07XG5cbmNsYXNzIFBlcm1hbmVudFVzZXJEYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtZTWFwPGFueT59IFtzdG9yZVR5cGVdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBzdG9yZVR5cGUgPSBkb2MuZ2V0TWFwKCd1c2VycycpKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsRGVsZXRlU2V0Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkc3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy55dXNlcnMgPSBzdG9yZVR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudGlkIHRvIHVzZXJEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kc3MgPSBkc3M7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZTWFwPGFueT59IHVzZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgY29uc3QgaW5pdFVzZXIgPSAodXNlciwgdXNlckRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtZQXJyYXk8VWludDhBcnJheT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRzID0gdXNlci5nZXQoJ2RzJyk7XG4gICAgICBjb25zdCBpZHMgPSB1c2VyLmdldCgnaWRzJyk7XG4gICAgICBjb25zdCBhZGRDbGllbnRJZCA9IC8qKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWQgKi8gY2xpZW50aWQgPT4gdGhpcy5jbGllbnRzLnNldChjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uKTtcbiAgICAgIGRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGVuY29kZWREcyA9PiB7XG4gICAgICAgICAgICBpZiAoZW5jb2RlZERzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICB0aGlzLmRzcy5zZXQodXNlckRlc2NyaXB0aW9uLCBtZXJnZURlbGV0ZVNldHMoW3RoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pIHx8IGNyZWF0ZURlbGV0ZVNldCgpLCByZWFkRGVsZXRlU2V0KG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGVuY29kZWREcykpKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhkcy5tYXAoZW5jb2RlZERzID0+IHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpKSkpO1xuICAgICAgaWRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT5cbiAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGFkZENsaWVudElkKSlcbiAgICAgICk7XG4gICAgICBpZHMuZm9yRWFjaChhZGRDbGllbnRJZCk7XG4gICAgfTtcbiAgICAvLyBvYnNlcnZlIHVzZXJzXG4gICAgc3RvcmVUeXBlLm9ic2VydmUoZXZlbnQgPT4ge1xuICAgICAgZXZlbnQua2V5c0NoYW5nZWQuZm9yRWFjaCh1c2VyRGVzY3JpcHRpb24gPT5cbiAgICAgICAgaW5pdFVzZXIoc3RvcmVUeXBlLmdldCh1c2VyRGVzY3JpcHRpb24pLCB1c2VyRGVzY3JpcHRpb24pXG4gICAgICApO1xuICAgIH0pO1xuICAgIC8vIGFkZCBpbnRpYWwgZGF0YVxuICAgIHN0b3JlVHlwZS5mb3JFYWNoKGluaXRVc2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZl1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRGVsZXRlU2V0KTpib29sZWFufSBbY29uZi5maWx0ZXJdXG4gICAqL1xuICBzZXRVc2VyTWFwcGluZyAoZG9jLCBjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uLCB7IGZpbHRlciA9ICgpID0+IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgdXNlcnMgPSB0aGlzLnl1c2VycztcbiAgICBsZXQgdXNlciA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdXNlciA9IG5ldyBZTWFwKCk7XG4gICAgICB1c2VyLnNldCgnaWRzJywgbmV3IFlBcnJheSgpKTtcbiAgICAgIHVzZXIuc2V0KCdkcycsIG5ldyBZQXJyYXkoKSk7XG4gICAgICB1c2Vycy5zZXQodXNlckRlc2NyaXB0aW9uLCB1c2VyKTtcbiAgICB9XG4gICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSk7XG4gICAgdXNlcnMub2JzZXJ2ZShldmVudCA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXNlck92ZXJ3cml0ZSA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAodXNlck92ZXJ3cml0ZSAhPT0gdXNlcikge1xuICAgICAgICAgIC8vIHVzZXIgd2FzIG92ZXJ3cml0dGVuLCBwb3J0IGFsbCBkYXRhIG92ZXIgdG8gdGhlIG5leHQgdXNlciBvYmplY3RcbiAgICAgICAgICAvLyBAdG9kbyBFeHBlcmltZW50IHdpdGggWS5TZXRzIGhlcmVcbiAgICAgICAgICB1c2VyID0gdXNlck92ZXJ3cml0ZTtcbiAgICAgICAgICAvLyBAdG9kbyBpdGVyYXRlIG92ZXIgb2xkIHR5cGVcbiAgICAgICAgICB0aGlzLmNsaWVudHMuZm9yRWFjaCgoX3VzZXJEZXNjcmlwdGlvbiwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgICAgIGlmICh1c2VyRGVzY3JpcHRpb24gPT09IF91c2VyRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMSgpO1xuICAgICAgICAgIGNvbnN0IGRzID0gdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbik7XG4gICAgICAgICAgaWYgKGRzKSB7XG4gICAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gICAgICAgICAgICB1c2VyLmdldCgnZHMnKS5wdXNoKFtlbmNvZGVyLnRvVWludDhBcnJheSgpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgICBkb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCAvKiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gKi8gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHlkcyA9IHVzZXIuZ2V0KCdkcycpO1xuICAgICAgICBjb25zdCBkcyA9IHRyYW5zYWN0aW9uLmRlbGV0ZVNldDtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmxvY2FsICYmIGRzLmNsaWVudHMuc2l6ZSA+IDAgJiYgZmlsdGVyKHRyYW5zYWN0aW9uLCBkcykpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKCk7XG4gICAgICAgICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICAgICAgICAgIHlkcy5wdXNoKFtlbmNvZGVyLnRvVWludDhBcnJheSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBnZXRVc2VyQnlDbGllbnRJZCAoY2xpZW50aWQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRzLmdldChjbGllbnRpZCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBnZXRVc2VyQnlEZWxldGVkSWQgKGlkKSB7XG4gICAgZm9yIChjb25zdCBbdXNlckRlc2NyaXB0aW9uLCBkc10gb2YgdGhpcy5kc3MuZW50cmllcygpKSB7XG4gICAgICBpZiAoaXNEZWxldGVkKGRzLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJEZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBiYXNlZCBvbiB0aGUgWWpzIG1vZGVsIGFuZCBpcyBub3QgYWZmZWN0ZWQgYnkgZG9jdW1lbnQgY2hhbmdlcy5cbiAqIEUuZy4gSWYgeW91IHBsYWNlIGEgcmVsYXRpdmUgcG9zaXRpb24gYmVmb3JlIGEgY2VydGFpbiBjaGFyYWN0ZXIsIGl0IHdpbGwgYWx3YXlzIHBvaW50IHRvIHRoaXMgY2hhcmFjdGVyLlxuICogSWYgeW91IHBsYWNlIGEgcmVsYXRpdmUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiBhIHR5cGUsIGl0IHdpbGwgYWx3YXlzIHBvaW50IHRvIHRoZSBlbmQgb2YgdGhlIHR5cGUuXG4gKlxuICogQSBudW1lcmljIHBvc2l0aW9uIGlzIG9mdGVuIHVuc3VpdGVkIGZvciB1c2VyIHNlbGVjdGlvbnMsIGJlY2F1c2UgaXQgZG9lcyBub3QgY2hhbmdlIHdoZW4gY29udGVudCBpcyBpbnNlcnRlZFxuICogYmVmb3JlIG9yIGFmdGVyLlxuICpcbiAqIGBgYEluc2VydCgwLCAneCcpKCdhfGJjJykgPSAneGF8YmMnYGBgIFdoZXJlIHwgaXMgdGhlIHJlbGF0aXZlIHBvc2l0aW9uLlxuICpcbiAqIE9uZSBvZiB0aGUgcHJvcGVydGllcyBtdXN0IGJlIGRlZmluZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gaXMgYXQgcG9zaXRpb24gMTBcbiAqICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSW5kZXgoeVRleHQsIDEwKVxuICogICAvLyBtb2RpZnkgeVRleHRcbiAqICAgeVRleHQuaW5zZXJ0KDAsICdhYmMnKVxuICogICB5VGV4dC5kZWxldGUoMywgMTApXG4gKiAgIC8vIENvbXB1dGUgdGhlIGN1cnNvciBwb3NpdGlvblxuICogICBjb25zdCBhYnNvbHV0ZVBvc2l0aW9uID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKHksIHJlbGF0aXZlUG9zaXRpb24pXG4gKiAgIGFic29sdXRlUG9zaXRpb24udHlwZSA9PT0geVRleHQgLy8gPT4gdHJ1ZVxuICogICBjb25zb2xlLmxvZygnY3Vyc29yIGxvY2F0aW9uIGlzICcgKyBhYnNvbHV0ZVBvc2l0aW9uLmluZGV4KSAvLyA9PiBjdXJzb3IgbG9jYXRpb24gaXMgM1xuICpcbiAqL1xuY2xhc3MgUmVsYXRpdmVQb3NpdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfG51bGx9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdG5hbWVcbiAgICogQHBhcmFtIHtJRHxudWxsfSBpdGVtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhc3NvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUsIHRuYW1lLCBpdGVtLCBhc3NvYyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SUR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRuYW1lID0gdG5hbWU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgIC8qKlxuICAgICAqIEEgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byBhIHNwZWNpZmljIGNoYXJhY3Rlci4gQnkgZGVmYXVsdFxuICAgICAqIGFzc29jID49IDAsIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjaGFyYWN0ZXJcbiAgICAgKiBhZnRlciB0aGUgbWVhbnQgcG9zaXRpb24uXG4gICAgICogSS5lLiBwb3NpdGlvbiAxIGluICdhYicgaXMgYXNzb2NpYXRlZCB0byBjaGFyYWN0ZXIgJ2InLlxuICAgICAqXG4gICAgICogSWYgYXNzb2MgPCAwLCB0aGVuIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjYWhhcmFjdGVyXG4gICAgICogYmVmb3JlIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hc3NvYyA9IGFzc29jO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmNvbnN0IHJlbGF0aXZlUG9zaXRpb25Ub0pTT04gPSBycG9zID0+IHtcbiAgY29uc3QganNvbiA9IHt9O1xuICBpZiAocnBvcy50eXBlKSB7XG4gICAganNvbi50eXBlID0gcnBvcy50eXBlO1xuICB9XG4gIGlmIChycG9zLnRuYW1lKSB7XG4gICAganNvbi50bmFtZSA9IHJwb3MudG5hbWU7XG4gIH1cbiAgaWYgKHJwb3MuaXRlbSkge1xuICAgIGpzb24uaXRlbSA9IHJwb3MuaXRlbTtcbiAgfVxuICBpZiAocnBvcy5hc3NvYyAhPSBudWxsKSB7XG4gICAganNvbi5hc3NvYyA9IHJwb3MuYXNzb2M7XG4gIH1cbiAgcmV0dXJuIGpzb25cbn07XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGpzb25cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiA9IGpzb24gPT4gbmV3IFJlbGF0aXZlUG9zaXRpb24oanNvbi50eXBlID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi50eXBlLmNsaWVudCwganNvbi50eXBlLmNsb2NrKSwganNvbi50bmFtZSB8fCBudWxsLCBqc29uLml0ZW0gPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLml0ZW0uY2xpZW50LCBqc29uLml0ZW0uY2xvY2spLCBqc29uLmFzc29jID09IG51bGwgPyAwIDoganNvbi5hc3NvYyk7XG5cbmNsYXNzIEFic29sdXRlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5hc3NvYyA9IGFzc29jO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IG5ldyBBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBhc3NvYyk7XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtJRHxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uID0gKHR5cGUsIGl0ZW0sIGFzc29jKSA9PiB7XG4gIGxldCB0eXBlaWQgPSBudWxsO1xuICBsZXQgdG5hbWUgPSBudWxsO1xuICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCkge1xuICAgIHRuYW1lID0gZmluZFJvb3RUeXBlS2V5KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGVpZCA9IGNyZWF0ZUlEKHR5cGUuX2l0ZW0uaWQuY2xpZW50LCB0eXBlLl9pdGVtLmlkLmNsb2NrKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbSwgYXNzb2MpXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlbGF0aXZlUG9zaXRpb24gYmFzZWQgb24gYSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlIFRoZSBiYXNlIHR5cGUgKGUuZy4gWVRleHQgb3IgWUFycmF5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgYWJzb2x1dGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXggPSAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkgPT4ge1xuICBsZXQgdCA9IHR5cGUuX3N0YXJ0O1xuICBpZiAoYXNzb2MgPCAwKSB7XG4gICAgLy8gYXNzb2NpYXRlZCB0byB0aGUgbGVmdCBjaGFyYWN0ZXIgb3IgdGhlIGJlZ2lubmluZyBvZiBhIHR5cGUsIGluY3JlbWVudCBpbmRleCBpZiBwb3NzaWJsZS5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIG51bGwsIGFzc29jKVxuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG4gIHdoaWxlICh0ICE9PSBudWxsKSB7XG4gICAgaWYgKCF0LmRlbGV0ZWQgJiYgdC5jb3VudGFibGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgIC8vIGNhc2UgMTogZm91bmQgcG9zaXRpb24gc29tZXdoZXJlIGluIHRoZSBsaW5rZWQgbGlzdFxuICAgICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBjcmVhdGVJRCh0LmlkLmNsaWVudCwgdC5pZC5jbG9jayArIGluZGV4KSwgYXNzb2MpXG4gICAgICB9XG4gICAgICBpbmRleCAtPSB0Lmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHQucmlnaHQgPT09IG51bGwgJiYgYXNzb2MgPCAwKSB7XG4gICAgICAvLyBsZWZ0LWFzc29jaWF0ZWQgcG9zaXRpb24sIHJldHVybiBsYXN0IGF2YWlsYWJsZSBpZFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgdC5sYXN0SWQsIGFzc29jKVxuICAgIH1cbiAgICB0ID0gdC5yaWdodDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVSZWxhdGl2ZVBvc2l0aW9uID0gKGVuY29kZXIsIHJwb3MpID0+IHtcbiAgY29uc3QgeyB0eXBlLCB0bmFtZSwgaXRlbSwgYXNzb2MgfSA9IHJwb3M7XG4gIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDApO1xuICAgIHdyaXRlSUQoZW5jb2RlciwgaXRlbSk7XG4gIH0gZWxzZSBpZiAodG5hbWUgIT09IG51bGwpIHtcbiAgICAvLyBjYXNlIDI6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgc3RvcmVkIGluIHkuc2hhcmVcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXIsIDEpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRuYW1lKTtcbiAgfSBlbHNlIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAzOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIGF0dGFjaGVkIHRvIGFuIGl0ZW1cbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXIsIDIpO1xuICAgIHdyaXRlSUQoZW5jb2RlciwgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICB9XG4gIGVuY29kaW5nLndyaXRlVmFySW50KGVuY29kZXIsIGFzc29jKTtcbiAgcmV0dXJuIGVuY29kZXJcbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uID0gcnBvcyA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gIHdyaXRlUmVsYXRpdmVQb3NpdGlvbihlbmNvZGVyLCBycG9zKTtcbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRSZWxhdGl2ZVBvc2l0aW9uID0gZGVjb2RlciA9PiB7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRuYW1lID0gbnVsbDtcbiAgbGV0IGl0ZW1JRCA9IG51bGw7XG4gIHN3aXRjaCAoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgIGl0ZW1JRCA9IHJlYWRJRChkZWNvZGVyKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgICB0bmFtZSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2Rlcik7XG4gICAgICBicmVha1xuICAgIGNhc2UgMjoge1xuICAgICAgLy8gY2FzZSAzOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIGF0dGFjaGVkIHRvIGFuIGl0ZW1cbiAgICAgIHR5cGUgPSByZWFkSUQoZGVjb2Rlcik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFzc29jID0gZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSA/IGRlY29kaW5nLnJlYWRWYXJJbnQoZGVjb2RlcikgOiAwO1xuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZSwgdG5hbWUsIGl0ZW1JRCwgYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqL1xuY29uc3QgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHVpbnQ4QXJyYXkgPT4gcmVhZFJlbGF0aXZlUG9zaXRpb24oZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1aW50OEFycmF5KSk7XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtBYnNvbHV0ZVBvc2l0aW9ufG51bGx9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbiA9IChycG9zLCBkb2MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IHJpZ2h0SUQgPSBycG9zLml0ZW07XG4gIGNvbnN0IHR5cGVJRCA9IHJwb3MudHlwZTtcbiAgY29uc3QgdG5hbWUgPSBycG9zLnRuYW1lO1xuICBjb25zdCBhc3NvYyA9IHJwb3MuYXNzb2M7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgaWYgKHJpZ2h0SUQgIT09IG51bGwpIHtcbiAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHJpZ2h0SUQuY2xpZW50KSA8PSByaWdodElELmNsb2NrKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjb25zdCByZXMgPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHJpZ2h0SUQpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcmVzLml0ZW07XG4gICAgaWYgKCEocmlnaHQgaW5zdGFuY2VvZiBJdGVtKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpO1xuICAgIGlmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgIGluZGV4ID0gKHJpZ2h0LmRlbGV0ZWQgfHwgIXJpZ2h0LmNvdW50YWJsZSkgPyAwIDogKHJlcy5kaWZmICsgKGFzc29jID49IDAgPyAwIDogMSkpOyAvLyBhZGp1c3QgcG9zaXRpb24gYmFzZWQgb24gbGVmdCBhc3NvY2lhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgIGxldCBuID0gcmlnaHQubGVmdDtcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICAgICAgaW5kZXggKz0gbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ubGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRuYW1lICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gZG9jLmdldCh0bmFtZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlSUQgIT09IG51bGwpIHtcbiAgICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgdHlwZUlELmNsaWVudCkgPD0gdHlwZUlELmNsb2NrKSB7XG4gICAgICAgIC8vIHR5cGUgZG9lcyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBjb25zdCB7IGl0ZW0gfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgdHlwZUlEKTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiBpdGVtLmNvbnRlbnQgaW5zdGFuY2VvZiBDb250ZW50VHlwZSkge1xuICAgICAgICB0eXBlID0gaXRlbS5jb250ZW50LnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJ1Y3QgaXMgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBpZiAoYXNzb2MgPj0gMCkge1xuICAgICAgaW5kZXggPSB0eXBlLl9sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUFic29sdXRlUG9zaXRpb24odHlwZSwgaW5kZXgsIHJwb3MuYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbnxudWxsfSBhXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKFxuICBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS50bmFtZSA9PT0gYi50bmFtZSAmJiBjb21wYXJlSURzKGEuaXRlbSwgYi5pdGVtKSAmJiBjb21wYXJlSURzKGEudHlwZSwgYi50eXBlKSAmJiBhLmFzc29jID09PSBiLmFzc29jXG4pO1xuXG5jbGFzcyBTbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAgICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2IHN0YXRlIG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRzLCBzdikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kcyA9IGRzO1xuICAgIC8qKlxuICAgICAqIFN0YXRlIE1hcFxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5zdiA9IHN2O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcDFcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbFNuYXBzaG90cyA9IChzbmFwMSwgc25hcDIpID0+IHtcbiAgY29uc3QgZHMxID0gc25hcDEuZHMuY2xpZW50cztcbiAgY29uc3QgZHMyID0gc25hcDIuZHMuY2xpZW50cztcbiAgY29uc3Qgc3YxID0gc25hcDEuc3Y7XG4gIGNvbnN0IHN2MiA9IHNuYXAyLnN2O1xuICBpZiAoc3YxLnNpemUgIT09IHN2Mi5zaXplIHx8IGRzMS5zaXplICE9PSBkczIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN2MS5lbnRyaWVzKCkpIHtcbiAgICBpZiAoc3YyLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgW2NsaWVudCwgZHNpdGVtczFdIG9mIGRzMS5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBkc2l0ZW1zMiA9IGRzMi5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBpZiAoZHNpdGVtczEubGVuZ3RoICE9PSBkc2l0ZW1zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzaXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkc2l0ZW0xID0gZHNpdGVtczFbaV07XG4gICAgICBjb25zdCBkc2l0ZW0yID0gZHNpdGVtczJbaV07XG4gICAgICBpZiAoZHNpdGVtMS5jbG9jayAhPT0gZHNpdGVtMi5jbG9jayB8fCBkc2l0ZW0xLmxlbiAhPT0gZHNpdGVtMi5sZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU25hcHNob3RWMiA9IChzbmFwc2hvdCwgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHNuYXBzaG90LmRzKTtcbiAgd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBzbmFwc2hvdC5zdik7XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTbmFwc2hvdCA9IHNuYXBzaG90ID0+IGVuY29kZVNuYXBzaG90VjIoc25hcHNob3QsIG5ldyBEU0VuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBbZGVjb2Rlcl1cbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBkZWNvZGVTbmFwc2hvdFYyID0gKGJ1ZiwgZGVjb2RlciA9IG5ldyBEU0RlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpKSA9PiB7XG4gIHJldHVybiBuZXcgU25hcHNob3QocmVhZERlbGV0ZVNldChkZWNvZGVyKSwgcmVhZFN0YXRlVmVjdG9yKGRlY29kZXIpKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGRlY29kZVNuYXBzaG90ID0gYnVmID0+IGRlY29kZVNuYXBzaG90VjIoYnVmLCBuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc21cbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBjcmVhdGVTbmFwc2hvdCA9IChkcywgc20pID0+IG5ldyBTbmFwc2hvdChkcywgc20pO1xuXG5jb25zdCBlbXB0eVNuYXBzaG90ID0gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IHNuYXBzaG90ID0gZG9jID0+IGNyZWF0ZVNuYXBzaG90KGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U25hcHNob3R8dW5kZWZpbmVkfSBzbmFwc2hvdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpc1Zpc2libGUgPSAoaXRlbSwgc25hcHNob3QpID0+IHNuYXBzaG90ID09PSB1bmRlZmluZWQgPyAhaXRlbS5kZWxldGVkIDogKFxuICBzbmFwc2hvdC5zdi5oYXMoaXRlbS5pZC5jbGllbnQpICYmIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApID4gaXRlbS5pZC5jbG9jayAmJiAhaXNEZWxldGVkKHNuYXBzaG90LmRzLCBpdGVtLmlkKVxuKTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqL1xuY29uc3Qgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgbWV0YSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5tZXRhLCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzLCBzZXQuY3JlYXRlKTtcbiAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5kb2Muc3RvcmU7XG4gIC8vIGNoZWNrIGlmIHdlIGFscmVhZHkgc3BsaXQgZm9yIHRoaXMgc25hcHNob3RcbiAgaWYgKCFtZXRhLmhhcyhzbmFwc2hvdCkpIHtcbiAgICBzbmFwc2hvdC5zdi5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QuZHMsIGl0ZW0gPT4ge30pO1xuICAgIG1ldGEuYWRkKHNuYXBzaG90KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tU25hcHNob3QgPSAob3JpZ2luRG9jLCBzbmFwc2hvdCwgbmV3RG9jID0gbmV3IERvYygpKSA9PiB7XG4gIGlmIChvcmlnaW5Eb2MuZ2MpIHtcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyeSB0byByZXN0b3JlIGEgR0MtZWQgZG9jdW1lbnQsIGJlY2F1c2Ugc29tZSBvZiB0aGUgcmVzdG9yZWQgaXRlbXMgbWlnaHQgaGF2ZSB0aGVpciBjb250ZW50IGRlbGV0ZWRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29yaWdpbkRvYyBtdXN0IG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZCcpXG4gIH1cbiAgY29uc3QgeyBzdiwgZHMgfSA9IHNuYXBzaG90O1xuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gIG9yaWdpbkRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHN2LmZvckVhY2goY2xvY2sgPT4ge1xuICAgICAgaWYgKGNsb2NrID4gMCkge1xuICAgICAgICBzaXplKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNpemUpO1xuICAgIC8vIHNwbGl0dGluZyB0aGUgc3RydWN0cyBiZWZvcmUgd3JpdGluZyB0aGVtIHRvIHRoZSBlbmNvZGVyXG4gICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2Ygc3YpIHtcbiAgICAgIGlmIChjbG9jayA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUob3JpZ2luRG9jLnN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgICBjb25zdCBsYXN0U3RydWN0SW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayAtIDEpO1xuICAgICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsYXN0U3RydWN0SW5kZXggKyAxKTtcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgICAgIC8vIGZpcnN0IGNsb2NrIHdyaXR0ZW4gaXMgMFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdFN0cnVjdEluZGV4OyBpKyspIHtcbiAgICAgICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICB9KTtcblxuICBhcHBseVVwZGF0ZVYyKG5ld0RvYywgZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgJ3NuYXBzaG90Jyk7XG4gIHJldHVybiBuZXdEb2Ncbn07XG5cbmNsYXNzIFN0cnVjdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PEdDfEl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCB7IG1pc3Npbmc6IE1hcDxudW1iZXIsIG51bWJlcj4sIHVwZGF0ZTogVWludDhBcnJheSB9fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1N0cnVjdHMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgVWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdEcyA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YXRlcyBhcyBhIE1hcDxjbGllbnQsY2xvY2s+LlxuICogTm90ZSB0aGF0IGNsb2NrIHJlZmVycyB0byB0aGUgbmV4dCBleHBlY3RlZCBjbG9jayBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRTdGF0ZVZlY3RvciA9IHN0b3JlID0+IHtcbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIHN0b3JlLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdO1xuICAgIHNtLnNldChjbGllbnQsIHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpO1xuICB9KTtcbiAgcmV0dXJuIHNtXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFN0YXRlID0gKHN0b3JlLCBjbGllbnQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCk7XG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gIHJldHVybiBsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGhcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCkgPT4ge1xuICBsZXQgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpO1xuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RydWN0cyA9IFtdO1xuICAgIHN0b3JlLmNsaWVudHMuc2V0KHN0cnVjdC5pZC5jbGllbnQsIHN0cnVjdHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aCAhPT0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG4gIHN0cnVjdHMucHVzaChzdHJ1Y3QpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheVxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhTUyA9IChzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IHN0cnVjdHMubGVuZ3RoIC0gMTtcbiAgbGV0IG1pZCA9IHN0cnVjdHNbcmlnaHRdO1xuICBsZXQgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2s7XG4gIGlmIChtaWRjbG9jayA9PT0gY2xvY2spIHtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuICAvLyBAdG9kbyBkb2VzIGl0IGV2ZW4gbWFrZSBzZW5zZSB0byBwaXZvdCB0aGUgc2VhcmNoP1xuICAvLyBJZiBhIGdvb2Qgc3BsaXQgbWlzc2VzLCBpdCBtaWdodCBhY3R1YWxseSBpbmNyZWFzZSB0aGUgdGltZSB0byBmaW5kIHRoZSBjb3JyZWN0IGl0ZW0uXG4gIC8vIEN1cnJlbnRseSwgdGhlIG9ubHkgYWR2YW50YWdlIGlzIHRoYXQgc2VhcmNoIHdpdGggcGl2b3RpbmcgbWlnaHQgZmluZCB0aGUgaXRlbSBvbiB0aGUgZmlyc3QgdHJ5LlxuICBsZXQgbWlkaW5kZXggPSBtYXRoLmZsb29yKChjbG9jayAvIChtaWRjbG9jayArIG1pZC5sZW5ndGggLSAxKSkgKiByaWdodCk7IC8vIHBpdm90aW5nIHRoZSBzZWFyY2hcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBtaWQgPSBzdHJ1Y3RzW21pZGluZGV4XTtcbiAgICBtaWRjbG9jayA9IG1pZC5pZC5jbG9jaztcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxO1xuICAgIH1cbiAgICBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICAvLyBBbHdheXMgY2hlY2sgc3RhdGUgYmVmb3JlIGxvb2tpbmcgZm9yIGEgc3RydWN0IGluIFN0cnVjdFN0b3JlXG4gIC8vIFRoZXJlZm9yZSB0aGUgY2FzZSBvZiBub3QgZmluZGluZyBhIHN0cnVjdCBpcyB1bmV4cGVjdGVkXG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0dDfEl0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtID0gLyoqIEB0eXBlIHtmdW5jdGlvbihTdHJ1Y3RTdG9yZSxJRCk6SXRlbX0gKi8gKGZpbmQpO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqL1xuY29uc3QgZmluZEluZGV4Q2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2spID0+IHtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2sgJiYgc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgcmV0dXJuIGluZGV4ICsgMVxuICB9XG4gIHJldHVybiBpbmRleFxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW1DbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBpZCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpKTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtQ2xlYW5FbmQgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoaWQuY2xvY2sgIT09IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGggLSAxICYmIHN0cnVjdC5jb25zdHJ1Y3RvciAhPT0gR0MpIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpZC5jbG9jayAtIHN0cnVjdC5pZC5jbG9jayArIDEpKTtcbiAgfVxuICByZXR1cm4gc3RydWN0XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYGl0ZW1gIHdpdGggYG5ld2l0ZW1gIGluIHN0b3JlXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7R0N8SXRlbX0gbmV3U3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZXBsYWNlU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QsIG5ld1N0cnVjdCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpKTtcbiAgc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBzdHJ1Y3QuaWQuY2xvY2spXSA9IG5ld1N0cnVjdDtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2Ygc3RydWN0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tTdGFydCBJbmNsdXNpdmUgc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpdGVyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCwgbGVuLCBmKSA9PiB7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrU3RhcnQgKyBsZW47XG4gIGxldCBpbmRleCA9IGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQpO1xuICBsZXQgc3RydWN0O1xuICBkbyB7XG4gICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja0VuZCk7XG4gICAgfVxuICAgIGYoc3RydWN0KTtcbiAgfSB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3RzW2luZGV4XS5pZC5jbG9jayA8IGNsb2NrRW5kKVxufTtcblxuLyoqXG4gKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICogdG8gYnVuZGxlIGNoYW5nZXMgb24gdGhlIFlqcyBtb2RlbCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0b1xuICogbWluaW1pemUgdGhlIG51bWJlciBvbiBtZXNzYWdlcyBzZW50IGFuZCB0aGUgbnVtYmVyIG9mIG9ic2VydmVyIGNhbGxzLlxuICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gKiBwb3NzaWJsZS4gSGVyZSBpcyBhbiBleGFtcGxlIHRvIGlsbHVzdHJhdGUgdGhlIGFkdmFudGFnZXMgb2YgYnVuZGxpbmc6XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1hcCA9IHkuZGVmaW5lKCdtYXAnLCBZTWFwKVxuICogLy8gTG9nIGNvbnRlbnQgd2hlbiBjaGFuZ2UgaXMgdHJpZ2dlcmVkXG4gKiBtYXAub2JzZXJ2ZSgoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdjaGFuZ2UgdHJpZ2dlcmVkJylcbiAqIH0pXG4gKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAqIG1hcC5zZXQoJ2EnLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogbWFwLnNldCgnYicsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gKiB5LnRyYW5zYWN0KCgpID0+IHtcbiAqICAgbWFwLnNldCgnYScsIDEpXG4gKiAgIG1hcC5zZXQoJ2InLCAxKVxuICogfSkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBvcmlnaW4sIGxvY2FsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFlqcyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgc2V0IG9mIGRlbGV0ZWQgaXRlbXMgYnkgaWRzXG4gICAgICogQHR5cGUge0RlbGV0ZVNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVNldCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSk7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBBbGwgdHlwZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IG1vZGlmaWVkIChwcm9wZXJ0eSBhZGRlZCBvciBjaGlsZFxuICAgICAqIGluc2VydGVkL2RlbGV0ZWQpLiBOZXcgdHlwZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIFNldC5cbiAgICAgKiBNYXBzIGZyb20gdHlwZSB0byBwYXJlbnRTdWJzIChgaXRlbS5wYXJlbnRTdWIgPSBudWxsYCBmb3IgWUFycmF5KVxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudD4sU2V0PFN0cmluZ3xudWxsPj59XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgZXZlbnRzIGZvciB0aGUgdHlwZXMgdGhhdCBvYnNlcnZlIGFsc28gY2hpbGQgZWxlbWVudHMuXG4gICAgICogSXQgaXMgbWFpbmx5IHVzZWQgYnkgYG9ic2VydmVEZWVwYC5cbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ+LEFycmF5PFlFdmVudD4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFBhcmVudFR5cGVzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59XG4gICAgICovXG4gICAgdGhpcy5fbWVyZ2VTdHJ1Y3RzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgbWV0YSBpbmZvcm1hdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAdHlwZSB7TWFwPGFueSxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgY2hhbmdlIG9yaWdpbmF0ZXMgZnJvbSB0aGlzIGRvYy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0FkZGVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NSZW1vdmVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NMb2FkZWQgPSBuZXcgU2V0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgZGF0YSB3YXMgd3JpdHRlbi5cbiAqL1xuY29uc3Qgd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB7XG4gIGlmICh0cmFuc2FjdGlvbi5kZWxldGVTZXQuY2xpZW50cy5zaXplID09PSAwICYmICFtYXAuYW55KHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUsIChjbG9jaywgY2xpZW50KSA9PiB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSAhPT0gY2xvY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIElmIGB0eXBlLnBhcmVudGAgd2FzIGFkZGVkIGluIGN1cnJlbnQgdHJhbnNhY3Rpb24sIGB0eXBlYCB0ZWNobmljYWxseVxuICogZGlkIG5vdCBjaGFuZ2UsIGl0IHdhcyBqdXN0IGFkZGVkIGFuZCB3ZSBzaG91bGQgbm90IGZpcmUgZXZlbnRzIGZvciBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPFlFdmVudD59IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHBhcmVudFN1YlxuICovXG5jb25zdCBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24sIHR5cGUsIHBhcmVudFN1YikgPT4ge1xuICBjb25zdCBpdGVtID0gdHlwZS5faXRlbTtcbiAgaWYgKGl0ZW0gPT09IG51bGwgfHwgKGl0ZW0uaWQuY2xvY2sgPCAodHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSAmJiAhaXRlbS5kZWxldGVkKSkge1xuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5jaGFuZ2VkLCB0eXBlLCBzZXQuY3JlYXRlKS5hZGQocGFyZW50U3ViKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFic3RyYWN0U3RydWN0Pn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICovXG5jb25zdCB0cnlUb01lcmdlV2l0aExlZnQgPSAoc3RydWN0cywgcG9zKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBzdHJ1Y3RzW3BvcyAtIDFdO1xuICBjb25zdCByaWdodCA9IHN0cnVjdHNbcG9zXTtcbiAgaWYgKGxlZnQuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJiBsZWZ0LmNvbnN0cnVjdG9yID09PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgIGlmIChsZWZ0Lm1lcmdlV2l0aChyaWdodCkpIHtcbiAgICAgIHN0cnVjdHMuc3BsaWNlKHBvcywgMSk7XG4gICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBJdGVtICYmIHJpZ2h0LnBhcmVudFN1YiAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KS5fbWFwLmdldChyaWdodC5wYXJlbnRTdWIpID09PSByaWdodCkge1xuICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KS5fbWFwLnNldChyaWdodC5wYXJlbnRTdWIsIC8qKiBAdHlwZSB7SXRlbX0gKi8gKGxlZnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5jb25zdCB0cnlHY0RlbGV0ZVNldCA9IChkcywgc3RvcmUsIGdjRmlsdGVyKSA9PiB7XG4gIGZvciAoY29uc3QgW2NsaWVudCwgZGVsZXRlSXRlbXNdIG9mIGRzLmNsaWVudHMuZW50cmllcygpKSB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICBmb3IgKGxldCBkaSA9IGRlbGV0ZUl0ZW1zLmxlbmd0aCAtIDE7IGRpID49IDA7IGRpLS0pIHtcbiAgICAgIGNvbnN0IGRlbGV0ZUl0ZW0gPSBkZWxldGVJdGVtc1tkaV07XG4gICAgICBjb25zdCBlbmREZWxldGVJdGVtQ2xvY2sgPSBkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW47XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgc2kgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBkZWxldGVJdGVtLmNsb2NrKSwgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpIDwgc3RydWN0cy5sZW5ndGggJiYgc3RydWN0LmlkLmNsb2NrIDwgZW5kRGVsZXRlSXRlbUNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzWysrc2ldXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIGlmIChkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW4gPD0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJiBzdHJ1Y3QuZGVsZXRlZCAmJiAhc3RydWN0LmtlZXAgJiYgZ2NGaWx0ZXIoc3RydWN0KSkge1xuICAgICAgICAgIHN0cnVjdC5nYyhzdG9yZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqL1xuY29uc3QgdHJ5TWVyZ2VEZWxldGVTZXQgPSAoZHMsIHN0b3JlKSA9PiB7XG4gIC8vIHRyeSB0byBtZXJnZSBkZWxldGVkIC8gZ2MnZCBpdGVtc1xuICAvLyBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnQgZm9yIGJldHRlciBlZmZpY2llY3kgYW5kIHNvIHdlIGRvbid0IG1pc3MgYW55IG1lcmdlIHRhcmdldHNcbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVJdGVtcywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICBmb3IgKGxldCBkaSA9IGRlbGV0ZUl0ZW1zLmxlbmd0aCAtIDE7IGRpID49IDA7IGRpLS0pIHtcbiAgICAgIGNvbnN0IGRlbGV0ZUl0ZW0gPSBkZWxldGVJdGVtc1tkaV07XG4gICAgICAvLyBzdGFydCB3aXRoIG1lcmdpbmcgdGhlIGl0ZW0gbmV4dCB0byB0aGUgbGFzdCBkZWxldGVkIGl0ZW1cbiAgICAgIGNvbnN0IG1vc3RSaWdodEluZGV4VG9DaGVjayA9IG1hdGgubWluKHN0cnVjdHMubGVuZ3RoIC0gMSwgMSArIGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiAtIDEpKTtcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IG1vc3RSaWdodEluZGV4VG9DaGVjaywgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpID4gMCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPj0gZGVsZXRlSXRlbS5jbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1stLXNpXVxuICAgICAgKSB7XG4gICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCBzaSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5jb25zdCB0cnlHYyA9IChkcywgc3RvcmUsIGdjRmlsdGVyKSA9PiB7XG4gIHRyeUdjRGVsZXRlU2V0KGRzLCBzdG9yZSwgZ2NGaWx0ZXIpO1xuICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uPn0gdHJhbnNhY3Rpb25DbGVhbnVwc1xuICogQHBhcmFtIHtudW1iZXJ9IGlcbiAqL1xuY29uc3QgY2xlYW51cFRyYW5zYWN0aW9ucyA9ICh0cmFuc2FjdGlvbkNsZWFudXBzLCBpKSA9PiB7XG4gIGlmIChpIDwgdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGgpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uQ2xlYW51cHNbaV07XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0O1xuICAgIGNvbnN0IG1lcmdlU3RydWN0cyA9IHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHM7XG4gICAgdHJ5IHtcbiAgICAgIHNvcnRBbmRNZXJnZURlbGV0ZVNldChkcyk7XG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlID0gZ2V0U3RhdGVWZWN0b3IodHJhbnNhY3Rpb24uZG9jLnN0b3JlKTtcbiAgICAgIGRvYy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCBbdHJhbnNhY3Rpb24sIGRvY10pO1xuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogRWFjaCBjYWxsYmFjayBpcyBjYWxsZWQgZXZlbiBpZiB0aGUgb3RoZXIgb25lcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZzID0gW107XG4gICAgICAvLyBvYnNlcnZlIGV2ZW50cyBvbiBjaGFuZ2VkIHR5cGVzXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YnMsIGl0ZW10eXBlKSA9PlxuICAgICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbXR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIWl0ZW10eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGl0ZW10eXBlLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHN1YnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gZGVlcCBvYnNlcnZlIGV2ZW50c1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRzLCB0eXBlKSA9PlxuICAgICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0aGluayBhYm91dCB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgdXNlciB0cmFuc2Zvcm1zIHRoZVxuICAgICAgICAgICAgLy8gWS5Eb2MgaW4gdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICBldmVudHMgPSBldmVudHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGV2ZW50ID0+XG4gICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuX2l0ZW0gPT09IG51bGwgfHwgIWV2ZW50LnRhcmdldC5faXRlbS5kZWxldGVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIHNvcnQgZXZlbnRzIGJ5IHBhdGggbGVuZ3RoIHNvIHRoYXQgdG9wLWxldmVsIGV2ZW50cyBhcmUgZmlyZWQgZmlyc3QuXG4gICAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAgIC5zb3J0KChldmVudDEsIGV2ZW50MikgPT4gZXZlbnQxLnBhdGgubGVuZ3RoIC0gZXZlbnQyLnBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZXZlbnRzLmxlbmd0aFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGtub3cgaXQgaGFzIGF0IGxlYXN0IG9uZSBlbGVtZW50XG4gICAgICAgICAgICAgIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnModHlwZS5fZEVILCBldmVudHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmcy5wdXNoKCgpID0+IGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uJywgW3RyYW5zYWN0aW9uLCBkb2NdKSk7XG4gICAgICB9KTtcbiAgICAgIGYuY2FsbEFsbChmcywgW10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXBsYWNlIGRlbGV0ZWQgaXRlbXMgd2l0aCBJdGVtRGVsZXRlZCAvIEdDLlxuICAgICAgLy8gVGhpcyBpcyB3aGVyZSBjb250ZW50IGlzIGFjdHVhbGx5IHJlbW92ZSBmcm9tIHRoZSBZanMgRG9jLlxuICAgICAgaWYgKGRvYy5nYykge1xuICAgICAgICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGRvYy5nY0ZpbHRlcik7XG4gICAgICB9XG4gICAgICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpO1xuXG4gICAgICAvLyBvbiBhbGwgYWZmZWN0ZWQgc3RvcmUuY2xpZW50cyBwcm9wcywgdHJ5IHRvIG1lcmdlXG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3QgYmVmb3JlQ2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYmVmb3JlQ2xvY2sgIT09IGNsb2NrKSB7XG4gICAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICAgICAgICAvLyB3ZSBpdGVyYXRlIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbnRyaWVzXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGFuZ2VQb3MgPSBtYXRoLm1heChmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBiZWZvcmVDbG9jayksIDEpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdHJ1Y3RzLmxlbmd0aCAtIDE7IGkgPj0gZmlyc3RDaGFuZ2VQb3M7IGktLSkge1xuICAgICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyB0cnkgdG8gbWVyZ2UgbWVyZ2VTdHJ1Y3RzXG4gICAgICAvLyBAdG9kbzogaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB0cmFuc2Zvcm0gbWVyZ2VTdHJ1Y3RzIHRvIGEgRFMsIHNvcnQgaXQsIGFuZCBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICAgIC8vICAgICAgICBidXQgYXQgdGhlIG1vbWVudCBEUyBkb2VzIG5vdCBoYW5kbGUgZHVwbGljYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXJnZVN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBtZXJnZVN0cnVjdHNbaV0uaWQ7XG4gICAgICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VkU3RydWN0UG9zID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spO1xuICAgICAgICBpZiAocmVwbGFjZWRTdHJ1Y3RQb3MgKyAxIDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0cnlUb01lcmdlV2l0aExlZnQoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwbGFjZWRTdHJ1Y3RQb3MgPiAwKSB7XG4gICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0cmFuc2FjdGlvbi5sb2NhbCAmJiB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmdldChkb2MuY2xpZW50SUQpICE9PSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSkge1xuICAgICAgICBkb2MuY2xpZW50SUQgPSBnZW5lcmF0ZU5ld0NsaWVudElkKCk7XG4gICAgICAgIGxvZ2dpbmcucHJpbnQobG9nZ2luZy5PUkFOR0UsIGxvZ2dpbmcuQk9MRCwgJ1t5anNdICcsIGxvZ2dpbmcuVU5CT0xELCBsb2dnaW5nLlJFRCwgJ0NoYW5nZWQgdGhlIGNsaWVudC1pZCBiZWNhdXNlIGFub3RoZXIgY2xpZW50IHNlZW1zIHRvIGJlIHVzaW5nIGl0LicpO1xuICAgICAgfVxuICAgICAgLy8gQHRvZG8gTWVyZ2UgYWxsIHRoZSB0cmFuc2FjdGlvbnMgaW50byBvbmUgYW5kIHByb3ZpZGUgc2VuZCB0aGUgZGF0YSBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZVxuICAgICAgZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb25DbGVhbnVwJywgW3RyYW5zYWN0aW9uLCBkb2NdKTtcbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZScpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYxKCk7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgIGRvYy5lbWl0KCd1cGRhdGUnLCBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgdHJhbnNhY3Rpb24ub3JpZ2luLCBkb2MsIHRyYW5zYWN0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZVYyJykpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgZG9jLmVtaXQoJ3VwZGF0ZVYyJywgW2VuY29kZXIudG9VaW50OEFycmF5KCksIHRyYW5zYWN0aW9uLm9yaWdpbiwgZG9jLCB0cmFuc2FjdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuYWRkKHN1YmRvYykpO1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuZGVsZXRlKHN1YmRvYykpO1xuXG4gICAgICBkb2MuZW1pdCgnc3ViZG9jcycsIFt7IGxvYWRlZDogdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZCwgYWRkZWQ6IHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZCwgcmVtb3ZlZDogdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQgfV0pO1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA8PSBpICsgMSkge1xuICAgICAgICBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHMgPSBbXTtcbiAgICAgICAgZG9jLmVtaXQoJ2FmdGVyQWxsVHJhbnNhY3Rpb25zJywgW2RvYywgdHJhbnNhY3Rpb25DbGVhbnVwc10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCBpICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYHkudHJhbnNhY3QoKCk9PnsuLn0pYFxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOnZvaWR9IGZcbiAqIEBwYXJhbSB7YW55fSBbb3JpZ2luPXRydWVdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHRyYW5zYWN0ID0gKGRvYywgZiwgb3JpZ2luID0gbnVsbCwgbG9jYWwgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uQ2xlYW51cHMgPSBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHM7XG4gIGxldCBpbml0aWFsQ2FsbCA9IGZhbHNlO1xuICBpZiAoZG9jLl90cmFuc2FjdGlvbiA9PT0gbnVsbCkge1xuICAgIGluaXRpYWxDYWxsID0gdHJ1ZTtcbiAgICBkb2MuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYywgb3JpZ2luLCBsb2NhbCk7XG4gICAgdHJhbnNhY3Rpb25DbGVhbnVwcy5wdXNoKGRvYy5fdHJhbnNhY3Rpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIFtkb2NdKTtcbiAgICB9XG4gICAgZG9jLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywgW2RvYy5fdHJhbnNhY3Rpb24sIGRvY10pO1xuICB9XG4gIHRyeSB7XG4gICAgZihkb2MuX3RyYW5zYWN0aW9uKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaW5pdGlhbENhbGwgJiYgdHJhbnNhY3Rpb25DbGVhbnVwc1swXSA9PT0gZG9jLl90cmFuc2FjdGlvbikge1xuICAgICAgLy8gVGhlIGZpcnN0IHRyYW5zYWN0aW9uIGVuZGVkLCBub3cgcHJvY2VzcyBvYnNlcnZlciBjYWxscy5cbiAgICAgIC8vIE9ic2VydmVyIGNhbGwgbWF5IGNyZWF0ZSBuZXcgdHJhbnNhY3Rpb25zIGZvciB3aGljaCB3ZSBuZWVkIHRvIGNhbGwgdGhlIG9ic2VydmVycyBhbmQgZG8gY2xlYW51cC5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gbmVzdCB0aGVzZSBjYWxscywgc28gd2UgZXhlY3V0ZSB0aGVzZSBjYWxscyBvbmUgYWZ0ZXJcbiAgICAgIC8vIGFub3RoZXIuXG4gICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGNsZWFudXBzIGFyZSBjYWxsZWQsIGV2ZW4gaWYgdGhlXG4gICAgICAvLyBvYnNlcnZlcyB0aHJvdyBlcnJvcnMuXG4gICAgICAvLyBUaGlzIGZpbGUgaXMgZnVsbCBvZiBoYWNreSB0cnkge30gZmluYWxseSB7fSBibG9ja3MgdG8gZW5zdXJlIHRoYXQgYW5cbiAgICAgIC8vIGV2ZW50IGNhbiB0aHJvdyBlcnJvcnMgYW5kIGFsc28gdGhhdCB0aGUgY2xlYW51cCBpcyBjYWxsZWQuXG4gICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIDApO1xuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgU3RhY2tJdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkZWxldGlvbnNcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGluc2VydGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWxldGlvbnMsIGluc2VydGlvbnMpIHtcbiAgICB0aGlzLmluc2VydGlvbnMgPSBpbnNlcnRpb25zO1xuICAgIHRoaXMuZGVsZXRpb25zID0gZGVsZXRpb25zO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIHNhdmUgYW5kIHJlc3RvcmUgbWV0YWRhdGEgbGlrZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7U3RhY2tJdGVtP31cbiAqL1xuY29uc3QgcG9wU3RhY2tJdGVtID0gKHVuZG9NYW5hZ2VyLCBzdGFjaywgZXZlbnRUeXBlKSA9PiB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEB0eXBlIHtTdGFja0l0ZW0/fVxuICAgKi9cbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIC8qKlxuICAgKiBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0cmFuc2FjdGlvbiBzbyB3ZSBjYW4gZmlyZSB0aGUgZXZlbnQgd2l0aCB0aGUgY2hhbmdlZFBhcmVudFR5cGVzXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgX3RyID0gbnVsbDtcbiAgY29uc3QgZG9jID0gdW5kb01hbmFnZXIuZG9jO1xuICBjb25zdCBzY29wZSA9IHVuZG9NYW5hZ2VyLnNjb3BlO1xuICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCAmJiByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgICAgY29uc3Qgc3RhY2tJdGVtID0gLyoqIEB0eXBlIHtTdGFja0l0ZW19ICovIChzdGFjay5wb3AoKSk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9SZWRvID0gbmV3IFNldCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9EZWxldGUgPSBbXTtcbiAgICAgIGxldCBwZXJmb3JtZWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB7IGl0ZW0sIGRpZmYgfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgc3RydWN0LmlkKTtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBpdGVtID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrICsgZGlmZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RydWN0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCAvKiogQHR5cGUge0l0ZW19ICovIChzdHJ1Y3QpKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChzdHJ1Y3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHN0YWNrSXRlbS5kZWxldGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmXG4gICAgICAgICAgc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgc3RydWN0KSkgJiZcbiAgICAgICAgICAvLyBOZXZlciByZWRvIHN0cnVjdHMgaW4gc3RhY2tJdGVtLmluc2VydGlvbnMgYmVjYXVzZSB0aGV5IHdlcmUgY3JlYXRlZCBhbmQgZGVsZXRlZCBpbiB0aGUgc2FtZSBjYXB0dXJlIGludGVydmFsLlxuICAgICAgICAgICFpc0RlbGV0ZWQoc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdC5pZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXRlbXNUb1JlZG8uYWRkKHN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlbXNUb1JlZG8uZm9yRWFjaChzdHJ1Y3QgPT4ge1xuICAgICAgICBwZXJmb3JtZWRDaGFuZ2UgPSByZWRvSXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpdGVtc1RvUmVkbykgIT09IG51bGwgfHwgcGVyZm9ybWVkQ2hhbmdlO1xuICAgICAgfSk7XG4gICAgICAvLyBXZSB3YW50IHRvIGRlbGV0ZSBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgY2hpbGRyZW4gYXJlIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAvLyBwYXJlbnRzLCBzbyB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYXZhaWxhYmxlIHdoZW4gaXRlbXMgYXJlIGZpbHRlcmVkLlxuICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zVG9EZWxldGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zVG9EZWxldGVbaV07XG4gICAgICAgIGlmICh1bmRvTWFuYWdlci5kZWxldGVGaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcGVyZm9ybWVkQ2hhbmdlID8gc3RhY2tJdGVtIDogbnVsbDtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKChzdWJQcm9wcywgdHlwZSkgPT4ge1xuICAgICAgLy8gZGVzdHJveSBzZWFyY2ggbWFya2VyIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN1YlByb3BzLmhhcyhudWxsKSAmJiB0eXBlLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgICAgdHlwZS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RyID0gdHJhbnNhY3Rpb247XG4gIH0sIHVuZG9NYW5hZ2VyKTtcbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gX3RyLmNoYW5nZWRQYXJlbnRUeXBlcztcbiAgICB1bmRvTWFuYWdlci5lbWl0KCdzdGFjay1pdGVtLXBvcHBlZCcsIFt7IHN0YWNrSXRlbTogcmVzdWx0LCB0eXBlOiBldmVudFR5cGUsIGNoYW5nZWRQYXJlbnRUeXBlcyB9LCB1bmRvTWFuYWdlcl0pO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5kb01hbmFnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5jYXB0dXJlVGltZW91dD01MDBdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IFtVbmRvTWFuYWdlck9wdGlvbnMuZGVsZXRlRmlsdGVyPSgpPT50cnVlXSBTb21ldGltZXNcbiAqIGl0IGlzIG5lY2Vzc2FyeSB0byBmaWx0ZXIgd2hhbiBhbiBVbmRvL1JlZG8gb3BlcmF0aW9uIGNhbiBkZWxldGUuIElmIHRoaXNcbiAqIGZpbHRlciByZXR1cm5zIGZhbHNlLCB0aGUgdHlwZS9pdGVtIHdvbid0IGJlIGRlbGV0ZWQgZXZlbiBpdCBpcyBpbiB0aGVcbiAqIHVuZG8vcmVkbyBzY29wZS5cbiAqIEBwcm9wZXJ0eSB7U2V0PGFueT59IFtVbmRvTWFuYWdlck9wdGlvbnMudHJhY2tlZE9yaWdpbnM9bmV3IFNldChbbnVsbF0pXVxuICovXG5cbi8qKlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tYWRkZWQnIGV2ZW50IHdoZW4gYSBzdGFjayBpdGVtIHdhcyBhZGRlZCB0byBlaXRoZXIgdGhlIHVuZG8tIG9yXG4gKiB0aGUgcmVkby1zdGFjay4gWW91IG1heSBzdG9yZSBhZGRpdGlvbmFsIHN0YWNrIGluZm9ybWF0aW9uIHZpYSB0aGVcbiAqIG1ldGFkYXRhIHByb3BlcnR5IG9uIGBldmVudC5zdGFja0l0ZW0ubWV0YWAgKGl0IGlzIGEgYE1hcGAgb2YgbWV0YWRhdGEgcHJvcGVydGllcykuXG4gKiBGaXJlcyAnc3RhY2staXRlbS1wb3BwZWQnIGV2ZW50IHdoZW4gYSBzdGFjayBpdGVtIHdhcyBwb3BwZWQgZnJvbSBlaXRoZXIgdGhlXG4gKiB1bmRvLSBvciB0aGUgcmVkby1zdGFjay4gWW91IG1heSByZXN0b3JlIHRoZSBzYXZlZCBzdGFjayBpbmZvcm1hdGlvbiBmcm9tIGBldmVudC5zdGFja0l0ZW0ubWV0YWAuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8J3N0YWNrLWl0ZW0tYWRkZWQnfCdzdGFjay1pdGVtLXBvcHBlZCc+fVxuICovXG5jbGFzcyBVbmRvTWFuYWdlciBleHRlbmRzIG9ic2VydmFibGVfanMuT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fEFycmF5PEFic3RyYWN0VHlwZTxhbnk+Pn0gdHlwZVNjb3BlIEFjY2VwdHMgZWl0aGVyIGEgc2luZ2xlIHR5cGUsIG9yIGFuIGFycmF5IG9mIHR5cGVzXG4gICAqIEBwYXJhbSB7VW5kb01hbmFnZXJPcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZVNjb3BlLCB7IGNhcHR1cmVUaW1lb3V0ID0gNTAwLCBkZWxldGVGaWx0ZXIgPSAoKSA9PiB0cnVlLCB0cmFja2VkT3JpZ2lucyA9IG5ldyBTZXQoW251bGxdKSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2NvcGUgPSB0eXBlU2NvcGUgaW5zdGFuY2VvZiBBcnJheSA/IHR5cGVTY29wZSA6IFt0eXBlU2NvcGVdO1xuICAgIHRoaXMuZGVsZXRlRmlsdGVyID0gZGVsZXRlRmlsdGVyO1xuICAgIHRyYWNrZWRPcmlnaW5zLmFkZCh0aGlzKTtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zID0gdHJhY2tlZE9yaWdpbnM7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59XG4gICAgICovXG4gICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgdW5kb2luZyAoY2FsbGluZyBVbmRvTWFuYWdlci51bmRvKVxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51bmRvaW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZWRvaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuc2NvcGVbMF0uZG9jKTtcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICAgIHRoaXMuZG9jLm9uKCdhZnRlclRyYW5zYWN0aW9uJywgLyoqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uICovIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgIC8vIE9ubHkgdHJhY2sgY2VydGFpbiB0cmFuc2FjdGlvbnNcbiAgICAgIGlmICghdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzLmhhcyh0eXBlKSkgfHwgKCF0aGlzLnRyYWNrZWRPcmlnaW5zLmhhcyh0cmFuc2FjdGlvbi5vcmlnaW4pICYmICghdHJhbnNhY3Rpb24ub3JpZ2luIHx8ICF0aGlzLnRyYWNrZWRPcmlnaW5zLmhhcyh0cmFuc2FjdGlvbi5vcmlnaW4uY29uc3RydWN0b3IpKSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCB1bmRvaW5nID0gdGhpcy51bmRvaW5nO1xuICAgICAgY29uc3QgcmVkb2luZyA9IHRoaXMucmVkb2luZztcbiAgICAgIGNvbnN0IHN0YWNrID0gdW5kb2luZyA/IHRoaXMucmVkb1N0YWNrIDogdGhpcy51bmRvU3RhY2s7XG4gICAgICBpZiAodW5kb2luZykge1xuICAgICAgICB0aGlzLnN0b3BDYXB0dXJpbmcoKTsgLy8gbmV4dCB1bmRvIHNob3VsZCBub3QgYmUgYXBwZW5kZWQgdG8gbGFzdCBzdGFjayBpdGVtXG4gICAgICB9IGVsc2UgaWYgKCFyZWRvaW5nKSB7XG4gICAgICAgIC8vIG5laXRoZXIgdW5kb2luZyBub3IgcmVkb2luZzogZGVsZXRlIHJlZG9TdGFja1xuICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IG5ldyBEZWxldGVTZXQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZm9yRWFjaCgoZW5kQ2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMDtcbiAgICAgICAgY29uc3QgbGVuID0gZW5kQ2xvY2sgLSBzdGFydENsb2NrO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KGluc2VydGlvbnMsIGNsaWVudCwgc3RhcnRDbG9jaywgbGVuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKCk7XG4gICAgICBpZiAobm93IC0gdGhpcy5sYXN0Q2hhbmdlIDwgY2FwdHVyZVRpbWVvdXQgJiYgc3RhY2subGVuZ3RoID4gMCAmJiAhdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICAvLyBhcHBlbmQgY2hhbmdlIHRvIGxhc3Qgc3RhY2sgb3BcbiAgICAgICAgY29uc3QgbGFzdE9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGxhc3RPcC5kZWxldGlvbnMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5kZWxldGlvbnMsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldF0pO1xuICAgICAgICBsYXN0T3AuaW5zZXJ0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmluc2VydGlvbnMsIGluc2VydGlvbnNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBzdGFjayBvcFxuICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0l0ZW0odHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpbnNlcnRpb25zKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgdGhpcy5sYXN0Q2hhbmdlID0gbm93O1xuICAgICAgfVxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgZGVsZXRlZCBzdHJ1Y3RzIGFyZSBub3QgZ2MnZFxuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIC8qKiBAcGFyYW0ge0l0ZW18R0N9IGl0ZW0gKi8gaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIGl0ZW0pKSkge1xuICAgICAgICAgIGtlZXBJdGVtKGl0ZW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS1hZGRlZCcsIFt7IHN0YWNrSXRlbTogc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0sIG9yaWdpbjogdHJhbnNhY3Rpb24ub3JpZ2luLCB0eXBlOiB1bmRvaW5nID8gJ3JlZG8nIDogJ3VuZG8nLCBjaGFuZ2VkUGFyZW50VHlwZXM6IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcyB9LCB0aGlzXSk7XG4gICAgfSk7XG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgdGhpcy5kb2MudHJhbnNhY3QodHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge1N0YWNrSXRlbX0gc3RhY2tJdGVtXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNsZWFySXRlbSA9IHN0YWNrSXRlbSA9PiB7XG4gICAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmRlbGV0aW9ucywgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIHRoaXMuc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICAgICAgICBrZWVwSXRlbShpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLnVuZG9TdGFjay5mb3JFYWNoKGNsZWFySXRlbSk7XG4gICAgICB0aGlzLnJlZG9TdGFjay5mb3JFYWNoKGNsZWFySXRlbSk7XG4gICAgfSk7XG4gICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZG9NYW5hZ2VyIG1lcmdlcyBVbmRvLVN0YWNrSXRlbSBpZiB0aGV5IGFyZSBjcmVhdGVkIHdpdGhpbiB0aW1lLWdhcFxuICAgKiBzbWFsbGVyIHRoYW4gYG9wdGlvbnMuY2FwdHVyZVRpbWVvdXRgLiBDYWxsIGB1bS5zdG9wQ2FwdHVyaW5nKClgIHNvIHRoYXQgdGhlIG5leHRcbiAgICogU3RhY2tJdGVtIHdvbid0IGJlIG1lcmdlZC5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIC8vIHdpdGhvdXQgc3RvcENhcHR1cmluZ1xuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdhJylcbiAgICogICAgIHl0ZXh0Lmluc2VydCgxLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJycgKG5vdGUgdGhhdCAnYWInIHdhcyByZW1vdmVkKVxuICAgKiAgICAgLy8gd2l0aCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2InKVxuICAgKiAgICAgdW0udW5kbygpXG4gICAqICAgICB5dGV4dC50b1N0cmluZygpIC8vID0+ICdhJyAobm90ZSB0aGF0IG9ubHkgJ2InIHdhcyByZW1vdmVkKVxuICAgKlxuICAgKi9cbiAgc3RvcENhcHR1cmluZyAoKSB7XG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvIGxhc3QgY2hhbmdlcyBvbiB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgdW5kbyAoKSB7XG4gICAgdGhpcy51bmRvaW5nID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy51bmRvU3RhY2ssICd1bmRvJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudW5kb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogUmVkbyBsYXN0IHVuZG8gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgcmVkbyAoKSB7XG4gICAgdGhpcy5yZWRvaW5nID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy5yZWRvU3RhY2ssICdyZWRvJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVkb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICovXG5mdW5jdGlvbiAqIGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IgKGRlY29kZXIpIHtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KCk7XG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIC8vIEB0b2RvIHVzZSBzd2l0Y2ggaW5zdGVhZCBvZiBpZnNcbiAgICAgIGlmIChpbmZvID09PSAxMCkge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgeWllbGQgbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgIH0gZWxzZSBpZiAoKGJpbmFyeS5CSVRTNSAmIGluZm8pICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGNhbnRDb3B5UGFyZW50SW5mbyA9IChpbmZvICYgKGJpbmFyeS5CSVQ3IHwgYmluYXJ5LkJJVDgpKSA9PT0gMDtcbiAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUNykgPT09IGJpbmFyeS5CSVQ3ID8gZGVjb2Rlci5yZWFkUmlnaHRJRCgpIDogbnVsbCwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBGb3JjZSB3cml0aW5nIGEgc3RyaW5nIGhlcmUuXG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvID8gKGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA/IGRlY29kZXIucmVhZFN0cmluZygpIDogZGVjb2Rlci5yZWFkTGVmdElEKCkpIDogbnVsbCwgLy8gcGFyZW50XG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICApO1xuICAgICAgICB5aWVsZCBzdHJ1Y3Q7XG4gICAgICAgIGNsb2NrICs9IHN0cnVjdC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgeWllbGQgbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICBjbG9jayArPSBsZW47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIExhenlTdHJ1Y3RSZWFkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTa2lwc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIsIGZpbHRlclNraXBzKSB7XG4gICAgdGhpcy5nZW4gPSBsYXp5U3RydWN0UmVhZGVyR2VuZXJhdG9yKGRlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgSXRlbSB8IFNraXAgfCBHQ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnIgPSBudWxsO1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyU2tpcHMgPSBmaWx0ZXJTa2lwcztcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVtIHwgR0MgfCBTa2lwIHxudWxsfVxuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLy8gaWdub3JlIFwiU2tpcFwiIHN0cnVjdHNcbiAgICBkbyB7XG4gICAgICB0aGlzLmN1cnIgPSB0aGlzLmdlbi5uZXh0KCkudmFsdWUgfHwgbnVsbDtcbiAgICB9IHdoaWxlICh0aGlzLmZpbHRlclNraXBzICYmIHRoaXMuY3VyciAhPT0gbnVsbCAmJiB0aGlzLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXApXG4gICAgcmV0dXJuIHRoaXMuY3VyclxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqXG4gKi9cbmNvbnN0IGxvZ1VwZGF0ZSA9IHVwZGF0ZSA9PiBsb2dVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqXG4gKi9cbmNvbnN0IGxvZ1VwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpO1xuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKTtcbiAgfVxuICBsb2dnaW5nLnByaW50KCdTdHJ1Y3RzOiAnLCBzdHJ1Y3RzKTtcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpO1xuICBsb2dnaW5nLnByaW50KCdEZWxldGVTZXQ6ICcsIGRzKTtcbn07XG5cbmNsYXNzIExhenlTdHJ1Y3RXcml0ZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbmNvZGVyKSB7XG4gICAgdGhpcy5jdXJyQ2xpZW50ID0gMDtcbiAgICB0aGlzLnN0YXJ0Q2xvY2sgPSAwO1xuICAgIHRoaXMud3JpdHRlbiA9IDA7XG4gICAgdGhpcy5lbmNvZGVyID0gZW5jb2RlcjtcbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIHdyaXRlIG9wZXJhdGlvbnMgbGF6aWx5LCBidXQgYWxzbyB3ZSBuZWVkIHRvIGtub3cgYmVmb3JlaGFuZCBob3cgbWFueSBvcGVyYXRpb25zIHdlIHdhbnQgdG8gd3JpdGUgZm9yIGVhY2ggY2xpZW50LlxuICAgICAqXG4gICAgICogVGhpcyBraW5kIG9mIG1ldGEtaW5mb3JtYXRpb24gKCNjbGllbnRzLCAjc3RydWN0cy1wZXItY2xpZW50LXdyaXR0ZW4pIGlzIHdyaXR0ZW4gdG8gdGhlIHJlc3RFbmNvZGVyLlxuICAgICAqXG4gICAgICogV2UgZnJhZ21lbnQgdGhlIHJlc3RFbmNvZGVyIGFuZCBzdG9yZSBhIHNsaWNlIG9mIGl0IHBlci1jbGllbnQgdW50aWwgd2Uga25vdyBob3cgbWFueSBjbGllbnRzIHRoZXJlIGFyZS5cbiAgICAgKiBXaGVuIHdlIGZsdXNoICh0b1VpbnQ4QXJyYXkpIHdlIHdyaXRlIHRoZSByZXN0RW5jb2RlciB1c2luZyB0aGUgZnJhZ21lbnRzIGFuZCB0aGUgbWV0YS1pbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTx7IHdyaXR0ZW46IG51bWJlciwgcmVzdEVuY29kZXI6IFVpbnQ4QXJyYXkgfT59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRTdHJ1Y3RzID0gW107XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFVpbnQ4QXJyYXk+fSB1cGRhdGVzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBtZXJnZVVwZGF0ZXMgPSB1cGRhdGVzID0+IG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgRFNFbmNvZGVyVjEgfCB0eXBlb2YgRFNFbmNvZGVyVjJ9IFlFbmNvZGVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIgPSAodXBkYXRlLCBZRW5jb2RlciA9IERTRW5jb2RlclYyLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSwgdHJ1ZSk7XG4gIGxldCBjdXJyID0gdXBkYXRlRGVjb2Rlci5jdXJyO1xuICBpZiAoY3VyciAhPT0gbnVsbCkge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgIGxldCBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrO1xuICAgIGxldCBzdG9wQ291bnRpbmcgPSBmYWxzZTtcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgc2l6ZSsrO1xuICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgLy8gd3JpdGUgd2hhdCB3ZSBoYXZlIHRvIHRoZSBlbmNvZGVyXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xpZW50KTtcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbG9jayk7XG4gICAgICAgIGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICAgICAgc3RvcENvdW50aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICBzdG9wQ291bnRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdG9wQ291bnRpbmcpIHtcbiAgICAgICAgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3cml0ZSB3aGF0IHdlIGhhdmVcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudCk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbG9jayk7XG4gICAgLy8gcHJlcGVuZCB0aGUgc2l6ZSBvZiB0aGUgc3RhdGUgdmVjdG9yXG4gICAgY29uc3QgZW5jID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmMsIHNpemUpO1xuICAgIGVuY29kaW5nLndyaXRlQmluYXJ5RW5jb2RlcihlbmMsIGVuY29kZXIucmVzdEVuY29kZXIpO1xuICAgIGVuY29kZXIucmVzdEVuY29kZXIgPSBlbmM7XG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMCk7XG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlID0gdXBkYXRlID0+IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyKHVwZGF0ZSwgRFNFbmNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFlEZWNvZGVyXG4gKiBAcmV0dXJuIHt7IGZyb206IE1hcDxudW1iZXIsbnVtYmVyPiwgdG86IE1hcDxudW1iZXIsbnVtYmVyPiB9fVxuICovXG5jb25zdCBwYXJzZVVwZGF0ZU1ldGFWMiA9ICh1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIGNvbnN0IGZyb20gPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIGNvbnN0IHRvID0gbmV3IE1hcCgpO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIobmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSksIGZhbHNlKTtcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnI7XG4gIGlmIChjdXJyICE9PSBudWxsKSB7XG4gICAgbGV0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICBsZXQgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jaztcbiAgICAvLyB3cml0ZSB0aGUgYmVnaW5uaW5nIHRvIGBmcm9tYFxuICAgIGZyb20uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jayk7XG4gICAgZm9yICg7IGN1cnIgIT09IG51bGw7IGN1cnIgPSB1cGRhdGVEZWNvZGVyLm5leHQoKSkge1xuICAgICAgaWYgKGN1cnJDbGllbnQgIT09IGN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgIC8vIFdlIGZvdW5kIGEgbmV3IGNsaWVudFxuICAgICAgICAvLyB3cml0ZSB0aGUgZW5kIHRvIGB0b2BcbiAgICAgICAgdG8uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jayk7XG4gICAgICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgICAgIGZyb20uc2V0KGN1cnIuaWQuY2xpZW50LCBjdXJyLmlkLmNsb2NrKTtcbiAgICAgICAgLy8gdXBkYXRlIGN1cnJDbGllbnRcbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgICAgfVxuICAgICAgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoO1xuICAgIH1cbiAgICAvLyB3cml0ZSB0aGUgZW5kIHRvIGB0b2BcbiAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKTtcbiAgfVxuICByZXR1cm4geyBmcm9tLCB0byB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcmV0dXJuIHt7IGZyb206IE1hcDxudW1iZXIsbnVtYmVyPiwgdG86IE1hcDxudW1iZXIsbnVtYmVyPiB9fVxuICovXG5jb25zdCBwYXJzZVVwZGF0ZU1ldGEgPSB1cGRhdGUgPT4gcGFyc2VVcGRhdGVNZXRhVjIodXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIHNsaWNlIGFueSBraW5kIG9mIHN0cnVjdCBhbmQgcmV0cmlldmUgdGhlIHJpZ2h0IHBhcnQuXG4gKiBJdCBkb2VzIG5vdCBoYW5kbGUgc2lkZS1lZmZlY3RzLCBzbyBpdCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IHRoZSBsYXp5LWVuY29kZXIuXG4gKlxuICogQHBhcmFtIHtJdGVtIHwgR0MgfCBTa2lwfSBsZWZ0XG4gKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICogQHJldHVybiB7SXRlbSB8IEdDfVxuICovXG5jb25zdCBzbGljZVN0cnVjdCA9IChsZWZ0LCBkaWZmKSA9PiB7XG4gIGlmIChsZWZ0LmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdC5pZDtcbiAgICByZXR1cm4gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2UgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWQ7XG4gICAgcmV0dXJuIG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlZnRJdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdCk7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZDtcbiAgICByZXR1cm4gbmV3IEl0ZW0oXG4gICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgICBudWxsLFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICAgIG51bGwsXG4gICAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gICAgKVxuICB9XG59O1xuXG4vKipcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIHNpbWlsYXJseSB0byBgcmVhZFVwZGF0ZVYyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFVpbnQ4QXJyYXk+fSB1cGRhdGVzXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYyfSBbWUVuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBtZXJnZVVwZGF0ZXNWMiA9ICh1cGRhdGVzLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgY29uc3QgdXBkYXRlRGVjb2RlcnMgPSB1cGRhdGVzLm1hcCh1cGRhdGUgPT4gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSkpO1xuICBsZXQgbGF6eVN0cnVjdERlY29kZXJzID0gdXBkYXRlRGVjb2RlcnMubWFwKGRlY29kZXIgPT4gbmV3IExhenlTdHJ1Y3RSZWFkZXIoZGVjb2RlciwgdHJ1ZSkpO1xuXG4gIC8qKlxuICAgKiBAdG9kbyB3ZSBkb24ndCBuZWVkIG9mZnNldCBiZWNhdXNlIHdlIGFsd2F5cyBzbGljZSBiZWZvcmVcbiAgICogQHR5cGUge251bGwgfCB7IHN0cnVjdDogSXRlbSB8IEdDIHwgU2tpcCwgb2Zmc2V0OiBudW1iZXIgfX1cbiAgICovXG4gIGxldCBjdXJyV3JpdGUgPSBudWxsO1xuXG4gIGNvbnN0IHVwZGF0ZUVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgLy8gd3JpdGUgc3RydWN0cyBsYXppbHlcbiAgY29uc3QgbGF6eVN0cnVjdEVuY29kZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcih1cGRhdGVFbmNvZGVyKTtcblxuICAvLyBOb3RlOiBXZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBsYXp5U3RydWN0RGVjb2RlcnMgYXJlIGZ1bGx5IGNvbnN1bWVkXG4gIC8vIE5vdGU6IFNob3VsZCBtZXJnZSBkb2N1bWVudCB1cGRhdGVzIHdoZW5ldmVyIHBvc3NpYmxlIC0gZXZlbiBmcm9tIGRpZmZlcmVudCB1cGRhdGVzXG4gIC8vIE5vdGU6IFNob3VsZCBoYW5kbGUgdGhhdCBzb21lIG9wZXJhdGlvbnMgY2Fubm90IGJlIGFwcGxpZWQgeWV0ICgpXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBXcml0ZSBoaWdoZXIgY2xpZW50cyBmaXJzdCDih5Igc29ydCBieSBjbGllbnRJRCAmIGNsb2NrIGFuZCByZW1vdmUgZGVjb2RlcnMgd2l0aG91dCBjb250ZW50XG4gICAgbGF6eVN0cnVjdERlY29kZXJzID0gbGF6eVN0cnVjdERlY29kZXJzLmZpbHRlcihkZWMgPT4gZGVjLmN1cnIgIT09IG51bGwpO1xuICAgIGxhenlTdHJ1Y3REZWNvZGVycy5zb3J0KFxuICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihhbnksYW55KTpudW1iZXJ9ICovIChkZWMxLCBkZWMyKSA9PiB7XG4gICAgICAgIGlmIChkZWMxLmN1cnIuaWQuY2xpZW50ID09PSBkZWMyLmN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgICAgY29uc3QgY2xvY2tEaWZmID0gZGVjMS5jdXJyLmlkLmNsb2NrIC0gZGVjMi5jdXJyLmlkLmNsb2NrO1xuICAgICAgICAgIGlmIChjbG9ja0RpZmYgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IGRlYzIuY3Vyci5jb25zdHJ1Y3RvciA/IDAgOiAoXG4gICAgICAgICAgICAgIGRlYzEuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCA/IDEgOiAtMVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2tEaWZmXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWMyLmN1cnIuaWQuY2xpZW50IC0gZGVjMS5jdXJyLmlkLmNsaWVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAobGF6eVN0cnVjdERlY29kZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY29uc3QgY3VyckRlY29kZXIgPSBsYXp5U3RydWN0RGVjb2RlcnNbMF07XG4gICAgLy8gd3JpdGUgZnJvbSBjdXJyRGVjb2RlciB1bnRpbCB0aGUgbmV4dCBvcGVyYXRpb24gaXMgZnJvbSBhbm90aGVyIGNsaWVudCBvciBpZiBmaWxsZXItc3RydWN0XG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlb3JkZXIgdGhlIGRlY29kZXJzIGFuZCBmaW5kIHRoZSBuZXh0IG9wZXJhdGlvbiB0byB3cml0ZVxuICAgIGNvbnN0IGZpcnN0Q2xpZW50ID0gLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKS5pZC5jbGllbnQ7XG5cbiAgICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgICBsZXQgY3VyciA9IC8qKiBAdHlwZSB7SXRlbSB8IEdDIHwgbnVsbH0gKi8gKGN1cnJEZWNvZGVyLmN1cnIpO1xuXG4gICAgICAvLyBpdGVyYXRlIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHRoYXQgd2UgaGF2ZW4ndCB3cml0dGVuIGFscmVhZHlcbiAgICAgIC8vIHJlbWVtYmVyOiBmaXJzdCB0aGUgaGlnaCBjbGllbnQtaWRzIGFyZSB3cml0dGVuXG4gICAgICB3aGlsZSAoY3VyciAhPT0gbnVsbCAmJiBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPD0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIGN1cnIuaWQuY2xpZW50ID49IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIGN1cnIgPSBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgICB9XG4gICAgICBpZiAoY3VyciA9PT0gbnVsbCB8fCBjdXJyLmlkLmNsaWVudCAhPT0gZmlyc3RDbGllbnQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0Q2xpZW50ICE9PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsaWVudCkge1xuICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBjdXJyLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgY3VyckRlY29kZXIubmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA8IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICAvLyBAdG9kbyB3cml0ZSBjdXJyU3RydWN0ICYgc2V0IGN1cnJTdHJ1Y3QgPSBTa2lwKGNsb2NrID0gY3VyclN0cnVjdC5pZC5jbG9jayArIGN1cnJTdHJ1Y3QubGVuZ3RoLCBsZW5ndGggPSBjdXJyLmlkLmNsb2NrIC0gc2VsZi5jbG9jaylcbiAgICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICAgICAgLy8gZXh0ZW5kIGV4aXN0aW5nIHNraXBcbiAgICAgICAgICAgIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoIC0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnIuaWQuY2xvY2sgLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5sZW5ndGg7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtTa2lwfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgU2tpcChjcmVhdGVJRChmaXJzdENsaWVudCwgY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoKSwgZGlmZik7XG4gICAgICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdCwgb2Zmc2V0OiAwIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID49IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIC0gY3Vyci5pZC5jbG9jaztcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAgIC8vIHByZWZlciB0byBzbGljZSBTa2lwIGJlY2F1c2UgdGhlIG90aGVyIHN0cnVjdCBtaWdodCBjb250YWluIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggLT0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnIgPSBzbGljZVN0cnVjdChjdXJyLCBkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjdXJyV3JpdGUuc3RydWN0Lm1lcmdlV2l0aCgvKiogQHR5cGUge2FueX0gKi8gKGN1cnIpKSkge1xuICAgICAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IGN1cnIsIG9mZnNldDogMCB9O1xuICAgICAgICAgICAgY3VyckRlY29kZXIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKSwgb2Zmc2V0OiAwIH07XG4gICAgICBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBsZXQgbmV4dCA9IGN1cnJEZWNvZGVyLmN1cnI7XG4gICAgICBuZXh0ICE9PSBudWxsICYmIG5leHQuaWQuY2xpZW50ID09PSBmaXJzdENsaWVudCAmJiBuZXh0LmlkLmNsb2NrID09PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggJiYgbmV4dC5jb25zdHJ1Y3RvciAhPT0gU2tpcDtcbiAgICAgIG5leHQgPSBjdXJyRGVjb2Rlci5uZXh0KClcbiAgICApIHtcbiAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBuZXh0LCBvZmZzZXQ6IDAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJXcml0ZSAhPT0gbnVsbCkge1xuICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICBjdXJyV3JpdGUgPSBudWxsO1xuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlTdHJ1Y3RFbmNvZGVyKTtcblxuICBjb25zdCBkc3MgPSB1cGRhdGVEZWNvZGVycy5tYXAoZGVjb2RlciA9PiByZWFkRGVsZXRlU2V0KGRlY29kZXIpKTtcbiAgY29uc3QgZHMgPSBtZXJnZURlbGV0ZVNldHMoZHNzKTtcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpO1xuICByZXR1cm4gdXBkYXRlRW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzdlxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYxIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMn0gW1lFbmNvZGVyXVxuICovXG5jb25zdCBkaWZmVXBkYXRlVjIgPSAodXBkYXRlLCBzdiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIsIFlFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYyKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gZGVjb2RlU3RhdGVWZWN0b3Ioc3YpO1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIGNvbnN0IGxhenlTdHJ1Y3RXcml0ZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcihlbmNvZGVyKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpO1xuICBjb25zdCByZWFkZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihkZWNvZGVyLCBmYWxzZSk7XG4gIHdoaWxlIChyZWFkZXIuY3Vycikge1xuICAgIGNvbnN0IGN1cnIgPSByZWFkZXIuY3VycjtcbiAgICBjb25zdCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgY29uc3Qgc3ZDbG9jayA9IHN0YXRlLmdldChjdXJyQ2xpZW50KSB8fCAwO1xuICAgIGlmIChyZWFkZXIuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgLy8gdGhlIGZpcnN0IHdyaXR0ZW4gc3RydWN0IHNob3VsZG4ndCBiZSBhIHNraXBcbiAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoID4gc3ZDbG9jaykge1xuICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdFdyaXRlciwgY3VyciwgbWF0aC5tYXgoc3ZDbG9jayAtIGN1cnIuaWQuY2xvY2ssIDApKTtcbiAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIHJlYWRlci5jdXJyLCAwKTtcbiAgICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZCB1bnRpbCBzb21ldGhpbmcgbmV3IGNvbWVzIHVwXG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50ICYmIHJlYWRlci5jdXJyLmlkLmNsb2NrICsgcmVhZGVyLmN1cnIubGVuZ3RoIDw9IHN2Q2xvY2spIHtcbiAgICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdFdyaXRlcik7XG4gIC8vIHdyaXRlIGRzXG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldChkZWNvZGVyKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzdlxuICovXG5jb25zdCBkaWZmVXBkYXRlID0gKHVwZGF0ZSwgc3YpID0+IGRpZmZVcGRhdGVWMih1cGRhdGUsIHN2LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKi9cbmNvbnN0IGZsdXNoTGF6eVN0cnVjdFdyaXRlciA9IGxhenlXcml0ZXIgPT4ge1xuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCkge1xuICAgIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5wdXNoKHsgd3JpdHRlbjogbGF6eVdyaXRlci53cml0dGVuLCByZXN0RW5jb2RlcjogZW5jb2RpbmcudG9VaW50OEFycmF5KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlcikgfSk7XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICAgIGxhenlXcml0ZXIud3JpdHRlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKiBAcGFyYW0ge0l0ZW0gfCBHQ30gc3RydWN0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyID0gKGxhenlXcml0ZXIsIHN0cnVjdCwgb2Zmc2V0KSA9PiB7XG4gIC8vIGZsdXNoIGN1cnIgaWYgd2Ugc3RhcnQgYW5vdGhlciBjbGllbnRcbiAgaWYgKGxhenlXcml0ZXIud3JpdHRlbiA+IDAgJiYgbGF6eVdyaXRlci5jdXJyQ2xpZW50ICE9PSBzdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgZmx1c2hMYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIpO1xuICB9XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPT09IDApIHtcbiAgICBsYXp5V3JpdGVyLmN1cnJDbGllbnQgPSBzdHJ1Y3QuaWQuY2xpZW50O1xuICAgIC8vIHdyaXRlIG5leHQgY2xpZW50XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLndyaXRlQ2xpZW50KHN0cnVjdC5pZC5jbGllbnQpO1xuICAgIC8vIHdyaXRlIHN0YXJ0Q2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyLCBzdHJ1Y3QuaWQuY2xvY2sgKyBvZmZzZXQpO1xuICB9XG4gIHN0cnVjdC53cml0ZShsYXp5V3JpdGVyLmVuY29kZXIsIG9mZnNldCk7XG4gIGxhenlXcml0ZXIud3JpdHRlbisrO1xufTtcbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gd2UgY29sbGVjdGVkIGFsbCBwYXJ0cyBhbmQgd2FudCB0b1xuICogcHV0IGFsbCB0aGUgcGFydHMgdG9nZXRoZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gKiB5b3UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBVcGRhdGVFbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICovXG5jb25zdCBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyA9IChsYXp5V3JpdGVyKSA9PiB7XG4gIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKTtcblxuICAvLyB0aGlzIGlzIGEgZnJlc2ggZW5jb2RlciBiZWNhdXNlIHdlIGNhbGxlZCBmbHVzaEN1cnJcbiAgY29uc3QgcmVzdEVuY29kZXIgPSBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXI7XG5cbiAgLyoqXG4gICAqIE5vdyB3ZSBwdXQgYWxsIHRoZSBmcmFnbWVudHMgdG9nZXRoZXIuXG4gICAqIFRoaXMgd29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZUNsaWVudHNTdHJ1Y3RzYFxuICAgKi9cblxuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZCAtIGkuZS4gdGhlIGNsaWVudHNcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHMubGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcnRTdHJ1Y3RzID0gbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzW2ldO1xuICAgIC8qKlxuICAgICAqIFdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVTdHJ1Y3RzYFxuICAgICAqL1xuICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy53cml0dGVuKTtcbiAgICAvLyB3cml0ZSB0aGUgcmVzdCBvZiB0aGUgZnJhZ21lbnRcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4QXJyYXkocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLnJlc3RFbmNvZGVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBZRXZlbnQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVR5cGUuXG4gKi9cbmNsYXNzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0YXJnZXQgVGhlIGNoYW5nZWQgdHlwZS5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHRyYW5zYWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb24gd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdGFyZ2V0IG9uIHdoaWNoIHRoZSBvYnNlcnZlIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0O1xuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGlzIGV2ZW50LlxuICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX2NoYW5nZXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgTWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9rZXlzID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PHsgaW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2RlbHRhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgcGF0aCBmcm9tIGB5YCB0byB0aGUgY2hhbmdlZCB0eXBlLlxuICAgKlxuICAgKiBAdG9kbyB2MTQgc2hvdWxkIHN0YW5kYXJkaXplIG9uIHBhdGg6IEFycmF5PHtwYXJlbnQsIGluZGV4fT4gYmVjYXVzZSB0aGF0IGlzIGVhc2llciB0byB3b3JrIHdpdGguXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgcHJvcGVydHkgaG9sZHM6XG4gICAqIEBleGFtcGxlXG4gICAqICAgbGV0IHR5cGUgPSB5XG4gICAqICAgZXZlbnQucGF0aC5mb3JFYWNoKGRpciA9PiB7XG4gICAqICAgICB0eXBlID0gdHlwZS5nZXQoZGlyKVxuICAgKiAgIH0pXG4gICAqICAgdHlwZSA9PT0gZXZlbnQudGFyZ2V0IC8vID0+IHRydWVcbiAgICovXG4gIGdldCBwYXRoICgpIHtcbiAgICAvLyBAdHMtaWdub3JlIF9pdGVtIGlzIGRlZmluZWQgYmVjYXVzZSB0YXJnZXQgaXMgaW50ZWdyYXRlZFxuICAgIHJldHVybiBnZXRQYXRoVG8odGhpcy5jdXJyZW50VGFyZ2V0LCB0aGlzLnRhcmdldClcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBkZWxldGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGRlbGV0ZXMgKHN0cnVjdCkge1xuICAgIHJldHVybiBpc0RlbGV0ZWQodGhpcy50cmFuc2FjdGlvbi5kZWxldGVTZXQsIHN0cnVjdC5pZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICovXG4gIGdldCBrZXlzICgpIHtcbiAgICBpZiAodGhpcy5fa2V5cyA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgY29uc3QgY2hhbmdlZCA9IC8qKiBAdHlwZSBTZXQ8c3RyaW5nfG51bGw+ICovICh0aGlzLnRyYW5zYWN0aW9uLmNoYW5nZWQuZ2V0KHRhcmdldCkpO1xuICAgICAgY2hhbmdlZC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodGFyZ2V0Ll9tYXAuZ2V0KGtleSkpO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHsnZGVsZXRlJyB8ICdhZGQnIHwgJ3VwZGF0ZSd9XG4gICAgICAgICAgICovXG4gICAgICAgICAgbGV0IGFjdGlvbjtcbiAgICAgICAgICBsZXQgb2xkVmFsdWU7XG4gICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBpdGVtLmxlZnQ7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmFkZHMocHJldikpIHtcbiAgICAgICAgICAgICAgcHJldiA9IHByZXYubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAndXBkYXRlJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGFycmF5Lmxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2FkZCc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KC8qKiBAdHlwZSB7SXRlbX0gKi8gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gLy8gbm9wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleXMuc2V0KGtleSwgeyBhY3Rpb24sIG9sZFZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2tleXMgPSBrZXlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fa2V5c1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+fT59XG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXMuZGVsdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBhZGRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhZGRzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0LmlkLmNsb2NrID49ICh0aGlzLnRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChzdHJ1Y3QuaWQuY2xpZW50KSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXJ9Pn19XG4gICAqL1xuICBnZXQgY2hhbmdlcyAoKSB7XG4gICAgbGV0IGNoYW5nZXMgPSB0aGlzLl9jaGFuZ2VzO1xuICAgIGlmIChjaGFuZ2VzID09PSBudWxsKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIGNvbnN0IGFkZGVkID0gc2V0LmNyZWF0ZSgpO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IHNldC5jcmVhdGUoKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ6QXJyYXk8YW55Pn18e2RlbGV0ZTpudW1iZXJ9fHtyZXRhaW46bnVtYmVyfT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbHRhID0gW107XG4gICAgICBjaGFuZ2VzID0ge1xuICAgICAgICBhZGRlZCxcbiAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIGtleXM6IHRoaXMua2V5c1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNoYW5nZWQgPSAvKiogQHR5cGUgU2V0PHN0cmluZ3xudWxsPiAqLyAodGhpcy50cmFuc2FjdGlvbi5jaGFuZ2VkLmdldCh0YXJnZXQpKTtcbiAgICAgIGlmIChjaGFuZ2VkLmhhcyhudWxsKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBsYXN0T3AgPSBudWxsO1xuICAgICAgICBjb25zdCBwYWNrT3AgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGxhc3RPcCkge1xuICAgICAgICAgICAgZGVsdGEucHVzaChsYXN0T3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaXRlbSA9IHRhcmdldC5fc3RhcnQ7IGl0ZW0gIT09IG51bGw7IGl0ZW0gPSBpdGVtLnJpZ2h0KSB7XG4gICAgICAgICAgaWYgKGl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSAmJiAhdGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmRlbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBkZWxldGU6IDAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AuZGVsZXRlICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICBkZWxldGVkLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH0gLy8gZWxzZSBub3BcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5pbnNlcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgaW5zZXJ0OiBbXSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5pbnNlcnQgPSBsYXN0T3AuaW5zZXJ0LmNvbmNhdChpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgYWRkZWQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IHJldGFpbjogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5yZXRhaW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0T3AgIT09IG51bGwgJiYgbGFzdE9wLnJldGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFja09wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjaGFuZ2VzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGF0aCBmcm9tIHRoaXMgdHlwZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBgY2hpbGRgIHNob3VsZCBiZSBhY2Nlc3NpYmxlIHZpYSBgdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pLi5gXG4gKiAgIGNvbnN0IHBhdGggPSB0eXBlLmdldFBhdGhUbyhjaGlsZClcbiAqICAgLy8gYXNzdW1pbmcgYHR5cGUgaW5zdGFuY2VvZiBZQXJyYXlgXG4gKiAgIGNvbnNvbGUubG9nKHBhdGgpIC8vIG1pZ2h0IGxvb2sgbGlrZSA9PiBbMiwgJ2tleTEnXVxuICogICBjaGlsZCA9PT0gdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBjaGlsZCB0YXJnZXRcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZ3xudW1iZXI+fSBQYXRoIHRvIHRoZSB0YXJnZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFBhdGhUbyA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKGNoaWxkLl9pdGVtICE9PSBudWxsICYmIGNoaWxkICE9PSBwYXJlbnQpIHtcbiAgICBpZiAoY2hpbGQuX2l0ZW0ucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbWFwLWlzaFxuICAgICAgcGF0aC51bnNoaWZ0KGNoaWxkLl9pdGVtLnBhcmVudFN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBpcyBhcnJheS1pc2hcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBjID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudCkuX3N0YXJ0O1xuICAgICAgd2hpbGUgKGMgIT09IGNoaWxkLl9pdGVtICYmIGMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFjLmRlbGV0ZWQpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGMucmlnaHQ7XG4gICAgICB9XG4gICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgfVxuICAgIGNoaWxkID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIHBhdGhcbn07XG5cbmNvbnN0IG1heFNlYXJjaE1hcmtlciA9IDgwO1xuXG4vKipcbiAqIEEgdW5pcXVlIHRpbWVzdGFtcCB0aGF0IGlkZW50aWZpZXMgZWFjaCBtYXJrZXIuXG4gKlxuICogVGltZSBpcyByZWxhdGl2ZSwuLiB0aGlzIGlzIG1vcmUgbGlrZSBhbiBldmVyLWluY3JlYXNpbmcgY2xvY2suXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCA9IDA7XG5cbmNsYXNzIEFycmF5U2VhcmNoTWFya2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbX0gcFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChwLCBpbmRleCkge1xuICAgIHAubWFya2VyID0gdHJ1ZTtcbiAgICB0aGlzLnAgPSBwO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKi9cbmNvbnN0IHJlZnJlc2hNYXJrZXJUaW1lc3RhbXAgPSBtYXJrZXIgPT4geyBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7IH07XG5cbi8qKlxuICogVGhpcyBpcyByYXRoZXIgY29tcGxleCBzbyB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmx5IHRoaW5nIHRoYXQgc2hvdWxkIG92ZXJ3cml0ZSBhIG1hcmtlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlTZWFyY2hNYXJrZXJ9IG1hcmtlclxuICogQHBhcmFtIHtJdGVtfSBwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3Qgb3ZlcndyaXRlTWFya2VyID0gKG1hcmtlciwgcCwgaW5kZXgpID0+IHtcbiAgbWFya2VyLnAubWFya2VyID0gZmFsc2U7XG4gIG1hcmtlci5wID0gcDtcbiAgcC5tYXJrZXIgPSB0cnVlO1xuICBtYXJrZXIuaW5kZXggPSBpbmRleDtcbiAgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn0gc2VhcmNoTWFya2VyXG4gKiBAcGFyYW0ge0l0ZW19IHBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBtYXJrUG9zaXRpb24gPSAoc2VhcmNoTWFya2VyLCBwLCBpbmRleCkgPT4ge1xuICBpZiAoc2VhcmNoTWFya2VyLmxlbmd0aCA+PSBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBvdmVycmlkZSBvbGRlc3QgbWFya2VyICh3ZSBkb24ndCB3YW50IHRvIGNyZWF0ZSBtb3JlIG9iamVjdHMpXG4gICAgY29uc3QgbWFya2VyID0gc2VhcmNoTWFya2VyLnJlZHVjZSgoYSwgYikgPT4gYS50aW1lc3RhbXAgPCBiLnRpbWVzdGFtcCA/IGEgOiBiKTtcbiAgICBvdmVyd3JpdGVNYXJrZXIobWFya2VyLCBwLCBpbmRleCk7XG4gICAgcmV0dXJuIG1hcmtlclxuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBuZXcgbWFya2VyXG4gICAgY29uc3QgcG0gPSBuZXcgQXJyYXlTZWFyY2hNYXJrZXIocCwgaW5kZXgpO1xuICAgIHNlYXJjaE1hcmtlci5wdXNoKHBtKTtcbiAgICByZXR1cm4gcG1cbiAgfVxufTtcblxuLyoqXG4gKiBTZWFyY2ggbWFya2VyIGhlbHAgdXMgdG8gZmluZCBwb3NpdGlvbnMgaW4gdGhlIGFzc29jaWF0aXZlIGFycmF5IGZhc3Rlci5cbiAqXG4gKiBUaGV5IHNwZWVkIHVwIHRoZSBwcm9jZXNzIG9mIGZpbmRpbmcgYSBwb3NpdGlvbiB3aXRob3V0IG11Y2ggYm9va2tlZXBpbmcuXG4gKlxuICogQSBtYXhpbXVtIG9mIGBtYXhTZWFyY2hNYXJrZXJgIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHdheXMgcmV0dXJucyBhIHJlZnJlc2hlZCBtYXJrZXIgKHVwZGF0ZWQgdGltZXN0YW1wKVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHlhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IGZpbmRNYXJrZXIgPSAoeWFycmF5LCBpbmRleCkgPT4ge1xuICBpZiAoeWFycmF5Ll9zdGFydCA9PT0gbnVsbCB8fCBpbmRleCA9PT0gMCB8fCB5YXJyYXkuX3NlYXJjaE1hcmtlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgbWFya2VyID0geWFycmF5Ll9zZWFyY2hNYXJrZXIubGVuZ3RoID09PSAwID8gbnVsbCA6IHlhcnJheS5fc2VhcmNoTWFya2VyLnJlZHVjZSgoYSwgYikgPT4gbWF0aC5hYnMoaW5kZXggLSBhLmluZGV4KSA8IG1hdGguYWJzKGluZGV4IC0gYi5pbmRleCkgPyBhIDogYik7XG4gIGxldCBwID0geWFycmF5Ll9zdGFydDtcbiAgbGV0IHBpbmRleCA9IDA7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBwID0gbWFya2VyLnA7XG4gICAgcGluZGV4ID0gbWFya2VyLmluZGV4O1xuICAgIHJlZnJlc2hNYXJrZXJUaW1lc3RhbXAobWFya2VyKTsgLy8gd2UgdXNlZCBpdCwgd2UgbWlnaHQgbmVlZCB0byB1c2UgaXQgYWdhaW5cbiAgfVxuICAvLyBpdGVyYXRlIHRvIHJpZ2h0IGlmIHBvc3NpYmxlXG4gIHdoaWxlIChwLnJpZ2h0ICE9PSBudWxsICYmIHBpbmRleCA8IGluZGV4KSB7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IHBpbmRleCArIHAubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwaW5kZXggKz0gcC5sZW5ndGg7XG4gICAgfVxuICAgIHAgPSBwLnJpZ2h0O1xuICB9XG4gIC8vIGl0ZXJhdGUgdG8gbGVmdCBpZiBuZWNlc3NhcnkgKG1pZ2h0IGJlIHRoYXQgcGluZGV4ID4gaW5kZXgpXG4gIHdoaWxlIChwLmxlZnQgIT09IG51bGwgJiYgcGluZGV4ID4gaW5kZXgpIHtcbiAgICBwID0gcC5sZWZ0O1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgfVxuICB9XG4gIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgcCBjYW4ndCBiZSBtZXJnZWQgd2l0aCBsZWZ0LCBiZWNhdXNlIHRoYXQgd291bGQgc2NyZXcgdXAgZXZlcnl0aGluZ1xuICAvLyBpbiB0aGF0IGNhcyBqdXN0IHJldHVybiB3aGF0IHdlIGhhdmUgKGl0IGlzIG1vc3QgbGlrZWx5IHRoZSBiZXN0IG1hcmtlciBhbnl3YXkpXG4gIC8vIGl0ZXJhdGUgdG8gbGVmdCB1bnRpbCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnRcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwLmxlZnQuaWQuY2xpZW50ID09PSBwLmlkLmNsaWVudCAmJiBwLmxlZnQuaWQuY2xvY2sgKyBwLmxlZnQubGVuZ3RoID09PSBwLmlkLmNsb2NrKSB7XG4gICAgcCA9IHAubGVmdDtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgcGluZGV4IC09IHAubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8vIEB0b2RvIHJlbW92ZSFcbiAgLy8gYXNzdXJlIHBvc2l0aW9uXG4gIC8vIHtcbiAgLy8gICBsZXQgc3RhcnQgPSB5YXJyYXkuX3N0YXJ0XG4gIC8vICAgbGV0IHBvcyA9IDBcbiAgLy8gICB3aGlsZSAoc3RhcnQgIT09IHApIHtcbiAgLy8gICAgIGlmICghc3RhcnQuZGVsZXRlZCAmJiBzdGFydC5jb3VudGFibGUpIHtcbiAgLy8gICAgICAgcG9zICs9IHN0YXJ0Lmxlbmd0aFxuICAvLyAgICAgfVxuICAvLyAgICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodClcbiAgLy8gICB9XG4gIC8vICAgaWYgKHBvcyAhPT0gcGluZGV4KSB7XG4gIC8vICAgICBkZWJ1Z2dlclxuICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdHb3RjaGEgcG9zaXRpb24gZmFpbCEnKVxuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBpZiAobWFya2VyKSB7XG4gIC8vICAgaWYgKHdpbmRvdy5sZW5ndGhlcyA9PSBudWxsKSB7XG4gIC8vICAgICB3aW5kb3cubGVuZ3RoZXMgPSBbXVxuICAvLyAgICAgd2luZG93LmdldExlbmd0aGVzID0gKCkgPT4gd2luZG93Lmxlbmd0aGVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAvLyAgIH1cbiAgLy8gICB3aW5kb3cubGVuZ3RoZXMucHVzaChtYXJrZXIuaW5kZXggLSBwaW5kZXgpXG4gIC8vICAgY29uc29sZS5sb2coJ2Rpc3RhbmNlJywgbWFya2VyLmluZGV4IC0gcGluZGV4LCAnbGVuJywgcCAmJiBwLnBhcmVudC5sZW5ndGgpXG4gIC8vIH1cbiAgaWYgKG1hcmtlciAhPT0gbnVsbCAmJiBtYXRoLmFicyhtYXJrZXIuaW5kZXggLSBwaW5kZXgpIDwgLyoqIEB0eXBlIHtZVGV4dHxZQXJyYXk8YW55Pn0gKi8gKHAucGFyZW50KS5sZW5ndGggLyBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBhZGp1c3QgZXhpc3RpbmcgbWFya2VyXG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgcGluZGV4KTtcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICByZXR1cm4gbWFya1Bvc2l0aW9uKHlhcnJheS5fc2VhcmNoTWFya2VyLCBwLCBwaW5kZXgpXG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIG1hcmtlcnMgd2hlbiBhIGNoYW5nZSBoYXBwZW5lZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGRvaW5nIGEgZGVsZXRpb24hXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIElmIGluc2VydGlvbiwgbGVuIGlzIHBvc2l0aXZlLiBJZiBkZWxldGlvbiwgbGVuIGlzIG5lZ2F0aXZlLlxuICovXG5jb25zdCB1cGRhdGVNYXJrZXJDaGFuZ2VzID0gKHNlYXJjaE1hcmtlciwgaW5kZXgsIGxlbikgPT4ge1xuICBmb3IgKGxldCBpID0gc2VhcmNoTWFya2VyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbSA9IHNlYXJjaE1hcmtlcltpXTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcCA9IG0ucDtcbiAgICAgIHAubWFya2VyID0gZmFsc2U7XG4gICAgICAvLyBJZGVhbGx5IHdlIGp1c3Qgd2FudCB0byBkbyBhIHNpbXBsZSBwb3NpdGlvbiBjb21wYXJpc29uLCBidXQgdGhpcyB3aWxsIG9ubHkgd29yayBpZlxuICAgICAgLy8gc2VhcmNoIG1hcmtlcnMgZG9uJ3QgcG9pbnQgdG8gZGVsZXRlZCBpdGVtcyBmb3IgZm9ybWF0cy5cbiAgICAgIC8vIEl0ZXJhdGUgbWFya2VyIHRvIHByZXYgdW5kZWxldGVkIGNvdW50YWJsZSBwb3NpdGlvbiBzbyB3ZSBrbm93IHdoYXQgdG8gZG8gd2hlbiB1cGRhdGluZyBhIHBvc2l0aW9uXG4gICAgICB3aGlsZSAocCAmJiAocC5kZWxldGVkIHx8ICFwLmNvdW50YWJsZSkpIHtcbiAgICAgICAgcCA9IHAubGVmdDtcbiAgICAgICAgaWYgKHAgJiYgIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbi4gdGhlIGxvb3Agc2hvdWxkIGJyZWFrIG5vd1xuICAgICAgICAgIG0uaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBudWxsIHx8IHAubWFya2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBzZWFyY2ggbWFya2VyIGlmIHVwZGF0ZWQgcG9zaXRpb24gaXMgbnVsbCBvciBpZiBwb3NpdGlvbiBpcyBhbHJlYWR5IG1hcmtlZFxuICAgICAgICBzZWFyY2hNYXJrZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbS5wID0gcDtcbiAgICAgIHAubWFya2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgbS5pbmRleCB8fCAobGVuID4gMCAmJiBpbmRleCA9PT0gbS5pbmRleCkpIHsgLy8gYSBzaW1wbGUgaW5kZXggPD0gbS5pbmRleCBjaGVjayB3b3VsZCBhY3R1YWxseSBzdWZmaWNlXG4gICAgICBtLmluZGV4ID0gbWF0aC5tYXgoaW5kZXgsIG0uaW5kZXggKyBsZW4pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlIGFsbCAobGlzdCkgY2hpbGRyZW4gb2YgYSB0eXBlIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0XG4gKiBAcmV0dXJuIHtBcnJheTxJdGVtPn1cbiAqL1xuY29uc3QgZ2V0VHlwZUNoaWxkcmVuID0gdCA9PiB7XG4gIGxldCBzID0gdC5fc3RhcnQ7XG4gIGNvbnN0IGFyciA9IFtdO1xuICB3aGlsZSAocykge1xuICAgIGFyci5wdXNoKHMpO1xuICAgIHMgPSBzLnJpZ2h0O1xuICB9XG4gIHJldHVybiBhcnJcbn07XG5cbi8qKlxuICogQ2FsbCBldmVudCBsaXN0ZW5lcnMgd2l0aCBhbiBldmVudC4gVGhpcyB3aWxsIGFsc28gYWRkIGFuIGV2ZW50IHRvIGFsbFxuICogcGFyZW50cyAoZm9yIGAub2JzZXJ2ZURlZXBgIGhhbmRsZXJzKS5cbiAqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxFdmVudFR5cGU+fSB0eXBlXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtFdmVudFR5cGV9IGV2ZW50XG4gKi9cbmNvbnN0IGNhbGxUeXBlT2JzZXJ2ZXJzID0gKHR5cGUsIHRyYW5zYWN0aW9uLCBldmVudCkgPT4ge1xuICBjb25zdCBjaGFuZ2VkVHlwZSA9IHR5cGU7XG4gIGNvbnN0IGNoYW5nZWRQYXJlbnRUeXBlcyA9IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbWFwLnNldElmVW5kZWZpbmVkKGNoYW5nZWRQYXJlbnRUeXBlcywgdHlwZSwgKCkgPT4gW10pLnB1c2goZXZlbnQpO1xuICAgIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICB0eXBlID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHR5cGUuX2l0ZW0ucGFyZW50KTtcbiAgfVxuICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzKGNoYW5nZWRUeXBlLl9lSCwgZXZlbnQsIHRyYW5zYWN0aW9uKTtcbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIEV2ZW50VHlwZVxuICogQWJzdHJhY3QgWWpzIFR5cGUgY2xhc3NcbiAqL1xuY2xhc3MgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsSXRlbT59XG4gICAgICovXG4gICAgdGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fc3RhcnQgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAvKipcbiAgICAgKiBFdmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8RXZlbnRUeXBlLFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9lSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgIC8qKlxuICAgICAqIERlZXAgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyPEFycmF5PFlFdmVudD4sVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX2RFSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPGFueT58bnVsbH1cbiAgICovXG4gIGdldCBwYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMuX2l0ZW0ucGFyZW50KSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHRoaXMuZG9jID0geTtcbiAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7IH1cblxuICAvKipcbiAgICogVGhlIGZpcnN0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBfZmlyc3QgKCkge1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlFdmVudCBhbmQgY2FsbHMgYWxsIHR5cGUgb2JzZXJ2ZXJzLlxuICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbi5sb2NhbCAmJiB0aGlzLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgIHRoaXMuX3NlYXJjaE1hcmtlci5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBvbiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLCBUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgb2JzZXJ2ZSAoZikge1xuICAgIGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2VILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPYnNlcnZlIGFsbCBldmVudHMgdGhhdCBhcmUgY3JlYXRlZCBieSB0aGlzIHR5cGUgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ+LFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlRGVlcCAoZikge1xuICAgIGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZSAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2VILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudD4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZURlZXAgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICB0b0pTT04gKCkge31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFNsaWNlID0gKHR5cGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdHlwZS5fbGVuZ3RoICsgc3RhcnQ7XG4gIH1cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSB0eXBlLl9sZW5ndGggKyBlbmQ7XG4gIH1cbiAgbGV0IGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCAmJiBsZW4gPiAwKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgaWYgKGMubGVuZ3RoIDw9IHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0IC09IGMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgYy5sZW5ndGggJiYgbGVuID4gMDsgaSsrKSB7XG4gICAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgICAgICBsZW4tLTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RUb0FycmF5ID0gdHlwZSA9PiB7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0VG9BcnJheVNuYXBzaG90ID0gKHR5cGUsIHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmIGlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIHJldHVybiBjc1xufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gb3ZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxudW1iZXIsYW55KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RGb3JFYWNoID0gKHR5cGUsIGYpID0+IHtcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZihjW2ldLCBpbmRleCsrLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIEMsUlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihDLG51bWJlcixBYnN0cmFjdFR5cGU8YW55Pik6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdE1hcCA9ICh0eXBlLCBmKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0eXBlTGlzdEZvckVhY2godHlwZSwgKGMsIGkpID0+IHtcbiAgICByZXN1bHQucHVzaChmKGMsIGksIHR5cGUpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RDcmVhdGVJdGVyYXRvciA9IHR5cGUgPT4ge1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICovXG4gIGxldCBjdXJyZW50Q29udGVudCA9IG51bGw7XG4gIGxldCBjdXJyZW50Q29udGVudEluZGV4ID0gMDtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgLy8gZmluZCBzb21lIGNvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSByZWFjaGVkIHRoZSBlbmQsIG5vIG5lZWQgdG8gY2hlY2sgY3VycmVudENvbnRlbnQsIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZm91bmQgbiwgc28gd2UgY2FuIHNldCBjdXJyZW50Q29udGVudFxuICAgICAgICBjdXJyZW50Q29udGVudCA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICAgIGN1cnJlbnRDb250ZW50SW5kZXggPSAwO1xuICAgICAgICBuID0gbi5yaWdodDsgLy8gd2UgdXNlZCB0aGUgY29udGVudCBvZiBuLCBub3cgaXRlcmF0ZSB0byBuZXh0XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRDb250ZW50W2N1cnJlbnRDb250ZW50SW5kZXgrK107XG4gICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGVtcHR5IGN1cnJlbnRDb250ZW50XG4gICAgICBpZiAoY3VycmVudENvbnRlbnQubGVuZ3RoIDw9IGN1cnJlbnRDb250ZW50SW5kZXgpIHtcbiAgICAgICAgY3VycmVudENvbnRlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7YW55fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RHZXQgPSAodHlwZSwgaW5kZXgpID0+IHtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcih0eXBlLCBpbmRleCk7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnA7XG4gICAgaW5kZXggLT0gbWFya2VyLmluZGV4O1xuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbi5jb250ZW50LmdldENvbnRlbnQoKVtpbmRleF1cbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW0/fSByZWZlcmVuY2VJdGVtXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fGJvb2xlYW58bnVtYmVyfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIHJlZmVyZW5jZUl0ZW0sIGNvbnRlbnQpID0+IHtcbiAgbGV0IGxlZnQgPSByZWZlcmVuY2VJdGVtO1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgY29uc3QgcmlnaHQgPSByZWZlcmVuY2VJdGVtID09PSBudWxsID8gcGFyZW50Ll9zdGFydCA6IHJlZmVyZW5jZUl0ZW0ucmlnaHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0fEFycmF5PGFueT58bnVtYmVyPn1cbiAgICovXG4gIGxldCBqc29uQ29udGVudCA9IFtdO1xuICBjb25zdCBwYWNrSnNvbkNvbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKGpzb25Db250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEFueShqc29uQ29udGVudCkpO1xuICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAganNvbkNvbnRlbnQgPSBbXTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQuZm9yRWFjaChjID0+IHtcbiAgICBzd2l0Y2ggKGMuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIEFycmF5OlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICAgIGpzb25Db250ZW50LnB1c2goYyk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBwYWNrSnNvbkNvbnRlbnQoKTtcbiAgICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRCaW5hcnkobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAoYykpKSk7XG4gICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgRG9jOlxuICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50RG9jKC8qKiBAdHlwZSB7RG9jfSAqLyAoYykpKTtcbiAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudFR5cGUoYykpO1xuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlIGluIGluc2VydCBvcGVyYXRpb24nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9KTtcbiAgcGFja0pzb25Db250ZW50KCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCBjb250ZW50KSA9PiB7XG4gIGlmIChpbmRleCA9PT0gMCkge1xuICAgIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgaW5kZXgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBudWxsLCBjb250ZW50KVxuICB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KTtcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0O1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wO1xuICAgIGluZGV4IC09IG1hcmtlci5pbmRleDtcbiAgICAvLyB3ZSBuZWVkIHRvIGl0ZXJhdGUgb25lIHRvIHRoZSBsZWZ0IHNvIHRoYXQgdGhlIGFsZ29yaXRobSB3b3Jrc1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gQHRvZG8gcmVmYWN0b3IgdGhpcyBhcyBpdCBhY3R1YWxseSBkb2Vzbid0IGNvbnNpZGVyIGZvcm1hdHNcbiAgICAgIG4gPSBuLnByZXY7IC8vIGltcG9ydGFudCEgZ2V0IHRoZSBsZWZ0IHVuZGVsZXRlZCBpdGVtIHNvIHRoYXQgd2UgY2FuIGFjdHVhbGx5IGRlY3JlYXNlIGluZGV4XG4gICAgICBpbmRleCArPSAobiAmJiBuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSA/IG4ubGVuZ3RoIDogMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8PSBuLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGluc2VydCBpbi1iZXR3ZWVuXG4gICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3REZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICBpZiAobGVuZ3RoID09PSAwKSB7IHJldHVybiB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgLy8gY29tcHV0ZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBkZWxldGVkXG4gIGZvciAoOyBuICE9PSBudWxsICYmIGluZGV4ID4gMDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyBkZWxldGUgYWxsIGl0ZW1zIHVudGlsIGRvbmVcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgbiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBuLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICBsZW5ndGggLT0gbi5sZW5ndGg7XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgZXJyb3IuY3JlYXRlKCdhcnJheSBsZW5ndGggZXhjZWVkZWQnKVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIC1zdGFydExlbmd0aCArIGxlbmd0aCAvKiBpbiBjYXNlIHdlIHJlbW92ZSB0aGUgYWJvdmUgZXhjZXB0aW9uICovKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwRGVsZXRlID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCBjID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICBjLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT59IHZhbHVlXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwU2V0ID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGtleSwgdmFsdWUpID0+IHtcbiAgY29uc3QgbGVmdCA9IHBhcmVudC5fbWFwLmdldChrZXkpIHx8IG51bGw7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGxldCBjb250ZW50O1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEJpbmFyeSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovICh2YWx1ZSkpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBEb2M6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudERvYygvKiogQHR5cGUge0RvY30gKi8gKHZhbHVlKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRUeXBlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCBudWxsLCBudWxsLCBwYXJlbnQsIGtleSwgY29udGVudCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldCA9IChwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCB2YWwgPSBwYXJlbnQuX21hcC5nZXQoa2V5KTtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmICF2YWwuZGVsZXRlZCA/IHZhbC5jb250ZW50LmdldENvbnRlbnQoKVt2YWwubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLE9iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWQ+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldEFsbCA9IChwYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fTtcbiAgcGFyZW50Ll9tYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICghdmFsdWUuZGVsZXRlZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWx1ZS5jb250ZW50LmdldENvbnRlbnQoKVt2YWx1ZS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBIYXMgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXRTbmFwc2hvdCA9IChwYXJlbnQsIGtleSwgc25hcHNob3QpID0+IHtcbiAgbGV0IHYgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsO1xuICB3aGlsZSAodiAhPT0gbnVsbCAmJiAoIXNuYXBzaG90LnN2Lmhhcyh2LmlkLmNsaWVudCkgfHwgdi5pZC5jbG9jayA+PSAoc25hcHNob3Quc3YuZ2V0KHYuaWQuY2xpZW50KSB8fCAwKSkpIHtcbiAgICB2ID0gdi5sZWZ0O1xuICB9XG4gIHJldHVybiB2ICE9PSBudWxsICYmIGlzVmlzaWJsZSh2LCBzbmFwc2hvdCkgPyB2LmNvbnRlbnQuZ2V0Q29udGVudCgpW3YubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLEl0ZW0+fSBtYXBcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8QXJyYXk8YW55Pj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVNYXBJdGVyYXRvciA9IG1hcCA9PiBpdGVyYXRvci5pdGVyYXRvckZpbHRlcihtYXAuZW50cmllcygpLCAvKiogQHBhcmFtIHthbnl9IGVudHJ5ICovIGVudHJ5ID0+ICFlbnRyeVsxXS5kZWxldGVkKTtcblxuLyoqXG4gKiBAbW9kdWxlIFlBcnJheVxuICovXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZQXJyYXlcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIFlBcnJheUV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WUFycmF5PFQ+fSB5YXJyYXkgVGhlIGNoYW5nZWQgdHlwZVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWFycmF5LCB0cmFuc2FjdGlvbikge1xuICAgIHN1cGVyKHlhcnJheSwgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBIHNoYXJlZCBBcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WUFycmF5RXZlbnQ8VD4+XG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8VD59XG4gKi9cbmNsYXNzIFlBcnJheSBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBZQXJyYXkgY29udGFpbmluZyB0aGUgc3BlY2lmaWVkIGl0ZW1zLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBpdGVtc1xuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBzdGF0aWMgZnJvbSAoaXRlbXMpIHtcbiAgICBjb25zdCBhID0gbmV3IFlBcnJheSgpO1xuICAgIGEucHVzaChpdGVtcyk7XG4gICAgcmV0dXJuIGFcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlBcnJheSgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBZQXJyYXkoKTtcbiAgICBhcnIuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChlbCA9PlxuICAgICAgZWwgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBlbC5jbG9uZSgpIDogZWxcbiAgICApKTtcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlbGltQ29udGVudCA9PT0gbnVsbCA/IHRoaXMuX2xlbmd0aCA6IHRoaXMuX3ByZWxpbUNvbnRlbnQubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZQXJyYXlFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKTtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlBcnJheUV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29udGVudC4gTm90IGp1c3QgYSBjb250ZW50XG4gICAqIG9iamVjdC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBcIndlaXJkbmVzc1wiIGlzIHRoYXQgaW5zZXJ0aW5nIHNldmVyYWwgZWxlbWVudHNcbiAgICogaXMgdmVyeSBlZmZpY2llbnQgd2hlbiBpdCBpcyBkb25lIGFzIGEgc2luZ2xlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHlhcnJheS5pbnNlcnQoMCwgWydhJ10pXG4gICAqICAvLyBJbnNlcnQgbnVtYmVycyAxLCAyIGF0IHBvc2l0aW9uIDFcbiAgICogIHlhcnJheS5pbnNlcnQoMSwgWzEsIDJdKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0LlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgY29udGVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKi9cbiAgcHVzaCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMubGVuZ3RoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgZWxlbWVudHMgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICBnZXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0R2V0KHRoaXMsIGluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdFRvQXJyYXkodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gYy50b0pTT04oKSA6IGMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5XG4gICAqIGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBULE1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihULG51bWJlcixZQXJyYXk8VD4pOk19IGYgRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBlbGVtZW50IG9mIHRoZSBuZXcgQXJyYXlcbiAgICogQHJldHVybiB7QXJyYXk8TT59IEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgbWFwIChmKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0TWFwKHRoaXMsIC8qKiBAdHlwZSB7YW55fSAqLyAoZikpXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlBcnJheVJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWUFycmF5ID0gZGVjb2RlciA9PiBuZXcgWUFycmF5KCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWU1hcC5cbiAqL1xuY2xhc3MgWU1hcEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WU1hcDxUPn0geW1hcCBUaGUgWUFycmF5IHRoYXQgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8YW55Pn0gc3VicyBUaGUga2V5cyB0aGF0IGNoYW5nZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeW1hcCwgdHJhbnNhY3Rpb24sIHN1YnMpIHtcbiAgICBzdXBlcih5bWFwLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5rZXlzQ2hhbmdlZCA9IHN1YnM7XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCBudW1iZXJ8c3RyaW5nfE9iamVjdHxBcnJheXxVaW50OEFycmF5XG4gKiBBIHNoYXJlZCBNYXAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlNYXBFdmVudDxUPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxUPn1cbiAqL1xuY2xhc3MgWU1hcCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlPHJlYWRvbmx5IFtzdHJpbmcsIGFueV0+PX0gZW50cmllcyAtIGFuIG9wdGlvbmFsIGl0ZXJhYmxlIHRvIGluaXRpYWxpemUgdGhlIFlNYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbnRyaWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuXG4gICAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoZW50cmllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7LyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZTWFwPFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZTWFwKCk7XG4gICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyB2YWx1ZS5jbG9uZSgpIDogdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlNYXBFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlNYXBFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3VicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLFQ+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBjb25zdCB2ID0gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVtpdGVtLmxlbmd0aCAtIDFdO1xuICAgICAgICBtYXBba2V5XSA9IHYgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyB2LnRvSlNPTigpIDogdjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgWU1hcCAoY291bnQgb2Yga2V5L3ZhbHVlIHBhaXJzKVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIFsuLi5jcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApXS5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxzdHJpbmc+fVxuICAgKi9cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMF0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSXRlcmF0b3Igb2YgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAgICovXG4gIGVudHJpZXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvci5pdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiBbdlswXSwgdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gZXZlcnkga2V5LXZhbHVlIHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxzdHJpbmcsWU1hcDxUPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBmKGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXSwga2V5LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhpcyBZTWFwXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKi9cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBrZXkpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBIYXModGhpcywga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZTWFwUmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZTWFwID0gZGVjb2RlciA9PiBuZXcgWU1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxBdHRycyA9IChhLCBiKSA9PiBhID09PSBiIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYiAmJiBvYmplY3QuZXF1YWxGbGF0KGEsIGIpKTtcblxuY2xhc3MgSXRlbVRleHRMaXN0UG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCwgaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZXMgPSBjdXJyZW50QXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGwgdGhpcyBpZiB5b3Uga25vdyB0aGF0IHRoaXMucmlnaHQgaXMgZGVmaW5lZFxuICAgKi9cbiAgZm9yd2FyZCAoKSB7XG4gICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgaWYgKCF0aGlzLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmluZGV4ICs9IHRoaXMucmlnaHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXModGhpcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAodGhpcy5yaWdodC5jb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5yaWdodDtcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5yaWdodC5yaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBwb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBzdGVwcyB0byBtb3ZlIGZvcndhcmRcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZE5leHRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcG9zLCBjb3VudCkgPT4ge1xuICB3aGlsZSAocG9zLnJpZ2h0ICE9PSBudWxsICYmIGNvdW50ID4gMCkge1xuICAgIHN3aXRjaCAocG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgcG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcmlnaHRcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChwb3MucmlnaHQuaWQuY2xpZW50LCBwb3MucmlnaHQuaWQuY2xvY2sgKyBjb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MuaW5kZXggKz0gcG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBjb3VudCAtPSBwb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgIGlmICghcG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhwb3MuY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKHBvcy5yaWdodC5jb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgcG9zLmxlZnQgPSBwb3MucmlnaHQ7XG4gICAgcG9zLnJpZ2h0ID0gcG9zLnJpZ2h0LnJpZ2h0O1xuICAgIC8vIHBvcy5mb3J3YXJkKCkgLSB3ZSBkb24ndCBmb3J3YXJkIGJlY2F1c2UgdGhhdCB3b3VsZCBoYWx2ZSB0aGUgcGVyZm9ybWFuY2UgYmVjYXVzZSB3ZSBhbHJlYWR5IGRvIHRoZSBjaGVja3MgYWJvdmVcbiAgfVxuICByZXR1cm4gcG9zXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kUG9zaXRpb24gPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGlmIChtYXJrZXIpIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obWFya2VyLnAubGVmdCwgbWFya2VyLnAsIG1hcmtlci5pbmRleCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKHRyYW5zYWN0aW9uLCBwb3MsIGluZGV4IC0gbWFya2VyLmluZGV4KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihudWxsLCBwYXJlbnQuX3N0YXJ0LCAwLCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXgpXG4gIH1cbn07XG5cbi8qKlxuICogTmVnYXRlIGFwcGxpZWQgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBuZWdhdGVkQXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gY2hlY2sgaWYgd2UgcmVhbGx5IG5lZWQgdG8gcmVtb3ZlIGF0dHJpYnV0ZXNcbiAgd2hpbGUgKFxuICAgIGN1cnJQb3MucmlnaHQgIT09IG51bGwgJiYgKFxuICAgICAgY3VyclBvcy5yaWdodC5kZWxldGVkID09PSB0cnVlIHx8IChcbiAgICAgICAgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmXG4gICAgICAgIGVxdWFsQXR0cnMobmVnYXRlZEF0dHJpYnV0ZXMuZ2V0KC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkua2V5KSwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSlcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpO1xuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBsZXQgbmV4dEZvcm1hdCA9IGN1cnJQb3MubGVmdDtcbiAgY29uc3QgcmlnaHQgPSBjdXJyUG9zLnJpZ2h0O1xuICBuZWdhdGVkQXR0cmlidXRlcy5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgIG5leHRGb3JtYXQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBuZXh0Rm9ybWF0LCBuZXh0Rm9ybWF0ICYmIG5leHRGb3JtYXQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKTtcbiAgICBuZXh0Rm9ybWF0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgY3VyclBvcy5yaWdodCA9IG5leHRGb3JtYXQ7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7Q29udGVudEZvcm1hdH0gZm9ybWF0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyA9IChjdXJyZW50QXR0cmlidXRlcywgZm9ybWF0KSA9PiB7XG4gIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZm9ybWF0O1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyA9IChjdXJyUG9zLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIGdvIHJpZ2h0IHdoaWxlIGF0dHJpYnV0ZXNbcmlnaHQua2V5XSA9PT0gcmlnaHQudmFsdWUgKG9yIHJpZ2h0IGlzIGRlbGV0ZWQpXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgfHwgKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCAmJiBlcXVhbEF0dHJzKGF0dHJpYnV0ZXNbKC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkpLmtleV0gfHwgbnVsbCwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSkpKSA7IGVsc2Uge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge01hcDxzdHJpbmcsYW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiovXG5jb25zdCBpbnNlcnRBdHRyaWJ1dGVzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gIC8vIGluc2VydCBmb3JtYXQtc3RhcnQgaXRlbXNcbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHZhbCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICBjb25zdCBjdXJyZW50VmFsID0gY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgIGlmICghZXF1YWxBdHRycyhjdXJyZW50VmFsLCB2YWwpKSB7XG4gICAgICAvLyBzYXZlIG5lZ2F0ZWQgYXR0cmlidXRlIChzZXQgbnVsbCBpZiBjdXJyZW50VmFsIHVuZGVmaW5lZClcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIGN1cnJlbnRWYWwpO1xuICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCB9ID0gY3VyclBvcztcbiAgICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKTtcbiAgICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVnYXRlZEF0dHJpYnV0ZXNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgdGV4dCwgYXR0cmlidXRlcykgPT4ge1xuICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICAvLyBpbnNlcnQgY29udGVudFxuICBjb25zdCBjb250ZW50ID0gdGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gbmV3IENvbnRlbnRTdHJpbmcoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0ZXh0KSkgOiBuZXcgQ29udGVudEVtYmVkKHRleHQpO1xuICBsZXQgeyBsZWZ0LCByaWdodCwgaW5kZXggfSA9IGN1cnJQb3M7XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGN1cnJQb3MuaW5kZXgsIGNvbnRlbnQuZ2V0TGVuZ3RoKCkpO1xuICB9XG4gIHJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpO1xuICByaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICBjdXJyUG9zLnJpZ2h0ID0gcmlnaHQ7XG4gIGN1cnJQb3MuaW5kZXggPSBpbmRleDtcbiAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZvcm1hdFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICAvLyBpdGVyYXRlIHVudGlsIGZpcnN0IG5vbi1mb3JtYXQgb3IgbnVsbCBpcyBmb3VuZFxuICAvLyBkZWxldGUgYWxsIGZvcm1hdHMgd2l0aCBhdHRyaWJ1dGVzW2Zvcm1hdC5rZXldICE9IG51bGxcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgY3VyclBvcy5yaWdodCAhPT0gbnVsbCkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgY3VyclBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjdXJyUG9zLnJpZ2h0LmlkLmNsaWVudCwgY3VyclBvcy5yaWdodC5pZC5jbG9jayArIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgLy8gUXVpbGwganVzdCBhc3N1bWVzIHRoYXQgdGhlIGVkaXRvciBzdGFydHMgd2l0aCBhIG5ld2xpbmUgYW5kIHRoYXQgaXQgYWx3YXlzXG4gIC8vIGVuZHMgd2l0aCBhIG5ld2xpbmUuIFdlIG9ubHkgaW5zZXJ0IHRoYXQgbmV3bGluZSB3aGVuIGEgbmV3IG5ld2xpbmUgaXNcbiAgLy8gaW5zZXJ0ZWQgLSBpLmUgd2hlbiBsZW5ndGggaXMgYmlnZ2VyIHRoYW4gdHlwZS5sZW5ndGhcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICBsZXQgbmV3bGluZXMgPSAnJztcbiAgICBmb3IgKDsgbGVuZ3RoID4gMDsgbGVuZ3RoLS0pIHtcbiAgICAgIG5ld2xpbmVzICs9ICdcXG4nO1xuICAgIH1cbiAgICBjdXJyUG9zLnJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgY3VyclBvcy5sZWZ0LCBjdXJyUG9zLmxlZnQgJiYgY3VyclBvcy5sZWZ0Lmxhc3RJZCwgY3VyclBvcy5yaWdodCwgY3VyclBvcy5yaWdodCAmJiBjdXJyUG9zLnJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50U3RyaW5nKG5ld2xpbmVzKSk7XG4gICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHN0cmluZyBjb250ZW50IGhhcyBiZWVuIGRlbGV0ZWQgaW4gb3JkZXIgdG9cbiAqIGNsZWFuIHVwIGZvcm1hdHRpbmcgSXRlbXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gc3RhcnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBlbmQgZXhjbHVzaXZlIGVuZCwgYXV0b21hdGljYWxseSBpdGVyYXRlcyB0byB0aGUgbmV4dCBDb250ZW50IEl0ZW1cbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBzdGFydEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBlbmRBdHRyaWJ1dGVzIFRoaXMgYXR0cmlidXRlIGlzIG1vZGlmaWVkIVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIGZvcm1hdHRpbmcgSXRlbXMgZGVsZXRlZC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY2xlYW51cEZvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIHN0YXJ0LCBlbmQsIHN0YXJ0QXR0cmlidXRlcywgZW5kQXR0cmlidXRlcykgPT4ge1xuICB3aGlsZSAoZW5kICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50U3RyaW5nICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50RW1iZWQpIHtcbiAgICBpZiAoIWVuZC5kZWxldGVkICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhlbmRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChlbmQuY29udGVudCkpO1xuICAgIH1cbiAgICBlbmQgPSBlbmQucmlnaHQ7XG4gIH1cbiAgbGV0IGNsZWFudXBzID0gMDtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBlbmQpIHtcbiAgICBpZiAoIXN0YXJ0LmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBzdGFydC5jb250ZW50O1xuICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudCk7XG4gICAgICAgICAgaWYgKChlbmRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGwpICE9PSB2YWx1ZSB8fCAoc3RhcnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGwpID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRWl0aGVyIHRoaXMgZm9ybWF0IGlzIG92ZXJ3cml0dGVuIG9yIGl0IGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYXR0cmlidXRlIGFscmVhZHkgZXhpc3RlZC5cbiAgICAgICAgICAgIHN0YXJ0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjbGVhbnVwcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RhcnQucmlnaHQpO1xuICB9XG4gIHJldHVybiBjbGVhbnVwc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbVxuICovXG5jb25zdCBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBpdGVtKSA9PiB7XG4gIC8vIGl0ZXJhdGUgdW50aWwgaXRlbS5yaWdodCBpcyBudWxsIG9yIGNvbnRlbnRcbiAgd2hpbGUgKGl0ZW0gJiYgaXRlbS5yaWdodCAmJiAoaXRlbS5yaWdodC5kZWxldGVkIHx8IChpdGVtLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRTdHJpbmcgJiYgaXRlbS5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50RW1iZWQpKSkge1xuICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICB9XG4gIGNvbnN0IGF0dHJzID0gbmV3IFNldCgpO1xuICAvLyBpdGVyYXRlIGJhY2sgdW50aWwgYSBjb250ZW50IGl0ZW0gaXMgZm91bmRcbiAgd2hpbGUgKGl0ZW0gJiYgKGl0ZW0uZGVsZXRlZCB8fCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50U3RyaW5nICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciAhPT0gQ29udGVudEVtYmVkKSkpIHtcbiAgICBpZiAoIWl0ZW0uZGVsZXRlZCAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCkua2V5O1xuICAgICAgaWYgKGF0dHJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVtID0gaXRlbS5sZWZ0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSAvIGJlIHJlbW92ZWQuXG4gKlxuICogSWRlYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGF0IGFsbC4gRm9ybWF0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBjbGVhbmVkIHVwXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGVhY2ggY2hhbmdlLiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHR3aWNlIG92ZXIgdGhlIGNvbXBsZXRlIFlUZXh0IHR5cGVcbiAqIGFuZCByZW1vdmVzIHVubmVjZXNzYXJ5IGZvcm1hdHRpbmcgYXR0cmlidXRlcy4gVGhpcyBpcyBhbHNvIGhlbHBmdWwgZm9yIHRlc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBleHBvcnRlZCBhbnltb3JlIGFzIHNvb24gYXMgdGhlcmUgaXMgY29uZmlkZW5jZSB0aGF0IHRoZSBZVGV4dCB0eXBlIHdvcmtzIGFzIGludGVuZGVkLlxuICpcbiAqIEBwYXJhbSB7WVRleHR9IHR5cGVcbiAqIEByZXR1cm4ge251bWJlcn0gSG93IG1hbnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjbGVhbmVkIHVwLlxuICovXG5jb25zdCBjbGVhbnVwWVRleHRGb3JtYXR0aW5nID0gdHlwZSA9PiB7XG4gIGxldCByZXMgPSAwO1xuICB0cmFuc2FjdCgvKiogQHR5cGUge0RvY30gKi8gKHR5cGUuZG9jKSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHR5cGUuX3N0YXJ0KTtcbiAgICBsZXQgZW5kID0gdHlwZS5fc3RhcnQ7XG4gICAgbGV0IHN0YXJ0QXR0cmlidXRlcyA9IG1hcC5jcmVhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG1hcC5jb3B5KHN0YXJ0QXR0cmlidXRlcyk7XG4gICAgd2hpbGUgKGVuZCkge1xuICAgICAgaWYgKGVuZC5kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICBzd2l0Y2ggKGVuZC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICAgIHJlcyArPSBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGVuZCwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBzdGFydEF0dHJpYnV0ZXMgPSBtYXAuY29weShjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZC5yaWdodDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJuIHtJdGVtVGV4dExpc3RQb3NpdGlvbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGRlbGV0ZVRleHQgPSAodHJhbnNhY3Rpb24sIGN1cnJQb3MsIGxlbmd0aCkgPT4ge1xuICBjb25zdCBzdGFydExlbmd0aCA9IGxlbmd0aDtcbiAgY29uc3Qgc3RhcnRBdHRycyA9IG1hcC5jb3B5KGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpO1xuICBjb25zdCBzdGFydCA9IGN1cnJQb3MucmlnaHQ7XG4gIHdoaWxlIChsZW5ndGggPiAwICYmIGN1cnJQb3MucmlnaHQgIT09IG51bGwpIHtcbiAgICBpZiAoY3VyclBvcy5yaWdodC5kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgc3dpdGNoIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgY3VyclBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjdXJyUG9zLnJpZ2h0LmlkLmNsaWVudCwgY3VyclBvcy5yaWdodC5pZC5jbG9jayArIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgY3VyclBvcy5yaWdodC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGlmIChzdGFydCkge1xuICAgIGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgY3VyclBvcy5yaWdodCwgc3RhcnRBdHRycywgbWFwLmNvcHkoY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcykpO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICgvKiogQHR5cGUge0l0ZW19ICovIChjdXJyUG9zLmxlZnQgfHwgY3VyclBvcy5yaWdodCkucGFyZW50KTtcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gY3VyclBvc1xufTtcblxuLyoqXG4gKiBUaGUgUXVpbGwgRGVsdGEgZm9ybWF0IHJlcHJlc2VudHMgY2hhbmdlcyBvbiBhIHRleHQgZG9jdW1lbnQgd2l0aFxuICogZm9ybWF0dGluZyBpbmZvcm1hdGlvbi4gRm9yIG1vciBpbmZvcm1hdGlvbiB2aXNpdCB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX1cbiAqXG4gKiBAZXhhbXBsZVxuICogICB7XG4gKiAgICAgb3BzOiBbXG4gKiAgICAgICB7IGluc2VydDogJ0dhbmRhbGYnLCBhdHRyaWJ1dGVzOiB7IGJvbGQ6IHRydWUgfSB9LFxuICogICAgICAgeyBpbnNlcnQ6ICcgdGhlICcgfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnR3JleScsIGF0dHJpYnV0ZXM6IHsgY29sb3I6ICcjY2NjY2NjJyB9IH1cbiAqICAgICBdXG4gKiAgIH1cbiAqXG4gKi9cblxuLyoqXG4gICogQXR0cmlidXRlcyB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHNlbGVjdGlvbiBvZiB0ZXh0LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAgIHtcbiAgKiAgICAgYm9sZDogdHJ1ZSxcbiAgKiAgICAgZm9udC1zaXplOiAnNDBweCdcbiAgKiAgIH1cbiAgKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRBdHRyaWJ1dGVzXG4gICovXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVGV4dCB0eXBlLlxuICovXG5jbGFzcyBZVGV4dEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVRleHR9IHl0ZXh0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeXRleHQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5c0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgICAgICovXG4gICAgICBjb25zdCBjaGFuZ2VzID0ge1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICBhZGRlZDogbmV3IFNldCgpLFxuICAgICAgICBkZWxldGVkOiBuZXcgU2V0KClcbiAgICAgIH07XG4gICAgICB0aGlzLl9jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodGhpcy5fY2hhbmdlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjaGFuZ2VzIGluIHRoZSBkZWx0YSBmb3JtYXQuXG4gICAqIEEge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9KSB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgb24gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLGFueT59Pn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IGRlbHRhICgpIHtcbiAgICBpZiAodGhpcy5fZGVsdGEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHkgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMudGFyZ2V0LmRvYyk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0PzpzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy50YXJnZXQuX3N0YXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZz99XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307IC8vIGNvdW50cyBhZGRlZCBvciByZW1vdmVkIG5ldyBhdHRyaWJ1dGVzIGZvciByZXRhaW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGluc2VydCA9ICcnO1xuICAgICAgICBsZXQgcmV0YWluID0gMDtcbiAgICAgICAgbGV0IGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgIGNvbnN0IGFkZE9wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IG9wO1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICBvcCA9IHsgZGVsZXRlOiBkZWxldGVMZW4gfTtcbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgb3AgPSB7IGluc2VydCB9O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc2VydCA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ3JldGFpbic6XG4gICAgICAgICAgICAgICAgb3AgPSB7IHJldGFpbiB9O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluID0gMDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsdGEucHVzaChvcCk7XG4gICAgICAgICAgICBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGl0ZW0uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gLyoqIEB0eXBlIHtDb250ZW50RW1iZWR9ICovIChpdGVtLmNvbnRlbnQpLmVtYmVkO1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbnNlcnQgKz0gLyoqIEB0eXBlIHtDb250ZW50U3RyaW5nfSAqLyAoaXRlbS5jb250ZW50KS5zdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoY3VyVmFsLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKHZhbHVlLCAob2xkQXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gY3VyVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBhZGRPcCgpO1xuICAgICAgICB3aGlsZSAoZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcCA9IGRlbHRhW2RlbHRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0T3AucmV0YWluICE9PSB1bmRlZmluZWQgJiYgbGFzdE9wLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0YWluIGRlbHRhJ3MgaWYgdGhleSBkb24ndCBhc3NpZ24gYXR0cmlidXRlc1xuICAgICAgICAgICAgZGVsdGEucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2RlbHRhKVxuICB9XG59XG5cbi8qKlxuICogVHlwZSB0aGF0IHJlcHJlc2VudHMgdGV4dCB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyB0eXBlIHJlcGxhY2VzIHktcmljaHRleHQgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhYmxlIHRvIGhhbmRsZVxuICogYmxvY2sgZm9ybWF0cyAoZm9ybWF0IGluZm9ybWF0aW9uIG9uIGEgcGFyYWdyYXBoKSwgZW1iZWRzIChjb21wbGV4IGVsZW1lbnRzXG4gKiBsaWtlIHBpY3R1cmVzIGFuZCB2aWRlb3MpLCBhbmQgdGV4dCBmb3JtYXRzICgqKmJvbGQqKiwgKml0YWxpYyopLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZVGV4dEV2ZW50PlxuICovXG5jbGFzcyBZVGV4dCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ10gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIFlUZXh0LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGVuZGluZyBvcGVyYXRpb25zIG9uIHRoaXMgdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbigpOnZvaWQ+P31cbiAgICAgKi9cbiAgICB0aGlzLl9wZW5kaW5nID0gc3RyaW5nICE9PSB1bmRlZmluZWQgPyBbKCkgPT4gdGhpcy5pbnNlcnQoMCwgc3RyaW5nKV0gOiBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRoaXMgdGV4dCB0eXBlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSB5XG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykuZm9yRWFjaChmID0+IGYoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZyA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZVGV4dCgpO1xuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSk7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlUZXh0RXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgc3VwZXIuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgWVRleHRFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBldmVudCk7XG4gICAgLy8gSWYgYSByZW1vdGUgY2hhbmdlIGhhcHBlbmVkLCB3ZSB0cnkgdG8gY2xlYW51cCBwb3RlbnRpYWwgZm9ybWF0dGluZyBkdXBsaWNhdGVzLlxuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGFub3RoZXIgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZFxuICAgICAgbGV0IGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgYWZ0ZXJDbG9ja10gb2YgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYWZ0ZXJDbG9jayA9PT0gY2xvY2spIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0FycmF5PEl0ZW18R0M+fSAqLyAoZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpLCBjbG9jaywgYWZ0ZXJDbG9jaywgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQgJiYgLyoqIEB0eXBlIHtJdGVtfSAqLyAoaXRlbSkuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICAgICAgZm91bmRGb3JtYXR0aW5nSXRlbSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0gPT4ge1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MgfHwgZm91bmRGb3JtYXR0aW5nSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnBhcmVudCA9PT0gdGhpcyAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgICAgICAgIGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cmFuc2FjdChkb2MsICh0KSA9PiB7XG4gICAgICAgIGlmIChmb3VuZEZvcm1hdHRpbmdJdGVtKSB7XG4gICAgICAgICAgLy8gSWYgYSBmb3JtYXR0aW5nIGl0ZW0gd2FzIGluc2VydGVkLCB3ZSBzaW1wbHkgY2xlYW4gdGhlIHdob2xlIHR5cGUuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgY3VycmVudCBwb3NpdGlvbiBhbnl3YXkuXG4gICAgICAgICAgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBubyBmb3JtYXR0aW5nIGF0dHJpYnV0ZSB3YXMgaW5zZXJ0ZWQsIHdlIGNhbiBtYWtlIGR1ZSB3aXRoIGNvbnRleHRsZXNzXG4gICAgICAgICAgLy8gZm9ybWF0dGluZyBjbGVhbnVwcy5cbiAgICAgICAgICAvLyBDb250ZXh0bGVzczogaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgYWZmZWN0ZWQgcG9zaXRpb24uXG4gICAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHQsIHQuZGVsZXRlU2V0LCBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgY2xlYW51cENvbnRleHRsZXNzRm9ybWF0dGluZ0dhcCh0LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyO1xuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEge0BsaW5rIERlbHRhfSBvbiB0aGlzIHNoYXJlZCBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZGVsdGEgVGhlIGNoYW5nZXMgdG8gYXBwbHkgb24gdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRzXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNhbml0aXplXSBTYW5pdGl6ZSBpbnB1dCBkZWx0YS4gUmVtb3ZlcyBlbmRpbmcgbmV3bGluZXMgaWYgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFwcGx5RGVsdGEgKGRlbHRhLCB7IHNhbml0aXplID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJQb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgdGhpcy5fc3RhcnQsIDAsIG5ldyBNYXAoKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcCA9IGRlbHRhW2ldO1xuICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUXVpbGwgYXNzdW1lcyB0aGF0IHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIGFuIGVtcHR5IHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFlqcy9ZLlRleHQgYXNzdW1lcyB0aGF0IGl0IHN0YXJ0cyBlbXB0eS4gV2UgYWx3YXlzIGhpZGUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBuZXdsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBJZiB3ZSBvbWl0IHRoaXMgc3RlcCwgY2xpZW50cyB3aWxsIHNlZSBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHBhcmFncmFwaHMsIGJ1dCBub3RoaW5nIGJhZCB3aWxsIGhhcHBlbi5cbiAgICAgICAgICAgIGNvbnN0IGlucyA9ICghc2FuaXRpemUgJiYgdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgaSA9PT0gZGVsdGEubGVuZ3RoIC0gMSAmJiBjdXJyUG9zLnJpZ2h0ID09PSBudWxsICYmIG9wLmluc2VydC5zbGljZSgtMSkgPT09ICdcXG4nKSA/IG9wLmluc2VydC5zbGljZSgwLCAtMSkgOiBvcC5pbnNlcnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucyAhPT0gJ3N0cmluZycgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgaW5zLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLnJldGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBjdXJyUG9zLCBvcC5yZXRhaW4sIG9wLmF0dHJpYnV0ZXMgfHwge30pO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3AuZGVsZXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGN1cnJQb3MsIG9wLmRlbGV0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuYXBwbHlEZWx0YShkZWx0YSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAgICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBJRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9EZWx0YSAoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZXtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRvYyA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy5kb2MpO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0O1xuICAgIGZ1bmN0aW9uIHBhY2tTdHIgKCkge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHBhY2sgc3RyIHdpdGggYXR0cmlidXRlcyB0byBvcHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGxldCBhZGRBdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBhZGRBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3AgPSB7IGluc2VydDogc3RyIH07XG4gICAgICAgIGlmIChhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2gob3ApO1xuICAgICAgICBzdHIgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc25hcHNob3RzIGFyZSBtZXJnZWQgYWdhaW4gYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCBzbyB3ZSBuZWVkIHRvIGtlZXAgdGhlXG4gICAgLy8gdHJhbnNhbGl2ZSB1bnRpbCB3ZSBhcmUgZG9uZVxuICAgIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2U25hcHNob3QpIHtcbiAgICAgICAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgcHJldlNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpIHx8IChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiBpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldCgneWNoYW5nZScpO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnN0YXRlICE9PSAncmVtb3ZlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCBuLmlkKSA6IHsgdHlwZTogJ3JlbW92ZWQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci5zdGF0ZSAhPT0gJ2FkZGVkJykge1xuICAgICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KCd5Y2hhbmdlJywgY29tcHV0ZVlDaGFuZ2UgPyBjb21wdXRlWUNoYW5nZSgnYWRkZWQnLCBuLmlkKSA6IHsgdHlwZTogJ2FkZGVkJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZGVsZXRlKCd5Y2hhbmdlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAgICAgIGluc2VydDogLyoqIEB0eXBlIHtDb250ZW50RW1iZWR9ICovIChuLmNvbnRlbnQpLmVtYmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59ICovICh7fSk7XG4gICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChuLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgIH1cbiAgICAgIHBhY2tTdHIoKTtcbiAgICB9LCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKTtcbiAgICByZXR1cm4gb3BzXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRleHQgYXQgYSBnaXZlbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGluc2VydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBbYXR0cmlidXRlc10gT3B0aW9uYWxseSBkZWZpbmUgc29tZSBmb3JtYXR0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlIGluc2VydGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHBvcy5jdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7IGF0dHJpYnV0ZXNba10gPSB2OyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIHRleHQsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGVtYmVkIGF0IGEgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBlbWJlZCBhdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVtYmVkIFRoZSBPYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBlbWJlZC5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0RW1iZWQgKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgaWYgKGVtYmVkLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW1iZWQgbXVzdCBiZSBhbiBPYmplY3QnKVxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgZW1iZWQsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRleHQgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgZGVsZXRlVGV4dCh0cmFuc2FjdGlvbiwgZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCksIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZGVsZXRlKGluZGV4LCBsZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBwcm9wZXJ0aWVzIHRvIGEgcmFuZ2Ugb2YgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCBmb3JtYXR0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byBhc3NpZ24gcHJvcGVydGllcyB0by5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9ybWF0IChpbmRleCwgbGVuZ3RoLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKHBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGZvcm1hdFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5mb3JtYXQoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHthbnl9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlkZW50aWZpZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgdmFsdWUuXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKHNuYXBzaG90KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBHZXRBbGwodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVRleHRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVRleHR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVRleHQgPSBkZWNvZGVyID0+IG5ldyBZVGV4dCgpO1xuXG4vKipcbiAqIEBtb2R1bGUgWVhtbFxuICovXG5cbi8qKlxuICogRGVmaW5lIHRoZSBlbGVtZW50cyB0byB3aGljaCBhIHNldCBvZiBDU1MgcXVlcmllcyBhcHBseS5cbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1NlbGVjdG9yc3xDU1NfU2VsZWN0b3JzfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHF1ZXJ5ID0gJy5jbGFzc1NlbGVjdG9yJ1xuICogICBxdWVyeSA9ICdub2RlU2VsZWN0b3InXG4gKiAgIHF1ZXJ5ID0gJyNpZFNlbGVjdG9yJ1xuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IENTU19TZWxlY3RvclxuICovXG5cbi8qKlxuICogRG9tIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAY2FsbGJhY2sgZG9tRmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge01hcH0gYXR0cmlidXRlcyBUaGUgbWFwIG9mIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIERvbSBub2RlIGluIHRoZSBZWG1sRWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIGEgWVhtbEVsZW1lbnQgLyBZWG1sRnJhZ21lbnQgYW5kIGFcbiAqIHBvc2l0aW9uIHdpdGhpbiB0aGVtLlxuICpcbiAqIENhbiBiZSBjcmVhdGVkIHdpdGgge0BsaW5rIFlYbWxGcmFnbWVudCNjcmVhdGVUcmVlV2Fsa2VyfVxuICpcbiAqIEBwdWJsaWNcbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRWxlbWVudHxZWG1sSG9vaz59XG4gKi9cbmNsYXNzIFlYbWxUcmVlV2Fsa2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVhtbEZyYWdtZW50IHwgWVhtbEVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gW2ZdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocm9vdCwgZiA9ICgpID0+IHRydWUpIHtcbiAgICB0aGlzLl9maWx0ZXIgPSBmO1xuICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAocm9vdC5fc3RhcnQpO1xuICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IHRydWU7XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmF0b3JSZXN1bHQ8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fSBUaGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCBuID0gdGhpcy5fY3VycmVudE5vZGU7XG4gICAgbGV0IHR5cGUgPSBuICYmIG4uY29udGVudCAmJiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZTtcbiAgICBpZiAobiAhPT0gbnVsbCAmJiAoIXRoaXMuX2ZpcnN0Q2FsbCB8fCBuLmRlbGV0ZWQgfHwgIXRoaXMuX2ZpbHRlcih0eXBlKSkpIHsgLy8gaWYgZmlyc3QgY2FsbCwgd2UgY2hlY2sgaWYgd2UgY2FuIHVzZSB0aGUgZmlyc3QgaXRlbVxuICAgICAgZG8ge1xuICAgICAgICB0eXBlID0gLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGU7XG4gICAgICAgIGlmICghbi5kZWxldGVkICYmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRWxlbWVudCB8fCB0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRnJhZ21lbnQpICYmIHR5cGUuX3N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gd2FsayBkb3duIGluIHRoZSB0cmVlXG4gICAgICAgICAgbiA9IHR5cGUuX3N0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdhbGsgcmlnaHQgb3IgdXAgaW4gdGhlIHRyZWVcbiAgICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG4ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4ucGFyZW50ID09PSB0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgIG4gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbiA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChuLnBhcmVudCkuX2l0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuICE9PSBudWxsICYmIChuLmRlbGV0ZWQgfHwgIXRoaXMuX2ZpbHRlcigvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSkpXG4gICAgfVxuICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IGZhbHNlO1xuICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH1cbiAgICB9XG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSBuO1xuICAgIHJldHVybiB7IHZhbHVlOiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZSwgZG9uZTogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGxpc3Qgb2Yge0BsaW5rIFlYbWxFbGVtZW50fS5hbmQge0BsaW5rIFlYbWxUZXh0fSB0eXBlcy5cbiAqIEEgWXhtbEZyYWdtZW50IGlzIHNpbWlsYXIgdG8gYSB7QGxpbmsgWVhtbEVsZW1lbnR9LCBidXQgaXQgZG9lcyBub3QgaGF2ZSBhXG4gKiBub2RlTmFtZSBhbmQgaXQgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLiBUaG91Z2ggaXQgY2FuIGJlIGJvdW5kIHRvIGEgRE9NXG4gKiBlbGVtZW50IC0gaW4gdGhpcyBjYXNlIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGUgbm9kZU5hbWUgYXJlIG5vdCBzaGFyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlYbWxFdmVudD5cbiAqL1xuY2xhc3MgWVhtbEZyYWdtZW50IGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW107XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgZmlyc3RDaGlsZCAoKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLl9maXJzdDtcbiAgICByZXR1cm4gZmlyc3QgPyBmaXJzdC5jb250ZW50LmdldENvbnRlbnQoKVswXSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxGcmFnbWVudCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxGcmFnbWVudCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgZWwudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlbGltQ29udGVudCA9PT0gbnVsbCA/IHRoaXMuX2xlbmd0aCA6IHRoaXMuX3ByZWxpbUNvbnRlbnQubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3VidHJlZSBvZiBjaGlsZE5vZGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB3YWxrZXIgPSBlbGVtLmNyZWF0ZVRyZWVXYWxrZXIoZG9tID0+IGRvbS5ub2RlTmFtZSA9PT0gJ2RpdicpXG4gICAqIGZvciAobGV0IG5vZGUgaW4gd2Fsa2VyKSB7XG4gICAqICAgLy8gYG5vZGVgIGlzIGEgZGl2IG5vZGVcbiAgICogICBub3Aobm9kZSlcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFic3RyYWN0VHlwZTxhbnk+KTpib29sZWFufSBmaWx0ZXIgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZWFjaCBjaGlsZCBlbGVtZW50IGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjaGlsZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHN1YnRyZWUuXG4gICAqIEByZXR1cm4ge1lYbWxUcmVlV2Fsa2VyfSBBIHN1YnRyZWUgYW5kIGEgcG9zaXRpb24gd2l0aGluIGl0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVUcmVlV2Fsa2VyIChmaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxUcmVlV2Fsa2VyKHRoaXMsIGZpbHRlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBZWG1sRWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICAgKiBTaW1pbGFyIHRvIERPTSdzIHtAbGluayBxdWVyeVNlbGVjdG9yfS5cbiAgICpcbiAgICogUXVlcnkgc3VwcG9ydDpcbiAgICogICAtIHRhZ25hbWVcbiAgICogVE9ETzpcbiAgICogICAtIGlkXG4gICAqICAgLSBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW4uXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rfG51bGx9IFRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnkgb3IgbnVsbC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcXVlcnlTZWxlY3RvciAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IFlYbWxUcmVlV2Fsa2VyKHRoaXMsIGVsZW1lbnQgPT4gZWxlbWVudC5ub2RlTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHF1ZXJ5KTtcbiAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFlYbWxFbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBEb20ncyB7QGxpbmsgcXVlcnlTZWxlY3RvckFsbH0uXG4gICAqXG4gICAqIEB0b2RvIERvZXMgbm90IHlldCBzdXBwb3J0IGFsbCBxdWVyaWVzLiBDdXJyZW50bHkgb25seSBxdWVyeSBieSB0YWdOYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0NTU19TZWxlY3Rvcn0gcXVlcnkgVGhlIHF1ZXJ5IG9uIHRoZSBjaGlsZHJlblxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsPn0gVGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBxdWVyeS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcXVlcnlTZWxlY3RvckFsbCAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSkpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZWG1sRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZWG1sRXZlbnQodGhpcywgcGFyZW50U3VicywgdHJhbnNhY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoaXMgWVhtbEZyYWdtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCB4bWwgPT4geG1sLnRvU3RyaW5nKCkpLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGZyYWdtZW50LCB0aGlzKTtcbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHhtbFR5cGUgPT4ge1xuICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKHhtbFR5cGUudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZyksIG51bGwpO1xuICAgIH0pO1xuICAgIHJldHVybiBmcmFnbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0XG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgY29udGVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZSBfcHJlbGltQ29udGVudCBpcyBkZWZpbmVkIGJlY2F1c2UgdGhpcyBpcyBub3QgeWV0IGludGVncmF0ZWRcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHhtbC5pbnNlcnQoMCwgW25ldyBZLlhtbFRleHQoJ3RleHQnKV0pXG4gICAqXG4gICAqIEBwYXJhbSB7bnVsbHxJdGVtfFlYbWxFbGVtZW50fFlYbWxUZXh0fSByZWYgVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0XG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnRBZnRlciAocmVmLCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCByZWZJdGVtID0gKHJlZiAmJiByZWYgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpID8gcmVmLl9pdGVtIDogcmVmO1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHRoaXMsIHJlZkl0ZW0sIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBjID0gLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCk7XG4gICAgICBjb25zdCBpbmRleCA9IHJlZiA9PT0gbnVsbCA/IDAgOiBwYy5maW5kSW5kZXgoZWwgPT4gZWwgPT09IHJlZikgKyAxO1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmIHJlZiAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvci5jcmVhdGUoJ1JlZmVyZW5jZSBpdGVtIG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICBwYy5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGVsZW1lbnRzIHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZyBlbGVtZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlIF9wcmVsaW1Db250ZW50IGlzIGRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIG5vdCB5ZXQgaW50ZWdyYXRlZFxuICAgICAgdGhpcy5fcHJlbGltQ29udGVudC5zcGxpY2UoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9vaz59XG4gICAqL1xuICB0b0FycmF5ICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RUb0FycmF5KHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIGFwcGVuZC5cbiAgICovXG4gIHB1c2ggKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCh0aGlzLmxlbmd0aCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcHBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaS10aCBlbGVtZW50IGZyb20gYSBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuIGZyb20gdGhlIFlBcnJheVxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxGcmFnbWVudFJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbEZyYWdtZW50ID0gZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KCk7XG5cbi8qKlxuICogQW4gWVhtbEVsZW1lbnQgaW1pdGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGFcbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH0uXG4gKlxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgYXR0cmlidXRlcyAoa2V5IHZhbHVlIHBhaXJzKVxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgY2hpbGRFbGVtZW50cyB0aGF0IG11c3QgaW5oZXJpdCBmcm9tIFlYbWxFbGVtZW50XG4gKi9cbmNsYXNzIFlYbWxFbGVtZW50IGV4dGVuZHMgWVhtbEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IgKG5vZGVOYW1lID0gJ1VOREVGSU5FRCcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgYW55PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IG5leHRTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ubmV4dCA6IG51bGw7XG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgcHJldlNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5wcmV2IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgOygvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICpcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRWxlbWVudCh0aGlzLm5vZGVOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIGVsLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFhNTCBzZXJpYWxpemF0aW9uIG9mIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBvcmRlcmVkIGJ5IGF0dHJpYnV0ZS1uYW1lLCBzbyB5b3UgY2FuIGVhc2lseSB1c2UgdGhpc1xuICAgKiBtZXRob2QgdG8gY29tcGFyZSBZWG1sRWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG4gICAgY29uc3Qgc3RyaW5nQnVpbGRlciA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMuc29ydCgpO1xuICAgIGNvbnN0IGtleXNMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIHN0cmluZ0J1aWxkZXIucHVzaChrZXkgKyAnPVwiJyArIGF0dHJzW2tleV0gKyAnXCInKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZU5hbWUgPSB0aGlzLm5vZGVOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYXR0cnNTdHJpbmcgPSBzdHJpbmdCdWlsZGVyLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJpbmdCdWlsZGVyLmpvaW4oJyAnKSA6ICcnO1xuICAgIHJldHVybiBgPCR7bm9kZU5hbWV9JHthdHRyc1N0cmluZ30+JHtzdXBlci50b1N0cmluZygpfTwvJHtub2RlTmFtZX0+YFxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5kZWxldGUoYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykuc2V0KGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaWRlbnRpZmllcyB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllZCB2YWx1ZS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiB0eXBlTWFwR2V0QWxsKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuICAgIH1cbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgeXhtbCA9PiB7XG4gICAgICBkb20uYXBwZW5kQ2hpbGQoeXhtbC50b0RPTShfZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSk7XG4gICAgfSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRWxlbWVudFJlZklEKTtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMubm9kZU5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbEVsZW1lbnQgPSBkZWNvZGVyID0+IG5ldyBZWG1sRWxlbWVudChkZWNvZGVyLnJlYWRLZXkoKSk7XG5cbi8qKlxuICogQW4gRXZlbnQgdGhhdCBkZXNjcmliZXMgY2hhbmdlcyBvbiBhIFlYbWwgRWxlbWVudCBvciBZeG1sIEZyYWdtZW50XG4gKi9cbmNsYXNzIFlYbWxFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxGcmFnbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgb24gd2hpY2ggdGhlIGV2ZW50IGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U2V0PHN0cmluZ3xudWxsPn0gc3VicyBUaGUgc2V0IG9mIGNoYW5nZWQgYXR0cmlidXRlcy4gYG51bGxgIGlzIGluY2x1ZGVkIGlmIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICBjaGlsZCBsaXN0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSB3aXRoIHdpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHN1YnMsIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIodGFyZ2V0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogWW91IGNhbiBtYW5hZ2UgYmluZGluZyB0byBhIGN1c3RvbSB0eXBlIHdpdGggWVhtbEhvb2suXG4gKlxuICogQGV4dGVuZHMge1lNYXA8YW55Pn1cbiAqL1xuY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5ob29rTmFtZSA9IGhvb2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZWG1sSG9va31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV07XG4gICAgbGV0IGRvbTtcbiAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb20gPSBob29rLmNyZWF0ZURvbSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKTtcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEhvb2tSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sSG9va31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmNsYXNzIFlYbWxUZXh0IGV4dGVuZHMgWVRleHQge1xuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbFRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVhtbFRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMudG9EZWx0YSgpLm1hcChkZWx0YSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWROb2RlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7IGtleSwgdmFsdWU6IGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdW2tleV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBhdHRyaWJ1dGVzIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgICBhdHRycy5zb3J0KChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiAxKTtcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbm9kZSBvcmRlciB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgIG5lc3RlZE5vZGVzLnNvcnQoKGEsIGIpID0+IGEubm9kZU5hbWUgPCBiLm5vZGVOYW1lID8gLTEgOiAxKTtcbiAgICAgIC8vIG5vdyBjb252ZXJ0IHRvIGRvbSBzdHJpbmdcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldO1xuICAgICAgICBzdHIgKz0gYDwke25vZGUubm9kZU5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IG5vZGUuYXR0cnNbal07XG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnPic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gZGVsdGEuaW5zZXJ0O1xuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVhtbFRleHQoKTtcblxuY2xhc3MgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhpcyBzdHJ1Y3Qgd2l0aCB0aGUgaXRlbSB0byB0aGUgcmlnaHQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFscmVhZHkgYXNzdW1pbmcgdGhhdCBgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSB0aGlzLmlkLmNsb2NrYC5cbiAgICogQWxzbyB0aGlzIG1ldGhvZCBkb2VzICpub3QqIHJlbW92ZSByaWdodCBmcm9tIFN0cnVjdFN0b3JlIVxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgdGhpcyBtZXJnZWQgd2l0aCByaWdodFxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuY29kaW5nUmVmXG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0LCBlbmNvZGluZ1JlZikge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG59XG5cbmNvbnN0IHN0cnVjdEdDUmVmTnVtYmVyID0gMDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBHQyBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtHQ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXQ7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXQ7XG4gICAgfVxuICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RHQ1JlZk51bWJlcik7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbmd0aCAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgQ29udGVudEJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5jb250ZW50XVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QmluYXJ5KHRoaXMuY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEJpbmFyeX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUJ1Zih0aGlzLmNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRCaW5hcnkgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50QmluYXJ5KGRlY29kZXIucmVhZEJ1ZigpKTtcblxuY2xhc3MgQ29udGVudERlbGV0ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlbikge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuIC0gb2Zmc2V0KTtcbiAgICB0aGlzLmxlbiA9IG9mZnNldDtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREZWxldGVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMubGVuICs9IHJpZ2h0LmxlbjtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIGFkZFRvRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaXRlbS5pZC5jbGllbnQsIGl0ZW0uaWQuY2xvY2ssIHRoaXMubGVuKTtcbiAgICBpdGVtLm1hcmtEZWxldGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVMZW4odGhpcy5sZW4gLSBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIgfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnREZWxldGVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERlbGV0ZWQoZGVjb2Rlci5yZWFkTGVuKCkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnREb2Mge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYykge1xuICAgIGlmIChkb2MuX2l0ZW0pIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RoaXMgZG9jdW1lbnQgd2FzIGFscmVhZHkgaW50ZWdyYXRlZCBhcyBhIHN1Yi1kb2N1bWVudC4gWW91IHNob3VsZCBjcmVhdGUgYSBzZWNvbmQgaW5zdGFuY2UgaW5zdGVhZCB3aXRoIHRoZSBzYW1lIGd1aWQuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICBjb25zdCBvcHRzID0ge307XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICBpZiAoIWRvYy5nYykge1xuICAgICAgb3B0cy5nYyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZG9jLmF1dG9Mb2FkKSB7XG4gICAgICBvcHRzLmF1dG9Mb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRvYy5tZXRhICE9PSBudWxsKSB7XG4gICAgICBvcHRzLm1ldGEgPSBkb2MubWV0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZG9jXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RG9jKHRoaXMuZG9jKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RG9jfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgcmVmbGVjdGVkIGluIGRvYy5kZXN0cm95IGFzIHdlbGxcbiAgICB0aGlzLmRvYy5faXRlbSA9IGl0ZW07XG4gICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZCh0aGlzLmRvYyk7XG4gICAgaWYgKHRoaXMuZG9jLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMuZG9jKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmhhcyh0aGlzLmRvYykpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5kZWxldGUodGhpcy5kb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5hZGQodGhpcy5kb2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7IH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcodGhpcy5kb2MuZ3VpZCk7XG4gICAgZW5jb2Rlci53cml0ZUFueSh0aGlzLm9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDlcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RG9jID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERvYyhuZXcgRG9jKHsgZ3VpZDogZGVjb2Rlci5yZWFkU3RyaW5nKCksIC4uLmRlY29kZXIucmVhZEFueSgpIH0pKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50RW1iZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVtYmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW1iZWQpIHtcbiAgICB0aGlzLmVtYmVkID0gZW1iZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZW1iZWRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEVtYmVkKHRoaXMuZW1iZWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEVtYmVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLmVtYmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA1XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RW1iZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RW1iZWQoZGVjb2Rlci5yZWFkSlNPTigpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50Rm9ybWF0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEZvcm1hdCh0aGlzLmtleSwgdGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEZvcm1hdH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyBAdG9kbyBzZWFyY2htYXJrZXIgYXJlIGN1cnJlbnRseSB1bnN1cHBvcnRlZCBmb3IgcmljaCB0ZXh0IGRvY3VtZW50c1xuICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX3NlYXJjaE1hcmtlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5rZXkpO1xuICAgIGVuY29kZXIud3JpdGVKU09OKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICovXG5jb25zdCByZWFkQ29udGVudEZvcm1hdCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRGb3JtYXQoZGVjb2Rlci5yZWFkU3RyaW5nKCksIGRlY29kZXIucmVhZEpTT04oKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEpTT04ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50SlNPTih0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50SlNPTih0aGlzLmFyci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50SlNPTn0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLmNvbmNhdChyaWdodC5hcnIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aDtcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldCk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5hcnJbaV07XG4gICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGMgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAyXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRKU09OID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICBjb25zdCBjcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYyA9IGRlY29kZXIucmVhZFN0cmluZygpO1xuICAgIGlmIChjID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcy5wdXNoKEpTT04ucGFyc2UoYykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRKU09OKGNzKVxufTtcblxuY2xhc3MgQ29udGVudEFueSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGFycikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEFueSh0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSk7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5zbGljZSgwLCBvZmZzZXQpO1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEFueX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLmNvbmNhdChyaWdodC5hcnIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aDtcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldCk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5hcnJbaV07XG4gICAgICBlbmNvZGVyLndyaXRlQW55KGMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA4XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEFueX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRBbnkgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gIGNvbnN0IGNzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjcy5wdXNoKGRlY29kZXIucmVhZEFueSgpKTtcbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRBbnkoY3MpXG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRTdHJpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5zdHIgPSBzdHI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5zcGxpdCgnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0cilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRTdHJpbmcodGhpcy5zdHIuc2xpY2Uob2Zmc2V0KSk7XG4gICAgdGhpcy5zdHIgPSB0aGlzLnN0ci5zbGljZSgwLCBvZmZzZXQpO1xuXG4gICAgLy8gUHJldmVudCBlbmNvZGluZyBpbnZhbGlkIGRvY3VtZW50cyBiZWNhdXNlIG9mIHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy8yNDhcbiAgICBjb25zdCBmaXJzdENoYXJDb2RlID0gdGhpcy5zdHIuY2hhckNvZGVBdChvZmZzZXQgLSAxKTtcbiAgICBpZiAoZmlyc3RDaGFyQ29kZSA+PSAweEQ4MDAgJiYgZmlyc3RDaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIC8vIExhc3QgY2hhcmFjdGVyIG9mIHRoZSBsZWZ0IHNwbGl0IGlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSB1dGYxNi91Y3MyIHBhaXIuXG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnMgYmVjYXVzZSB0aGlzIG1heSBsZWFkIHRvIGludmFsaWQgZG9jdW1lbnRzLlxuICAgICAgLy8gUmVwbGFjZSB0aGUgaW52YWxpZCBjaGFyYWN0ZXIgd2l0aCBhIHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyICjvv70gLyBVK0ZGRkQpXG4gICAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldCAtIDEpICsgJ++/vSc7XG4gICAgICAvLyByZXBsYWNlIHJpZ2h0IGFzIHdlbGxcbiAgICAgIHJpZ2h0LnN0ciA9ICfvv70nICsgcmlnaHQuc3RyLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRTdHJpbmd9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5zdHIgKz0gcmlnaHQuc3RyO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcob2Zmc2V0ID09PSAwID8gdGhpcy5zdHIgOiB0aGlzLnN0ci5zbGljZShvZmZzZXQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA0XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICovXG5jb25zdCByZWFkQ29udGVudFN0cmluZyA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRTdHJpbmcoZGVjb2Rlci5yZWFkU3RyaW5nKCkpO1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIpOkFic3RyYWN0VHlwZTxhbnk+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHR5cGVSZWZzID0gW1xuICByZWFkWUFycmF5LFxuICByZWFkWU1hcCxcbiAgcmVhZFlUZXh0LFxuICByZWFkWVhtbEVsZW1lbnQsXG4gIHJlYWRZWG1sRnJhZ21lbnQsXG4gIHJlYWRZWG1sSG9vayxcbiAgcmVhZFlYbWxUZXh0XG5dO1xuXG5jb25zdCBZQXJyYXlSZWZJRCA9IDA7XG5jb25zdCBZTWFwUmVmSUQgPSAxO1xuY29uc3QgWVRleHRSZWZJRCA9IDI7XG5jb25zdCBZWG1sRWxlbWVudFJlZklEID0gMztcbmNvbnN0IFlYbWxGcmFnbWVudFJlZklEID0gNDtcbmNvbnN0IFlYbWxIb29rUmVmSUQgPSA1O1xuY29uc3QgWVhtbFRleHRSZWZJRCA9IDY7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8WUV2ZW50Pn0gdHlwZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy50eXBlXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudFR5cGUodGhpcy50eXBlLl9jb3B5KCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50VHlwZX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICB0aGlzLnR5cGUuX2ludGVncmF0ZSh0cmFuc2FjdGlvbi5kb2MsIGl0ZW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0O1xuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGlzIHdpbGwgYmUgZ2MnZCBsYXRlciBhbmQgd2Ugd2FudCB0byBtZXJnZSBpdCBpZiBwb3NzaWJsZVxuICAgICAgICAvLyBXZSB0cnkgdG8gbWVyZ2UgYWxsIGRlbGV0ZWQgaXRlbXMgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbixcbiAgICAgICAgLy8gYnV0IHdlIGhhdmUgbm8ga25vd2xlZGdlIGFib3V0IHRoYXQgdGhpcyBuZWVkcyB0byBiZSBtZXJnZWRcbiAgICAgICAgLy8gc2luY2UgaXQgaXMgbm90IGluIHRyYW5zYWN0aW9uLmRzLiBIZW5jZSB3ZSBhZGQgaXQgdG8gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0c1xuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICB9XG4gICAgdGhpcy50eXBlLl9tYXAuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNhbWUgYXMgYWJvdmVcbiAgICAgICAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZGVsZXRlKHRoaXMudHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge1xuICAgIGxldCBpdGVtID0gdGhpcy50eXBlLl9zdGFydDtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaXRlbS5nYyhzdG9yZSwgdHJ1ZSk7XG4gICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICB9XG4gICAgdGhpcy50eXBlLl9zdGFydCA9IG51bGw7XG4gICAgdGhpcy50eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbSAqLyAoaXRlbSkgPT4ge1xuICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgaXRlbS5nYyhzdG9yZSwgdHJ1ZSk7XG4gICAgICAgIGl0ZW0gPSBpdGVtLmxlZnQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy50eXBlLl9tYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIHRoaXMudHlwZS5fd3JpdGUoZW5jb2Rlcik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gN1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50VHlwZSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRUeXBlKHR5cGVSZWZzW2RlY29kZXIucmVhZFR5cGVSZWYoKV0oZGVjb2RlcikpO1xuXG4vKipcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHJldHVybiBzZXZlcmFsIGl0ZW1zXG4gKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHt7aXRlbTpJdGVtLCBkaWZmOm51bWJlcn19XG4gKi9cbmNvbnN0IGZvbGxvd1JlZG9uZSA9IChzdG9yZSwgaWQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtJRHxudWxsfVxuICAgKi9cbiAgbGV0IG5leHRJRCA9IGlkO1xuICBsZXQgZGlmZiA9IDA7XG4gIGxldCBpdGVtO1xuICBkbyB7XG4gICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICBuZXh0SUQgPSBjcmVhdGVJRChuZXh0SUQuY2xpZW50LCBuZXh0SUQuY2xvY2sgKyBkaWZmKTtcbiAgICB9XG4gICAgaXRlbSA9IGdldEl0ZW0oc3RvcmUsIG5leHRJRCk7XG4gICAgZGlmZiA9IG5leHRJRC5jbG9jayAtIGl0ZW0uaWQuY2xvY2s7XG4gICAgbmV4dElEID0gaXRlbS5yZWRvbmU7XG4gIH0gd2hpbGUgKG5leHRJRCAhPT0gbnVsbCAmJiBpdGVtIGluc3RhbmNlb2YgSXRlbSlcbiAgcmV0dXJuIHtcbiAgICBpdGVtLCBkaWZmXG4gIH1cbn07XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgbmVpdGhlciBpdGVtIG5vciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgZXZlciBkZWxldGVkLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgZG9lcyBub3QgcGVyc2lzdCB3aGVuIHN0b3JpbmcgaXQgaW50byBhIGRhdGFiYXNlIG9yIHdoZW5cbiAqIHNlbmRpbmcgaXQgdG8gb3RoZXIgcGVlcnNcbiAqXG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBrZWVwXG4gKi9cbmNvbnN0IGtlZXBJdGVtID0gKGl0ZW0sIGtlZXApID0+IHtcbiAgd2hpbGUgKGl0ZW0gIT09IG51bGwgJiYgaXRlbS5rZWVwICE9PSBrZWVwKSB7XG4gICAgaXRlbS5rZWVwID0ga2VlcDtcbiAgICBpdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbTtcbiAgfVxufTtcblxuLyoqXG4gKiBTcGxpdCBsZWZ0SXRlbSBpbnRvIHR3byBpdGVtc1xuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gbGVmdEl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBmdW5jdGlvblxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgc3BsaXRJdGVtID0gKHRyYW5zYWN0aW9uLCBsZWZ0SXRlbSwgZGlmZikgPT4ge1xuICAvLyBjcmVhdGUgcmlnaHRJdGVtXG4gIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdEl0ZW0uaWQ7XG4gIGNvbnN0IHJpZ2h0SXRlbSA9IG5ldyBJdGVtKFxuICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSxcbiAgICBsZWZ0SXRlbSxcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiAtIDEpLFxuICAgIGxlZnRJdGVtLnJpZ2h0LFxuICAgIGxlZnRJdGVtLnJpZ2h0T3JpZ2luLFxuICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICBsZWZ0SXRlbS5wYXJlbnRTdWIsXG4gICAgbGVmdEl0ZW0uY29udGVudC5zcGxpY2UoZGlmZilcbiAgKTtcbiAgaWYgKGxlZnRJdGVtLmRlbGV0ZWQpIHtcbiAgICByaWdodEl0ZW0ubWFya0RlbGV0ZWQoKTtcbiAgfVxuICBpZiAobGVmdEl0ZW0ua2VlcCkge1xuICAgIHJpZ2h0SXRlbS5rZWVwID0gdHJ1ZTtcbiAgfVxuICBpZiAobGVmdEl0ZW0ucmVkb25lICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJlZG9uZSA9IGNyZWF0ZUlEKGxlZnRJdGVtLnJlZG9uZS5jbGllbnQsIGxlZnRJdGVtLnJlZG9uZS5jbG9jayArIGRpZmYpO1xuICB9XG4gIC8vIHVwZGF0ZSBsZWZ0IChkbyBub3Qgc2V0IGxlZnRJdGVtLnJpZ2h0T3JpZ2luIGFzIGl0IHdpbGwgbGVhZCB0byBwcm9ibGVtcyB3aGVuIHN5bmNpbmcpXG4gIGxlZnRJdGVtLnJpZ2h0ID0gcmlnaHRJdGVtO1xuICAvLyB1cGRhdGUgcmlnaHRcbiAgaWYgKHJpZ2h0SXRlbS5yaWdodCAhPT0gbnVsbCkge1xuICAgIHJpZ2h0SXRlbS5yaWdodC5sZWZ0ID0gcmlnaHRJdGVtO1xuICB9XG4gIC8vIHJpZ2h0IGlzIG1vcmUgc3BlY2lmaWMuXG4gIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChyaWdodEl0ZW0pO1xuICAvLyB1cGRhdGUgcGFyZW50Ll9tYXBcbiAgaWYgKHJpZ2h0SXRlbS5wYXJlbnRTdWIgIT09IG51bGwgJiYgcmlnaHRJdGVtLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0SXRlbS5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0SXRlbS5wYXJlbnRTdWIsIHJpZ2h0SXRlbSk7XG4gIH1cbiAgbGVmdEl0ZW0ubGVuZ3RoID0gZGlmZjtcbiAgcmV0dXJuIHJpZ2h0SXRlbVxufTtcblxuLyoqXG4gKiBSZWRvZXMgdGhlIGVmZmVjdCBvZiB0aGlzIG9wZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgWWpzIGluc3RhbmNlLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1NldDxJdGVtPn0gcmVkb2l0ZW1zXG4gKlxuICogQHJldHVybiB7SXRlbXxudWxsfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlZG9JdGVtID0gKHRyYW5zYWN0aW9uLCBpdGVtLCByZWRvaXRlbXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgY29uc3Qgb3duQ2xpZW50SUQgPSBkb2MuY2xpZW50SUQ7XG4gIGNvbnN0IHJlZG9uZSA9IGl0ZW0ucmVkb25lO1xuICBpZiAocmVkb25lICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCByZWRvbmUpXG4gIH1cbiAgbGV0IHBhcmVudEl0ZW0gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9pdGVtO1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCBsZWZ0O1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCByaWdodDtcbiAgaWYgKGl0ZW0ucGFyZW50U3ViID09PSBudWxsKSB7XG4gICAgLy8gSXMgYW4gYXJyYXkgaXRlbS4gSW5zZXJ0IGF0IHRoZSBvbGQgcG9zaXRpb25cbiAgICBsZWZ0ID0gaXRlbS5sZWZ0O1xuICAgIHJpZ2h0ID0gaXRlbTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJcyBhIG1hcCBpdGVtLiBJbnNlcnQgYXMgY3VycmVudCB2YWx1ZVxuICAgIGxlZnQgPSBpdGVtO1xuICAgIHdoaWxlIChsZWZ0LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBsZWZ0ID0gbGVmdC5yaWdodDtcbiAgICAgIGlmIChsZWZ0LmlkLmNsaWVudCAhPT0gb3duQ2xpZW50SUQpIHtcbiAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZG8gdGhpcyBpdGVtIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggYVxuICAgICAgICAvLyBjaGFuZ2UgZnJvbSBhbm90aGVyIGNsaWVudFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGVmdC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgbGVmdCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX21hcC5nZXQoaXRlbS5wYXJlbnRTdWIpKTtcbiAgICB9XG4gICAgcmlnaHQgPSBudWxsO1xuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGF0IHBhcmVudCBpcyByZWRvbmVcbiAgaWYgKHBhcmVudEl0ZW0gIT09IG51bGwgJiYgcGFyZW50SXRlbS5kZWxldGVkID09PSB0cnVlICYmIHBhcmVudEl0ZW0ucmVkb25lID09PSBudWxsKSB7XG4gICAgLy8gdHJ5IHRvIHVuZG8gcGFyZW50IGlmIGl0IHdpbGwgYmUgdW5kb25lIGFueXdheVxuICAgIGlmICghcmVkb2l0ZW1zLmhhcyhwYXJlbnRJdGVtKSB8fCByZWRvSXRlbSh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbSwgcmVkb2l0ZW1zKSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmVudEl0ZW0gIT09IG51bGwgJiYgcGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICB3aGlsZSAocGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbS5yZWRvbmUpO1xuICAgIH1cbiAgICAvLyBmaW5kIG5leHQgY2xvbmVkX3JlZG8gaXRlbXNcbiAgICB3aGlsZSAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgbGVmdFRyYWNlID0gbGVmdDtcbiAgICAgIC8vIHRyYWNlIHJlZG9uZSB1bnRpbCBwYXJlbnQgbWF0Y2hlc1xuICAgICAgd2hpbGUgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdFRyYWNlID0gbGVmdFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgbGVmdFRyYWNlLnJlZG9uZSk7XG4gICAgICB9XG4gICAgICBpZiAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0ID0gbGVmdFRyYWNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbGVmdCA9IGxlZnQubGVmdDtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCByaWdodFRyYWNlID0gcmlnaHQ7XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChyaWdodFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgcmlnaHRUcmFjZSA9IHJpZ2h0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCByaWdodFRyYWNlLnJlZG9uZSk7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtID09PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0ID0gcmlnaHRUcmFjZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5leHRDbG9jayA9IGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJRCk7XG4gIGNvbnN0IG5leHRJZCA9IGNyZWF0ZUlEKG93bkNsaWVudElELCBuZXh0Q2xvY2spO1xuICBjb25zdCByZWRvbmVJdGVtID0gbmV3IEl0ZW0oXG4gICAgbmV4dElkLFxuICAgIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsXG4gICAgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLFxuICAgIHBhcmVudEl0ZW0gPT09IG51bGwgPyBpdGVtLnBhcmVudCA6IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGUsXG4gICAgaXRlbS5wYXJlbnRTdWIsXG4gICAgaXRlbS5jb250ZW50LmNvcHkoKVxuICApO1xuICBpdGVtLnJlZG9uZSA9IG5leHRJZDtcbiAga2VlcEl0ZW0ocmVkb25lSXRlbSwgdHJ1ZSk7XG4gIHJlZG9uZUl0ZW0uaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgcmV0dXJuIHJlZG9uZUl0ZW1cbn07XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCByZXByZXNlbnRzIGFueSBjb250ZW50LlxuICovXG5jbGFzcyBJdGVtIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gbGVmdFxuICAgKiBAcGFyYW0ge0lEIHwgbnVsbH0gb3JpZ2luXG4gICAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSByaWdodE9yaWdpblxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9IHBhcmVudCBJcyBhIHR5cGUgaWYgaW50ZWdyYXRlZCwgaXMgbnVsbCBpZiBpdCBpcyBwb3NzaWJsZSB0byBjb3B5IHBhcmVudCBmcm9tIGxlZnQgb3IgcmlnaHQsIGlzIElEIGJlZm9yZSBpbnRlZ3JhdGlvbiB0byBzZWFyY2ggZm9yIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHBhcmVudFN1YlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udGVudH0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZWZ0LCBvcmlnaW4sIHJpZ2h0LCByaWdodE9yaWdpbiwgcGFyZW50LCBwYXJlbnRTdWIsIGNvbnRlbnQpIHtcbiAgICBzdXBlcihpZCwgY29udGVudC5nZXRMZW5ndGgoKSk7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgbGVmdCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0l0ZW0gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmlnaHRPcmlnaW4gPSByaWdodE9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGFyZW50IHJlZmVycyB0byB0aGlzIGl0ZW0gd2l0aCBzb21lIGtpbmQgb2Yga2V5IChlLmcuIFlNYXAsIHRoZVxuICAgICAqIGtleSBpcyBzcGVjaWZpZWQgaGVyZS4gVGhlIGtleSBpcyB0aGVuIHVzZWQgdG8gcmVmZXIgdG8gdGhlIGxpc3QgaW4gd2hpY2hcbiAgICAgKiB0byBpbnNlcnQgdGhpcyBpdGVtLiBJZiBgcGFyZW50U3ViID0gbnVsbGAgdHlwZS5fc3RhcnQgaXMgdGhlIGxpc3QgaW5cbiAgICAgKiB3aGljaCB0byBpbnNlcnQgdG8uIE90aGVyd2lzZSBpdCBpcyBgcGFyZW50Ll9tYXBgLlxuICAgICAqIEB0eXBlIHtTdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50U3ViID0gcGFyZW50U3ViO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgdHlwZSdzIGVmZmVjdCBpcyByZXVuZG9uZSB0aGlzIHR5cGUgcmVmZXJzIHRvIHRoZSB0eXBlIHRoYXQgdW5kaWRcbiAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVkb25lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RDb250ZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogYml0MToga2VlcFxuICAgICAqIGJpdDI6IGNvdW50YWJsZVxuICAgICAqIGJpdDM6IGRlbGV0ZWRcbiAgICAgKiBiaXQ0OiBtYXJrIC0gbWFyayBub2RlIGFzIGZhc3Qtc2VhcmNoLW1hcmtlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IGJ5dGVcbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB0aGlzLmNvbnRlbnQuaXNDb3VudGFibGUoKSA/IGJpbmFyeS5CSVQyIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gbWFyayB0aGUgaXRlbSBhcyBhbiBpbmRleGVkIGZhc3Qtc2VhcmNoIG1hcmtlclxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBtYXJrZXIgKGlzTWFya2VkKSB7XG4gICAgaWYgKCgodGhpcy5pbmZvICYgYmluYXJ5LkJJVDQpID4gMCkgIT09IGlzTWFya2VkKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1hcmtlciAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUNCkgPiAwXG4gIH1cblxuICAvKipcbiAgICogSWYgdHJ1ZSwgZG8gbm90IGdhcmJhZ2UgY29sbGVjdCB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQga2VlcCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMSkgPiAwXG4gIH1cblxuICBzZXQga2VlcCAoZG9LZWVwKSB7XG4gICAgaWYgKHRoaXMua2VlcCAhPT0gZG9LZWVwKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDE7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMikgPiAwXG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGl0ZW0gd2FzIGRlbGV0ZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQzKSA+IDBcbiAgfVxuXG4gIHNldCBkZWxldGVkIChkb0RlbGV0ZSkge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQgIT09IGRvRGVsZXRlKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDM7XG4gICAgfVxuICB9XG5cbiAgbWFya0RlbGV0ZWQgKCkge1xuICAgIHRoaXMuaW5mbyB8PSBiaW5hcnkuQklUMztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNyZWF0b3IgY2xpZW50SUQgb2YgdGhlIG1pc3Npbmcgb3Agb3IgZGVmaW5lIG1pc3NpbmcgaXRlbXMgYW5kIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luICYmIHRoaXMub3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5vcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMub3JpZ2luLmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucmlnaHRPcmlnaW4gJiYgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQgIT09IHRoaXMuaWQuY2xpZW50ICYmIHRoaXMucmlnaHRPcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQgJiYgdGhpcy5pZC5jbGllbnQgIT09IHRoaXMucGFyZW50LmNsaWVudCAmJiB0aGlzLnBhcmVudC5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5wYXJlbnQuY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNsaWVudFxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYWxsIG1pc3NpbmcgaWRzLCBub3cgZmluZCB0aGUgaXRlbXNcblxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCBzdG9yZSwgdGhpcy5vcmlnaW4pO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbikge1xuICAgICAgdGhpcy5yaWdodCA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCB0aGlzLnJpZ2h0T3JpZ2luKTtcbiAgICAgIHRoaXMucmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0LmlkO1xuICAgIH1cbiAgICBpZiAoKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB8fCAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBHQykpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgLy8gb25seSBzZXQgcGFyZW50IGlmIHRoaXMgc2hvdWxkbid0IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEl0ZW0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLmxlZnQucGFyZW50O1xuICAgICAgICB0aGlzLnBhcmVudFN1YiA9IHRoaXMubGVmdC5wYXJlbnRTdWI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5yaWdodC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5yaWdodC5wYXJlbnRTdWI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBnZXRJdGVtKHN0b3JlLCB0aGlzLnBhcmVudCk7XG4gICAgICBpZiAocGFyZW50SXRlbS5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAocGFyZW50SXRlbS5jb250ZW50KS50eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICB0aGlzLmlkLmNsb2NrICs9IG9mZnNldDtcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayAtIDEpKTtcbiAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5sZWZ0Lmxhc3RJZDtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudC5zcGxpY2Uob2Zmc2V0KTtcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICgoIXRoaXMubGVmdCAmJiAoIXRoaXMucmlnaHQgfHwgdGhpcy5yaWdodC5sZWZ0ICE9PSBudWxsKSkgfHwgKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQucmlnaHQgIT09IHRoaXMucmlnaHQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbztcbiAgICAgICAgLy8gc2V0IG8gdG8gdGhlIGZpcnN0IGNvbmZsaWN0aW5nIGl0ZW1cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gbGVmdC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVzZSBzb21ldGhpbmcgbGlrZSBEZWxldGVTZXQgaGVyZSAoYSB0cmVlIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlIGJlc3QpXG4gICAgICAgIC8vIEB0b2RvIHVzZSBnbG9iYWwgc2V0IGRlZmluaXRpb25zXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29uZmxpY3RpbmdJdGVtcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpdGVtc0JlZm9yZU9yaWdpbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gTGV0IGMgaW4gY29uZmxpY3RpbmdJdGVtcywgYiBpbiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICAvLyAqKip7b3JpZ2lufWJiYmJ7dGhpc317YyxifXtjLGJ9e299KioqXG4gICAgICAgIC8vIE5vdGUgdGhhdCBjb25mbGljdGluZ0l0ZW1zIGlzIGEgc3Vic2V0IG9mIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8gIT09IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICBpdGVtc0JlZm9yZU9yaWdpbi5hZGQobyk7XG4gICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5hZGQobyk7XG4gICAgICAgICAgaWYgKGNvbXBhcmVJRHModGhpcy5vcmlnaW4sIG8ub3JpZ2luKSkge1xuICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICBpZiAoby5pZC5jbGllbnQgPCB0aGlzLmlkLmNsaWVudCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbztcbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlSURzKHRoaXMucmlnaHRPcmlnaW4sIG8ucmlnaHRPcmlnaW4pKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgYW5kIG8gYXJlIGNvbmZsaWN0aW5nIGFuZCBwb2ludCB0byB0aGUgc2FtZSBpbnRlZ3JhdGlvbiBwb2ludHMuIFRoZSBpZCBkZWNpZGVzIHdoaWNoIGl0ZW0gY29tZXMgZmlyc3QuXG4gICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdG8gdGhlIGxlZnQgb2Ygbywgd2UgY2FuIGJyZWFrIGhlcmVcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gLy8gZWxzZSwgbyBtaWdodCBiZSBpbnRlZ3JhdGVkIGJlZm9yZSBhbiBpdGVtIHRoYXQgdGhpcyBjb25mbGljdHMgd2l0aC4gSWYgc28sIHdlIHdpbGwgZmluZCBpdCBpbiB0aGUgbmV4dCBpdGVyYXRpb25zXG4gICAgICAgICAgfSBlbHNlIGlmIChvLm9yaWdpbiAhPT0gbnVsbCAmJiBpdGVtc0JlZm9yZU9yaWdpbi5oYXMoZ2V0SXRlbSh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIG8ub3JpZ2luKSkpIHsgLy8gdXNlIGdldEl0ZW0gaW5zdGVhZCBvZiBnZXRJdGVtQ2xlYW5FbmQgYmVjYXVzZSB3ZSBkb24ndCB3YW50IC8gbmVlZCB0byBzcGxpdCBpdGVtcy5cbiAgICAgICAgICAgIC8vIGNhc2UgMlxuICAgICAgICAgICAgaWYgKCFjb25mbGljdGluZ0l0ZW1zLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbztcbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBvID0gby5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgICAgLy8gcmVjb25uZWN0IGxlZnQvcmlnaHQgKyB1cGRhdGUgcGFyZW50IG1hcC9zdGFydCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLmxlZnQucmlnaHQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5sZWZ0LnJpZ2h0ID0gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbDtcbiAgICAgICAgICB3aGlsZSAociAhPT0gbnVsbCAmJiByLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHIgPSByLmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydFxuICAgICAgICAgIDsvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWdodCA9IHI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBzZXQgYXMgY3VycmVudCBwYXJlbnQgdmFsdWUgaWYgcmlnaHQgPT09IG51bGwgYW5kIHRoaXMgaXMgcGFyZW50U3ViXG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5zZXQodGhpcy5wYXJlbnRTdWIsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50LiBkZWxldGUgcmlnaHRcbiAgICAgICAgICB0aGlzLmxlZnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYWRqdXN0IGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCAmJiB0aGlzLmNvdW50YWJsZSAmJiAhdGhpcy5kZWxldGVkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2xlbmd0aCArPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICAgICAgdGhpcy5jb250ZW50LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgdGhpcyk7XG4gICAgICAvLyBhZGQgcGFyZW50IHRvIHRyYW5zYWN0aW9uLmNoYW5nZWRcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KSwgdGhpcy5wYXJlbnRTdWIpO1xuICAgICAgaWYgKCgvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0uZGVsZXRlZCkgfHwgKHRoaXMucGFyZW50U3ViICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBpZiBwYXJlbnQgaXMgZGVsZXRlZCBvciBpZiB0aGlzIGlzIG5vdCB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50XG4gICAgICAgIHRoaXMuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBkZWZpbmVkLiBJbnRlZ3JhdGUgR0Mgc3RydWN0IGluc3RlYWRcbiAgICAgIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dCBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgbmV4dCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLnJpZ2h0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IHByZXYgKCkge1xuICAgIGxldCBuID0gdGhpcy5sZWZ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbGFzdCBjb250ZW50IGFkZHJlc3Mgb2YgdGhpcyBJdGVtLlxuICAgKi9cbiAgZ2V0IGxhc3RJZCAoKSB7XG4gICAgLy8gYWxsb2NhdGluZyBpZHMgaXMgcHJldHR5IGNvc3RseSBiZWNhdXNlIG9mIHRoZSBhbW91bnQgb2YgaWRzIGNyZWF0ZWQsIHNvIHdlIHRyeSB0byByZXVzZSB3aGVuZXZlciBwb3NzaWJsZVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSA/IHRoaXMuaWQgOiBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gbWVyZ2UgdHdvIGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID09PSByaWdodC5jb25zdHJ1Y3RvciAmJlxuICAgICAgY29tcGFyZUlEcyhyaWdodC5vcmlnaW4sIHRoaXMubGFzdElkKSAmJlxuICAgICAgdGhpcy5yaWdodCA9PT0gcmlnaHQgJiZcbiAgICAgIGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgcmlnaHQucmlnaHRPcmlnaW4pICYmXG4gICAgICB0aGlzLmlkLmNsaWVudCA9PT0gcmlnaHQuaWQuY2xpZW50ICYmXG4gICAgICB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggPT09IHJpZ2h0LmlkLmNsb2NrICYmXG4gICAgICB0aGlzLmRlbGV0ZWQgPT09IHJpZ2h0LmRlbGV0ZWQgJiZcbiAgICAgIHRoaXMucmVkb25lID09PSBudWxsICYmXG4gICAgICByaWdodC5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHRoaXMuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciAmJlxuICAgICAgdGhpcy5jb250ZW50Lm1lcmdlV2l0aChyaWdodC5jb250ZW50KVxuICAgICkge1xuICAgICAgaWYgKHJpZ2h0LmtlZXApIHtcbiAgICAgICAgdGhpcy5rZWVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmlnaHQgPSByaWdodC5yaWdodDtcbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrIHRoaXMgSXRlbSBhcyBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGlmICghdGhpcy5kZWxldGVkKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpO1xuICAgICAgLy8gYWRqdXN0IHRoZSBsZW5ndGggb2YgcGFyZW50XG4gICAgICBpZiAodGhpcy5jb3VudGFibGUgJiYgdGhpcy5wYXJlbnRTdWIgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50Ll9sZW5ndGggLT0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcmtEZWxldGVkKCk7XG4gICAgICBhZGRUb0RlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrLCB0aGlzLmxlbmd0aCk7XG4gICAgICBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHBhcmVudCwgdGhpcy5wYXJlbnRTdWIpO1xuICAgICAgdGhpcy5jb250ZW50LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyZW50R0NkXG4gICAqL1xuICBnYyAoc3RvcmUsIHBhcmVudEdDZCkge1xuICAgIGlmICghdGhpcy5kZWxldGVkKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICAgIHRoaXMuY29udGVudC5nYyhzdG9yZSk7XG4gICAgaWYgKHBhcmVudEdDZCkge1xuICAgICAgcmVwbGFjZVN0cnVjdChzdG9yZSwgdGhpcywgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGVudCA9IG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBvcmlnaW4gPSBvZmZzZXQgPiAwID8gY3JlYXRlSUQodGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2sgKyBvZmZzZXQgLSAxKSA6IHRoaXMub3JpZ2luO1xuICAgIGNvbnN0IHJpZ2h0T3JpZ2luID0gdGhpcy5yaWdodE9yaWdpbjtcbiAgICBjb25zdCBwYXJlbnRTdWIgPSB0aGlzLnBhcmVudFN1YjtcbiAgICBjb25zdCBpbmZvID0gKHRoaXMuY29udGVudC5nZXRSZWYoKSAmIGJpbmFyeS5CSVRTNSkgfFxuICAgICAgKG9yaWdpbiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUOCkgfCAvLyBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHJpZ2h0T3JpZ2luID09PSBudWxsID8gMCA6IGJpbmFyeS5CSVQ3KSB8IC8vIHJpZ2h0IG9yaWdpbiBpcyBkZWZpbmVkXG4gICAgICAocGFyZW50U3ViID09PSBudWxsID8gMCA6IGJpbmFyeS5CSVQ2KTsgLy8gcGFyZW50U3ViIGlzIG5vbi1udWxsXG4gICAgZW5jb2Rlci53cml0ZUluZm8oaW5mbyk7XG4gICAgaWYgKG9yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChvcmlnaW4pO1xuICAgIH1cbiAgICBpZiAocmlnaHRPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVSaWdodElEKHJpZ2h0T3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCAmJiByaWdodE9yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnQuX2l0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRJdGVtID0gcGFyZW50Ll9pdGVtO1xuICAgICAgICBpZiAocGFyZW50SXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHBhcmVudCB0eXBlIG9uIHkuX21hcFxuICAgICAgICAgIC8vIGZpbmQgdGhlIGNvcnJlY3Qga2V5XG4gICAgICAgICAgY29uc3QgeWtleSA9IGZpbmRSb290VHlwZUtleShwYXJlbnQpO1xuICAgICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKHRydWUpOyAvLyB3cml0ZSBwYXJlbnRZS2V5XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyh5a2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSk7IC8vIHdyaXRlIHBhcmVudCBpZFxuICAgICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50SXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHsgLy8gdGhpcyBlZGdlIGNhc2Ugd2FzIGFkZGVkIGJ5IGRpZmZlcmVudGlhbCB1cGRhdGVzXG4gICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKHRydWUpOyAvLyB3cml0ZSBwYXJlbnRZS2V5XG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcocGFyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSk7IC8vIHdyaXRlIHBhcmVudCBpZFxuICAgICAgICBlbmNvZGVyLndyaXRlTGVmdElEKHBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudFN1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGVudC53cml0ZShlbmNvZGVyLCBvZmZzZXQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvXG4gKi9cbmNvbnN0IHJlYWRJdGVtQ29udGVudCA9IChkZWNvZGVyLCBpbmZvKSA9PiBjb250ZW50UmVmc1tpbmZvICYgYmluYXJ5LkJJVFM1XShkZWNvZGVyKTtcblxuLyoqXG4gKiBBIGxvb2t1cCBtYXAgZm9yIHJlYWRpbmcgSXRlbSBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIpOkFic3RyYWN0Q29udGVudD59XG4gKi9cbmNvbnN0IGNvbnRlbnRSZWZzID0gW1xuICAoKSA9PiB7IGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7IH0sIC8vIEdDIGlzIG5vdCBJdGVtQ29udGVudFxuICByZWFkQ29udGVudERlbGV0ZWQsIC8vIDFcbiAgcmVhZENvbnRlbnRKU09OLCAvLyAyXG4gIHJlYWRDb250ZW50QmluYXJ5LCAvLyAzXG4gIHJlYWRDb250ZW50U3RyaW5nLCAvLyA0XG4gIHJlYWRDb250ZW50RW1iZWQsIC8vIDVcbiAgcmVhZENvbnRlbnRGb3JtYXQsIC8vIDZcbiAgcmVhZENvbnRlbnRUeXBlLCAvLyA3XG4gIHJlYWRDb250ZW50QW55LCAvLyA4XG4gIHJlYWRDb250ZW50RG9jLCAvLyA5XG4gICgpID0+IHsgZXJyb3IudW5leHBlY3RlZENhc2UoKTsgfSAvLyAxMCAtIFNraXAgaXMgbm90IEl0ZW1Db250ZW50XG5dO1xuXG5jb25zdCBzdHJ1Y3RTa2lwUmVmTnVtYmVyID0gMTA7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgU2tpcCBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkZWxldGUgKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtTa2lwfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIC8vIHNraXAgc3RydWN0cyBjYW5ub3QgYmUgaW50ZWdyYXRlZFxuICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVJbmZvKHN0cnVjdFNraXBSZWZOdW1iZXIpO1xuICAgIC8vIHdyaXRlIGFzIFZhclVpbnQgYmVjYXVzZSBTa2lwcyBjYW4ndCBtYWtlIHVzZSBvZiBwcmVkaWN0YWJsZSBsZW5ndGgtZW5jb2RpbmdcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgdGhpcy5sZW5ndGggLSBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmV4cG9ydHMuQWJzdHJhY3RDb25uZWN0b3IgPSBBYnN0cmFjdENvbm5lY3RvcjtcbmV4cG9ydHMuQWJzdHJhY3RTdHJ1Y3QgPSBBYnN0cmFjdFN0cnVjdDtcbmV4cG9ydHMuQWJzdHJhY3RUeXBlID0gQWJzdHJhY3RUeXBlO1xuZXhwb3J0cy5BcnJheSA9IFlBcnJheTtcbmV4cG9ydHMuQ29udGVudEFueSA9IENvbnRlbnRBbnk7XG5leHBvcnRzLkNvbnRlbnRCaW5hcnkgPSBDb250ZW50QmluYXJ5O1xuZXhwb3J0cy5Db250ZW50RGVsZXRlZCA9IENvbnRlbnREZWxldGVkO1xuZXhwb3J0cy5Db250ZW50RW1iZWQgPSBDb250ZW50RW1iZWQ7XG5leHBvcnRzLkNvbnRlbnRGb3JtYXQgPSBDb250ZW50Rm9ybWF0O1xuZXhwb3J0cy5Db250ZW50SlNPTiA9IENvbnRlbnRKU09OO1xuZXhwb3J0cy5Db250ZW50U3RyaW5nID0gQ29udGVudFN0cmluZztcbmV4cG9ydHMuQ29udGVudFR5cGUgPSBDb250ZW50VHlwZTtcbmV4cG9ydHMuRG9jID0gRG9jO1xuZXhwb3J0cy5HQyA9IEdDO1xuZXhwb3J0cy5JRCA9IElEO1xuZXhwb3J0cy5JdGVtID0gSXRlbTtcbmV4cG9ydHMuTWFwID0gWU1hcDtcbmV4cG9ydHMuUGVybWFuZW50VXNlckRhdGEgPSBQZXJtYW5lbnRVc2VyRGF0YTtcbmV4cG9ydHMuUmVsYXRpdmVQb3NpdGlvbiA9IFJlbGF0aXZlUG9zaXRpb247XG5leHBvcnRzLlNuYXBzaG90ID0gU25hcHNob3Q7XG5leHBvcnRzLlRleHQgPSBZVGV4dDtcbmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbmV4cG9ydHMuVW5kb01hbmFnZXIgPSBVbmRvTWFuYWdlcjtcbmV4cG9ydHMuWG1sRWxlbWVudCA9IFlYbWxFbGVtZW50O1xuZXhwb3J0cy5YbWxGcmFnbWVudCA9IFlYbWxGcmFnbWVudDtcbmV4cG9ydHMuWG1sSG9vayA9IFlYbWxIb29rO1xuZXhwb3J0cy5YbWxUZXh0ID0gWVhtbFRleHQ7XG5leHBvcnRzLllBcnJheUV2ZW50ID0gWUFycmF5RXZlbnQ7XG5leHBvcnRzLllFdmVudCA9IFlFdmVudDtcbmV4cG9ydHMuWU1hcEV2ZW50ID0gWU1hcEV2ZW50O1xuZXhwb3J0cy5ZVGV4dEV2ZW50ID0gWVRleHRFdmVudDtcbmV4cG9ydHMuWVhtbEV2ZW50ID0gWVhtbEV2ZW50O1xuZXhwb3J0cy5hcHBseVVwZGF0ZSA9IGFwcGx5VXBkYXRlO1xuZXhwb3J0cy5hcHBseVVwZGF0ZVYyID0gYXBwbHlVcGRhdGVWMjtcbmV4cG9ydHMuY29tcGFyZUlEcyA9IGNvbXBhcmVJRHM7XG5leHBvcnRzLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyA9IGNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucztcbmV4cG9ydHMuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uO1xuZXhwb3J0cy5jcmVhdGVEZWxldGVTZXQgPSBjcmVhdGVEZWxldGVTZXQ7XG5leHBvcnRzLmNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSA9IGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZTtcbmV4cG9ydHMuY3JlYXRlRG9jRnJvbVNuYXBzaG90ID0gY3JlYXRlRG9jRnJvbVNuYXBzaG90O1xuZXhwb3J0cy5jcmVhdGVJRCA9IGNyZWF0ZUlEO1xuZXhwb3J0cy5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04gPSBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT047XG5leHBvcnRzLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4ID0gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXg7XG5leHBvcnRzLmNyZWF0ZVNuYXBzaG90ID0gY3JlYXRlU25hcHNob3Q7XG5leHBvcnRzLmRlY29kZVJlbGF0aXZlUG9zaXRpb24gPSBkZWNvZGVSZWxhdGl2ZVBvc2l0aW9uO1xuZXhwb3J0cy5kZWNvZGVTbmFwc2hvdCA9IGRlY29kZVNuYXBzaG90O1xuZXhwb3J0cy5kZWNvZGVTbmFwc2hvdFYyID0gZGVjb2RlU25hcHNob3RWMjtcbmV4cG9ydHMuZGVjb2RlU3RhdGVWZWN0b3IgPSBkZWNvZGVTdGF0ZVZlY3RvcjtcbmV4cG9ydHMuZGlmZlVwZGF0ZSA9IGRpZmZVcGRhdGU7XG5leHBvcnRzLmRpZmZVcGRhdGVWMiA9IGRpZmZVcGRhdGVWMjtcbmV4cG9ydHMuZW1wdHlTbmFwc2hvdCA9IGVtcHR5U25hcHNob3Q7XG5leHBvcnRzLmVuY29kZVJlbGF0aXZlUG9zaXRpb24gPSBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uO1xuZXhwb3J0cy5lbmNvZGVTbmFwc2hvdCA9IGVuY29kZVNuYXBzaG90O1xuZXhwb3J0cy5lbmNvZGVTbmFwc2hvdFYyID0gZW5jb2RlU25hcHNob3RWMjtcbmV4cG9ydHMuZW5jb2RlU3RhdGVBc1VwZGF0ZSA9IGVuY29kZVN0YXRlQXNVcGRhdGU7XG5leHBvcnRzLmVuY29kZVN0YXRlQXNVcGRhdGVWMiA9IGVuY29kZVN0YXRlQXNVcGRhdGVWMjtcbmV4cG9ydHMuZW5jb2RlU3RhdGVWZWN0b3IgPSBlbmNvZGVTdGF0ZVZlY3RvcjtcbmV4cG9ydHMuZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlID0gZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlO1xuZXhwb3J0cy5lbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMiA9IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyO1xuZXhwb3J0cy5lcXVhbFNuYXBzaG90cyA9IGVxdWFsU25hcHNob3RzO1xuZXhwb3J0cy5maW5kUm9vdFR5cGVLZXkgPSBmaW5kUm9vdFR5cGVLZXk7XG5leHBvcnRzLmdldEl0ZW0gPSBnZXRJdGVtO1xuZXhwb3J0cy5nZXRTdGF0ZSA9IGdldFN0YXRlO1xuZXhwb3J0cy5nZXRUeXBlQ2hpbGRyZW4gPSBnZXRUeXBlQ2hpbGRyZW47XG5leHBvcnRzLmlzRGVsZXRlZCA9IGlzRGVsZXRlZDtcbmV4cG9ydHMuaXNQYXJlbnRPZiA9IGlzUGFyZW50T2Y7XG5leHBvcnRzLml0ZXJhdGVEZWxldGVkU3RydWN0cyA9IGl0ZXJhdGVEZWxldGVkU3RydWN0cztcbmV4cG9ydHMubG9nVHlwZSA9IGxvZ1R5cGU7XG5leHBvcnRzLmxvZ1VwZGF0ZSA9IGxvZ1VwZGF0ZTtcbmV4cG9ydHMubG9nVXBkYXRlVjIgPSBsb2dVcGRhdGVWMjtcbmV4cG9ydHMubWVyZ2VVcGRhdGVzID0gbWVyZ2VVcGRhdGVzO1xuZXhwb3J0cy5tZXJnZVVwZGF0ZXNWMiA9IG1lcmdlVXBkYXRlc1YyO1xuZXhwb3J0cy5wYXJzZVVwZGF0ZU1ldGEgPSBwYXJzZVVwZGF0ZU1ldGE7XG5leHBvcnRzLnBhcnNlVXBkYXRlTWV0YVYyID0gcGFyc2VVcGRhdGVNZXRhVjI7XG5leHBvcnRzLnJlYWRVcGRhdGUgPSByZWFkVXBkYXRlO1xuZXhwb3J0cy5yZWFkVXBkYXRlVjIgPSByZWFkVXBkYXRlVjI7XG5leHBvcnRzLnJlbGF0aXZlUG9zaXRpb25Ub0pTT04gPSByZWxhdGl2ZVBvc2l0aW9uVG9KU09OO1xuZXhwb3J0cy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuZXhwb3J0cy50cmFuc2FjdCA9IHRyYW5zYWN0O1xuZXhwb3J0cy50cnlHYyA9IHRyeUdjO1xuZXhwb3J0cy50eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCA9IHR5cGVMaXN0VG9BcnJheVNuYXBzaG90O1xuZXhwb3J0cy50eXBlTWFwR2V0U25hcHNob3QgPSB0eXBlTWFwR2V0U25hcHNob3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD15anMuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yjs/dist/yjs.cjs\n")},"./node_modules/yjs/dist/yjs.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractConnector\": () => (/* binding */ AbstractConnector),\n/* harmony export */   \"AbstractStruct\": () => (/* binding */ AbstractStruct),\n/* harmony export */   \"AbstractType\": () => (/* binding */ AbstractType),\n/* harmony export */   \"Array\": () => (/* binding */ YArray),\n/* harmony export */   \"ContentAny\": () => (/* binding */ ContentAny),\n/* harmony export */   \"ContentBinary\": () => (/* binding */ ContentBinary),\n/* harmony export */   \"ContentDeleted\": () => (/* binding */ ContentDeleted),\n/* harmony export */   \"ContentEmbed\": () => (/* binding */ ContentEmbed),\n/* harmony export */   \"ContentFormat\": () => (/* binding */ ContentFormat),\n/* harmony export */   \"ContentJSON\": () => (/* binding */ ContentJSON),\n/* harmony export */   \"ContentString\": () => (/* binding */ ContentString),\n/* harmony export */   \"ContentType\": () => (/* binding */ ContentType),\n/* harmony export */   \"Doc\": () => (/* binding */ Doc),\n/* harmony export */   \"GC\": () => (/* binding */ GC),\n/* harmony export */   \"ID\": () => (/* binding */ ID),\n/* harmony export */   \"Item\": () => (/* binding */ Item),\n/* harmony export */   \"Map\": () => (/* binding */ YMap),\n/* harmony export */   \"PermanentUserData\": () => (/* binding */ PermanentUserData),\n/* harmony export */   \"RelativePosition\": () => (/* binding */ RelativePosition),\n/* harmony export */   \"Snapshot\": () => (/* binding */ Snapshot),\n/* harmony export */   \"Text\": () => (/* binding */ YText),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"UndoManager\": () => (/* binding */ UndoManager),\n/* harmony export */   \"XmlElement\": () => (/* binding */ YXmlElement),\n/* harmony export */   \"XmlFragment\": () => (/* binding */ YXmlFragment),\n/* harmony export */   \"XmlHook\": () => (/* binding */ YXmlHook),\n/* harmony export */   \"XmlText\": () => (/* binding */ YXmlText),\n/* harmony export */   \"YArrayEvent\": () => (/* binding */ YArrayEvent),\n/* harmony export */   \"YEvent\": () => (/* binding */ YEvent),\n/* harmony export */   \"YMapEvent\": () => (/* binding */ YMapEvent),\n/* harmony export */   \"YTextEvent\": () => (/* binding */ YTextEvent),\n/* harmony export */   \"YXmlEvent\": () => (/* binding */ YXmlEvent),\n/* harmony export */   \"applyUpdate\": () => (/* binding */ applyUpdate),\n/* harmony export */   \"applyUpdateV2\": () => (/* binding */ applyUpdateV2),\n/* harmony export */   \"compareIDs\": () => (/* binding */ compareIDs),\n/* harmony export */   \"compareRelativePositions\": () => (/* binding */ compareRelativePositions),\n/* harmony export */   \"createAbsolutePositionFromRelativePosition\": () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   \"createDeleteSet\": () => (/* binding */ createDeleteSet),\n/* harmony export */   \"createDeleteSetFromStructStore\": () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   \"createDocFromSnapshot\": () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   \"createID\": () => (/* binding */ createID),\n/* harmony export */   \"createRelativePositionFromJSON\": () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   \"createRelativePositionFromTypeIndex\": () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   \"createSnapshot\": () => (/* binding */ createSnapshot),\n/* harmony export */   \"decodeRelativePosition\": () => (/* binding */ decodeRelativePosition),\n/* harmony export */   \"decodeSnapshot\": () => (/* binding */ decodeSnapshot),\n/* harmony export */   \"decodeSnapshotV2\": () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   \"decodeStateVector\": () => (/* binding */ decodeStateVector),\n/* harmony export */   \"diffUpdate\": () => (/* binding */ diffUpdate),\n/* harmony export */   \"diffUpdateV2\": () => (/* binding */ diffUpdateV2),\n/* harmony export */   \"emptySnapshot\": () => (/* binding */ emptySnapshot),\n/* harmony export */   \"encodeRelativePosition\": () => (/* binding */ encodeRelativePosition),\n/* harmony export */   \"encodeSnapshot\": () => (/* binding */ encodeSnapshot),\n/* harmony export */   \"encodeSnapshotV2\": () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   \"encodeStateAsUpdate\": () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   \"encodeStateAsUpdateV2\": () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   \"encodeStateVector\": () => (/* binding */ encodeStateVector),\n/* harmony export */   \"encodeStateVectorFromUpdate\": () => (/* binding */ encodeStateVectorFromUpdate),\n/* harmony export */   \"encodeStateVectorFromUpdateV2\": () => (/* binding */ encodeStateVectorFromUpdateV2),\n/* harmony export */   \"equalSnapshots\": () => (/* binding */ equalSnapshots),\n/* harmony export */   \"findRootTypeKey\": () => (/* binding */ findRootTypeKey),\n/* harmony export */   \"getItem\": () => (/* binding */ getItem),\n/* harmony export */   \"getState\": () => (/* binding */ getState),\n/* harmony export */   \"getTypeChildren\": () => (/* binding */ getTypeChildren),\n/* harmony export */   \"isDeleted\": () => (/* binding */ isDeleted),\n/* harmony export */   \"isParentOf\": () => (/* binding */ isParentOf),\n/* harmony export */   \"iterateDeletedStructs\": () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   \"logType\": () => (/* binding */ logType),\n/* harmony export */   \"logUpdate\": () => (/* binding */ logUpdate),\n/* harmony export */   \"logUpdateV2\": () => (/* binding */ logUpdateV2),\n/* harmony export */   \"mergeUpdates\": () => (/* binding */ mergeUpdates),\n/* harmony export */   \"mergeUpdatesV2\": () => (/* binding */ mergeUpdatesV2),\n/* harmony export */   \"parseUpdateMeta\": () => (/* binding */ parseUpdateMeta),\n/* harmony export */   \"parseUpdateMetaV2\": () => (/* binding */ parseUpdateMetaV2),\n/* harmony export */   \"readUpdate\": () => (/* binding */ readUpdate),\n/* harmony export */   \"readUpdateV2\": () => (/* binding */ readUpdateV2),\n/* harmony export */   \"relativePositionToJSON\": () => (/* binding */ relativePositionToJSON),\n/* harmony export */   \"snapshot\": () => (/* binding */ snapshot),\n/* harmony export */   \"transact\": () => (/* binding */ transact),\n/* harmony export */   \"tryGc\": () => (/* binding */ tryGc),\n/* harmony export */   \"typeListToArraySnapshot\": () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   \"typeMapGetSnapshot\": () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable.js */ \"./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/array.js */ \"./node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math.js */ \"./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map.js */ \"./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding.js */ \"./node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding.js */ \"./node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random.js */ \"./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_buffer_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/buffer.js */ \"./node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/error.js */ \"./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/binary.js */ \"./node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/function.js */ \"./node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/set.js */ \"./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/logging.js */ \"./node_modules/lib0/logging.js\");\n/* harmony import */ var lib0_time_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/time.js */ \"./node_modules/lib0/time.js\");\n/* harmony import */ var lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/iterator.js */ \"./node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/object.js */ \"./node_modules/lib0/object.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nclass AbstractConnector extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i];\n      iterateStructs(transaction, structs, del.clock, del.len, f);\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.appendTo)(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(ds.clients, client, () => []).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.id.clock === clock + len && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, ds.clients.size);\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, client);\n    const len = dsitems.length;\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, len);\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i];\n      encoder.writeDsClock(item.clock);\n      encoder.writeDsLen(item.len);\n    }\n  });\n};\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const numberOfDeletes = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(ds.clients, client, () => []);\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const numberOfDeletes = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(ds.restEncoder, 0); // encode 0 structs\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array()\n  }\n  return null\n};\n\n/**\n * @module Y\n */\n\nconst generateNewClientId = lib0_random_js__WEBPACK_IMPORTED_MODULE_6__.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nclass Doc extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = (0,lib0_random_js__WEBPACK_IMPORTED_MODULE_6__.uuidv4)(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = autoLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin);\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.from)(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null;\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts });\n        content.doc._item = item;\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    this.emit('destroyed', [true]);\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f);\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f);\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8)(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return (0,lib0_buffer_js__WEBPACK_IMPORTED_MODULE_7__.copyUint8Array)((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.clientDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.leftClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.rightClockDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.infoDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.RleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder), lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.stringDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.StringDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.parentInfoDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.RleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder), lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.typeRefDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n    this.lenDecoder = new lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array)(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny)(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n  }\n\n  toUint8Array () {\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.client);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.client);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n    }\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.clientEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.leftClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.infoEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.stringEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n    this.parentInfoEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.typeRefEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.lenEncoder = new lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, 0); // this is a feature flag that we might use in the future\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.keyClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.clientEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.leftClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.rightClockEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.infoEncoder));\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.stringEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.parentInfoEncoder));\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.typeRefEncoder.toUint8Array());\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array)(encoder, (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(this.restEncoder));\n    return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array)(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny)(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(this.keyClock++);\n    }\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(clock, structs[0].id.clock); // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock);\n  });\n};\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.create)();\n  const numOfStateUpdates = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs });\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      switch (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen();\n          refs[i] = new GC(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n          refs[i] = new Skip(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 | lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8)) === 0;\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          );\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = [];\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore();\n  const missingSV = new Map();\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item]);\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);\n    }\n    stack.length = 0;\n  };\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing));\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop());\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, new Map());\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    let retry = false;\n    const doc = transaction.doc;\n    const store = doc.store;\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc);\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true;\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(store.pendingDs));\n      (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest;\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  // also add the pending updates (if there are any)\n  // @todo support diffirent encoders\n  if (encoder.constructor === UpdateEncoderV2) {\n    if (doc.store.pendingDs) {\n      updates.push(doc.store.pendingDs);\n    }\n    if (doc.store.pendingStructs) {\n      updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(decodedState)));\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, sv.size);\n  sv.forEach((clock, client) => {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc);\n  } else {\n    writeDocumentStateVector(encoder, doc);\n  }\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  (0,lib0_function_js__WEBPACK_IMPORTED_MODULE_10__.callAll)(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nconst writeID = (encoder, id) => {\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, id.client);\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, id.clock);\n};\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nconst readID = decoder =>\n  createID((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder), (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder));\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add intial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} [conf]\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nconst relativePositionToJSON = rpos => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json\n};\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nconst writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(encoder, 1);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarString)(encoder, tname);\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8)(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n  }\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarInt)(encoder, assoc);\n  return encoder\n};\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nconst encodeRelativePosition = rpos => {\n  const encoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n  writeRelativePosition(encoder, rpos);\n  return (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(encoder)\n};\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nconst readRelativePosition = decoder => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch ((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder);\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarString)(decoder);\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder);\n    }\n  }\n  const assoc = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.hasContent)(decoder) ? (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarInt)(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc)\n};\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nconst decodeRelativePosition = uint8Array => readRelativePosition((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(uint8Array));\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1());\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(transaction.meta, splitSnapshotAffectedStructs, lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null;\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null;\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.floor)((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !(0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.any)(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(transaction.changed, type, lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1];\n  const right = structs[pos];\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1);\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.min)(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc._transaction = null;\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                );\n              events\n                .forEach(event => {\n                  event.currentTarget = type;\n                });\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length);\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          })\n        );\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      });\n      (0,lib0_function_js__WEBPACK_IMPORTED_MODULE_10__.callAll)(fs, []);\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1);\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId();\n        (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)(lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.ORANGE, lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.BOLD, '[yjs] ', lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.UNBOLD, lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.RED, 'Changed the client-id because another client seems to be using it.');\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc));\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }]);\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy());\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    f(doc._transaction);\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0);\n    }\n  }\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null;\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter whan an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'>}\n */\nclass UndoManager extends lib0_observable_js__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, { captureTimeout = 500, deleteFilter = () => true, trackedOrigins = new Set([null]) } = {}) {\n    super();\n    this.scope = typeScope instanceof Array ? typeScope : [typeScope];\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = /** @type {Doc} */ (this.scope[0].doc);\n    this.lastChange = 0;\n    this.doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      // Only track certain transactions\n      if (!this.scope.some(type => transaction.changedParentTypes.has(type)) || (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.redoStack = [];\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = (0,lib0_time_js__WEBPACK_IMPORTED_MODULE_13__.getUnixTime)();\n      if (now - this.lastChange < captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true);\n        }\n      });\n      this.emit('stack-item-added', [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this]);\n    });\n  }\n\n  clear () {\n    this.doc.transact(transaction => {\n      /**\n       * @param {StackItem} stackItem\n       */\n      const clearItem = stackItem => {\n        iterateDeletedStructs(transaction, stackItem.deletions, item => {\n          if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n            keepItem(item, false);\n          }\n        });\n      };\n      this.undoStack.forEach(clearItem);\n      this.redoStack.forEach(clearItem);\n    });\n    this.undoStack = [];\n    this.redoStack = [];\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = (0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.readVarUint)(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 | lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6) === lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\n\nclass LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst logUpdate = update => logUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)('Structs: ', structs);\n  const ds = readDeleteSet(updateDecoder);\n  (0,lib0_logging_js__WEBPACK_IMPORTED_MODULE_12__.print)('DeleteSet: ', ds);\n};\n\nclass LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = [];\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nconst mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update)), true);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 1;\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    let stopCounting = false;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        size++;\n        // We found a new client\n        // write what we have to the encoder\n        (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClient);\n        (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClock);\n        currClient = curr.id.client;\n        stopCounting = false;\n      }\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    // write what we have\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClient);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, currClock);\n    // prepend the size of the state vector\n    const enc = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(enc, size);\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder)(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array()\n  } else {\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, 0);\n    return encoder.toUint8Array()\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map();\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    // write the beginning to `from`\n    from.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock);\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock);\n        // update currClient\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    // write the end to `to`\n    to.set(currClient, currClock);\n  }\n  return { from, to }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1);\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left);\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n};\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nconst mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const updateDecoders = updates.map(update => new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update)));\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null;\n\n  const updateEncoder = new YEncoder();\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : (\n              dec1.curr.constructor === Skip ? 1 : -1\n            )\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0];\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n      }\n      if (curr === null || curr.id.client !== firstClient) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };\n      currDecoder.next();\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nconst diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder((0,lib0_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder)(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next();\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  // write ds\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nconst diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array)(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder)();\n    lazyWriter.written = 0;\n  }\n};\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client);\n    // write startClock\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder;\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(restEncoder, lazyWriter.clientStructs.length);\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(restEncoder, partStructs.written);\n    // write the rest of the fragment\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array)(restEncoder, partStructs.restEncoder);\n  }\n};\n\n/**\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null;\n    /**\n     * @type {null | Array<{ insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map();\n      const target = this.target;\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = (0,lib0_array_js__WEBPACK_IMPORTED_MODULE_2__.last)(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys;\n    }\n    return this._keys\n  }\n\n  /**\n   * @type {Array<{insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      const target = this.target;\n      const added = (0,lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create)();\n      const deleted = (0,lib0_set_js__WEBPACK_IMPORTED_MODULE_11__.create)();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index - a.index) < (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = (0,lib0_math_js__WEBPACK_IMPORTED_MODULE_1__.max)(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined)(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c);\n        break\n      default:\n        packJsonContent();\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n            left.integrate(transaction, 0);\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n            left.integrate(transaction, 0);\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n              left.integrate(transaction, 0);\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  });\n  packJsonContent();\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.create)('array length exceeded')\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = map => (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorFilter)(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted);\n\n/**\n * @module YArray\n */\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nclass YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ));\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYArray = decoder => new YArray();\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return (0,lib0_iterator_js__WEBPACK_IMPORTED_MODULE_14__.iteratorMap)(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nconst readYMap = decoder => new YMap();\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && (0,lib0_object_js__WEBPACK_IMPORTED_MODULE_15__.equalFlat)(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let nextFormat = currPos.left;\n  const right = currPos.right;\n  negatedAttributes.forEach((val, key) => {\n    nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), nextFormat, nextFormat && nextFormat.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text);\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content));\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.create)();\n    const currentAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, (0,lib0_map_js__WEBPACK_IMPORTED_MODULE_3__.copy)(currPos.currentAttributes));\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      };\n      this._changes = changes;\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      /**\n       * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = [];\n      transact(y, transaction => {\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op;\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen };\n                deleteLen = 0;\n                break\n              case 'insert':\n                op = { insert };\n                if (currentAttributes.size > 0) {\n                  op.attributes = {};\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value;\n                    }\n                  });\n                }\n                insert = '';\n                break\n              case 'retain':\n                op = { retain };\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {};\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key];\n                  }\n                }\n                retain = 0;\n                break\n            }\n            delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = /** @type {ContentEmbed} */ (item.content).embed;\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      attributes[key] = value;\n                    } else {\n                      delete attributes[key];\n                    }\n                  } else {\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    const doc = transaction.doc;\n    callTypeObservers(this, transaction, event);\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false;\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this);\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot);\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot);\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    }, splitSnapshotAffectedStructs);\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = decoder => new YText();\n\n/**\n * @module YXml\n */\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.create)('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = decoder => new YXmlFragment();\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key]);\n    }\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key]);\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '�';\n      // replace right as well\n      right.str = '�' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.methodUnimplemented)()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n  } else {\n    // Is a map item. Insert as current value\n    left = item;\n    while (left.right !== null) {\n      left = left.right;\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub));\n    }\n    right = null;\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4) > 0) !== isMarked) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5) |\n      (origin === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      if (parent._item !== undefined) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true); // write parentYKey\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false); // write parent id\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parent);\n      } else {\n        (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & lib0_binary_js__WEBPACK_IMPORTED_MODULE_9__.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nconst contentRefs = [\n  () => { (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)(); }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)(); } // 10 - Skip is not ItemContent\n];\n\nconst structSkipRefNumber = 10;\n\n/**\n * @private\n */\nclass Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    (0,lib0_error_js__WEBPACK_IMPORTED_MODULE_8__.unexpectedCase)();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    (0,lib0_encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeVarUint)(encoder.restEncoder, this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\n\n//# sourceMappingURL=yjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS5jb2RlbWlycm9yLy4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanM/NzQyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNLO0FBQ0Q7QUFDWTtBQUM2TDtBQUM3QztBQUNoSztBQUNBO0FBQ3dDO0FBQ1A7QUFDdEM7QUFDTTtBQUNrQjtBQUN4QjtBQUNvQjtBQUNwQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0NBQWdDLDBEQUFVO0FBQzFDO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFVBQVU7QUFDckIsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFB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QSxXQUFXLGtDQUFrQztBQUM3QyxXQUFXLE9BQU87QUFDbEI7QUFDQSw4REFBOEQsaURBQUs7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUyxDQUFDLDZEQUFjLEdBQUcsRUFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLENBQUMsNkRBQWMsR0FBRyxFQUFFO0FBQzdCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDZEQUFjO0FBQ2xCOztBQUVBO0FBQ0EsYUFBYSxrQ0FBa0M7QUFDL0MsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBWTtBQUNoQjs7QUFFQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTgxQztBQUM5MUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWpzL2Rpc3QveWpzLm1qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdsaWIwL29ic2VydmFibGUuanMnO1xuaW1wb3J0IHsgYXBwZW5kVG8sIGZyb20sIGxhc3QgfSBmcm9tICdsaWIwL2FycmF5LmpzJztcbmltcG9ydCB7IGZsb29yLCBtYXgsIG1pbiwgYWJzIH0gZnJvbSAnbGliMC9tYXRoLmpzJztcbmltcG9ydCB7IHNldElmVW5kZWZpbmVkLCBjcmVhdGUsIGFueSwgY29weSB9IGZyb20gJ2xpYjAvbWFwLmpzJztcbmltcG9ydCB7IHdyaXRlVmFyVWludCwgY3JlYXRlRW5jb2RlciwgdG9VaW50OEFycmF5LCB3cml0ZVVpbnQ4LCB3cml0ZVZhclN0cmluZywgd3JpdGVBbnksIHdyaXRlVmFyVWludDhBcnJheSwgSW50RGlmZk9wdFJsZUVuY29kZXIsIFVpbnRPcHRSbGVFbmNvZGVyLCBSbGVFbmNvZGVyLCBTdHJpbmdFbmNvZGVyLCB3cml0ZVVpbnQ4QXJyYXksIHdyaXRlVmFySW50LCB3cml0ZUJpbmFyeUVuY29kZXIgfSBmcm9tICdsaWIwL2VuY29kaW5nLmpzJztcbmltcG9ydCB7IHJlYWRWYXJVaW50LCByZWFkVWludDgsIHJlYWRWYXJTdHJpbmcsIHJlYWRBbnksIHJlYWRWYXJVaW50OEFycmF5LCBJbnREaWZmT3B0UmxlRGVjb2RlciwgVWludE9wdFJsZURlY29kZXIsIFJsZURlY29kZXIsIFN0cmluZ0RlY29kZXIsIGNyZWF0ZURlY29kZXIsIGhhc0NvbnRlbnQsIHJlYWRWYXJJbnQgfSBmcm9tICdsaWIwL2RlY29kaW5nLmpzJztcbmltcG9ydCB7IHV1aWR2NCwgdWludDMyIH0gZnJvbSAnbGliMC9yYW5kb20uanMnO1xuaW1wb3J0IHsgY29weVVpbnQ4QXJyYXkgfSBmcm9tICdsaWIwL2J1ZmZlci5qcyc7XG5pbXBvcnQgeyB1bmV4cGVjdGVkQ2FzZSwgbWV0aG9kVW5pbXBsZW1lbnRlZCwgY3JlYXRlIGFzIGNyZWF0ZSQyIH0gZnJvbSAnbGliMC9lcnJvci5qcyc7XG5pbXBvcnQgeyBCSVRTNSwgQklUOCwgQklUNywgQklUNiwgQklUMiwgQklUNCwgQklUMSwgQklUMyB9IGZyb20gJ2xpYjAvYmluYXJ5LmpzJztcbmltcG9ydCB7IGNhbGxBbGwgfSBmcm9tICdsaWIwL2Z1bmN0aW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZSBhcyBjcmVhdGUkMSB9IGZyb20gJ2xpYjAvc2V0LmpzJztcbmltcG9ydCB7IHByaW50LCBPUkFOR0UsIEJPTEQsIFVOQk9MRCwgUkVEIH0gZnJvbSAnbGliMC9sb2dnaW5nLmpzJztcbmltcG9ydCB7IGdldFVuaXhUaW1lIH0gZnJvbSAnbGliMC90aW1lLmpzJztcbmltcG9ydCB7IGl0ZXJhdG9yRmlsdGVyLCBpdGVyYXRvck1hcCB9IGZyb20gJ2xpYjAvaXRlcmF0b3IuanMnO1xuaW1wb3J0IHsgZXF1YWxGbGF0IH0gZnJvbSAnbGliMC9vYmplY3QuanMnO1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgaW50ZXJmYWNlIHRoYXQgYWxsIENvbm5lY3RvcnMgc2hvdWxkIGltcGxlbWVudCB0byBrZWVwIHRoZW0gaW50ZXJjaGFuZ2VhYmxlLlxuICpcbiAqIEBub3RlIFRoaXMgaW50ZXJmYWNlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXQgaXMgbm90IGFkdmlzZWQgdG8gYWN0dWFsbHkgaW5oZXJpdCB0aGlzIGNsYXNzLlxuICogICAgICAgSXQganVzdCBzZXJ2ZXMgYXMgdHlwaW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlPGFueT59XG4gKi9cbmNsYXNzIEFic3RyYWN0Q29ubmVjdG9yIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geWRvY1xuICAgKiBAcGFyYW0ge2FueX0gYXdhcmVuZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWRvYywgYXdhcmVuZXNzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvYyA9IHlkb2M7XG4gICAgdGhpcy5hd2FyZW5lc3MgPSBhd2FyZW5lc3M7XG4gIH1cbn1cblxuY2xhc3MgRGVsZXRlSXRlbSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNsb2NrLCBsZW4pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9jaztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuICB9XG59XG5cbi8qKlxuICogV2Ugbm8gbG9uZ2VyIG1haW50YWluIGEgRGVsZXRlU3RvcmUuIERlbGV0ZVNldCBpcyBhIHRlbXBvcmFyeSBvYmplY3QgdGhhdCBpcyBjcmVhdGVkIHdoZW4gbmVlZGVkLlxuICogLSBXaGVuIGNyZWF0ZWQgaW4gYSB0cmFuc2FjdGlvbiwgaXQgbXVzdCBvbmx5IGJlIGFjY2Vzc2VkIGFmdGVyIHNvcnRpbmcsIGFuZCBtZXJnaW5nXG4gKiAgIC0gVGhpcyBEZWxldGVTZXQgaXMgc2VuZCB0byBvdGhlciBjbGllbnRzXG4gKiAtIFdlIGRvIG5vdCBjcmVhdGUgYSBEZWxldGVTZXQgd2hlbiB3ZSBzZW5kIGEgc3luYyBtZXNzYWdlLiBUaGUgRGVsZXRlU2V0IG1lc3NhZ2UgaXMgY3JlYXRlZCBkaXJlY3RseSBmcm9tIFN0cnVjdFN0b3JlXG4gKiAtIFdlIHJlYWQgYSBEZWxldGVTZXQgYXMgcGFydCBvZiBhIHN5bmMvdXBkYXRlIG1lc3NhZ2UuIEluIHRoaXMgY2FzZSB0aGUgRGVsZXRlU2V0IGlzIGFscmVhZHkgc29ydGVkIGFuZCBtZXJnZWQuXG4gKi9cbmNsYXNzIERlbGV0ZVNldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixBcnJheTxEZWxldGVJdGVtPj59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpO1xuICB9XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCBzdHJ1Y3RzIHRoYXQgdGhlIERlbGV0ZVNldCBnYydzLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpdGVyYXRlRGVsZXRlZFN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIGRzLCBmKSA9PlxuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZXMsIGNsaWVudGlkKSA9PiB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovICh0cmFuc2FjdGlvbi5kb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50aWQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRlbCA9IGRlbGV0ZXNbaV07XG4gICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RydWN0cywgZGVsLmNsb2NrLCBkZWwubGVuLCBmKTtcbiAgICB9XG4gIH0pO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlSXRlbT59IGRpc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRJbmRleERTID0gKGRpcywgY2xvY2spID0+IHtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSBkaXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWRpbmRleCA9IGZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gICAgY29uc3QgbWlkID0gZGlzW21pZGluZGV4XTtcbiAgICBjb25zdCBtaWRjbG9jayA9IG1pZC5jbG9jaztcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbikge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNEZWxldGVkID0gKGRzLCBpZCkgPT4ge1xuICBjb25zdCBkaXMgPSBkcy5jbGllbnRzLmdldChpZC5jbGllbnQpO1xuICByZXR1cm4gZGlzICE9PSB1bmRlZmluZWQgJiYgZmluZEluZGV4RFMoZGlzLCBpZC5jbG9jaykgIT09IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBzb3J0QW5kTWVyZ2VEZWxldGVTZXQgPSBkcyA9PiB7XG4gIGRzLmNsaWVudHMuZm9yRWFjaChkZWxzID0+IHtcbiAgICBkZWxzLnNvcnQoKGEsIGIpID0+IGEuY2xvY2sgLSBiLmNsb2NrKTtcbiAgICAvLyBtZXJnZSBpdGVtcyB3aXRob3V0IGZpbHRlcmluZyBvciBzcGxpY2luZyB0aGUgYXJyYXlcbiAgICAvLyBpIGlzIHRoZSBjdXJyZW50IHBvaW50ZXJcbiAgICAvLyBqIHJlZmVycyB0byB0aGUgY3VycmVudCBpbnNlcnQgcG9zaXRpb24gZm9yIHRoZSBwb2ludGVkIGl0ZW1cbiAgICAvLyB0cnkgdG8gbWVyZ2UgZGVsc1tpXSBpbnRvIGRlbHNbai0xXSBvciBzZXQgZGVsc1tqXT1kZWxzW2ldXG4gICAgbGV0IGksIGo7XG4gICAgZm9yIChpID0gMSwgaiA9IDE7IGkgPCBkZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gZGVsc1tqIC0gMV07XG4gICAgICBjb25zdCByaWdodCA9IGRlbHNbaV07XG4gICAgICBpZiAobGVmdC5jbG9jayArIGxlZnQubGVuID49IHJpZ2h0LmNsb2NrKSB7XG4gICAgICAgIGxlZnQubGVuID0gbWF4KGxlZnQubGVuLCByaWdodC5jbG9jayArIHJpZ2h0LmxlbiAtIGxlZnQuY2xvY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGogPCBpKSB7XG4gICAgICAgICAgZGVsc1tqXSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgZGVscy5sZW5ndGggPSBqO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVTZXQ+fSBkc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gQSBmcmVzaCBEZWxldGVTZXRcbiAqL1xuY29uc3QgbWVyZ2VEZWxldGVTZXRzID0gZHNzID0+IHtcbiAgY29uc3QgbWVyZ2VkID0gbmV3IERlbGV0ZVNldCgpO1xuICBmb3IgKGxldCBkc3NJID0gMDsgZHNzSSA8IGRzcy5sZW5ndGg7IGRzc0krKykge1xuICAgIGRzc1tkc3NJXS5jbGllbnRzLmZvckVhY2goKGRlbHNMZWZ0LCBjbGllbnQpID0+IHtcbiAgICAgIGlmICghbWVyZ2VkLmNsaWVudHMuaGFzKGNsaWVudCkpIHtcbiAgICAgICAgLy8gV3JpdGUgYWxsIG1pc3Npbmcga2V5cyBmcm9tIGN1cnJlbnQgZHMgYW5kIGFsbCBmb2xsb3dpbmcuXG4gICAgICAgIC8vIElmIG1lcmdlZCBhbHJlYWR5IGNvbnRhaW5zIGBjbGllbnRgIGN1cnJlbnQgZHMgaGFzIGFscmVhZHkgYmVlbiBhZGRlZC5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlbHMgPSBkZWxzTGVmdC5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZHNzSSArIDE7IGkgPCBkc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcHBlbmRUbyhkZWxzLCBkc3NbaV0uY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkLmNsaWVudHMuc2V0KGNsaWVudCwgZGVscyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KG1lcmdlZCk7XG4gIHJldHVybiBtZXJnZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZFRvRGVsZXRlU2V0ID0gKGRzLCBjbGllbnQsIGNsb2NrLCBsZW5ndGgpID0+IHtcbiAgc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiBbXSkucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuZ3RoKSk7XG59O1xuXG5jb25zdCBjcmVhdGVEZWxldGVTZXQgPSAoKSA9PiBuZXcgRGVsZXRlU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gTWVyZ2VkIGFuZCBzb3J0ZWQgRGVsZXRlU2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUgPSBzcyA9PiB7XG4gIGNvbnN0IGRzID0gY3JlYXRlRGVsZXRlU2V0KCk7XG4gIHNzLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzaXRlbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaV07XG4gICAgICBpZiAoc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBzdHJ1Y3QuaWQuY2xvY2s7XG4gICAgICAgIGxldCBsZW4gPSBzdHJ1Y3QubGVuZ3RoO1xuICAgICAgICBpZiAoaSArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IG5leHQgPSBzdHJ1Y3RzW2kgKyAxXTsgaSArIDEgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBuZXh0LmlkLmNsb2NrID09PSBjbG9jayArIGxlbiAmJiBuZXh0LmRlbGV0ZWQ7IG5leHQgPSBzdHJ1Y3RzWysraSArIDFdKSB7XG4gICAgICAgICAgICBsZW4gKz0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRzaXRlbXMucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkc2l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGRzLmNsaWVudHMuc2V0KGNsaWVudCwgZHNpdGVtcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZURlbGV0ZVNldCA9IChlbmNvZGVyLCBkcykgPT4ge1xuICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgZHMuY2xpZW50cy5zaXplKTtcbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkc2l0ZW1zLCBjbGllbnQpID0+IHtcbiAgICBlbmNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KTtcbiAgICBjb25zdCBsZW4gPSBkc2l0ZW1zLmxlbmd0aDtcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgbGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZHNpdGVtc1tpXTtcbiAgICAgIGVuY29kZXIud3JpdGVEc0Nsb2NrKGl0ZW0uY2xvY2spO1xuICAgICAgZW5jb2Rlci53cml0ZURzTGVuKGl0ZW0ubGVuKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWREZWxldGVTZXQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgZHMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGNvbnN0IG51bUNsaWVudHMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICBjb25zdCBjbGllbnQgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBpZiAobnVtYmVyT2ZEZWxldGVzID4gMCkge1xuICAgICAgY29uc3QgZHNGaWVsZCA9IHNldElmVW5kZWZpbmVkKGRzLmNsaWVudHMsIGNsaWVudCwgKCkgPT4gW10pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRlbGV0ZXM7IGkrKykge1xuICAgICAgICBkc0ZpZWxkLnB1c2gobmV3IERlbGV0ZUl0ZW0oZGVjb2Rlci5yZWFkRHNDbG9jaygpLCBkZWNvZGVyLnJlYWREc0xlbigpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkc1xufTtcblxuLyoqXG4gKiBAdG9kbyBZRGVjb2RlciBhbHNvIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gU3RyaW5nIGFuZCBvdGhlciBEZWNvZGVycy4gV291bGQgbWFrZSBzZW5zZSB0byBleGNoYW5nZSBZRGVjb2Rlci50b1VpbnQ4QXJyYXkgZm9yIFlEZWNvZGVyLkRzVG9VaW50OEFycmF5KCkuLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl8bnVsbH0gUmV0dXJucyBhIHYyIHVwZGF0ZSBjb250YWluaW5nIGFsbCBkZWxldGVzIHRoYXQgY291bGRuJ3QgYmUgYXBwbGllZCB5ZXQ7IG9yIG51bGwgaWYgYWxsIGRlbGV0ZXMgd2VyZSBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRBbmRBcHBseURlbGV0ZVNldCA9IChkZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpID0+IHtcbiAgY29uc3QgdW5hcHBsaWVkRFMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGNvbnN0IG51bUNsaWVudHMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICBjb25zdCBjbGllbnQgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsb2NrID0gZGVjb2Rlci5yZWFkRHNDbG9jaygpO1xuICAgICAgY29uc3QgY2xvY2tFbmQgPSBjbG9jayArIGRlY29kZXIucmVhZERzTGVuKCk7XG4gICAgICBpZiAoY2xvY2sgPCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPCBjbG9ja0VuZCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIHN0YXRlLCBjbG9ja0VuZCAtIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBjYW4gaWdub3JlIHRoZSBjYXNlIG9mIEdDIGFuZCBEZWxldGUgc3RydWN0cywgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gc2tpcCB0aGVtXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gICAgICAgIC8vIHNwbGl0IHRoZSBmaXJzdCBpdGVtIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkICYmIHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrKSB7XG4gICAgICAgICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICBpbmRleCsrOyAvLyBpbmNyZWFzZSB3ZSBub3cgd2FudCB0byB1c2UgdGhlIG5leHQgc3RydWN0XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICAgICAgICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGNsb2NrRW5kIDwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4LCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2tFbmQgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJ1Y3QuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIGNsb2NrLCBjbG9ja0VuZCAtIGNsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHVuYXBwbGllZERTLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBkcyA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgICB3cml0ZVZhclVpbnQoZHMucmVzdEVuY29kZXIsIDApOyAvLyBlbmNvZGUgMCBzdHJ1Y3RzXG4gICAgd3JpdGVEZWxldGVTZXQoZHMsIHVuYXBwbGllZERTKTtcbiAgICByZXR1cm4gZHMudG9VaW50OEFycmF5KClcbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAbW9kdWxlIFlcbiAqL1xuXG5jb25zdCBnZW5lcmF0ZU5ld0NsaWVudElkID0gdWludDMyO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvY09wdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuZ2M9dHJ1ZV0gRGlzYWJsZSBnYXJiYWdlIGNvbGxlY3Rpb24gKGRlZmF1bHQ6IGdjPXRydWUpXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IFtEb2NPcHRzLmdjRmlsdGVyXSBXaWxsIGJlIGNhbGxlZCBiZWZvcmUgYW4gSXRlbSBpcyBnYXJiYWdlIGNvbGxlY3RlZC4gUmV0dXJuIGZhbHNlIHRvIGtlZXAgdGhlIEl0ZW0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0RvY09wdHMuZ3VpZF0gRGVmaW5lIGEgZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZG9jdW1lbnRcbiAqIEBwcm9wZXJ0eSB7YW55fSBbRG9jT3B0cy5tZXRhXSBBbnkga2luZCBvZiBtZXRhIGluZm9ybWF0aW9uIHlvdSB3YW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgc3RvcmUgdGhlIG1ldGEgaW5mb3JtYXRpb24gYXMgd2VsbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuYXV0b0xvYWRdIElmIGEgc3ViZG9jdW1lbnQsIGF1dG9tYXRpY2FsbHkgbG9hZCBkb2N1bWVudC4gSWYgdGhpcyBpcyBhIHN1YmRvY3VtZW50LCByZW1vdGUgcGVlcnMgd2lsbCBsb2FkIHRoZSBkb2N1bWVudCBhcyB3ZWxsIGF1dG9tYXRpY2FsbHkuXG4gKi9cblxuLyoqXG4gKiBBIFlqcyBpbnN0YW5jZSBoYW5kbGVzIHRoZSBzdGF0ZSBvZiBzaGFyZWQgZGF0YS5cbiAqIEBleHRlbmRzIE9ic2VydmFibGU8c3RyaW5nPlxuICovXG5jbGFzcyBEb2MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jT3B0c30gW29wdHNdIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh7IGd1aWQgPSB1dWlkdjQoKSwgZ2MgPSB0cnVlLCBnY0ZpbHRlciA9ICgpID0+IHRydWUsIG1ldGEgPSBudWxsLCBhdXRvTG9hZCA9IGZhbHNlIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5nYyA9IGdjO1xuICAgIHRoaXMuZ2NGaWx0ZXIgPSBnY0ZpbHRlcjtcbiAgICB0aGlzLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpO1xuICAgIHRoaXMuZ3VpZCA9IGd1aWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIEFic3RyYWN0VHlwZTxZRXZlbnQ+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXJlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgU3RydWN0U3RvcmUoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb24gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uQ2xlYW51cHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgZG9jdW1lbnQgaXMgYSBzdWJkb2N1bWVudCAtIGEgZG9jdW1lbnQgaW50ZWdyYXRlZCBpbnRvIGFub3RoZXIgZG9jdW1lbnQgLSB0aGVuIF9pdGVtIGlzIGRlZmluZWQuXG4gICAgICogQHR5cGUge0l0ZW0/fVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgIHRoaXMuc2hvdWxkTG9hZCA9IGF1dG9Mb2FkO1xuICAgIHRoaXMuYXV0b0xvYWQgPSBhdXRvTG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB0aGUgcGFyZW50IGRvY3VtZW50IHRoYXQgeW91IHJlcXVlc3QgdG8gbG9hZCBkYXRhIGludG8gdGhpcyBzdWJkb2N1bWVudCAoaWYgaXQgaXMgYSBzdWJkb2N1bWVudCkuXG4gICAqXG4gICAqIGBsb2FkKClgIG1pZ2h0IGJlIHVzZWQgaW4gdGhlIGZ1dHVyZSB0byByZXF1ZXN0IGFueSBwcm92aWRlciB0byBsb2FkIHRoZSBtb3N0IGN1cnJlbnQgZGF0YS5cbiAgICpcbiAgICogSXQgaXMgc2FmZSB0byBjYWxsIGBsb2FkKClgIG11bHRpcGxlIHRpbWVzLlxuICAgKi9cbiAgbG9hZCAoKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW07XG4gICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgIXRoaXMuc2hvdWxkTG9hZCkge1xuICAgICAgdHJhbnNhY3QoLyoqIEB0eXBlIHthbnl9ICovIChpdGVtLnBhcmVudCkuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMpO1xuICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuc2hvdWxkTG9hZCA9IHRydWU7XG4gIH1cblxuICBnZXRTdWJkb2NzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJkb2NzXG4gIH1cblxuICBnZXRTdWJkb2NHdWlkcyAoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbSh0aGlzLnN1YmRvY3MpLm1hcChkb2MgPT4gZG9jLmd1aWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhhdCBoYXBwZW4gaW5zaWRlIG9mIGEgdHJhbnNhY3Rpb24gYXJlIGJ1bmRsZWQuIFRoaXMgbWVhbnMgdGhhdFxuICAgKiB0aGUgb2JzZXJ2ZXIgZmlyZXMgX2FmdGVyXyB0aGUgdHJhbnNhY3Rpb24gaXMgZmluaXNoZWQgYW5kIHRoYXQgYWxsIGNoYW5nZXNcbiAgICogdGhhdCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHRyYW5zYWN0aW9uIGFyZSBzZW50IGFzIG9uZSBtZXNzYWdlIHRvIHRoZVxuICAgKiBvdGhlciBwZWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6dm9pZH0gZiBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge2FueX0gW29yaWdpbl0gT3JpZ2luIG9mIHdobyBzdGFydGVkIHRoZSB0cmFuc2FjdGlvbi4gV2lsbCBiZSBzdG9yZWQgb24gdHJhbnNhY3Rpb24ub3JpZ2luXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRyYW5zYWN0IChmLCBvcmlnaW4gPSBudWxsKSB7XG4gICAgdHJhbnNhY3QodGhpcywgZiwgb3JpZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBzaGFyZWQgZGF0YSB0eXBlLlxuICAgKlxuICAgKiBNdWx0aXBsZSBjYWxscyBvZiBgeS5nZXQobmFtZSwgVHlwZUNvbnN0cnVjdG9yKWAgeWllbGQgdGhlIHNhbWUgcmVzdWx0XG4gICAqIGFuZCBkbyBub3Qgb3ZlcndyaXRlIGVhY2ggb3RoZXIuIEkuZS5cbiAgICogYHkuZGVmaW5lKG5hbWUsIFkuQXJyYXkpID09PSB5LmRlZmluZShuYW1lLCBZLkFycmF5KWBcbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgdHlwZSBpcyBhbHNvIGF2YWlsYWJsZSBvbiBgeS5zaGFyZS5nZXQobmFtZSlgLlxuICAgKlxuICAgKiAqQmVzdCBQcmFjdGljZXM6KlxuICAgKiBEZWZpbmUgYWxsIHR5cGVzIHJpZ2h0IGFmdGVyIHRoZSBZanMgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgc3RvcmUgdGhlbSBpbiBhIHNlcGFyYXRlIG9iamVjdC5cbiAgICogQWxzbyB1c2UgdGhlIHR5cGVkIG1ldGhvZHMgYGdldFRleHQobmFtZSlgLCBgZ2V0QXJyYXkobmFtZSlgLCAuLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbnN0IHkgPSBuZXcgWSguLilcbiAgICogICBjb25zdCBhcHBTdGF0ZSA9IHtcbiAgICogICAgIGRvY3VtZW50OiB5LmdldFRleHQoJ2RvY3VtZW50JylcbiAgICogICAgIGNvbW1lbnRzOiB5LmdldEFycmF5KCdjb21tZW50cycpXG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBUeXBlQ29uc3RydWN0b3IgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB0eXBlIGRlZmluaXRpb24uIEUuZy4gWS5UZXh0LCBZLkFycmF5LCBZLk1hcCwgLi4uXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxhbnk+fSBUaGUgY3JlYXRlZCB0eXBlLiBDb25zdHJ1Y3RlZCB3aXRoIFR5cGVDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgKG5hbWUsIFR5cGVDb25zdHJ1Y3RvciA9IEFic3RyYWN0VHlwZSkge1xuICAgIGNvbnN0IHR5cGUgPSBzZXRJZlVuZGVmaW5lZCh0aGlzLnNoYXJlLCBuYW1lLCAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpO1xuICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgcmV0dXJuIHRcbiAgICB9KTtcbiAgICBjb25zdCBDb25zdHIgPSB0eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlQ29uc3RydWN0b3IgIT09IEFic3RyYWN0VHlwZSAmJiBDb25zdHIgIT09IFR5cGVDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKENvbnN0ciA9PT0gQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKTtcbiAgICAgICAgdC5fbWFwID0gdHlwZS5fbWFwO1xuICAgICAgICB0eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtP30gbiAqLyBuID0+IHtcbiAgICAgICAgICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ubGVmdCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbi5wYXJlbnQgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHQuX3N0YXJ0ID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIGZvciAobGV0IG4gPSB0Ll9zdGFydDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICAgICAgICBuLnBhcmVudCA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdC5fbGVuZ3RoID0gdHlwZS5fbGVuZ3RoO1xuICAgICAgICB0aGlzLnNoYXJlLnNldChuYW1lLCB0KTtcbiAgICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgICByZXR1cm4gdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIHdpdGggdGhlIG5hbWUgJHtuYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgd2l0aCBhIGRpZmZlcmVudCBjb25zdHJ1Y3RvcmApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEFycmF5IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlBcnJheSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRUZXh0IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlUZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WU1hcDxhbnk+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRNYXAgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWU1hcClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0WG1sRnJhZ21lbnQgKG5hbWUgPSAnJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVhtbEZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBlbnRpcmUgZG9jdW1lbnQgaW50byBhIGpzIG9iamVjdCwgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyBlYWNoIHlqcyB0eXBlXG4gICAqIERvZXNuJ3QgbG9nIHR5cGVzIHRoYXQgaGF2ZSBub3QgYmVlbiBkZWZpbmVkICh1c2luZyB5ZG9jLmdldFR5cGUoLi4pKS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBhbmQgcmF0aGVyIGNhbGwgdG9KU09OIGRpcmVjdGx5IG9uIHRoZSBzaGFyZWQgdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IGRvYyA9IHt9O1xuXG4gICAgdGhpcy5zaGFyZS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBkb2Nba2V5XSA9IHZhbHVlLnRvSlNPTigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYGRlc3Ryb3lgIGV2ZW50IGFuZCB1bnJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICovXG4gIGRlc3Ryb3kgKCkge1xuICAgIGZyb20odGhpcy5zdWJkb2NzKS5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbTtcbiAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtDb250ZW50RG9jfSAqLyAoaXRlbS5jb250ZW50KTtcbiAgICAgIGlmIChpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb250ZW50LmRvYyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50LmRvYyA9IG5ldyBEb2MoeyBndWlkOiB0aGlzLmd1aWQsIC4uLmNvbnRlbnQub3B0cyB9KTtcbiAgICAgICAgY29udGVudC5kb2MuX2l0ZW0gPSBpdGVtO1xuICAgICAgfVxuICAgICAgdHJhbnNhY3QoLyoqIEB0eXBlIHthbnl9ICovIChpdGVtKS5wYXJlbnQuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZChjb250ZW50LmRvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuYWRkKHRoaXMpO1xuICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnZGVzdHJveWVkJywgW3RydWVdKTtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55KTphbnl9IGZcbiAgICovXG4gIG9uIChldmVudE5hbWUsIGYpIHtcbiAgICBzdXBlci5vbihldmVudE5hbWUsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb2ZmIChldmVudE5hbWUsIGYpIHtcbiAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBmKTtcbiAgfVxufVxuXG5jbGFzcyBEU0RlY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgdGhpcy5yZXN0RGVjb2RlciA9IGRlY29kZXI7XG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVEZWNvZGVyVjEgZXh0ZW5kcyBEU0RlY29kZXJWMSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRMZWZ0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChyZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkUmlnaHRJRCAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUlEKHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpLCByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBuZXh0IGNsaWVudCBpZC5cbiAgICogVXNlIHRoaXMgaW4gZmF2b3Igb2YgcmVhZElEIHdoZW5ldmVyIHBvc3NpYmxlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIG9iamVjdHMgY3JlYXRlZC5cbiAgICovXG4gIHJlYWRDbGllbnQgKCkge1xuICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkSW5mbyAoKSB7XG4gICAgcmV0dXJuIHJlYWRVaW50OCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRTdHJpbmcgKCkge1xuICAgIHJldHVybiByZWFkVmFyU3RyaW5nKHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gaXNLZXlcbiAgICovXG4gIHJlYWRQYXJlbnRJbmZvICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgPT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZFR5cGVSZWYgKCkge1xuICAgIHJldHVybiByZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gbGVuXG4gICAqL1xuICByZWFkTGVuICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkQW55ICgpIHtcbiAgICByZXR1cm4gcmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICByZWFkQnVmICgpIHtcbiAgICByZXR1cm4gY29weVVpbnQ4QXJyYXkocmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogTGVnYWN5IGltcGxlbWVudGF0aW9uIHVzZXMgSlNPTiBwYXJzZS4gV2UgdXNlIGFueS1kZWNvZGluZyBpbiB2Mi5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgcmV0dXJuIHJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5jbGFzcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gICAgdGhpcy5yZXN0RGVjb2RlciA9IGRlY29kZXI7XG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpO1xuICAgIHJldHVybiB0aGlzLmRzQ3VyclZhbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgY29uc3QgZGlmZiA9IHJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpICsgMTtcbiAgICB0aGlzLmRzQ3VyclZhbCArPSBkaWZmO1xuICAgIHJldHVybiBkaWZmXG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRGVjb2RlclYyIGV4dGVuZHMgRFNEZWNvZGVyVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHN1cGVyKGRlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgY2FjaGVkIGtleXMuIElmIHRoZSBrZXlzW2lkXSBkb2VzIG5vdCBleGlzdCwgd2UgcmVhZCBhIG5ldyBrZXlcbiAgICAgKiBmcm9tIHN0cmluZ0VuY29kZXIgYW5kIHB1c2ggaXQgdG8ga2V5cy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIHJlYWRWYXJVaW50KGRlY29kZXIpOyAvLyByZWFkIGZlYXR1cmUgZmxhZyAtIGN1cnJlbnRseSB1bnVzZWRcbiAgICB0aGlzLmtleUNsb2NrRGVjb2RlciA9IG5ldyBJbnREaWZmT3B0UmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5jbGllbnREZWNvZGVyID0gbmV3IFVpbnRPcHRSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmxlZnRDbG9ja0RlY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMucmlnaHRDbG9ja0RlY29kZXIgPSBuZXcgSW50RGlmZk9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMuaW5mb0RlY29kZXIgPSBuZXcgUmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSwgcmVhZFVpbnQ4KTtcbiAgICB0aGlzLnN0cmluZ0RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5wYXJlbnRJbmZvRGVjb2RlciA9IG5ldyBSbGVEZWNvZGVyKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCByZWFkVWludDgpO1xuICAgIHRoaXMudHlwZVJlZkRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIocmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMubGVuRGVjb2RlciA9IG5ldyBVaW50T3B0UmxlRGVjb2RlcihyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMubGVmdENsb2NrRGVjb2Rlci5yZWFkKCkpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkUmlnaHRJRCAoKSB7XG4gICAgcmV0dXJuIG5ldyBJRCh0aGlzLmNsaWVudERlY29kZXIucmVhZCgpLCB0aGlzLnJpZ2h0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkIHRoZSBuZXh0IGNsaWVudCBpZC5cbiAgICogVXNlIHRoaXMgaW4gZmF2b3Igb2YgcmVhZElEIHdoZW5ldmVyIHBvc3NpYmxlIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIG9iamVjdHMgY3JlYXRlZC5cbiAgICovXG4gIHJlYWRDbGllbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudERlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRJbmZvICgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLmluZm9EZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmdEZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50SW5mb0RlY29kZXIucmVhZCgpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkVHlwZVJlZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZVJlZkRlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkQW55ICgpIHtcbiAgICByZXR1cm4gcmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gICAqL1xuICByZWFkQnVmICgpIHtcbiAgICByZXR1cm4gcmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG1haW5seSBoZXJlIGZvciBsZWdhY3kgcHVycG9zZXMuXG4gICAqXG4gICAqIEluaXRpYWwgd2UgaW5jb2RlZCBvYmplY3RzIHVzaW5nIEpTT04uIE5vdyB3ZSB1c2UgdGhlIG11Y2ggZmFzdGVyIGxpYjAvYW55LWVuY29kZXIuIFRoaXMgbWV0aG9kIG1haW5seSBleGlzdHMgZm9yIGxlZ2FjeSBwdXJwb3NlcyBmb3IgdGhlIHYxIGVuY29kZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRKU09OICgpIHtcbiAgICByZXR1cm4gcmVhZEFueSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRLZXkgKCkge1xuICAgIGNvbnN0IGtleUNsb2NrID0gdGhpcy5rZXlDbG9ja0RlY29kZXIucmVhZCgpO1xuICAgIGlmIChrZXlDbG9jayA8IHRoaXMua2V5cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleXNba2V5Q2xvY2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuc3RyaW5nRGVjb2Rlci5yZWFkKCk7XG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBEU0VuY29kZXJWMSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIHdyaXRlRHNDbG9jayAoY2xvY2spIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlRHNMZW4gKGxlbikge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4pO1xuICB9XG59XG5cbmNsYXNzIFVwZGF0ZUVuY29kZXJWMSBleHRlbmRzIERTRW5jb2RlclYxIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZUxlZnRJRCAoaWQpIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KTtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZVJpZ2h0SUQgKGlkKSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsaWVudCk7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2Ugd3JpdGVDbGllbnQgYW5kIHdyaXRlQ2xvY2sgaW5zdGVhZCBvZiB3cml0ZUlEIGlmIHBvc3NpYmxlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqL1xuICB3cml0ZUNsaWVudCAoY2xpZW50KSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGNsaWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVJbmZvIChpbmZvKSB7XG4gICAgd3JpdGVVaW50OCh0aGlzLnJlc3RFbmNvZGVyLCBpbmZvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgKi9cbiAgd3JpdGVTdHJpbmcgKHMpIHtcbiAgICB3cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICB3cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaXNZS2V5ID8gMSA6IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlVHlwZVJlZiAoaW5mbykge1xuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpbmZvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZUxlbiAobGVuKSB7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGFueVxuICAgKi9cbiAgd3JpdGVBbnkgKGFueSkge1xuICAgIHdyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGFueSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICovXG4gIHdyaXRlQnVmIChidWYpIHtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlciwgYnVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZW1iZWRcbiAgICovXG4gIHdyaXRlSlNPTiAoZW1iZWQpIHtcbiAgICB3cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBKU09OLnN0cmluZ2lmeShlbWJlZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICB3cml0ZVZhclN0cmluZyh0aGlzLnJlc3RFbmNvZGVyLCBrZXkpO1xuICB9XG59XG5cbmNsYXNzIERTRW5jb2RlclYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7IC8vIGVuY29kZXMgYWxsIHRoZSByZXN0IC8gbm9uLW9wdGltaXplZFxuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKVxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGNvbnN0IGRpZmYgPSBjbG9jayAtIHRoaXMuZHNDdXJyVmFsO1xuICAgIHRoaXMuZHNDdXJyVmFsID0gY2xvY2s7XG4gICAgd3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGRpZmYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlRHNMZW4gKGxlbikge1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICAgIHdyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4gLSAxKTtcbiAgICB0aGlzLmRzQ3VyclZhbCArPSBsZW47XG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRW5jb2RlclYyIGV4dGVuZHMgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxudW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFJlZmVycyB0byB0aGUgbmV4dCB1bmlxZSBrZXktaWRlbnRpZmllciB0byBtZSB1c2VkLlxuICAgICAqIFNlZSB3cml0ZUtleSBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMua2V5Q2xvY2sgPSAwO1xuICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyID0gbmV3IEludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyID0gbmV3IFVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyID0gbmV3IEludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2RlciA9IG5ldyBJbnREaWZmT3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMuaW5mb0VuY29kZXIgPSBuZXcgUmxlRW5jb2Rlcih3cml0ZVVpbnQ4KTtcbiAgICB0aGlzLnN0cmluZ0VuY29kZXIgPSBuZXcgU3RyaW5nRW5jb2RlcigpO1xuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIgPSBuZXcgUmxlRW5jb2Rlcih3cml0ZVVpbnQ4KTtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyID0gbmV3IFVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5sZW5FbmNvZGVyID0gbmV3IFVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIDApOyAvLyB0aGlzIGlzIGEgZmVhdHVyZSBmbGFnIHRoYXQgd2UgbWlnaHQgdXNlIGluIHRoZSBmdXR1cmVcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5rZXlDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmNsaWVudEVuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlZnRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KHRoaXMuaW5mb0VuY29kZXIpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5zdHJpbmdFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KHRoaXMucGFyZW50SW5mb0VuY29kZXIpKTtcbiAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy50eXBlUmVmRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgLy8gQG5vdGUgVGhlIHJlc3QgZW5jb2RlciBpcyBhcHBlbmRlZCEgKG5vdGUgdGhlIG1pc3NpbmcgdmFyKVxuICAgIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcikpO1xuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpO1xuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICB0aGlzLmluZm9FbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyLndyaXRlKGlzWUtleSA/IDEgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICB0aGlzLmxlbkVuY29kZXIud3JpdGUobGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgd3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIHdyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgd3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgZW1iZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IGtleXMgYXJlIG9mdGVuIHJldXNlZC4gRm9yIGV4YW1wbGUsIGluIHktcHJvc2VtaXJyb3IgdGhlIGtleSBgYm9sZGAgbWlnaHRcbiAgICogb2NjdXIgdmVyeSBvZnRlbi4gRm9yIGEgM2QgYXBwbGljYXRpb24sIHRoZSBrZXkgYHBvc2l0aW9uYCBtaWdodCBvY2N1ciB2ZXJ5IG9mdGVuLlxuICAgKlxuICAgKiBXZSBjYWNoZSB0aGVzZSBrZXlzIGluIGEgTWFwIGFuZCByZWZlciB0byB0aGVtIHZpYSBhIHVuaXF1ZSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBjb25zdCBjbG9jayA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIGlmIChjbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZSh0aGlzLmtleUNsb2NrKyspO1xuICAgICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyLndyaXRlKHRoaXMua2V5Q2xvY2srKyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7QXJyYXk8R0N8SXRlbT59IHN0cnVjdHMgQWxsIHN0cnVjdHMgYnkgYGNsaWVudGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB3cml0ZSBzdHJ1Y3RzIHN0YXJ0aW5nIHdpdGggYElEKGNsaWVudCxjbG9jaylgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0cyA9IChlbmNvZGVyLCBzdHJ1Y3RzLCBjbGllbnQsIGNsb2NrKSA9PiB7XG4gIC8vIHdyaXRlIGZpcnN0IGlkXG4gIGNsb2NrID0gbWF4KGNsb2NrLCBzdHJ1Y3RzWzBdLmlkLmNsb2NrKTsgLy8gbWFrZSBzdXJlIHRoZSBmaXJzdCBpZCBleGlzdHNcbiAgY29uc3Qgc3RhcnROZXdTdHJ1Y3RzID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spO1xuICAvLyB3cml0ZSAjIGVuY29kZWQgc3RydWN0c1xuICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3RydWN0cy5sZW5ndGggLSBzdGFydE5ld1N0cnVjdHMpO1xuICBlbmNvZGVyLndyaXRlQ2xpZW50KGNsaWVudCk7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIGNvbnN0IGZpcnN0U3RydWN0ID0gc3RydWN0c1tzdGFydE5ld1N0cnVjdHNdO1xuICAvLyB3cml0ZSBmaXJzdCBzdHJ1Y3Qgd2l0aCBhbiBvZmZzZXRcbiAgZmlyc3RTdHJ1Y3Qud3JpdGUoZW5jb2RlciwgY2xvY2sgLSBmaXJzdFN0cnVjdC5pZC5jbG9jayk7XG4gIGZvciAobGV0IGkgPSBzdGFydE5ld1N0cnVjdHMgKyAxOyBpIDwgc3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIHN0cnVjdHNbaV0ud3JpdGUoZW5jb2RlciwgMCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gX3NtXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZUNsaWVudHNTdHJ1Y3RzID0gKGVuY29kZXIsIHN0b3JlLCBfc20pID0+IHtcbiAgLy8gd2UgZmlsdGVyIGFsbCB2YWxpZCBfc20gZW50cmllcyBpbnRvIHNtXG4gIGNvbnN0IHNtID0gbmV3IE1hcCgpO1xuICBfc20uZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIC8vIG9ubHkgd3JpdGUgaWYgbmV3IHN0cnVjdHMgYXJlIGF2YWlsYWJsZVxuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSA+IGNsb2NrKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCBjbG9jayk7XG4gICAgfVxuICB9KTtcbiAgZ2V0U3RhdGVWZWN0b3Ioc3RvcmUpLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICBpZiAoIV9zbS5oYXMoY2xpZW50KSkge1xuICAgICAgc20uc2V0KGNsaWVudCwgMCk7XG4gICAgfVxuICB9KTtcbiAgLy8gd3JpdGUgIyBzdGF0ZXMgdGhhdCB3ZXJlIHVwZGF0ZWRcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNtLnNpemUpO1xuICAvLyBXcml0ZSBpdGVtcyB3aXRoIGhpZ2hlciBjbGllbnQgaWRzIGZpcnN0XG4gIC8vIFRoaXMgaGVhdmlseSBpbXByb3ZlcyB0aGUgY29uZmxpY3QgYWxnb3JpdGhtLlxuICBBcnJheS5mcm9tKHNtLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlswXSAtIGFbMF0pLmZvckVhY2goKFtjbGllbnQsIGNsb2NrXSkgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB3cml0ZVN0cnVjdHMoZW5jb2Rlciwgc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSwgY2xpZW50LCBjbG9jayk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRDbGllbnRzU3RydWN0UmVmcyA9IChkZWNvZGVyLCBkb2MpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAgICovXG4gIGNvbnN0IGNsaWVudFJlZnMgPSBjcmVhdGUoKTtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IHJlZnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZTdHJ1Y3RzKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKTtcbiAgICBsZXQgY2xvY2sgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAvLyBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY2xpZW50UmVmcy5zZXQoY2xpZW50LCB7IGk6IDAsIHJlZnMgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIHN3aXRjaCAoQklUUzUgJiBpbmZvKSB7XG4gICAgICAgIGNhc2UgMDogeyAvLyBHQ1xuICAgICAgICAgIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICAgICAgICAgIHJlZnNbaV0gPSBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxMDogeyAvLyBTa2lwIFN0cnVjdCAobm90aGluZyB0byBhcHBseSlcbiAgICAgICAgICAvLyBAdG9kbyB3ZSBjb3VsZCByZWR1Y2UgdGhlIGFtb3VudCBvZiBjaGVja3MgYnkgYWRkaW5nIFNraXAgc3RydWN0IHRvIGNsaWVudFJlZnMgc28gd2Uga25vdyB0aGF0IHNvbWV0aGluZyBpcyBtaXNzaW5nLlxuICAgICAgICAgIGNvbnN0IGxlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgICAgICAgIHJlZnNbaV0gPSBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKTtcbiAgICAgICAgICBjbG9jayArPSBsZW47XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7IC8vIEl0ZW0gd2l0aCBjb250ZW50XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogVGhlIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBhbnkgdmFyaWFibGVzIGJlY2F1c2UgaW5saW5pbmcgdmFyaWFibGVzIGlzIGZhc3Rlci5cbiAgICAgICAgICAgKiBCZWxvdyBhIG5vbi1vcHRpbWl6ZWQgdmVyc2lvbiBpcyBzaG93biB0aGF0IGltcGxlbWVudHMgdGhlIGJhc2ljIGFsZ29yaXRobSB3aXRoXG4gICAgICAgICAgICogYSBmZXcgY29tbWVudHNcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChCSVQ3IHwgQklUOCkpID09PSAwO1xuICAgICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgKGluZm8gJiBCSVQ4KSA9PT0gQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbCwgLy8gb3JpZ2luXG4gICAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgICAgKGluZm8gJiBCSVQ3KSA9PT0gQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGwsIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvID8gKGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA/IGRvYy5nZXQoZGVjb2Rlci5yZWFkU3RyaW5nKCkpIDogZGVjb2Rlci5yZWFkTGVmdElEKCkpIDogbnVsbCwgLy8gcGFyZW50XG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgKGluZm8gJiBCSVQ2KSA9PT0gQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICAvKiBBIG5vbi1vcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobTpcblxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbFxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICBjb25zdCBoYXNQYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvID8gZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpIDogZmFsc2VcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvICYmIGhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGxcblxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgb3JpZ2luLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICByaWdodE9yaWdpbiwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgIWhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IChwYXJlbnRZS2V5ICE9PSBudWxsID8gZG9jLmdldChwYXJlbnRZS2V5KSA6IG51bGwpLCAvLyBwYXJlbnRcbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgICAqL1xuICAgICAgICAgIHJlZnNbaV0gPSBzdHJ1Y3Q7XG4gICAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgfVxuICByZXR1cm4gY2xpZW50UmVmc1xufTtcblxuLyoqXG4gKiBSZXN1bWUgY29tcHV0aW5nIHN0cnVjdHMgZ2VuZXJhdGVkIGJ5IHN0cnVjdCByZWFkZXJzLlxuICpcbiAqIFdoaWxlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbywgd2UgaW50ZWdyYXRlIHN0cnVjdHMgaW4gdGhpcyBvcmRlclxuICogMS4gdG9wIGVsZW1lbnQgb24gc3RhY2ssIGlmIHN0YWNrIGlzIG5vdCBlbXB0eVxuICogMi4gbmV4dCBlbGVtZW50IGZyb20gY3VycmVudCBzdHJ1Y3QgcmVhZGVyIChpZiBlbXB0eSwgdXNlIG5leHQgc3RydWN0IHJlYWRlcilcbiAqXG4gKiBJZiBzdHJ1Y3QgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHN0cnVjdCAocmVmLm1pc3NpbmcpLCB3ZSBwdXQgbmV4dCByZWFkZXIgb2ZcbiAqIGByZWYuaWQuY2xpZW50YCBvbiB0b3Agb2Ygc3RhY2suXG4gKlxuICogQXQgc29tZSBwb2ludCB3ZSBmaW5kIGEgc3RydWN0IHRoYXQgaGFzIG5vIGNhdXNhbCBkZXBlbmRlbmNpZXMsXG4gKiB0aGVuIHdlIHN0YXJ0IGVtcHR5aW5nIHRoZSBzdGFjay5cbiAqXG4gKiBJdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSBjaXJjbGVzOiBpLmUuIHN0cnVjdDEgKGZyb20gY2xpZW50MSkgZGVwZW5kcyBvbiBzdHJ1Y3QyIChmcm9tIGNsaWVudDIpXG4gKiBkZXBlbmRzIG9uIHN0cnVjdDMgKGZyb20gY2xpZW50MSkuIFRoZXJlZm9yZSB0aGUgbWF4IHN0YWNrIHNpemUgaXMgZXFhdWwgdG8gYHN0cnVjdFJlYWRlcnMubGVuZ3RoYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCBpbiBhIHdheSBzbyB0aGF0IHdlIGNhbiByZXN1bWUgY29tcHV0YXRpb24gaWYgdGhpcyB1cGRhdGVcbiAqIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiAoR0MgfCBJdGVtKVtdIH0+fSBjbGllbnRzU3RydWN0UmVmc1xuICogQHJldHVybiB7IG51bGwgfCB7IHVwZGF0ZTogVWludDhBcnJheSwgbWlzc2luZzogTWFwPG51bWJlcixudW1iZXI+IH0gfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW50ZWdyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGNsaWVudHNTdHJ1Y3RSZWZzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbSB8IEdDPn1cbiAgICovXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIC8vIHNvcnQgdGhlbSBzbyB0aGF0IHdlIHRha2UgdGhlIGhpZ2hlciBpZCBmaXJzdCwgaW4gY2FzZSBvZiBjb25mbGljdHMgdGhlIGxvd2VyIGlkIHdpbGwgcHJvYmFibHkgbm90IGNvbmZsaWN0IHdpdGggdGhlIGlkIGZyb20gdGhlIGhpZ2hlciB1c2VyLlxuICBsZXQgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBBcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBnZXROZXh0U3RydWN0VGFyZ2V0ID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGxldCBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSk7XG4gICAgd2hpbGUgKG5leHRTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoID09PSBuZXh0U3RydWN0c1RhcmdldC5pKSB7XG4gICAgICBjbGllbnRzU3RydWN0UmVmc0lkcy5wb3AoKTtcbiAgICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RydWN0c1RhcmdldFxuICB9O1xuICBsZXQgY3VyU3RydWN0c1RhcmdldCA9IGdldE5leHRTdHJ1Y3RUYXJnZXQoKTtcbiAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwgJiYgc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RydWN0U3RvcmV9XG4gICAqL1xuICBjb25zdCByZXN0U3RydWN0cyA9IG5ldyBTdHJ1Y3RTdG9yZSgpO1xuICBjb25zdCBtaXNzaW5nU1YgPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgY29uc3QgdXBkYXRlTWlzc2luZ1N2ID0gKGNsaWVudCwgY2xvY2spID0+IHtcbiAgICBjb25zdCBtY2xvY2sgPSBtaXNzaW5nU1YuZ2V0KGNsaWVudCk7XG4gICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICBtaXNzaW5nU1Yuc2V0KGNsaWVudCwgY2xvY2spO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEB0eXBlIHtHQ3xJdGVtfVxuICAgKi9cbiAgbGV0IHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoY3VyU3RydWN0c1RhcmdldCkucmVmc1svKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLmkrK107XG4gIC8vIGNhY2hpbmcgdGhlIHN0YXRlIGJlY2F1c2UgaXQgaXMgdXNlZCB2ZXJ5IG9mdGVuXG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0IGFkZFN0YWNrVG9SZXN0U1MgPSAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHN0YWNrKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSBpdGVtLmlkLmNsaWVudDtcbiAgICAgIGNvbnN0IHVuYXBwbGljYWJsZUl0ZW1zID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudCk7XG4gICAgICBpZiAodW5hcHBsaWNhYmxlSXRlbXMpIHtcbiAgICAgICAgLy8gZGVjcmVtZW50IGJlY2F1c2Ugd2Ugd2VyZW4ndCBhYmxlIHRvIGFwcGx5IHByZXZpb3VzIG9wZXJhdGlvblxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pLS07XG4gICAgICAgIHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2V0KGNsaWVudCwgdW5hcHBsaWNhYmxlSXRlbXMucmVmcy5zbGljZSh1bmFwcGxpY2FibGVJdGVtcy5pKSk7XG4gICAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzLmRlbGV0ZShjbGllbnQpO1xuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pID0gMDtcbiAgICAgICAgdW5hcHBsaWNhYmxlSXRlbXMucmVmcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXRlbSB3YXMgdGhlIGxhc3QgaXRlbSBvbiBjbGllbnRzU3RydWN0UmVmcyBhbmQgdGhlIGZpZWxkIHdhcyBhbHJlYWR5IGNsZWFyZWQuIEFkZCBpdGVtIHRvIHJlc3RTdHJ1Y3RzIGFuZCBjb250aW51ZVxuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIFtpdGVtXSk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xpZW50IGZyb20gY2xpZW50c1N0cnVjdFJlZnNJZHMgdG8gcHJldmVudCB1c2VycyBmcm9tIGFwcGx5aW5nIHRoZSBzYW1lIHVwZGF0ZSBhZ2FpblxuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBjbGllbnRzU3RydWN0UmVmc0lkcy5maWx0ZXIoYyA9PiBjICE9PSBjbGllbnQpO1xuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0IHJlYWRlcnMgdW50aWwgd2UgYXJlIGRvbmVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoc3RhY2tIZWFkLmNvbnN0cnVjdG9yICE9PSBTa2lwKSB7XG4gICAgICBjb25zdCBsb2NhbENsb2NrID0gc2V0SWZVbmRlZmluZWQoc3RhdGUsIHN0YWNrSGVhZC5pZC5jbGllbnQsICgpID0+IGdldFN0YXRlKHN0b3JlLCBzdGFja0hlYWQuaWQuY2xpZW50KSk7XG4gICAgICBjb25zdCBvZmZzZXQgPSBsb2NhbENsb2NrIC0gc3RhY2tIZWFkLmlkLmNsb2NrO1xuICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgLy8gdXBkYXRlIGZyb20gdGhlIHNhbWUgY2xpZW50IGlzIG1pc3NpbmdcbiAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgICB1cGRhdGVNaXNzaW5nU3Yoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrIC0gMSk7XG4gICAgICAgIC8vIGhpZCBhIGRlYWQgd2FsbCwgYWRkIGFsbCBpdGVtcyBmcm9tIHN0YWNrIHRvIHJlc3RTU1xuICAgICAgICBhZGRTdGFja1RvUmVzdFNTKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gc3RhY2tIZWFkLmdldE1pc3NpbmcodHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICAgICAgaWYgKG1pc3NpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrSGVhZCk7XG4gICAgICAgICAgLy8gZ2V0IHRoZSBzdHJ1Y3QgcmVhZGVyIHRoYXQgaGFzIHRoZSBtaXNzaW5nIHN0cnVjdFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHt7IHJlZnM6IEFycmF5PEdDfEl0ZW0+LCBpOiBudW1iZXIgfX1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBzdHJ1Y3RSZWZzID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZykpIHx8IHsgcmVmczogW10sIGk6IDAgfTtcbiAgICAgICAgICBpZiAoc3RydWN0UmVmcy5yZWZzLmxlbmd0aCA9PT0gc3RydWN0UmVmcy5pKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBtZXNzYWdlIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUgbWVzc2FnZSB0aGF0IGRvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICAgICAgICB1cGRhdGVNaXNzaW5nU3YoLyoqIEB0eXBlIHtudW1iZXJ9ICovIChtaXNzaW5nKSwgZ2V0U3RhdGUoc3RvcmUsIG1pc3NpbmcpKTtcbiAgICAgICAgICAgIGFkZFN0YWNrVG9SZXN0U1MoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhY2tIZWFkID0gc3RydWN0UmVmcy5yZWZzW3N0cnVjdFJlZnMuaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9mZnNldCA9PT0gMCB8fCBvZmZzZXQgPCBzdGFja0hlYWQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gYWxsIGZpbmUsIGFwcGx5IHRoZSBzdGFja2hlYWRcbiAgICAgICAgICBzdGFja0hlYWQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCBvZmZzZXQpO1xuICAgICAgICAgIHN0YXRlLnNldChzdGFja0hlYWQuaWQuY2xpZW50LCBzdGFja0hlYWQuaWQuY2xvY2sgKyBzdGFja0hlYWQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpdGVyYXRlIHRvIG5leHQgc3RhY2tIZWFkXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKHN0YWNrLnBvcCgpKTtcbiAgICB9IGVsc2UgaWYgKGN1clN0cnVjdHNUYXJnZXQgIT09IG51bGwgJiYgY3VyU3RydWN0c1RhcmdldC5pIDwgY3VyU3RydWN0c1RhcmdldC5yZWZzLmxlbmd0aCkge1xuICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoY3VyU3RydWN0c1RhcmdldC5yZWZzW2N1clN0cnVjdHNUYXJnZXQuaSsrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1clN0cnVjdHNUYXJnZXQgPSBnZXROZXh0U3RydWN0VGFyZ2V0KCk7XG4gICAgICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAvLyB3ZSBhcmUgZG9uZSFcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVzdFN0cnVjdHMuY2xpZW50cy5zaXplID4gMCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCByZXN0U3RydWN0cywgbmV3IE1hcCgpKTtcbiAgICAvLyB3cml0ZSBlbXB0eSBkZWxldGVzZXRcbiAgICAvLyB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBuZXcgRGVsZXRlU2V0KCkpXG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApOyAvLyA9PiBubyBuZWVkIGZvciBhbiBleHRyYSBmdW5jdGlvbiBjYWxsLCBqdXN0IHdyaXRlIDAgZGVsZXRlc1xuICAgIHJldHVybiB7IG1pc3Npbmc6IG1pc3NpbmdTViwgdXBkYXRlOiBlbmNvZGVyLnRvVWludDhBcnJheSgpIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbiA9IChlbmNvZGVyLCB0cmFuc2FjdGlvbikgPT4gd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCB0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlKTtcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhbiBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IFtzdHJ1Y3REZWNvZGVyXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkVXBkYXRlVjIgPSAoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIHN0cnVjdERlY29kZXIgPSBuZXcgVXBkYXRlRGVjb2RlclYyKGRlY29kZXIpKSA9PlxuICB0cmFuc2FjdCh5ZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHJldHJ5ID0gZmFsc2U7XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgIC8vIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3Qgc3MgPSByZWFkQ2xpZW50c1N0cnVjdFJlZnMoc3RydWN0RGVjb2RlciwgZG9jKTtcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkIHN0cnVjdHM6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBtZXJnZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHJlc3RTdHJ1Y3RzID0gaW50ZWdyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RvcmUsIHNzKTtcbiAgICBjb25zdCBwZW5kaW5nID0gc3RvcmUucGVuZGluZ1N0cnVjdHM7XG4gICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBhcHBseSBzb21ldGhpbmdcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHBlbmRpbmcubWlzc2luZykge1xuICAgICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICAgIHJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdFN0cnVjdHMpIHtcbiAgICAgICAgLy8gbWVyZ2UgcmVzdFN0cnVjdHMgaW50byBzdG9yZS5wZW5kaW5nXG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHJlc3RTdHJ1Y3RzLm1pc3NpbmcpIHtcbiAgICAgICAgICBjb25zdCBtY2xvY2sgPSBwZW5kaW5nLm1pc3NpbmcuZ2V0KGNsaWVudCk7XG4gICAgICAgICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICAgICAgICBwZW5kaW5nLm1pc3Npbmcuc2V0KGNsaWVudCwgY2xvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nLnVwZGF0ZSA9IG1lcmdlVXBkYXRlc1YyKFtwZW5kaW5nLnVwZGF0ZSwgcmVzdFN0cnVjdHMudXBkYXRlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gcmVzdFN0cnVjdHM7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGludGVncmF0ZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGRzUmVzdCA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChzdHJ1Y3REZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICAgIGlmIChzdG9yZS5wZW5kaW5nRHMpIHtcbiAgICAgIC8vIEB0b2RvIHdlIGNvdWxkIG1ha2UgYSBsb3dlci1ib3VuZCBzdGF0ZS12ZWN0b3IgY2hlY2sgYXMgd2UgZG8gYWJvdmVcbiAgICAgIGNvbnN0IHBlbmRpbmdEU1VwZGF0ZSA9IG5ldyBVcGRhdGVEZWNvZGVyVjIoY3JlYXRlRGVjb2RlcihzdG9yZS5wZW5kaW5nRHMpKTtcbiAgICAgIHJlYWRWYXJVaW50KHBlbmRpbmdEU1VwZGF0ZS5yZXN0RGVjb2Rlcik7IC8vIHJlYWQgMCBzdHJ1Y3RzLCBiZWNhdXNlIHdlIG9ubHkgZW5jb2RlIGRlbGV0ZXMgaW4gcGVuZGluZ2RzdXBkYXRlXG4gICAgICBjb25zdCBkc1Jlc3QyID0gcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHBlbmRpbmdEU1VwZGF0ZSwgdHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICAgIGlmIChkc1Jlc3QgJiYgZHNSZXN0Mikge1xuICAgICAgICAvLyBjYXNlIDE6IGRzMSAhPSBudWxsICYmIGRzMiAhPSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IG1lcmdlVXBkYXRlc1YyKFtkc1Jlc3QsIGRzUmVzdDJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgMjogZHMxICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSAzOiBkczIgIT0gbnVsbFxuICAgICAgICAvLyBjYXNlIDQ6IGRzMSA9PSBudWxsICYmIGRzMiA9PSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdCB8fCBkc1Jlc3QyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFaXRoZXIgZHNSZXN0ID09IG51bGwgJiYgcGVuZGluZ0RzID09IG51bGwgT1IgZHNSZXN0ICE9IG51bGxcbiAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdDtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gY2xlYW51cDogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVzdW1lIGRlbGV0ZSByZWFkZXJzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSAvKiogQHR5cGUge3t1cGRhdGU6IFVpbnQ4QXJyYXl9fSAqLyAoc3RvcmUucGVuZGluZ1N0cnVjdHMpLnVwZGF0ZTtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gbnVsbDtcbiAgICAgIGFwcGx5VXBkYXRlVjIodHJhbnNhY3Rpb24uZG9jLCB1cGRhdGUpO1xuICAgIH1cbiAgfSwgdHJhbnNhY3Rpb25PcmlnaW4sIGZhbHNlKTtcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhbiBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkVXBkYXRlID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBVcGRhdGVEZWNvZGVyVjEoZGVjb2RlcikpO1xuXG4vKipcbiAqIEFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlIGNyZWF0ZWQgYnksIGZvciBleGFtcGxlLCBgeS5vbigndXBkYXRlJywgdXBkYXRlID0+IC4uKWAgb3IgYHVwZGF0ZSA9IGVuY29kZVN0YXRlQXNVcGRhdGUoKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGByZWFkVXBkYXRlYCBidXQgYWNjZXB0cyBhbiBVaW50OEFycmF5IGluc3RlYWQgb2YgYSBEZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFwcGx5VXBkYXRlVjIgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZURlY29kZXIodXBkYXRlKTtcbiAgcmVhZFVwZGF0ZVYyKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBuZXcgWURlY29kZXIoZGVjb2RlcikpO1xufTtcblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhcHBseVVwZGF0ZSA9ICh5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiBhcHBseVVwZGF0ZVYyKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4sIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZS4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVWZWN0b3JgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBbdGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdGF0ZUFzVXBkYXRlID0gKGVuY29kZXIsIGRvYywgdGFyZ2V0U3RhdGVWZWN0b3IgPSBuZXcgTWFwKCkpID0+IHtcbiAgd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCBkb2Muc3RvcmUsIHRhcmdldFN0YXRlVmVjdG9yKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSkpO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlIHRoYXQgY2FuIGJlIGFwcGxpZWQgb24gdGhlIHJlbW90ZSBkb2N1bWVudC4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogVXNlIGB3cml0ZVN0YXRlQXNVcGRhdGVgIGluc3RlYWQgaWYgeW91IGFyZSB3b3JraW5nIHdpdGggbGliMC9lbmNvZGluZy5qcyNFbmNvZGVyXG4gKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IgPSBuZXcgVWludDhBcnJheShbMF0pLCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpKSA9PiB7XG4gIGNvbnN0IHRhcmdldFN0YXRlVmVjdG9yID0gZGVjb2RlU3RhdGVWZWN0b3IoZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKTtcbiAgd3JpdGVTdGF0ZUFzVXBkYXRlKGVuY29kZXIsIGRvYywgdGFyZ2V0U3RhdGVWZWN0b3IpO1xuICBjb25zdCB1cGRhdGVzID0gW2VuY29kZXIudG9VaW50OEFycmF5KCldO1xuICAvLyBhbHNvIGFkZCB0aGUgcGVuZGluZyB1cGRhdGVzIChpZiB0aGVyZSBhcmUgYW55KVxuICAvLyBAdG9kbyBzdXBwb3J0IGRpZmZpcmVudCBlbmNvZGVyc1xuICBpZiAoZW5jb2Rlci5jb25zdHJ1Y3RvciA9PT0gVXBkYXRlRW5jb2RlclYyKSB7XG4gICAgaWYgKGRvYy5zdG9yZS5wZW5kaW5nRHMpIHtcbiAgICAgIHVwZGF0ZXMucHVzaChkb2Muc3RvcmUucGVuZGluZ0RzKTtcbiAgICB9XG4gICAgaWYgKGRvYy5zdG9yZS5wZW5kaW5nU3RydWN0cykge1xuICAgICAgdXBkYXRlcy5wdXNoKGRpZmZVcGRhdGVWMihkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMudXBkYXRlLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMpXG4gICAgfVxuICB9XG4gIHJldHVybiB1cGRhdGVzWzBdXG59O1xuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgYXBwbGllZCBvbiB0aGUgcmVtb3RlIGRvY3VtZW50LiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZWApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBVc2UgYHdyaXRlU3RhdGVBc1VwZGF0ZWAgaW5zdGVhZCBpZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBsaWIwL2VuY29kaW5nLmpzI0VuY29kZXJcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGUgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpID0+IGVuY29kZVN0YXRlQXNVcGRhdGVWMihkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciwgbmV3IFVwZGF0ZUVuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBSZWFkIHN0YXRlIHZlY3RvciBmcm9tIERlY29kZXIgYW5kIHJldHVybiBhcyBNYXBcbiAqXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkU3RhdGVWZWN0b3IgPSBkZWNvZGVyID0+IHtcbiAgY29uc3Qgc3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHNzTGVuZ3RoID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3NMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNsaWVudCA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IGNsb2NrID0gcmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgc3Muc2V0KGNsaWVudCwgY2xvY2spO1xuICB9XG4gIHJldHVybiBzc1xufTtcblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbi8vIGV4cG9ydCBjb25zdCBkZWNvZGVTdGF0ZVZlY3RvclYyID0gZGVjb2RlZFN0YXRlID0+IHJlYWRTdGF0ZVZlY3RvcihuZXcgRFNEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihkZWNvZGVkU3RhdGUpKSlcblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGRlY29kZVN0YXRlVmVjdG9yID0gZGVjb2RlZFN0YXRlID0+IHJlYWRTdGF0ZVZlY3RvcihuZXcgRFNEZWNvZGVyVjEoY3JlYXRlRGVjb2RlcihkZWNvZGVkU3RhdGUpKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc3ZcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0YXRlVmVjdG9yID0gKGVuY29kZXIsIHN2KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzdi5zaXplKTtcbiAgc3YuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpOyAvLyBAdG9kbyB1c2UgYSBzcGVjaWFsIGNsaWVudCBkZWNvZGVyIHRoYXQgaXMgYmFzZWQgb24gbWFwcGluZ1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIH0pO1xuICByZXR1cm4gZW5jb2RlclxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yID0gKGVuY29kZXIsIGRvYykgPT4gd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yVjIgPSAoZG9jLCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKTtcbiAgfVxuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3IgPSBkb2MgPT4gZW5jb2RlU3RhdGVWZWN0b3JWMihkb2MsIG5ldyBEU0VuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBHZW5lcmFsIGV2ZW50IGhhbmRsZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsIEFSRzFcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKEFSRzAsIEFSRzEpOnZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMubCA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHJldHVybnMge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlRXZlbnRIYW5kbGVyID0gKCkgPT4gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlblxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNjYWxsRXZlbnRMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIgPSAoZXZlbnRIYW5kbGVyLCBmKSA9PlxuICBldmVudEhhbmRsZXIubC5wdXNoKGYpO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IHdhcyBhZGRlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT4ge1xuICBjb25zdCBsID0gZXZlbnRIYW5kbGVyLmw7XG4gIGNvbnN0IGxlbiA9IGwubGVuZ3RoO1xuICBldmVudEhhbmRsZXIubCA9IGwuZmlsdGVyKGcgPT4gZiAhPT0gZyk7XG4gIGlmIChsZW4gPT09IGV2ZW50SGFuZGxlci5sLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t5anNdIFRyaWVkIHRvIHJlbW92ZSBldmVudCBoYW5kbGVyIHRoYXQgZG9lc25cXCd0IGV4aXN0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYWxsIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdmlhXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtBUkcwfSBhcmcwXG4gKiBAcGFyYW0ge0FSRzF9IGFyZzFcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSAoZXZlbnRIYW5kbGVyLCBhcmcwLCBhcmcxKSA9PlxuICBjYWxsQWxsKGV2ZW50SGFuZGxlci5sLCBbYXJnMCwgYXJnMV0pO1xuXG5jbGFzcyBJRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50IGNsaWVudCBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBjbG9jaykge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqXG4gICAgICogdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYVxuICogQHBhcmFtIHtJRCB8IG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVJRHMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuY2xpZW50ID09PSBiLmNsaWVudCAmJiBhLmNsb2NrID09PSBiLmNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUlEID0gKGNsaWVudCwgY2xvY2spID0+IG5ldyBJRChjbGllbnQsIGNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZUlEID0gKGVuY29kZXIsIGlkKSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbGllbnQpO1xuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgaWQuY2xvY2spO1xufTtcblxuLyoqXG4gKiBSZWFkIElELlxuICogKiBJZiBmaXJzdCB2YXJVaW50IHJlYWQgaXMgMHhGRkZGRkYgYSBSb290SUQgaXMgcmV0dXJuZWQuXG4gKiAqIE90aGVyd2lzZSBhbiBJRCBpcyByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7SUR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkSUQgPSBkZWNvZGVyID0+XG4gIGNyZWF0ZUlEKHJlYWRWYXJVaW50KGRlY29kZXIpLCByZWFkVmFyVWludChkZWNvZGVyKSk7XG5cbi8qKlxuICogVGhlIHRvcCB0eXBlcyBhcmUgbWFwcGVkIGZyb20geS5zaGFyZS5nZXQoa2V5bmFtZSkgPT4gdHlwZS5cbiAqIGB0eXBlYCBkb2VzIG5vdCBzdG9yZSBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGBrZXluYW1lYC5cbiAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGNvcnJlY3QgYGtleW5hbWVgIGZvciBgdHlwZWAgYW5kIHRocm93cyBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFJvb3RUeXBlS2V5ID0gdHlwZSA9PiB7XG4gIC8vIEB0cy1pZ25vcmUgX3kgbXVzdCBiZSBkZWZpbmVkLCBvdGhlcndpc2UgdW5leHBlY3RlZCBjYXNlXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHR5cGUuZG9jLnNoYXJlLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHlwZSkge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxuICB0aHJvdyB1bmV4cGVjdGVkQ2FzZSgpXG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gY2hpbGRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzUGFyZW50T2YgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNoaWxkID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLnBhcmVudCkuX2l0ZW07XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vKipcbiAqIENvbnZlbmllbnQgaGVscGVyIHRvIGxvZyB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqIERvIG5vdCB1c2UgaW4gcHJvZHVjdGl2ZSBzeXN0ZW1zIGFzIHRoZSBvdXRwdXQgY2FuIGJlIGltbWVuc2UhXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICovXG5jb25zdCBsb2dUeXBlID0gdHlwZSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobikge1xuICAgIHJlcy5wdXNoKG4pO1xuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGNvbnNvbGUubG9nKCdDaGlsZHJlbjogJywgcmVzKTtcbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuIGNvbnRlbnQ6ICcsIHJlcy5maWx0ZXIobSA9PiAhbS5kZWxldGVkKS5tYXAobSA9PiBtLmNvbnRlbnQpKTtcbn07XG5cbmNsYXNzIFBlcm1hbmVudFVzZXJEYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtZTWFwPGFueT59IFtzdG9yZVR5cGVdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBzdG9yZVR5cGUgPSBkb2MuZ2V0TWFwKCd1c2VycycpKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsRGVsZXRlU2V0Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkc3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy55dXNlcnMgPSBzdG9yZVR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudGlkIHRvIHVzZXJEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kc3MgPSBkc3M7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZTWFwPGFueT59IHVzZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgY29uc3QgaW5pdFVzZXIgPSAodXNlciwgdXNlckRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtZQXJyYXk8VWludDhBcnJheT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRzID0gdXNlci5nZXQoJ2RzJyk7XG4gICAgICBjb25zdCBpZHMgPSB1c2VyLmdldCgnaWRzJyk7XG4gICAgICBjb25zdCBhZGRDbGllbnRJZCA9IC8qKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWQgKi8gY2xpZW50aWQgPT4gdGhpcy5jbGllbnRzLnNldChjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uKTtcbiAgICAgIGRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGVuY29kZWREcyA9PiB7XG4gICAgICAgICAgICBpZiAoZW5jb2RlZERzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICB0aGlzLmRzcy5zZXQodXNlckRlc2NyaXB0aW9uLCBtZXJnZURlbGV0ZVNldHMoW3RoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pIHx8IGNyZWF0ZURlbGV0ZVNldCgpLCByZWFkRGVsZXRlU2V0KG5ldyBEU0RlY29kZXJWMShjcmVhdGVEZWNvZGVyKGVuY29kZWREcykpKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhkcy5tYXAoZW5jb2RlZERzID0+IHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpKSkpO1xuICAgICAgaWRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT5cbiAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGFkZENsaWVudElkKSlcbiAgICAgICk7XG4gICAgICBpZHMuZm9yRWFjaChhZGRDbGllbnRJZCk7XG4gICAgfTtcbiAgICAvLyBvYnNlcnZlIHVzZXJzXG4gICAgc3RvcmVUeXBlLm9ic2VydmUoZXZlbnQgPT4ge1xuICAgICAgZXZlbnQua2V5c0NoYW5nZWQuZm9yRWFjaCh1c2VyRGVzY3JpcHRpb24gPT5cbiAgICAgICAgaW5pdFVzZXIoc3RvcmVUeXBlLmdldCh1c2VyRGVzY3JpcHRpb24pLCB1c2VyRGVzY3JpcHRpb24pXG4gICAgICApO1xuICAgIH0pO1xuICAgIC8vIGFkZCBpbnRpYWwgZGF0YVxuICAgIHN0b3JlVHlwZS5mb3JFYWNoKGluaXRVc2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZl1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRGVsZXRlU2V0KTpib29sZWFufSBbY29uZi5maWx0ZXJdXG4gICAqL1xuICBzZXRVc2VyTWFwcGluZyAoZG9jLCBjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uLCB7IGZpbHRlciA9ICgpID0+IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgdXNlcnMgPSB0aGlzLnl1c2VycztcbiAgICBsZXQgdXNlciA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgIGlmICghdXNlcikge1xuICAgICAgdXNlciA9IG5ldyBZTWFwKCk7XG4gICAgICB1c2VyLnNldCgnaWRzJywgbmV3IFlBcnJheSgpKTtcbiAgICAgIHVzZXIuc2V0KCdkcycsIG5ldyBZQXJyYXkoKSk7XG4gICAgICB1c2Vycy5zZXQodXNlckRlc2NyaXB0aW9uLCB1c2VyKTtcbiAgICB9XG4gICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSk7XG4gICAgdXNlcnMub2JzZXJ2ZShldmVudCA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXNlck92ZXJ3cml0ZSA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAodXNlck92ZXJ3cml0ZSAhPT0gdXNlcikge1xuICAgICAgICAgIC8vIHVzZXIgd2FzIG92ZXJ3cml0dGVuLCBwb3J0IGFsbCBkYXRhIG92ZXIgdG8gdGhlIG5leHQgdXNlciBvYmplY3RcbiAgICAgICAgICAvLyBAdG9kbyBFeHBlcmltZW50IHdpdGggWS5TZXRzIGhlcmVcbiAgICAgICAgICB1c2VyID0gdXNlck92ZXJ3cml0ZTtcbiAgICAgICAgICAvLyBAdG9kbyBpdGVyYXRlIG92ZXIgb2xkIHR5cGVcbiAgICAgICAgICB0aGlzLmNsaWVudHMuZm9yRWFjaCgoX3VzZXJEZXNjcmlwdGlvbiwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgICAgIGlmICh1c2VyRGVzY3JpcHRpb24gPT09IF91c2VyRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMSgpO1xuICAgICAgICAgIGNvbnN0IGRzID0gdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbik7XG4gICAgICAgICAgaWYgKGRzKSB7XG4gICAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gICAgICAgICAgICB1c2VyLmdldCgnZHMnKS5wdXNoKFtlbmNvZGVyLnRvVWludDhBcnJheSgpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgICBkb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCAvKiogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gKi8gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHlkcyA9IHVzZXIuZ2V0KCdkcycpO1xuICAgICAgICBjb25zdCBkcyA9IHRyYW5zYWN0aW9uLmRlbGV0ZVNldDtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmxvY2FsICYmIGRzLmNsaWVudHMuc2l6ZSA+IDAgJiYgZmlsdGVyKHRyYW5zYWN0aW9uLCBkcykpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKCk7XG4gICAgICAgICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICAgICAgICAgIHlkcy5wdXNoKFtlbmNvZGVyLnRvVWludDhBcnJheSgpXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBnZXRVc2VyQnlDbGllbnRJZCAoY2xpZW50aWQpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRzLmdldChjbGllbnRpZCkgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqIEByZXR1cm4ge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBnZXRVc2VyQnlEZWxldGVkSWQgKGlkKSB7XG4gICAgZm9yIChjb25zdCBbdXNlckRlc2NyaXB0aW9uLCBkc10gb2YgdGhpcy5kc3MuZW50cmllcygpKSB7XG4gICAgICBpZiAoaXNEZWxldGVkKGRzLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJEZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBiYXNlZCBvbiB0aGUgWWpzIG1vZGVsIGFuZCBpcyBub3QgYWZmZWN0ZWQgYnkgZG9jdW1lbnQgY2hhbmdlcy5cbiAqIEUuZy4gSWYgeW91IHBsYWNlIGEgcmVsYXRpdmUgcG9zaXRpb24gYmVmb3JlIGEgY2VydGFpbiBjaGFyYWN0ZXIsIGl0IHdpbGwgYWx3YXlzIHBvaW50IHRvIHRoaXMgY2hhcmFjdGVyLlxuICogSWYgeW91IHBsYWNlIGEgcmVsYXRpdmUgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiBhIHR5cGUsIGl0IHdpbGwgYWx3YXlzIHBvaW50IHRvIHRoZSBlbmQgb2YgdGhlIHR5cGUuXG4gKlxuICogQSBudW1lcmljIHBvc2l0aW9uIGlzIG9mdGVuIHVuc3VpdGVkIGZvciB1c2VyIHNlbGVjdGlvbnMsIGJlY2F1c2UgaXQgZG9lcyBub3QgY2hhbmdlIHdoZW4gY29udGVudCBpcyBpbnNlcnRlZFxuICogYmVmb3JlIG9yIGFmdGVyLlxuICpcbiAqIGBgYEluc2VydCgwLCAneCcpKCdhfGJjJykgPSAneGF8YmMnYGBgIFdoZXJlIHwgaXMgdGhlIHJlbGF0aXZlIHBvc2l0aW9uLlxuICpcbiAqIE9uZSBvZiB0aGUgcHJvcGVydGllcyBtdXN0IGJlIGRlZmluZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gQ3VycmVudCBjdXJzb3IgcG9zaXRpb24gaXMgYXQgcG9zaXRpb24gMTBcbiAqICAgY29uc3QgcmVsYXRpdmVQb3NpdGlvbiA9IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSW5kZXgoeVRleHQsIDEwKVxuICogICAvLyBtb2RpZnkgeVRleHRcbiAqICAgeVRleHQuaW5zZXJ0KDAsICdhYmMnKVxuICogICB5VGV4dC5kZWxldGUoMywgMTApXG4gKiAgIC8vIENvbXB1dGUgdGhlIGN1cnNvciBwb3NpdGlvblxuICogICBjb25zdCBhYnNvbHV0ZVBvc2l0aW9uID0gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKHksIHJlbGF0aXZlUG9zaXRpb24pXG4gKiAgIGFic29sdXRlUG9zaXRpb24udHlwZSA9PT0geVRleHQgLy8gPT4gdHJ1ZVxuICogICBjb25zb2xlLmxvZygnY3Vyc29yIGxvY2F0aW9uIGlzICcgKyBhYnNvbHV0ZVBvc2l0aW9uLmluZGV4KSAvLyA9PiBjdXJzb3IgbG9jYXRpb24gaXMgM1xuICpcbiAqL1xuY2xhc3MgUmVsYXRpdmVQb3NpdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfG51bGx9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdG5hbWVcbiAgICogQHBhcmFtIHtJRHxudWxsfSBpdGVtXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhc3NvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUsIHRuYW1lLCBpdGVtLCBhc3NvYyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SUR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnRuYW1lID0gdG5hbWU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLml0ZW0gPSBpdGVtO1xuICAgIC8qKlxuICAgICAqIEEgcmVsYXRpdmUgcG9zaXRpb24gaXMgYXNzb2NpYXRlZCB0byBhIHNwZWNpZmljIGNoYXJhY3Rlci4gQnkgZGVmYXVsdFxuICAgICAqIGFzc29jID49IDAsIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjaGFyYWN0ZXJcbiAgICAgKiBhZnRlciB0aGUgbWVhbnQgcG9zaXRpb24uXG4gICAgICogSS5lLiBwb3NpdGlvbiAxIGluICdhYicgaXMgYXNzb2NpYXRlZCB0byBjaGFyYWN0ZXIgJ2InLlxuICAgICAqXG4gICAgICogSWYgYXNzb2MgPCAwLCB0aGVuIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjYWhhcmFjdGVyXG4gICAgICogYmVmb3JlIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5hc3NvYyA9IGFzc29jO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmNvbnN0IHJlbGF0aXZlUG9zaXRpb25Ub0pTT04gPSBycG9zID0+IHtcbiAgY29uc3QganNvbiA9IHt9O1xuICBpZiAocnBvcy50eXBlKSB7XG4gICAganNvbi50eXBlID0gcnBvcy50eXBlO1xuICB9XG4gIGlmIChycG9zLnRuYW1lKSB7XG4gICAganNvbi50bmFtZSA9IHJwb3MudG5hbWU7XG4gIH1cbiAgaWYgKHJwb3MuaXRlbSkge1xuICAgIGpzb24uaXRlbSA9IHJwb3MuaXRlbTtcbiAgfVxuICBpZiAocnBvcy5hc3NvYyAhPSBudWxsKSB7XG4gICAganNvbi5hc3NvYyA9IHJwb3MuYXNzb2M7XG4gIH1cbiAgcmV0dXJuIGpzb25cbn07XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGpzb25cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiA9IGpzb24gPT4gbmV3IFJlbGF0aXZlUG9zaXRpb24oanNvbi50eXBlID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi50eXBlLmNsaWVudCwganNvbi50eXBlLmNsb2NrKSwganNvbi50bmFtZSB8fCBudWxsLCBqc29uLml0ZW0gPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLml0ZW0uY2xpZW50LCBqc29uLml0ZW0uY2xvY2spLCBqc29uLmFzc29jID09IG51bGwgPyAwIDoganNvbi5hc3NvYyk7XG5cbmNsYXNzIEFic29sdXRlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5hc3NvYyA9IGFzc29jO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IG5ldyBBYnNvbHV0ZVBvc2l0aW9uKHR5cGUsIGluZGV4LCBhc3NvYyk7XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtJRHxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uID0gKHR5cGUsIGl0ZW0sIGFzc29jKSA9PiB7XG4gIGxldCB0eXBlaWQgPSBudWxsO1xuICBsZXQgdG5hbWUgPSBudWxsO1xuICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCkge1xuICAgIHRuYW1lID0gZmluZFJvb3RUeXBlS2V5KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHR5cGVpZCA9IGNyZWF0ZUlEKHR5cGUuX2l0ZW0uaWQuY2xpZW50LCB0eXBlLl9pdGVtLmlkLmNsb2NrKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbSwgYXNzb2MpXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlbGF0aXZlUG9zaXRpb24gYmFzZWQgb24gYSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlIFRoZSBiYXNlIHR5cGUgKGUuZy4gWVRleHQgb3IgWUFycmF5KS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgYWJzb2x1dGUgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXggPSAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkgPT4ge1xuICBsZXQgdCA9IHR5cGUuX3N0YXJ0O1xuICBpZiAoYXNzb2MgPCAwKSB7XG4gICAgLy8gYXNzb2NpYXRlZCB0byB0aGUgbGVmdCBjaGFyYWN0ZXIgb3IgdGhlIGJlZ2lubmluZyBvZiBhIHR5cGUsIGluY3JlbWVudCBpbmRleCBpZiBwb3NzaWJsZS5cbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIG51bGwsIGFzc29jKVxuICAgIH1cbiAgICBpbmRleC0tO1xuICB9XG4gIHdoaWxlICh0ICE9PSBudWxsKSB7XG4gICAgaWYgKCF0LmRlbGV0ZWQgJiYgdC5jb3VudGFibGUpIHtcbiAgICAgIGlmICh0Lmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICAgIC8vIGNhc2UgMTogZm91bmQgcG9zaXRpb24gc29tZXdoZXJlIGluIHRoZSBsaW5rZWQgbGlzdFxuICAgICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBjcmVhdGVJRCh0LmlkLmNsaWVudCwgdC5pZC5jbG9jayArIGluZGV4KSwgYXNzb2MpXG4gICAgICB9XG4gICAgICBpbmRleCAtPSB0Lmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHQucmlnaHQgPT09IG51bGwgJiYgYXNzb2MgPCAwKSB7XG4gICAgICAvLyBsZWZ0LWFzc29jaWF0ZWQgcG9zaXRpb24sIHJldHVybiBsYXN0IGF2YWlsYWJsZSBpZFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgdC5sYXN0SWQsIGFzc29jKVxuICAgIH1cbiAgICB0ID0gdC5yaWdodDtcbiAgfVxuICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVSZWxhdGl2ZVBvc2l0aW9uID0gKGVuY29kZXIsIHJwb3MpID0+IHtcbiAgY29uc3QgeyB0eXBlLCB0bmFtZSwgaXRlbSwgYXNzb2MgfSA9IHJwb3M7XG4gIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIDApO1xuICAgIHdyaXRlSUQoZW5jb2RlciwgaXRlbSk7XG4gIH0gZWxzZSBpZiAodG5hbWUgIT09IG51bGwpIHtcbiAgICAvLyBjYXNlIDI6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgc3RvcmVkIGluIHkuc2hhcmVcbiAgICB3cml0ZVVpbnQ4KGVuY29kZXIsIDEpO1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRuYW1lKTtcbiAgfSBlbHNlIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAzOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIGF0dGFjaGVkIHRvIGFuIGl0ZW1cbiAgICB3cml0ZVVpbnQ4KGVuY29kZXIsIDIpO1xuICAgIHdyaXRlSUQoZW5jb2RlciwgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgdW5leHBlY3RlZENhc2UoKVxuICB9XG4gIHdyaXRlVmFySW50KGVuY29kZXIsIGFzc29jKTtcbiAgcmV0dXJuIGVuY29kZXJcbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uID0gcnBvcyA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gIHdyaXRlUmVsYXRpdmVQb3NpdGlvbihlbmNvZGVyLCBycG9zKTtcbiAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRSZWxhdGl2ZVBvc2l0aW9uID0gZGVjb2RlciA9PiB7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IHRuYW1lID0gbnVsbDtcbiAgbGV0IGl0ZW1JRCA9IG51bGw7XG4gIHN3aXRjaCAocmVhZFZhclVpbnQoZGVjb2RlcikpIHtcbiAgICBjYXNlIDA6XG4gICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgIGl0ZW1JRCA9IHJlYWRJRChkZWNvZGVyKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgICB0bmFtZSA9IHJlYWRWYXJTdHJpbmcoZGVjb2Rlcik7XG4gICAgICBicmVha1xuICAgIGNhc2UgMjoge1xuICAgICAgLy8gY2FzZSAzOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIGF0dGFjaGVkIHRvIGFuIGl0ZW1cbiAgICAgIHR5cGUgPSByZWFkSUQoZGVjb2Rlcik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGFzc29jID0gaGFzQ29udGVudChkZWNvZGVyKSA/IHJlYWRWYXJJbnQoZGVjb2RlcikgOiAwO1xuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZSwgdG5hbWUsIGl0ZW1JRCwgYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqL1xuY29uc3QgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHVpbnQ4QXJyYXkgPT4gcmVhZFJlbGF0aXZlUG9zaXRpb24oY3JlYXRlRGVjb2Rlcih1aW50OEFycmF5KSk7XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtBYnNvbHV0ZVBvc2l0aW9ufG51bGx9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbiA9IChycG9zLCBkb2MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IHJpZ2h0SUQgPSBycG9zLml0ZW07XG4gIGNvbnN0IHR5cGVJRCA9IHJwb3MudHlwZTtcbiAgY29uc3QgdG5hbWUgPSBycG9zLnRuYW1lO1xuICBjb25zdCBhc3NvYyA9IHJwb3MuYXNzb2M7XG4gIGxldCB0eXBlID0gbnVsbDtcbiAgbGV0IGluZGV4ID0gMDtcbiAgaWYgKHJpZ2h0SUQgIT09IG51bGwpIHtcbiAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHJpZ2h0SUQuY2xpZW50KSA8PSByaWdodElELmNsb2NrKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjb25zdCByZXMgPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHJpZ2h0SUQpO1xuICAgIGNvbnN0IHJpZ2h0ID0gcmVzLml0ZW07XG4gICAgaWYgKCEocmlnaHQgaW5zdGFuY2VvZiBJdGVtKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpO1xuICAgIGlmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgIGluZGV4ID0gKHJpZ2h0LmRlbGV0ZWQgfHwgIXJpZ2h0LmNvdW50YWJsZSkgPyAwIDogKHJlcy5kaWZmICsgKGFzc29jID49IDAgPyAwIDogMSkpOyAvLyBhZGp1c3QgcG9zaXRpb24gYmFzZWQgb24gbGVmdCBhc3NvY2lhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgIGxldCBuID0gcmlnaHQubGVmdDtcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICAgICAgaW5kZXggKz0gbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ubGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRuYW1lICE9PSBudWxsKSB7XG4gICAgICB0eXBlID0gZG9jLmdldCh0bmFtZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlSUQgIT09IG51bGwpIHtcbiAgICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgdHlwZUlELmNsaWVudCkgPD0gdHlwZUlELmNsb2NrKSB7XG4gICAgICAgIC8vIHR5cGUgZG9lcyBub3QgZXhpc3QgeWV0XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBjb25zdCB7IGl0ZW0gfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgdHlwZUlEKTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiBpdGVtLmNvbnRlbnQgaW5zdGFuY2VvZiBDb250ZW50VHlwZSkge1xuICAgICAgICB0eXBlID0gaXRlbS5jb250ZW50LnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJ1Y3QgaXMgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgdW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBpZiAoYXNzb2MgPj0gMCkge1xuICAgICAgaW5kZXggPSB0eXBlLl9sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUFic29sdXRlUG9zaXRpb24odHlwZSwgaW5kZXgsIHJwb3MuYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbnxudWxsfSBhXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKFxuICBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS50bmFtZSA9PT0gYi50bmFtZSAmJiBjb21wYXJlSURzKGEuaXRlbSwgYi5pdGVtKSAmJiBjb21wYXJlSURzKGEudHlwZSwgYi50eXBlKSAmJiBhLmFzc29jID09PSBiLmFzc29jXG4pO1xuXG5jbGFzcyBTbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAgICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2IHN0YXRlIG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRzLCBzdikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kcyA9IGRzO1xuICAgIC8qKlxuICAgICAqIFN0YXRlIE1hcFxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5zdiA9IHN2O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcDFcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbFNuYXBzaG90cyA9IChzbmFwMSwgc25hcDIpID0+IHtcbiAgY29uc3QgZHMxID0gc25hcDEuZHMuY2xpZW50cztcbiAgY29uc3QgZHMyID0gc25hcDIuZHMuY2xpZW50cztcbiAgY29uc3Qgc3YxID0gc25hcDEuc3Y7XG4gIGNvbnN0IHN2MiA9IHNuYXAyLnN2O1xuICBpZiAoc3YxLnNpemUgIT09IHN2Mi5zaXplIHx8IGRzMS5zaXplICE9PSBkczIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN2MS5lbnRyaWVzKCkpIHtcbiAgICBpZiAoc3YyLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgW2NsaWVudCwgZHNpdGVtczFdIG9mIGRzMS5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBkc2l0ZW1zMiA9IGRzMi5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBpZiAoZHNpdGVtczEubGVuZ3RoICE9PSBkc2l0ZW1zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzaXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkc2l0ZW0xID0gZHNpdGVtczFbaV07XG4gICAgICBjb25zdCBkc2l0ZW0yID0gZHNpdGVtczJbaV07XG4gICAgICBpZiAoZHNpdGVtMS5jbG9jayAhPT0gZHNpdGVtMi5jbG9jayB8fCBkc2l0ZW0xLmxlbiAhPT0gZHNpdGVtMi5sZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU25hcHNob3RWMiA9IChzbmFwc2hvdCwgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHNuYXBzaG90LmRzKTtcbiAgd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBzbmFwc2hvdC5zdik7XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTbmFwc2hvdCA9IHNuYXBzaG90ID0+IGVuY29kZVNuYXBzaG90VjIoc25hcHNob3QsIG5ldyBEU0VuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBbZGVjb2Rlcl1cbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBkZWNvZGVTbmFwc2hvdFYyID0gKGJ1ZiwgZGVjb2RlciA9IG5ldyBEU0RlY29kZXJWMihjcmVhdGVEZWNvZGVyKGJ1ZikpKSA9PiB7XG4gIHJldHVybiBuZXcgU25hcHNob3QocmVhZERlbGV0ZVNldChkZWNvZGVyKSwgcmVhZFN0YXRlVmVjdG9yKGRlY29kZXIpKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGRlY29kZVNuYXBzaG90ID0gYnVmID0+IGRlY29kZVNuYXBzaG90VjIoYnVmLCBuZXcgRFNEZWNvZGVyVjEoY3JlYXRlRGVjb2RlcihidWYpKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc21cbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBjcmVhdGVTbmFwc2hvdCA9IChkcywgc20pID0+IG5ldyBTbmFwc2hvdChkcywgc20pO1xuXG5jb25zdCBlbXB0eVNuYXBzaG90ID0gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IHNuYXBzaG90ID0gZG9jID0+IGNyZWF0ZVNuYXBzaG90KGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U25hcHNob3R8dW5kZWZpbmVkfSBzbmFwc2hvdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpc1Zpc2libGUgPSAoaXRlbSwgc25hcHNob3QpID0+IHNuYXBzaG90ID09PSB1bmRlZmluZWQgPyAhaXRlbS5kZWxldGVkIDogKFxuICBzbmFwc2hvdC5zdi5oYXMoaXRlbS5pZC5jbGllbnQpICYmIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApID4gaXRlbS5pZC5jbG9jayAmJiAhaXNEZWxldGVkKHNuYXBzaG90LmRzLCBpdGVtLmlkKVxuKTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqL1xuY29uc3Qgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgbWV0YSA9IHNldElmVW5kZWZpbmVkKHRyYW5zYWN0aW9uLm1ldGEsIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMsIGNyZWF0ZSQxKTtcbiAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5kb2Muc3RvcmU7XG4gIC8vIGNoZWNrIGlmIHdlIGFscmVhZHkgc3BsaXQgZm9yIHRoaXMgc25hcHNob3RcbiAgaWYgKCFtZXRhLmhhcyhzbmFwc2hvdCkpIHtcbiAgICBzbmFwc2hvdC5zdi5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QuZHMsIGl0ZW0gPT4ge30pO1xuICAgIG1ldGEuYWRkKHNuYXBzaG90KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tU25hcHNob3QgPSAob3JpZ2luRG9jLCBzbmFwc2hvdCwgbmV3RG9jID0gbmV3IERvYygpKSA9PiB7XG4gIGlmIChvcmlnaW5Eb2MuZ2MpIHtcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyeSB0byByZXN0b3JlIGEgR0MtZWQgZG9jdW1lbnQsIGJlY2F1c2Ugc29tZSBvZiB0aGUgcmVzdG9yZWQgaXRlbXMgbWlnaHQgaGF2ZSB0aGVpciBjb250ZW50IGRlbGV0ZWRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29yaWdpbkRvYyBtdXN0IG5vdCBiZSBnYXJiYWdlIGNvbGxlY3RlZCcpXG4gIH1cbiAgY29uc3QgeyBzdiwgZHMgfSA9IHNuYXBzaG90O1xuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gIG9yaWdpbkRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHN2LmZvckVhY2goY2xvY2sgPT4ge1xuICAgICAgaWYgKGNsb2NrID4gMCkge1xuICAgICAgICBzaXplKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNpemUpO1xuICAgIC8vIHNwbGl0dGluZyB0aGUgc3RydWN0cyBiZWZvcmUgd3JpdGluZyB0aGVtIHRvIHRoZSBlbmNvZGVyXG4gICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2Ygc3YpIHtcbiAgICAgIGlmIChjbG9jayA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUob3JpZ2luRG9jLnN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgICBjb25zdCBsYXN0U3RydWN0SW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayAtIDEpO1xuICAgICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsYXN0U3RydWN0SW5kZXggKyAxKTtcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgICAgIC8vIGZpcnN0IGNsb2NrIHdyaXR0ZW4gaXMgMFxuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdFN0cnVjdEluZGV4OyBpKyspIHtcbiAgICAgICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICB9KTtcblxuICBhcHBseVVwZGF0ZVYyKG5ld0RvYywgZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgJ3NuYXBzaG90Jyk7XG4gIHJldHVybiBuZXdEb2Ncbn07XG5cbmNsYXNzIFN0cnVjdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PEdDfEl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCB7IG1pc3Npbmc6IE1hcDxudW1iZXIsIG51bWJlcj4sIHVwZGF0ZTogVWludDhBcnJheSB9fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1N0cnVjdHMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgVWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdEcyA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YXRlcyBhcyBhIE1hcDxjbGllbnQsY2xvY2s+LlxuICogTm90ZSB0aGF0IGNsb2NrIHJlZmVycyB0byB0aGUgbmV4dCBleHBlY3RlZCBjbG9jayBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRTdGF0ZVZlY3RvciA9IHN0b3JlID0+IHtcbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIHN0b3JlLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdO1xuICAgIHNtLnNldChjbGllbnQsIHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpO1xuICB9KTtcbiAgcmV0dXJuIHNtXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFN0YXRlID0gKHN0b3JlLCBjbGllbnQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCk7XG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gIHJldHVybiBsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGhcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCkgPT4ge1xuICBsZXQgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpO1xuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RydWN0cyA9IFtdO1xuICAgIHN0b3JlLmNsaWVudHMuc2V0KHN0cnVjdC5pZC5jbGllbnQsIHN0cnVjdHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aCAhPT0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICB0aHJvdyB1bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG4gIHN0cnVjdHMucHVzaChzdHJ1Y3QpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheVxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhTUyA9IChzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IHN0cnVjdHMubGVuZ3RoIC0gMTtcbiAgbGV0IG1pZCA9IHN0cnVjdHNbcmlnaHRdO1xuICBsZXQgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2s7XG4gIGlmIChtaWRjbG9jayA9PT0gY2xvY2spIHtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuICAvLyBAdG9kbyBkb2VzIGl0IGV2ZW4gbWFrZSBzZW5zZSB0byBwaXZvdCB0aGUgc2VhcmNoP1xuICAvLyBJZiBhIGdvb2Qgc3BsaXQgbWlzc2VzLCBpdCBtaWdodCBhY3R1YWxseSBpbmNyZWFzZSB0aGUgdGltZSB0byBmaW5kIHRoZSBjb3JyZWN0IGl0ZW0uXG4gIC8vIEN1cnJlbnRseSwgdGhlIG9ubHkgYWR2YW50YWdlIGlzIHRoYXQgc2VhcmNoIHdpdGggcGl2b3RpbmcgbWlnaHQgZmluZCB0aGUgaXRlbSBvbiB0aGUgZmlyc3QgdHJ5LlxuICBsZXQgbWlkaW5kZXggPSBmbG9vcigoY2xvY2sgLyAobWlkY2xvY2sgKyBtaWQubGVuZ3RoIC0gMSkpICogcmlnaHQpOyAvLyBwaXZvdGluZyB0aGUgc2VhcmNoXG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgbWlkID0gc3RydWN0c1ttaWRpbmRleF07XG4gICAgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2s7XG4gICAgaWYgKG1pZGNsb2NrIDw9IGNsb2NrKSB7XG4gICAgICBpZiAoY2xvY2sgPCBtaWRjbG9jayArIG1pZC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1pZGluZGV4XG4gICAgICB9XG4gICAgICBsZWZ0ID0gbWlkaW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMTtcbiAgICB9XG4gICAgbWlkaW5kZXggPSBmbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICB9XG4gIC8vIEFsd2F5cyBjaGVjayBzdGF0ZSBiZWZvcmUgbG9va2luZyBmb3IgYSBzdHJ1Y3QgaW4gU3RydWN0U3RvcmVcbiAgLy8gVGhlcmVmb3JlIHRoZSBjYXNlIG9mIG5vdCBmaW5kaW5nIGEgc3RydWN0IGlzIHVuZXhwZWN0ZWRcbiAgdGhyb3cgdW5leHBlY3RlZENhc2UoKVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7R0N8SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmQgPSAoc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpO1xuICByZXR1cm4gc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayldXG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW0gPSAvKiogQHR5cGUge2Z1bmN0aW9uKFN0cnVjdFN0b3JlLElEKTpJdGVtfSAqLyAoZmluZCk7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICovXG5jb25zdCBmaW5kSW5kZXhDbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gIGlmIChzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jayAmJiBzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICByZXR1cm4gaW5kZXggKyAxXG4gIH1cbiAgcmV0dXJuIGluZGV4XG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0SXRlbUNsZWFuU3RhcnQgPSAodHJhbnNhY3Rpb24sIGlkKSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudCkpO1xuICByZXR1cm4gc3RydWN0c1tmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBpZC5jbG9jayldXG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW1DbGVhbkVuZCA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpO1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGlkLmNsb2NrKTtcbiAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gIGlmIChpZC5jbG9jayAhPT0gc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCAtIDEgJiYgc3RydWN0LmNvbnN0cnVjdG9yICE9PSBHQykge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGlkLmNsb2NrIC0gc3RydWN0LmlkLmNsb2NrICsgMSkpO1xuICB9XG4gIHJldHVybiBzdHJ1Y3Rcbn07XG5cbi8qKlxuICogUmVwbGFjZSBgaXRlbWAgd2l0aCBgbmV3aXRlbWAgaW4gc3RvcmVcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0dDfEl0ZW19IHN0cnVjdFxuICogQHBhcmFtIHtHQ3xJdGVtfSBuZXdTdHJ1Y3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlcGxhY2VTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCwgbmV3U3RydWN0KSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoc3RydWN0LmlkLmNsaWVudCkpO1xuICBzdHJ1Y3RzW2ZpbmRJbmRleFNTKHN0cnVjdHMsIHN0cnVjdC5pZC5jbG9jayldID0gbmV3U3RydWN0O1xufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiBzdHJ1Y3RzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1N0YXJ0IEluY2x1c2l2ZSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHBhcmFtIHtmdW5jdGlvbihHQ3xJdGVtKTp2b2lkfSBmXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGl0ZXJhdGVTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja1N0YXJ0LCBsZW4sIGYpID0+IHtcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGNsb2NrRW5kID0gY2xvY2tTdGFydCArIGxlbjtcbiAgbGV0IGluZGV4ID0gZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCk7XG4gIGxldCBzdHJ1Y3Q7XG4gIGRvIHtcbiAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4KytdO1xuICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgIGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrRW5kKTtcbiAgICB9XG4gICAgZihzdHJ1Y3QpO1xuICB9IHdoaWxlIChpbmRleCA8IHN0cnVjdHMubGVuZ3RoICYmIHN0cnVjdHNbaW5kZXhdLmlkLmNsb2NrIDwgY2xvY2tFbmQpXG59O1xuXG4vKipcbiAqIEEgdHJhbnNhY3Rpb24gaXMgY3JlYXRlZCBmb3IgZXZlcnkgY2hhbmdlIG9uIHRoZSBZanMgbW9kZWwuIEl0IGlzIHBvc3NpYmxlXG4gKiB0byBidW5kbGUgY2hhbmdlcyBvbiB0aGUgWWpzIG1vZGVsIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHRvXG4gKiBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9uIG1lc3NhZ2VzIHNlbnQgYW5kIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXIgY2FsbHMuXG4gKiBJZiBwb3NzaWJsZSB0aGUgdXNlciBvZiB0aGlzIGxpYnJhcnkgc2hvdWxkIGJ1bmRsZSBhcyBtYW55IGNoYW5nZXMgYXNcbiAqIHBvc3NpYmxlLiBIZXJlIGlzIGFuIGV4YW1wbGUgdG8gaWxsdXN0cmF0ZSB0aGUgYWR2YW50YWdlcyBvZiBidW5kbGluZzpcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbWFwID0geS5kZWZpbmUoJ21hcCcsIFlNYXApXG4gKiAvLyBMb2cgY29udGVudCB3aGVuIGNoYW5nZSBpcyB0cmlnZ2VyZWRcbiAqIG1hcC5vYnNlcnZlKCgpID0+IHtcbiAqICAgY29uc29sZS5sb2coJ2NoYW5nZSB0cmlnZ2VyZWQnKVxuICogfSlcbiAqIC8vIEVhY2ggY2hhbmdlIG9uIHRoZSBtYXAgdHlwZSB0cmlnZ2VycyBhIGxvZyBtZXNzYWdlOlxuICogbWFwLnNldCgnYScsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiBtYXAuc2V0KCdiJywgMCkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqIC8vIFdoZW4gcHV0IGluIGEgdHJhbnNhY3Rpb24sIGl0IHdpbGwgdHJpZ2dlciB0aGUgbG9nIGFmdGVyIHRoZSB0cmFuc2FjdGlvbjpcbiAqIHkudHJhbnNhY3QoKCkgPT4ge1xuICogICBtYXAuc2V0KCdhJywgMSlcbiAqICAgbWFwLnNldCgnYicsIDEpXG4gKiB9KSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9jYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MsIG9yaWdpbiwgbG9jYWwpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgWWpzIGluc3RhbmNlLlxuICAgICAqIEB0eXBlIHtEb2N9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogRGVzY3JpYmVzIHRoZSBzZXQgb2YgZGVsZXRlZCBpdGVtcyBieSBpZHNcbiAgICAgKiBAdHlwZSB7RGVsZXRlU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZGVsZXRlU2V0ID0gbmV3IERlbGV0ZVNldCgpO1xuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBzdGF0ZSBiZWZvcmUgdGhlIHRyYW5zYWN0aW9uIHN0YXJ0ZWQuXG4gICAgICogQHR5cGUge01hcDxOdW1iZXIsTnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmJlZm9yZVN0YXRlID0gZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKTtcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5hZnRlclN0YXRlID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEFsbCB0eXBlcyB0aGF0IHdlcmUgZGlyZWN0bHkgbW9kaWZpZWQgKHByb3BlcnR5IGFkZGVkIG9yIGNoaWxkXG4gICAgICogaW5zZXJ0ZWQvZGVsZXRlZCkuIE5ldyB0eXBlcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoaXMgU2V0LlxuICAgICAqIE1hcHMgZnJvbSB0eXBlIHRvIHBhcmVudFN1YnMgKGBpdGVtLnBhcmVudFN1YiA9IG51bGxgIGZvciBZQXJyYXkpXG4gICAgICogQHR5cGUge01hcDxBYnN0cmFjdFR5cGU8WUV2ZW50PixTZXQ8U3RyaW5nfG51bGw+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWQgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBldmVudHMgZm9yIHRoZSB0eXBlcyB0aGF0IG9ic2VydmUgYWxzbyBjaGlsZCBlbGVtZW50cy5cbiAgICAgKiBJdCBpcyBtYWlubHkgdXNlZCBieSBgb2JzZXJ2ZURlZXBgLlxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudD4sQXJyYXk8WUV2ZW50Pj59XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkUGFyZW50VHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFic3RyYWN0U3RydWN0Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9tZXJnZVN0cnVjdHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyBtZXRhIGluZm9ybWF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEB0eXBlIHtNYXA8YW55LGFueT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBjaGFuZ2Ugb3JpZ2luYXRlcyBmcm9tIHRoaXMgZG9jLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzQWRkZWQgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc1JlbW92ZWQgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0xvYWRlZCA9IG5ldyBTZXQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBkYXRhIHdhcyB3cml0dGVuLlxuICovXG5jb25zdCB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24gPSAoZW5jb2RlciwgdHJhbnNhY3Rpb24pID0+IHtcbiAgaWYgKHRyYW5zYWN0aW9uLmRlbGV0ZVNldC5jbGllbnRzLnNpemUgPT09IDAgJiYgIWFueSh0cmFuc2FjdGlvbi5hZnRlclN0YXRlLCAoY2xvY2ssIGNsaWVudCkgPT4gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgIT09IGNsb2NrKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQpO1xuICB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBJZiBgdHlwZS5wYXJlbnRgIHdhcyBhZGRlZCBpbiBjdXJyZW50IHRyYW5zYWN0aW9uLCBgdHlwZWAgdGVjaG5pY2FsbHlcbiAqIGRpZCBub3QgY2hhbmdlLCBpdCB3YXMganVzdCBhZGRlZCBhbmQgd2Ugc2hvdWxkIG5vdCBmaXJlIGV2ZW50cyBmb3IgYHR5cGVgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxZRXZlbnQ+fSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBwYXJlbnRTdWJcbiAqL1xuY29uc3QgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uID0gKHRyYW5zYWN0aW9uLCB0eXBlLCBwYXJlbnRTdWIpID0+IHtcbiAgY29uc3QgaXRlbSA9IHR5cGUuX2l0ZW07XG4gIGlmIChpdGVtID09PSBudWxsIHx8IChpdGVtLmlkLmNsb2NrIDwgKHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkgJiYgIWl0ZW0uZGVsZXRlZCkpIHtcbiAgICBzZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5jaGFuZ2VkLCB0eXBlLCBjcmVhdGUkMSkuYWRkKHBhcmVudFN1Yik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqL1xuY29uc3QgdHJ5VG9NZXJnZVdpdGhMZWZ0ID0gKHN0cnVjdHMsIHBvcykgPT4ge1xuICBjb25zdCBsZWZ0ID0gc3RydWN0c1twb3MgLSAxXTtcbiAgY29uc3QgcmlnaHQgPSBzdHJ1Y3RzW3Bvc107XG4gIGlmIChsZWZ0LmRlbGV0ZWQgPT09IHJpZ2h0LmRlbGV0ZWQgJiYgbGVmdC5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICBpZiAobGVmdC5tZXJnZVdpdGgocmlnaHQpKSB7XG4gICAgICBzdHJ1Y3RzLnNwbGljZShwb3MsIDEpO1xuICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSAmJiByaWdodC5wYXJlbnRTdWIgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5nZXQocmlnaHQucGFyZW50U3ViKSA9PT0gcmlnaHQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCkuX21hcC5zZXQocmlnaHQucGFyZW50U3ViLCAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gZ2NGaWx0ZXJcbiAqL1xuY29uc3QgdHJ5R2NEZWxldGVTZXQgPSAoZHMsIHN0b3JlLCBnY0ZpbHRlcikgPT4ge1xuICBmb3IgKGNvbnN0IFtjbGllbnQsIGRlbGV0ZUl0ZW1zXSBvZiBkcy5jbGllbnRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldO1xuICAgICAgY29uc3QgZW5kRGVsZXRlSXRlbUNsb2NrID0gZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayksIHN0cnVjdCA9IHN0cnVjdHNbc2ldO1xuICAgICAgICBzaSA8IHN0cnVjdHMubGVuZ3RoICYmIHN0cnVjdC5pZC5jbG9jayA8IGVuZERlbGV0ZUl0ZW1DbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1srK3NpXVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbc2ldO1xuICAgICAgICBpZiAoZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIDw9IHN0cnVjdC5pZC5jbG9jaykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0gJiYgc3RydWN0LmRlbGV0ZWQgJiYgIXN0cnVjdC5rZWVwICYmIGdjRmlsdGVyKHN0cnVjdCkpIHtcbiAgICAgICAgICBzdHJ1Y3QuZ2Moc3RvcmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKi9cbmNvbnN0IHRyeU1lcmdlRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSkgPT4ge1xuICAvLyB0cnkgdG8gbWVyZ2UgZGVsZXRlZCAvIGdjJ2QgaXRlbXNcbiAgLy8gbWVyZ2UgZnJvbSByaWdodCB0byBsZWZ0IGZvciBiZXR0ZXIgZWZmaWNpZWN5IGFuZCBzbyB3ZSBkb24ndCBtaXNzIGFueSBtZXJnZSB0YXJnZXRzXG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZGVsZXRlSXRlbXMsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldO1xuICAgICAgLy8gc3RhcnQgd2l0aCBtZXJnaW5nIHRoZSBpdGVtIG5leHQgdG8gdGhlIGxhc3QgZGVsZXRlZCBpdGVtXG4gICAgICBjb25zdCBtb3N0UmlnaHRJbmRleFRvQ2hlY2sgPSBtaW4oc3RydWN0cy5sZW5ndGggLSAxLCAxICsgZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIC0gMSkpO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gbW9zdFJpZ2h0SW5kZXhUb0NoZWNrLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPiAwICYmIHN0cnVjdC5pZC5jbG9jayA+PSBkZWxldGVJdGVtLmNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzWy0tc2ldXG4gICAgICApIHtcbiAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHNpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBnY0ZpbHRlcik7XG4gIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb24+fSB0cmFuc2FjdGlvbkNsZWFudXBzXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5jb25zdCBjbGVhbnVwVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkpID0+IHtcbiAgaWYgKGkgPCB0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25DbGVhbnVwc1tpXTtcbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXQ7XG4gICAgY29uc3QgbWVyZ2VTdHJ1Y3RzID0gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cztcbiAgICB0cnkge1xuICAgICAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KGRzKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcih0cmFuc2FjdGlvbi5kb2Muc3RvcmUpO1xuICAgICAgZG9jLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBkb2MuZW1pdCgnYmVmb3JlT2JzZXJ2ZXJDYWxscycsIFt0cmFuc2FjdGlvbiwgZG9jXSk7XG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAqXG4gICAgICAgKiBFYWNoIGNhbGxiYWNrIGlzIGNhbGxlZCBldmVuIGlmIHRoZSBvdGhlciBvbmVzIHRocm93IGVycm9ycy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZnMgPSBbXTtcbiAgICAgIC8vIG9ic2VydmUgZXZlbnRzIG9uIGNoYW5nZWQgdHlwZXNcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3VicywgaXRlbXR5cGUpID0+XG4gICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtdHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhaXRlbXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaXRlbXR5cGUuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgc3Vicyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyBkZWVwIG9ic2VydmUgZXZlbnRzXG4gICAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKChldmVudHMsIHR5cGUpID0+XG4gICAgICAgICAgZnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRoaW5rIGFib3V0IHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSB1c2VyIHRyYW5zZm9ybXMgdGhlXG4gICAgICAgICAgICAvLyBZLkRvYyBpbiB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT5cbiAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5faXRlbSA9PT0gbnVsbCB8fCAhZXZlbnQudGFyZ2V0Ll9pdGVtLmRlbGV0ZWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBldmVudHNcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gdHlwZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gc29ydCBldmVudHMgYnkgcGF0aCBsZW5ndGggc28gdGhhdCB0b3AtbGV2ZWwgZXZlbnRzIGFyZSBmaXJlZCBmaXJzdC5cbiAgICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgICAgLnNvcnQoKGV2ZW50MSwgZXZlbnQyKSA9PiBldmVudDEucGF0aC5sZW5ndGggLSBldmVudDIucGF0aC5sZW5ndGgpO1xuICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBldmVudHMubGVuZ3RoXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2Uga25vdyBpdCBoYXMgYXQgbGVhc3Qgb25lIGVsZW1lbnRcbiAgICAgICAgICAgICAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyh0eXBlLl9kRUgsIGV2ZW50cywgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZzLnB1c2goKCkgPT4gZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb24nLCBbdHJhbnNhY3Rpb24sIGRvY10pKTtcbiAgICAgIH0pO1xuICAgICAgY2FsbEFsbChmcywgW10pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZXBsYWNlIGRlbGV0ZWQgaXRlbXMgd2l0aCBJdGVtRGVsZXRlZCAvIEdDLlxuICAgICAgLy8gVGhpcyBpcyB3aGVyZSBjb250ZW50IGlzIGFjdHVhbGx5IHJlbW92ZSBmcm9tIHRoZSBZanMgRG9jLlxuICAgICAgaWYgKGRvYy5nYykge1xuICAgICAgICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGRvYy5nY0ZpbHRlcik7XG4gICAgICB9XG4gICAgICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpO1xuXG4gICAgICAvLyBvbiBhbGwgYWZmZWN0ZWQgc3RvcmUuY2xpZW50cyBwcm9wcywgdHJ5IHRvIG1lcmdlXG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3QgYmVmb3JlQ2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYmVmb3JlQ2xvY2sgIT09IGNsb2NrKSB7XG4gICAgICAgICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICAgICAgICAvLyB3ZSBpdGVyYXRlIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbnRyaWVzXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGFuZ2VQb3MgPSBtYXgoZmluZEluZGV4U1Moc3RydWN0cywgYmVmb3JlQ2xvY2spLCAxKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RydWN0cy5sZW5ndGggLSAxOyBpID49IGZpcnN0Q2hhbmdlUG9zOyBpLS0pIHtcbiAgICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdHJ5IHRvIG1lcmdlIG1lcmdlU3RydWN0c1xuICAgICAgLy8gQHRvZG86IGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gdHJhbnNmb3JtIG1lcmdlU3RydWN0cyB0byBhIERTLCBzb3J0IGl0LCBhbmQgbWVyZ2UgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgICAvLyAgICAgICAgYnV0IGF0IHRoZSBtb21lbnQgRFMgZG9lcyBub3QgaGFuZGxlIGR1cGxpY2F0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VTdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbWVyZ2VTdHJ1Y3RzW2ldLmlkO1xuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgICAgICBjb25zdCByZXBsYWNlZFN0cnVjdFBvcyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zID4gMCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCByZXBsYWNlZFN0cnVjdFBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSAhPT0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkpIHtcbiAgICAgICAgZG9jLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpO1xuICAgICAgICBwcmludChPUkFOR0UsIEJPTEQsICdbeWpzXSAnLCBVTkJPTEQsIFJFRCwgJ0NoYW5nZWQgdGhlIGNsaWVudC1pZCBiZWNhdXNlIGFub3RoZXIgY2xpZW50IHNlZW1zIHRvIGJlIHVzaW5nIGl0LicpO1xuICAgICAgfVxuICAgICAgLy8gQHRvZG8gTWVyZ2UgYWxsIHRoZSB0cmFuc2FjdGlvbnMgaW50byBvbmUgYW5kIHByb3ZpZGUgc2VuZCB0aGUgZGF0YSBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZVxuICAgICAgZG9jLmVtaXQoJ2FmdGVyVHJhbnNhY3Rpb25DbGVhbnVwJywgW3RyYW5zYWN0aW9uLCBkb2NdKTtcbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZScpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYxKCk7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgIGRvYy5lbWl0KCd1cGRhdGUnLCBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgdHJhbnNhY3Rpb24ub3JpZ2luLCBkb2MsIHRyYW5zYWN0aW9uXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkb2MuX29ic2VydmVycy5oYXMoJ3VwZGF0ZVYyJykpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgZG9jLmVtaXQoJ3VwZGF0ZVYyJywgW2VuY29kZXIudG9VaW50OEFycmF5KCksIHRyYW5zYWN0aW9uLm9yaWdpbiwgZG9jLCB0cmFuc2FjdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuYWRkKHN1YmRvYykpO1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuZGVsZXRlKHN1YmRvYykpO1xuXG4gICAgICBkb2MuZW1pdCgnc3ViZG9jcycsIFt7IGxvYWRlZDogdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZCwgYWRkZWQ6IHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZCwgcmVtb3ZlZDogdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQgfV0pO1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA8PSBpICsgMSkge1xuICAgICAgICBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHMgPSBbXTtcbiAgICAgICAgZG9jLmVtaXQoJ2FmdGVyQWxsVHJhbnNhY3Rpb25zJywgW2RvYywgdHJhbnNhY3Rpb25DbGVhbnVwc10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCBpICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYHkudHJhbnNhY3QoKCk9PnsuLn0pYFxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOnZvaWR9IGZcbiAqIEBwYXJhbSB7YW55fSBbb3JpZ2luPXRydWVdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHRyYW5zYWN0ID0gKGRvYywgZiwgb3JpZ2luID0gbnVsbCwgbG9jYWwgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uQ2xlYW51cHMgPSBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHM7XG4gIGxldCBpbml0aWFsQ2FsbCA9IGZhbHNlO1xuICBpZiAoZG9jLl90cmFuc2FjdGlvbiA9PT0gbnVsbCkge1xuICAgIGluaXRpYWxDYWxsID0gdHJ1ZTtcbiAgICBkb2MuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYywgb3JpZ2luLCBsb2NhbCk7XG4gICAgdHJhbnNhY3Rpb25DbGVhbnVwcy5wdXNoKGRvYy5fdHJhbnNhY3Rpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIFtkb2NdKTtcbiAgICB9XG4gICAgZG9jLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywgW2RvYy5fdHJhbnNhY3Rpb24sIGRvY10pO1xuICB9XG4gIHRyeSB7XG4gICAgZihkb2MuX3RyYW5zYWN0aW9uKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaW5pdGlhbENhbGwgJiYgdHJhbnNhY3Rpb25DbGVhbnVwc1swXSA9PT0gZG9jLl90cmFuc2FjdGlvbikge1xuICAgICAgLy8gVGhlIGZpcnN0IHRyYW5zYWN0aW9uIGVuZGVkLCBub3cgcHJvY2VzcyBvYnNlcnZlciBjYWxscy5cbiAgICAgIC8vIE9ic2VydmVyIGNhbGwgbWF5IGNyZWF0ZSBuZXcgdHJhbnNhY3Rpb25zIGZvciB3aGljaCB3ZSBuZWVkIHRvIGNhbGwgdGhlIG9ic2VydmVycyBhbmQgZG8gY2xlYW51cC5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gbmVzdCB0aGVzZSBjYWxscywgc28gd2UgZXhlY3V0ZSB0aGVzZSBjYWxscyBvbmUgYWZ0ZXJcbiAgICAgIC8vIGFub3RoZXIuXG4gICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGNsZWFudXBzIGFyZSBjYWxsZWQsIGV2ZW4gaWYgdGhlXG4gICAgICAvLyBvYnNlcnZlcyB0aHJvdyBlcnJvcnMuXG4gICAgICAvLyBUaGlzIGZpbGUgaXMgZnVsbCBvZiBoYWNreSB0cnkge30gZmluYWxseSB7fSBibG9ja3MgdG8gZW5zdXJlIHRoYXQgYW5cbiAgICAgIC8vIGV2ZW50IGNhbiB0aHJvdyBlcnJvcnMgYW5kIGFsc28gdGhhdCB0aGUgY2xlYW51cCBpcyBjYWxsZWQuXG4gICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIDApO1xuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgU3RhY2tJdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkZWxldGlvbnNcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGluc2VydGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWxldGlvbnMsIGluc2VydGlvbnMpIHtcbiAgICB0aGlzLmluc2VydGlvbnMgPSBpbnNlcnRpb25zO1xuICAgIHRoaXMuZGVsZXRpb25zID0gZGVsZXRpb25zO1xuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIHNhdmUgYW5kIHJlc3RvcmUgbWV0YWRhdGEgbGlrZSBzZWxlY3Rpb24gcmFuZ2VcbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7U3RhY2tJdGVtP31cbiAqL1xuY29uc3QgcG9wU3RhY2tJdGVtID0gKHVuZG9NYW5hZ2VyLCBzdGFjaywgZXZlbnRUeXBlKSA9PiB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEB0eXBlIHtTdGFja0l0ZW0/fVxuICAgKi9cbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIC8qKlxuICAgKiBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0cmFuc2FjdGlvbiBzbyB3ZSBjYW4gZmlyZSB0aGUgZXZlbnQgd2l0aCB0aGUgY2hhbmdlZFBhcmVudFR5cGVzXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgX3RyID0gbnVsbDtcbiAgY29uc3QgZG9jID0gdW5kb01hbmFnZXIuZG9jO1xuICBjb25zdCBzY29wZSA9IHVuZG9NYW5hZ2VyLnNjb3BlO1xuICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCAmJiByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgICAgY29uc3Qgc3RhY2tJdGVtID0gLyoqIEB0eXBlIHtTdGFja0l0ZW19ICovIChzdGFjay5wb3AoKSk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9SZWRvID0gbmV3IFNldCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9EZWxldGUgPSBbXTtcbiAgICAgIGxldCBwZXJmb3JtZWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB7IGl0ZW0sIGRpZmYgfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgc3RydWN0LmlkKTtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBpdGVtID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrICsgZGlmZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RydWN0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCAvKiogQHR5cGUge0l0ZW19ICovIChzdHJ1Y3QpKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChzdHJ1Y3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHN0YWNrSXRlbS5kZWxldGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmXG4gICAgICAgICAgc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgc3RydWN0KSkgJiZcbiAgICAgICAgICAvLyBOZXZlciByZWRvIHN0cnVjdHMgaW4gc3RhY2tJdGVtLmluc2VydGlvbnMgYmVjYXVzZSB0aGV5IHdlcmUgY3JlYXRlZCBhbmQgZGVsZXRlZCBpbiB0aGUgc2FtZSBjYXB0dXJlIGludGVydmFsLlxuICAgICAgICAgICFpc0RlbGV0ZWQoc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdC5pZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXRlbXNUb1JlZG8uYWRkKHN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlbXNUb1JlZG8uZm9yRWFjaChzdHJ1Y3QgPT4ge1xuICAgICAgICBwZXJmb3JtZWRDaGFuZ2UgPSByZWRvSXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpdGVtc1RvUmVkbykgIT09IG51bGwgfHwgcGVyZm9ybWVkQ2hhbmdlO1xuICAgICAgfSk7XG4gICAgICAvLyBXZSB3YW50IHRvIGRlbGV0ZSBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgY2hpbGRyZW4gYXJlIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAvLyBwYXJlbnRzLCBzbyB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYXZhaWxhYmxlIHdoZW4gaXRlbXMgYXJlIGZpbHRlcmVkLlxuICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zVG9EZWxldGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zVG9EZWxldGVbaV07XG4gICAgICAgIGlmICh1bmRvTWFuYWdlci5kZWxldGVGaWx0ZXIoaXRlbSkpIHtcbiAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgcGVyZm9ybWVkQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcGVyZm9ybWVkQ2hhbmdlID8gc3RhY2tJdGVtIDogbnVsbDtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKChzdWJQcm9wcywgdHlwZSkgPT4ge1xuICAgICAgLy8gZGVzdHJveSBzZWFyY2ggbWFya2VyIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN1YlByb3BzLmhhcyhudWxsKSAmJiB0eXBlLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgICAgdHlwZS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3RyID0gdHJhbnNhY3Rpb247XG4gIH0sIHVuZG9NYW5hZ2VyKTtcbiAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gX3RyLmNoYW5nZWRQYXJlbnRUeXBlcztcbiAgICB1bmRvTWFuYWdlci5lbWl0KCdzdGFjay1pdGVtLXBvcHBlZCcsIFt7IHN0YWNrSXRlbTogcmVzdWx0LCB0eXBlOiBldmVudFR5cGUsIGNoYW5nZWRQYXJlbnRUeXBlcyB9LCB1bmRvTWFuYWdlcl0pO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5kb01hbmFnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5jYXB0dXJlVGltZW91dD01MDBdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IFtVbmRvTWFuYWdlck9wdGlvbnMuZGVsZXRlRmlsdGVyPSgpPT50cnVlXSBTb21ldGltZXNcbiAqIGl0IGlzIG5lY2Vzc2FyeSB0byBmaWx0ZXIgd2hhbiBhbiBVbmRvL1JlZG8gb3BlcmF0aW9uIGNhbiBkZWxldGUuIElmIHRoaXNcbiAqIGZpbHRlciByZXR1cm5zIGZhbHNlLCB0aGUgdHlwZS9pdGVtIHdvbid0IGJlIGRlbGV0ZWQgZXZlbiBpdCBpcyBpbiB0aGVcbiAqIHVuZG8vcmVkbyBzY29wZS5cbiAqIEBwcm9wZXJ0eSB7U2V0PGFueT59IFtVbmRvTWFuYWdlck9wdGlvbnMudHJhY2tlZE9yaWdpbnM9bmV3IFNldChbbnVsbF0pXVxuICovXG5cbi8qKlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tYWRkZWQnIGV2ZW50IHdoZW4gYSBzdGFjayBpdGVtIHdhcyBhZGRlZCB0byBlaXRoZXIgdGhlIHVuZG8tIG9yXG4gKiB0aGUgcmVkby1zdGFjay4gWW91IG1heSBzdG9yZSBhZGRpdGlvbmFsIHN0YWNrIGluZm9ybWF0aW9uIHZpYSB0aGVcbiAqIG1ldGFkYXRhIHByb3BlcnR5IG9uIGBldmVudC5zdGFja0l0ZW0ubWV0YWAgKGl0IGlzIGEgYE1hcGAgb2YgbWV0YWRhdGEgcHJvcGVydGllcykuXG4gKiBGaXJlcyAnc3RhY2staXRlbS1wb3BwZWQnIGV2ZW50IHdoZW4gYSBzdGFjayBpdGVtIHdhcyBwb3BwZWQgZnJvbSBlaXRoZXIgdGhlXG4gKiB1bmRvLSBvciB0aGUgcmVkby1zdGFjay4gWW91IG1heSByZXN0b3JlIHRoZSBzYXZlZCBzdGFjayBpbmZvcm1hdGlvbiBmcm9tIGBldmVudC5zdGFja0l0ZW0ubWV0YWAuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8J3N0YWNrLWl0ZW0tYWRkZWQnfCdzdGFjay1pdGVtLXBvcHBlZCc+fVxuICovXG5jbGFzcyBVbmRvTWFuYWdlciBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55PnxBcnJheTxBYnN0cmFjdFR5cGU8YW55Pj59IHR5cGVTY29wZSBBY2NlcHRzIGVpdGhlciBhIHNpbmdsZSB0eXBlLCBvciBhbiBhcnJheSBvZiB0eXBlc1xuICAgKiBAcGFyYW0ge1VuZG9NYW5hZ2VyT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGVTY29wZSwgeyBjYXB0dXJlVGltZW91dCA9IDUwMCwgZGVsZXRlRmlsdGVyID0gKCkgPT4gdHJ1ZSwgdHJhY2tlZE9yaWdpbnMgPSBuZXcgU2V0KFtudWxsXSkgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNjb3BlID0gdHlwZVNjb3BlIGluc3RhbmNlb2YgQXJyYXkgPyB0eXBlU2NvcGUgOiBbdHlwZVNjb3BlXTtcbiAgICB0aGlzLmRlbGV0ZUZpbHRlciA9IGRlbGV0ZUZpbHRlcjtcbiAgICB0cmFja2VkT3JpZ2lucy5hZGQodGhpcyk7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucyA9IHRyYWNrZWRPcmlnaW5zO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMudW5kb1N0YWNrID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59XG4gICAgICovXG4gICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjbGllbnQgaXMgY3VycmVudGx5IHVuZG9pbmcgKGNhbGxpbmcgVW5kb01hbmFnZXIudW5kbylcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudW5kb2luZyA9IGZhbHNlO1xuICAgIHRoaXMucmVkb2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZG9jID0gLyoqIEB0eXBlIHtEb2N9ICovICh0aGlzLnNjb3BlWzBdLmRvYyk7XG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICB0aGlzLmRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIC8qKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAqLyB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAvLyBPbmx5IHRyYWNrIGNlcnRhaW4gdHJhbnNhY3Rpb25zXG4gICAgICBpZiAoIXRoaXMuc2NvcGUuc29tZSh0eXBlID0+IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5oYXModHlwZSkpIHx8ICghdGhpcy50cmFja2VkT3JpZ2lucy5oYXModHJhbnNhY3Rpb24ub3JpZ2luKSAmJiAoIXRyYW5zYWN0aW9uLm9yaWdpbiB8fCAhdGhpcy50cmFja2VkT3JpZ2lucy5oYXModHJhbnNhY3Rpb24ub3JpZ2luLmNvbnN0cnVjdG9yKSkpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgdW5kb2luZyA9IHRoaXMudW5kb2luZztcbiAgICAgIGNvbnN0IHJlZG9pbmcgPSB0aGlzLnJlZG9pbmc7XG4gICAgICBjb25zdCBzdGFjayA9IHVuZG9pbmcgPyB0aGlzLnJlZG9TdGFjayA6IHRoaXMudW5kb1N0YWNrO1xuICAgICAgaWYgKHVuZG9pbmcpIHtcbiAgICAgICAgdGhpcy5zdG9wQ2FwdHVyaW5nKCk7IC8vIG5leHQgdW5kbyBzaG91bGQgbm90IGJlIGFwcGVuZGVkIHRvIGxhc3Qgc3RhY2sgaXRlbVxuICAgICAgfSBlbHNlIGlmICghcmVkb2luZykge1xuICAgICAgICAvLyBuZWl0aGVyIHVuZG9pbmcgbm9yIHJlZG9pbmc6IGRlbGV0ZSByZWRvU3RhY2tcbiAgICAgICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluc2VydGlvbnMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGVuZENsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxlbiA9IGVuZENsb2NrIC0gc3RhcnRDbG9jaztcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldChpbnNlcnRpb25zLCBjbGllbnQsIHN0YXJ0Q2xvY2ssIGxlbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgbm93ID0gZ2V0VW5peFRpbWUoKTtcbiAgICAgIGlmIChub3cgLSB0aGlzLmxhc3RDaGFuZ2UgPCBjYXB0dXJlVGltZW91dCAmJiBzdGFjay5sZW5ndGggPiAwICYmICF1bmRvaW5nICYmICFyZWRvaW5nKSB7XG4gICAgICAgIC8vIGFwcGVuZCBjaGFuZ2UgdG8gbGFzdCBzdGFjayBvcFxuICAgICAgICBjb25zdCBsYXN0T3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgbGFzdE9wLmRlbGV0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmRlbGV0aW9ucywgdHJhbnNhY3Rpb24uZGVsZXRlU2V0XSk7XG4gICAgICAgIGxhc3RPcC5pbnNlcnRpb25zID0gbWVyZ2VEZWxldGVTZXRzKFtsYXN0T3AuaW5zZXJ0aW9ucywgaW5zZXJ0aW9uc10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHN0YWNrIG9wXG4gICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrSXRlbSh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGluc2VydGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBub3c7XG4gICAgICB9XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBkZWxldGVkIHN0cnVjdHMgYXJlIG5vdCBnYydkXG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgLyoqIEBwYXJhbSB7SXRlbXxHQ30gaXRlbSAqLyBpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIHRoaXMuc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICAgICAga2VlcEl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KCdzdGFjay1pdGVtLWFkZGVkJywgW3sgc3RhY2tJdGVtOiBzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgb3JpZ2luOiB0cmFuc2FjdGlvbi5vcmlnaW4sIHR5cGU6IHVuZG9pbmcgPyAncmVkbycgOiAndW5kbycsIGNoYW5nZWRQYXJlbnRUeXBlczogdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzIH0sIHRoaXNdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsZWFyICgpIHtcbiAgICB0aGlzLmRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7U3RhY2tJdGVtfSBzdGFja0l0ZW1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2xlYXJJdGVtID0gc3RhY2tJdGVtID0+IHtcbiAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBpdGVtID0+IHtcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgICAgICAgIGtlZXBJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMudW5kb1N0YWNrLmZvckVhY2goY2xlYXJJdGVtKTtcbiAgICAgIHRoaXMucmVkb1N0YWNrLmZvckVhY2goY2xlYXJJdGVtKTtcbiAgICB9KTtcbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gIH1cblxuICAvKipcbiAgICogVW5kb01hbmFnZXIgbWVyZ2VzIFVuZG8tU3RhY2tJdGVtIGlmIHRoZXkgYXJlIGNyZWF0ZWQgd2l0aGluIHRpbWUtZ2FwXG4gICAqIHNtYWxsZXIgdGhhbiBgb3B0aW9ucy5jYXB0dXJlVGltZW91dGAuIENhbGwgYHVtLnN0b3BDYXB0dXJpbmcoKWAgc28gdGhhdCB0aGUgbmV4dFxuICAgKiBTdGFja0l0ZW0gd29uJ3QgYmUgbWVyZ2VkLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgLy8gd2l0aG91dCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDEsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnJyAobm90ZSB0aGF0ICdhYicgd2FzIHJlbW92ZWQpXG4gICAqICAgICAvLyB3aXRoIHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB1bS5zdG9wQ2FwdHVyaW5nKClcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJ2EnIChub3RlIHRoYXQgb25seSAnYicgd2FzIHJlbW92ZWQpXG4gICAqXG4gICAqL1xuICBzdG9wQ2FwdHVyaW5nICgpIHtcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZG8gbGFzdCBjaGFuZ2VzIG9uIHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICB1bmRvICgpIHtcbiAgICB0aGlzLnVuZG9pbmcgPSB0cnVlO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnVuZG9TdGFjaywgJ3VuZG8nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy51bmRvaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRvIGxhc3QgdW5kbyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICByZWRvICgpIHtcbiAgICB0aGlzLnJlZG9pbmcgPSB0cnVlO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnJlZG9TdGFjaywgJ3JlZG8nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWRvaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKi9cbmZ1bmN0aW9uICogbGF6eVN0cnVjdFJlYWRlckdlbmVyYXRvciAoZGVjb2Rlcikge1xuICBjb25zdCBudW1PZlN0YXRlVXBkYXRlcyA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mU3RhdGVVcGRhdGVzOyBpKyspIHtcbiAgICBjb25zdCBudW1iZXJPZlN0cnVjdHMgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKTtcbiAgICBsZXQgY2xvY2sgPSByZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mU3RydWN0czsgaSsrKSB7XG4gICAgICBjb25zdCBpbmZvID0gZGVjb2Rlci5yZWFkSW5mbygpO1xuICAgICAgLy8gQHRvZG8gdXNlIHN3aXRjaCBpbnN0ZWFkIG9mIGlmc1xuICAgICAgaWYgKGluZm8gPT09IDEwKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgICAgICB5aWVsZCBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKTtcbiAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgfSBlbHNlIGlmICgoQklUUzUgJiBpbmZvKSAhPT0gMCkge1xuICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChCSVQ3IHwgQklUOCkpID09PSAwO1xuICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IEl0ZW0oXG4gICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgbnVsbCwgLy8gbGVmdFxuICAgICAgICAgIChpbmZvICYgQklUOCkgPT09IEJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgKGluZm8gJiBCSVQ3KSA9PT0gQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGwsIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRm9yY2Ugd3JpdGluZyBhIHN0cmluZyBoZXJlLlxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIEJJVDYpID09PSBCSVQ2ID8gZGVjb2Rlci5yZWFkU3RyaW5nKCkgOiBudWxsLCAvLyBwYXJlbnRTdWJcbiAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICk7XG4gICAgICAgIHlpZWxkIHN0cnVjdDtcbiAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICAgICAgICB5aWVsZCBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgTGF6eVN0cnVjdFJlYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlclNraXBzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2RlciwgZmlsdGVyU2tpcHMpIHtcbiAgICB0aGlzLmdlbiA9IGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBJdGVtIHwgU2tpcCB8IEdDfVxuICAgICAqL1xuICAgIHRoaXMuY3VyciA9IG51bGw7XG4gICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJTa2lwcyA9IGZpbHRlclNraXBzO1xuICAgIHRoaXMubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZW0gfCBHQyB8IFNraXAgfG51bGx9XG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvLyBpZ25vcmUgXCJTa2lwXCIgc3RydWN0c1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY3VyciA9IHRoaXMuZ2VuLm5leHQoKS52YWx1ZSB8fCBudWxsO1xuICAgIH0gd2hpbGUgKHRoaXMuZmlsdGVyU2tpcHMgJiYgdGhpcy5jdXJyICE9PSBudWxsICYmIHRoaXMuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcClcbiAgICByZXR1cm4gdGhpcy5jdXJyXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICpcbiAqL1xuY29uc3QgbG9nVXBkYXRlID0gdXBkYXRlID0+IGxvZ1VwZGF0ZVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gW1lEZWNvZGVyXVxuICpcbiAqL1xuY29uc3QgbG9nVXBkYXRlVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW107XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSk7XG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpO1xuICB9XG4gIHByaW50KCdTdHJ1Y3RzOiAnLCBzdHJ1Y3RzKTtcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpO1xuICBwcmludCgnRGVsZXRlU2V0OiAnLCBkcyk7XG59O1xuXG5jbGFzcyBMYXp5U3RydWN0V3JpdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW5jb2Rlcikge1xuICAgIHRoaXMuY3VyckNsaWVudCA9IDA7XG4gICAgdGhpcy5zdGFydENsb2NrID0gMDtcbiAgICB0aGlzLndyaXR0ZW4gPSAwO1xuICAgIHRoaXMuZW5jb2RlciA9IGVuY29kZXI7XG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byB3cml0ZSBvcGVyYXRpb25zIGxhemlseSwgYnV0IGFsc28gd2UgbmVlZCB0byBrbm93IGJlZm9yZWhhbmQgaG93IG1hbnkgb3BlcmF0aW9ucyB3ZSB3YW50IHRvIHdyaXRlIGZvciBlYWNoIGNsaWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMga2luZCBvZiBtZXRhLWluZm9ybWF0aW9uICgjY2xpZW50cywgI3N0cnVjdHMtcGVyLWNsaWVudC13cml0dGVuKSBpcyB3cml0dGVuIHRvIHRoZSByZXN0RW5jb2Rlci5cbiAgICAgKlxuICAgICAqIFdlIGZyYWdtZW50IHRoZSByZXN0RW5jb2RlciBhbmQgc3RvcmUgYSBzbGljZSBvZiBpdCBwZXItY2xpZW50IHVudGlsIHdlIGtub3cgaG93IG1hbnkgY2xpZW50cyB0aGVyZSBhcmUuXG4gICAgICogV2hlbiB3ZSBmbHVzaCAodG9VaW50OEFycmF5KSB3ZSB3cml0ZSB0aGUgcmVzdEVuY29kZXIgdXNpbmcgdGhlIGZyYWdtZW50cyBhbmQgdGhlIG1ldGEtaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8eyB3cml0dGVuOiBudW1iZXIsIHJlc3RFbmNvZGVyOiBVaW50OEFycmF5IH0+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50U3RydWN0cyA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxVaW50OEFycmF5Pn0gdXBkYXRlc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgbWVyZ2VVcGRhdGVzID0gdXBkYXRlcyA9PiBtZXJnZVVwZGF0ZXNWMih1cGRhdGVzLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIERTRW5jb2RlclYxIHwgdHlwZW9mIERTRW5jb2RlclYyfSBZRW5jb2RlclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gWURlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyID0gKHVwZGF0ZSwgWUVuY29kZXIgPSBEU0VuY29kZXJWMiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIobmV3IFlEZWNvZGVyKGNyZWF0ZURlY29kZXIodXBkYXRlKSksIHRydWUpO1xuICBsZXQgY3VyciA9IHVwZGF0ZURlY29kZXIuY3VycjtcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgc2l6ZSA9IDE7XG4gICAgbGV0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICBsZXQgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jaztcbiAgICBsZXQgc3RvcENvdW50aW5nID0gZmFsc2U7XG4gICAgZm9yICg7IGN1cnIgIT09IG51bGw7IGN1cnIgPSB1cGRhdGVEZWNvZGVyLm5leHQoKSkge1xuICAgICAgaWYgKGN1cnJDbGllbnQgIT09IGN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgIHNpemUrKztcbiAgICAgICAgLy8gV2UgZm91bmQgYSBuZXcgY2xpZW50XG4gICAgICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZSB0byB0aGUgZW5jb2RlclxuICAgICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudCk7XG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spO1xuICAgICAgICBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgICAgIHN0b3BDb3VudGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnIuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgc3RvcENvdW50aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RvcENvdW50aW5nKSB7XG4gICAgICAgIGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JpdGUgd2hhdCB3ZSBoYXZlXG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbGllbnQpO1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spO1xuICAgIC8vIHByZXBlbmQgdGhlIHNpemUgb2YgdGhlIHN0YXRlIHZlY3RvclxuICAgIGNvbnN0IGVuYyA9IGNyZWF0ZUVuY29kZXIoKTtcbiAgICB3cml0ZVZhclVpbnQoZW5jLCBzaXplKTtcbiAgICB3cml0ZUJpbmFyeUVuY29kZXIoZW5jLCBlbmNvZGVyLnJlc3RFbmNvZGVyKTtcbiAgICBlbmNvZGVyLnJlc3RFbmNvZGVyID0gZW5jO1xuICAgIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG4gIH0gZWxzZSB7XG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZSA9IHVwZGF0ZSA9PiBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMih1cGRhdGUsIERTRW5jb2RlclYxLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuY29uc3QgcGFyc2VVcGRhdGVNZXRhVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICBjb25zdCBmcm9tID0gbmV3IE1hcCgpO1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIG51bWJlcj59XG4gICAqL1xuICBjb25zdCB0byA9IG5ldyBNYXAoKTtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihjcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCBmYWxzZSk7XG4gIGxldCBjdXJyID0gdXBkYXRlRGVjb2Rlci5jdXJyO1xuICBpZiAoY3VyciAhPT0gbnVsbCkge1xuICAgIGxldCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgbGV0IGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2s7XG4gICAgLy8gd3JpdGUgdGhlIGJlZ2lubmluZyB0byBgZnJvbWBcbiAgICBmcm9tLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spO1xuICAgIGZvciAoOyBjdXJyICE9PSBudWxsOyBjdXJyID0gdXBkYXRlRGVjb2Rlci5uZXh0KCkpIHtcbiAgICAgIGlmIChjdXJyQ2xpZW50ICE9PSBjdXJyLmlkLmNsaWVudCkge1xuICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgICAgIHRvLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spO1xuICAgICAgICAvLyB3cml0ZSB0aGUgYmVnaW5uaW5nIHRvIGBmcm9tYFxuICAgICAgICBmcm9tLnNldChjdXJyLmlkLmNsaWVudCwgY3Vyci5pZC5jbG9jayk7XG4gICAgICAgIC8vIHVwZGF0ZSBjdXJyQ2xpZW50XG4gICAgICAgIGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICAgIH1cbiAgICAgIGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgdG8uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jayk7XG4gIH1cbiAgcmV0dXJuIHsgZnJvbSwgdG8gfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHJldHVybiB7eyBmcm9tOiBNYXA8bnVtYmVyLG51bWJlcj4sIHRvOiBNYXA8bnVtYmVyLG51bWJlcj4gfX1cbiAqL1xuY29uc3QgcGFyc2VVcGRhdGVNZXRhID0gdXBkYXRlID0+IHBhcnNlVXBkYXRlTWV0YVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbnRlbmRlZCB0byBzbGljZSBhbnkga2luZCBvZiBzdHJ1Y3QgYW5kIHJldHJpZXZlIHRoZSByaWdodCBwYXJ0LlxuICogSXQgZG9lcyBub3QgaGFuZGxlIHNpZGUtZWZmZWN0cywgc28gaXQgc2hvdWxkIG9ubHkgYmUgdXNlZCBieSB0aGUgbGF6eS1lbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7SXRlbSB8IEdDIHwgU2tpcH0gbGVmdFxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW0gfCBHQ31cbiAqL1xuY29uc3Qgc2xpY2VTdHJ1Y3QgPSAobGVmdCwgZGlmZikgPT4ge1xuICBpZiAobGVmdC5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWQ7XG4gICAgcmV0dXJuIG5ldyBHQyhjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksIGxlZnQubGVuZ3RoIC0gZGlmZilcbiAgfSBlbHNlIGlmIChsZWZ0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0LmlkO1xuICAgIHJldHVybiBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksIGxlZnQubGVuZ3RoIC0gZGlmZilcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZWZ0SXRlbSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKGxlZnQpO1xuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdEl0ZW0uaWQ7XG4gICAgcmV0dXJuIG5ldyBJdGVtKFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLFxuICAgICAgbnVsbCxcbiAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmIC0gMSksXG4gICAgICBudWxsLFxuICAgICAgbGVmdEl0ZW0ucmlnaHRPcmlnaW4sXG4gICAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgICBsZWZ0SXRlbS5wYXJlbnRTdWIsXG4gICAgICBsZWZ0SXRlbS5jb250ZW50LnNwbGljZShkaWZmKVxuICAgIClcbiAgfVxufTtcblxuLyoqXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b3JrcyBzaW1pbGFybHkgdG8gYHJlYWRVcGRhdGVWMmAuXG4gKlxuICogQHBhcmFtIHtBcnJheTxVaW50OEFycmF5Pn0gdXBkYXRlc1xuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYxIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMn0gW1lFbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgbWVyZ2VVcGRhdGVzVjIgPSAodXBkYXRlcywgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIsIFlFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYyKSA9PiB7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXJzID0gdXBkYXRlcy5tYXAodXBkYXRlID0+IG5ldyBZRGVjb2RlcihjcmVhdGVEZWNvZGVyKHVwZGF0ZSkpKTtcbiAgbGV0IGxhenlTdHJ1Y3REZWNvZGVycyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIHRydWUpKTtcblxuICAvKipcbiAgICogQHRvZG8gd2UgZG9uJ3QgbmVlZCBvZmZzZXQgYmVjYXVzZSB3ZSBhbHdheXMgc2xpY2UgYmVmb3JlXG4gICAqIEB0eXBlIHtudWxsIHwgeyBzdHJ1Y3Q6IEl0ZW0gfCBHQyB8IFNraXAsIG9mZnNldDogbnVtYmVyIH19XG4gICAqL1xuICBsZXQgY3VycldyaXRlID0gbnVsbDtcblxuICBjb25zdCB1cGRhdGVFbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIC8vIHdyaXRlIHN0cnVjdHMgbGF6aWx5XG4gIGNvbnN0IGxhenlTdHJ1Y3RFbmNvZGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIodXBkYXRlRW5jb2Rlcik7XG5cbiAgLy8gTm90ZTogV2UgbmVlZCB0byBlbnN1cmUgdGhhdCBhbGwgbGF6eVN0cnVjdERlY29kZXJzIGFyZSBmdWxseSBjb25zdW1lZFxuICAvLyBOb3RlOiBTaG91bGQgbWVyZ2UgZG9jdW1lbnQgdXBkYXRlcyB3aGVuZXZlciBwb3NzaWJsZSAtIGV2ZW4gZnJvbSBkaWZmZXJlbnQgdXBkYXRlc1xuICAvLyBOb3RlOiBTaG91bGQgaGFuZGxlIHRoYXQgc29tZSBvcGVyYXRpb25zIGNhbm5vdCBiZSBhcHBsaWVkIHlldCAoKVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gV3JpdGUgaGlnaGVyIGNsaWVudHMgZmlyc3Qg4oeSIHNvcnQgYnkgY2xpZW50SUQgJiBjbG9jayBhbmQgcmVtb3ZlIGRlY29kZXJzIHdpdGhvdXQgY29udGVudFxuICAgIGxhenlTdHJ1Y3REZWNvZGVycyA9IGxhenlTdHJ1Y3REZWNvZGVycy5maWx0ZXIoZGVjID0+IGRlYy5jdXJyICE9PSBudWxsKTtcbiAgICBsYXp5U3RydWN0RGVjb2RlcnMuc29ydChcbiAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oYW55LGFueSk6bnVtYmVyfSAqLyAoZGVjMSwgZGVjMikgPT4ge1xuICAgICAgICBpZiAoZGVjMS5jdXJyLmlkLmNsaWVudCA9PT0gZGVjMi5jdXJyLmlkLmNsaWVudCkge1xuICAgICAgICAgIGNvbnN0IGNsb2NrRGlmZiA9IGRlYzEuY3Vyci5pZC5jbG9jayAtIGRlYzIuY3Vyci5pZC5jbG9jaztcbiAgICAgICAgICBpZiAoY2xvY2tEaWZmID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjMS5jdXJyLmNvbnN0cnVjdG9yID09PSBkZWMyLmN1cnIuY29uc3RydWN0b3IgPyAwIDogKFxuICAgICAgICAgICAgICBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXAgPyAxIDogLTFcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNsb2NrRGlmZlxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVjMi5jdXJyLmlkLmNsaWVudCAtIGRlYzEuY3Vyci5pZC5jbGllbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKGxhenlTdHJ1Y3REZWNvZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNvbnN0IGN1cnJEZWNvZGVyID0gbGF6eVN0cnVjdERlY29kZXJzWzBdO1xuICAgIC8vIHdyaXRlIGZyb20gY3VyckRlY29kZXIgdW50aWwgdGhlIG5leHQgb3BlcmF0aW9uIGlzIGZyb20gYW5vdGhlciBjbGllbnQgb3IgaWYgZmlsbGVyLXN0cnVjdFxuICAgIC8vIHRoZW4gd2UgbmVlZCB0byByZW9yZGVyIHRoZSBkZWNvZGVycyBhbmQgZmluZCB0aGUgbmV4dCBvcGVyYXRpb24gdG8gd3JpdGVcbiAgICBjb25zdCBmaXJzdENsaWVudCA9IC8qKiBAdHlwZSB7SXRlbSB8IEdDfSAqLyAoY3VyckRlY29kZXIuY3VycikuaWQuY2xpZW50O1xuXG4gICAgaWYgKGN1cnJXcml0ZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IGN1cnIgPSAvKiogQHR5cGUge0l0ZW0gfCBHQyB8IG51bGx9ICovIChjdXJyRGVjb2Rlci5jdXJyKTtcblxuICAgICAgLy8gaXRlcmF0ZSB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB0aGF0IHdlIGhhdmVuJ3Qgd3JpdHRlbiBhbHJlYWR5XG4gICAgICAvLyByZW1lbWJlcjogZmlyc3QgdGhlIGhpZ2ggY2xpZW50LWlkcyBhcmUgd3JpdHRlblxuICAgICAgd2hpbGUgKGN1cnIgIT09IG51bGwgJiYgY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoIDw9IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAmJiBjdXJyLmlkLmNsaWVudCA+PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsaWVudCkge1xuICAgICAgICBjdXJyID0gY3VyckRlY29kZXIubmV4dCgpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnIgPT09IG51bGwgfHwgY3Vyci5pZC5jbGllbnQgIT09IGZpcnN0Q2xpZW50KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdENsaWVudCAhPT0gY3VycldyaXRlLnN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPCBjdXJyLmlkLmNsb2NrKSB7XG4gICAgICAgICAgLy8gQHRvZG8gd3JpdGUgY3VyclN0cnVjdCAmIHNldCBjdXJyU3RydWN0ID0gU2tpcChjbG9jayA9IGN1cnJTdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyU3RydWN0Lmxlbmd0aCwgbGVuZ3RoID0gY3Vyci5pZC5jbG9jayAtIHNlbGYuY2xvY2spXG4gICAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgICAgIC8vIGV4dGVuZCBleGlzdGluZyBza2lwXG4gICAgICAgICAgICBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCAtIGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjdXJyLmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayAtIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7U2tpcH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IFNraXAoY3JlYXRlSUQoZmlyc3RDbGllbnQsIGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCksIGRpZmYpO1xuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3QsIG9mZnNldDogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA+PSBjdXJyLmlkLmNsb2NrKSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtIGN1cnIuaWQuY2xvY2s7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICAgICAgICAvLyBwcmVmZXIgdG8gc2xpY2UgU2tpcCBiZWNhdXNlIHRoZSBvdGhlciBzdHJ1Y3QgbWlnaHQgY29udGFpbiBtb3JlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIC09IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gc2xpY2VTdHJ1Y3QoY3VyciwgZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY3VycldyaXRlLnN0cnVjdC5tZXJnZVdpdGgoLyoqIEB0eXBlIHthbnl9ICovIChjdXJyKSkpIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBjdXJyLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IC8qKiBAdHlwZSB7SXRlbSB8IEdDfSAqLyAoY3VyckRlY29kZXIuY3VyciksIG9mZnNldDogMCB9O1xuICAgICAgY3VyckRlY29kZXIubmV4dCgpO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgbGV0IG5leHQgPSBjdXJyRGVjb2Rlci5jdXJyO1xuICAgICAgbmV4dCAhPT0gbnVsbCAmJiBuZXh0LmlkLmNsaWVudCA9PT0gZmlyc3RDbGllbnQgJiYgbmV4dC5pZC5jbG9jayA9PT0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIG5leHQuY29uc3RydWN0b3IgIT09IFNraXA7XG4gICAgICBuZXh0ID0gY3VyckRlY29kZXIubmV4dCgpXG4gICAgKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogbmV4dCwgb2Zmc2V0OiAwIH07XG4gICAgfVxuICB9XG4gIGlmIChjdXJyV3JpdGUgIT09IG51bGwpIHtcbiAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgY3VycldyaXRlID0gbnVsbDtcbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5U3RydWN0RW5jb2Rlcik7XG5cbiAgY29uc3QgZHNzID0gdXBkYXRlRGVjb2RlcnMubWFwKGRlY29kZXIgPT4gcmVhZERlbGV0ZVNldChkZWNvZGVyKSk7XG4gIGNvbnN0IGRzID0gbWVyZ2VEZWxldGVTZXRzKGRzcyk7XG4gIHdyaXRlRGVsZXRlU2V0KHVwZGF0ZUVuY29kZXIsIGRzKTtcbiAgcmV0dXJuIHVwZGF0ZUVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc3ZcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqL1xuY29uc3QgZGlmZlVwZGF0ZVYyID0gKHVwZGF0ZSwgc3YsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyLCBZRW5jb2RlciA9IFVwZGF0ZUVuY29kZXJWMikgPT4ge1xuICBjb25zdCBzdGF0ZSA9IGRlY29kZVN0YXRlVmVjdG9yKHN2KTtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICBjb25zdCBsYXp5U3RydWN0V3JpdGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIoZW5jb2Rlcik7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgWURlY29kZXIoY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgcmVhZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIoZGVjb2RlciwgZmFsc2UpO1xuICB3aGlsZSAocmVhZGVyLmN1cnIpIHtcbiAgICBjb25zdCBjdXJyID0gcmVhZGVyLmN1cnI7XG4gICAgY29uc3QgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgIGNvbnN0IHN2Q2xvY2sgPSBzdGF0ZS5nZXQoY3VyckNsaWVudCkgfHwgMDtcbiAgICBpZiAocmVhZGVyLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgIC8vIHRoZSBmaXJzdCB3cml0dGVuIHN0cnVjdCBzaG91bGRuJ3QgYmUgYSBza2lwXG4gICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCA+IHN2Q2xvY2spIHtcbiAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIGN1cnIsIG1heChzdkNsb2NrIC0gY3Vyci5pZC5jbG9jaywgMCkpO1xuICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIHdoaWxlIChyZWFkZXIuY3VyciAmJiByZWFkZXIuY3Vyci5pZC5jbGllbnQgPT09IGN1cnJDbGllbnQpIHtcbiAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdFdyaXRlciwgcmVhZGVyLmN1cnIsIDApO1xuICAgICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFkIHVudGlsIHNvbWV0aGluZyBuZXcgY29tZXMgdXBcbiAgICAgIHdoaWxlIChyZWFkZXIuY3VyciAmJiByZWFkZXIuY3Vyci5pZC5jbGllbnQgPT09IGN1cnJDbGllbnQgJiYgcmVhZGVyLmN1cnIuaWQuY2xvY2sgKyByZWFkZXIuY3Vyci5sZW5ndGggPD0gc3ZDbG9jaykge1xuICAgICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5U3RydWN0V3JpdGVyKTtcbiAgLy8gd3JpdGUgZHNcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KGRlY29kZXIpO1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKi9cbmNvbnN0IGRpZmZVcGRhdGUgPSAodXBkYXRlLCBzdikgPT4gZGlmZlVwZGF0ZVYyKHVwZGF0ZSwgc3YsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqL1xuY29uc3QgZmx1c2hMYXp5U3RydWN0V3JpdGVyID0gbGF6eVdyaXRlciA9PiB7XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwKSB7XG4gICAgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLnB1c2goeyB3cml0dGVuOiBsYXp5V3JpdGVyLndyaXR0ZW4sIHJlc3RFbmNvZGVyOiB0b1VpbnQ4QXJyYXkobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyKSB9KTtcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIgPSBjcmVhdGVFbmNvZGVyKCk7XG4gICAgbGF6eVdyaXRlci53cml0dGVuID0gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqIEBwYXJhbSB7SXRlbSB8IEdDfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuY29uc3Qgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIgPSAobGF6eVdyaXRlciwgc3RydWN0LCBvZmZzZXQpID0+IHtcbiAgLy8gZmx1c2ggY3VyciBpZiB3ZSBzdGFydCBhbm90aGVyIGNsaWVudFxuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCAmJiBsYXp5V3JpdGVyLmN1cnJDbGllbnQgIT09IHN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICBmbHVzaExhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlcik7XG4gIH1cbiAgaWYgKGxhenlXcml0ZXIud3JpdHRlbiA9PT0gMCkge1xuICAgIGxhenlXcml0ZXIuY3VyckNsaWVudCA9IHN0cnVjdC5pZC5jbGllbnQ7XG4gICAgLy8gd3JpdGUgbmV4dCBjbGllbnRcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIud3JpdGVDbGllbnQoc3RydWN0LmlkLmNsaWVudCk7XG4gICAgLy8gd3JpdGUgc3RhcnRDbG9ja1xuICAgIHdyaXRlVmFyVWludChsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdC5pZC5jbG9jayArIG9mZnNldCk7XG4gIH1cbiAgc3RydWN0LndyaXRlKGxhenlXcml0ZXIuZW5jb2Rlciwgb2Zmc2V0KTtcbiAgbGF6eVdyaXRlci53cml0dGVuKys7XG59O1xuLyoqXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gd2hlbiB3ZSBjb2xsZWN0ZWQgYWxsIHBhcnRzIGFuZCB3YW50IHRvXG4gKiBwdXQgYWxsIHRoZSBwYXJ0cyB0b2dldGhlci4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAqIHlvdSBjYW4gY29udGludWUgdXNpbmcgdGhlIFVwZGF0ZUVuY29kZXIuXG4gKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKi9cbmNvbnN0IGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nID0gKGxhenlXcml0ZXIpID0+IHtcbiAgZmx1c2hMYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIpO1xuXG4gIC8vIHRoaXMgaXMgYSBmcmVzaCBlbmNvZGVyIGJlY2F1c2Ugd2UgY2FsbGVkIGZsdXNoQ3VyclxuICBjb25zdCByZXN0RW5jb2RlciA9IGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlcjtcblxuICAvKipcbiAgICogTm93IHdlIHB1dCBhbGwgdGhlIGZyYWdtZW50cyB0b2dldGhlci5cbiAgICogVGhpcyB3b3JrcyBzaW1pbGFybHkgdG8gYHdyaXRlQ2xpZW50c1N0cnVjdHNgXG4gICAqL1xuXG4gIC8vIHdyaXRlICMgc3RhdGVzIHRoYXQgd2VyZSB1cGRhdGVkIC0gaS5lLiB0aGUgY2xpZW50c1xuICB3cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFydFN0cnVjdHMgPSBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHNbaV07XG4gICAgLyoqXG4gICAgICogV29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZVN0cnVjdHNgXG4gICAgICovXG4gICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICB3cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLndyaXR0ZW4pO1xuICAgIC8vIHdyaXRlIHRoZSByZXN0IG9mIHRoZSBmcmFnbWVudFxuICAgIHdyaXRlVWludDhBcnJheShyZXN0RW5jb2RlciwgcGFydFN0cnVjdHMucmVzdEVuY29kZXIpO1xuICB9XG59O1xuXG4vKipcbiAqIFlFdmVudCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVHlwZS5cbiAqL1xuY2xhc3MgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHRhcmdldCBUaGUgY2hhbmdlZCB0eXBlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgdHJhbnNhY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvbiB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkIG9uLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB0YXJnZXQgb24gd2hpY2ggdGhlIG9ic2VydmUgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fY2hhbmdlcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBNYXA8c3RyaW5nLCB7IGFjdGlvbjogJ2FkZCcgfCAndXBkYXRlJyB8ICdkZWxldGUnLCBvbGRWYWx1ZTogYW55LCBuZXdWYWx1ZTogYW55IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2tleXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8eyBpbnNlcnQ/OiBzdHJpbmcgfCBBcnJheTxhbnk+LCByZXRhaW4/OiBudW1iZXIsIGRlbGV0ZT86IG51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsIGFueT4gfT59XG4gICAgICovXG4gICAgdGhpcy5fZGVsdGEgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBwYXRoIGZyb20gYHlgIHRvIHRoZSBjaGFuZ2VkIHR5cGUuXG4gICAqXG4gICAqIEB0b2RvIHYxNCBzaG91bGQgc3RhbmRhcmRpemUgb24gcGF0aDogQXJyYXk8e3BhcmVudCwgaW5kZXh9PiBiZWNhdXNlIHRoYXQgaXMgZWFzaWVyIHRvIHdvcmsgd2l0aC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0eSBob2xkczpcbiAgICogQGV4YW1wbGVcbiAgICogICBsZXQgdHlwZSA9IHlcbiAgICogICBldmVudC5wYXRoLmZvckVhY2goZGlyID0+IHtcbiAgICogICAgIHR5cGUgPSB0eXBlLmdldChkaXIpXG4gICAqICAgfSlcbiAgICogICB0eXBlID09PSBldmVudC50YXJnZXQgLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZ2V0IHBhdGggKCkge1xuICAgIC8vIEB0cy1pZ25vcmUgX2l0ZW0gaXMgZGVmaW5lZCBiZWNhdXNlIHRhcmdldCBpcyBpbnRlZ3JhdGVkXG4gICAgcmV0dXJuIGdldFBhdGhUbyh0aGlzLmN1cnJlbnRUYXJnZXQsIHRoaXMudGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RydWN0IGlzIGRlbGV0ZWQgYnkgdGhpcyBldmVudC5cbiAgICpcbiAgICogSW4gY29udHJhc3QgdG8gY2hhbmdlLmRlbGV0ZWQsIHRoaXMgbWV0aG9kIGFsc28gcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJ1Y3Qgd2FzIGFkZGVkIGFuZCB0aGVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHN0cnVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZGVsZXRlcyAoc3RydWN0KSB7XG4gICAgcmV0dXJuIGlzRGVsZXRlZCh0aGlzLnRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgc3RydWN0LmlkKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCB7IGFjdGlvbjogJ2FkZCcgfCAndXBkYXRlJyB8ICdkZWxldGUnLCBvbGRWYWx1ZTogYW55LCBuZXdWYWx1ZTogYW55IH0+fVxuICAgKi9cbiAgZ2V0IGtleXMgKCkge1xuICAgIGlmICh0aGlzLl9rZXlzID09PSBudWxsKSB7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICBjb25zdCBjaGFuZ2VkID0gLyoqIEB0eXBlIFNldDxzdHJpbmd8bnVsbD4gKi8gKHRoaXMudHJhbnNhY3Rpb24uY2hhbmdlZC5nZXQodGFyZ2V0KSk7XG4gICAgICBjaGFuZ2VkLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovICh0YXJnZXQuX21hcC5nZXQoa2V5KSk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUgeydkZWxldGUnIHwgJ2FkZCcgfCAndXBkYXRlJ31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgYWN0aW9uO1xuICAgICAgICAgIGxldCBvbGRWYWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGl0ZW0ubGVmdDtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICE9PSBudWxsICYmIHRoaXMuYWRkcyhwcmV2KSkge1xuICAgICAgICAgICAgICBwcmV2ID0gcHJldi5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHRoaXMuZGVsZXRlcyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gbGFzdChwcmV2LmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAnYWRkJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGxhc3QoLyoqIEB0eXBlIHtJdGVtfSAqLyBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAvLyBub3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAga2V5cy5zZXQoa2V5LCB7IGFjdGlvbiwgb2xkVmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OiBzdHJpbmcgfCBBcnJheTxhbnk+LCByZXRhaW4/OiBudW1iZXIsIGRlbGV0ZT86IG51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsIGFueT59Pn1cbiAgICovXG4gIGdldCBkZWx0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5kZWx0YVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RydWN0IGlzIGFkZGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFkZHMgKHN0cnVjdCkge1xuICAgIHJldHVybiBzdHJ1Y3QuaWQuY2xvY2sgPj0gKHRoaXMudHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KHN0cnVjdC5pZC5jbGllbnQpIHx8IDApXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBsZXQgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXM7XG4gICAgaWYgKGNoYW5nZXMgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgY29uc3QgYWRkZWQgPSBjcmVhdGUkMSgpO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IGNyZWF0ZSQxKCk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0OkFycmF5PGFueT59fHtkZWxldGU6bnVtYmVyfXx7cmV0YWluOm51bWJlcn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgICAgY2hhbmdlcyA9IHtcbiAgICAgICAgYWRkZWQsXG4gICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIGRlbHRhLFxuICAgICAgICBrZXlzOiB0aGlzLmtleXNcbiAgICAgIH07XG4gICAgICBjb25zdCBjaGFuZ2VkID0gLyoqIEB0eXBlIFNldDxzdHJpbmd8bnVsbD4gKi8gKHRoaXMudHJhbnNhY3Rpb24uY2hhbmdlZC5nZXQodGFyZ2V0KSk7XG4gICAgICBpZiAoY2hhbmdlZC5oYXMobnVsbCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGFzdE9wID0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFja09wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChsYXN0T3ApIHtcbiAgICAgICAgICAgIGRlbHRhLnB1c2gobGFzdE9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGl0ZW0gPSB0YXJnZXQuX3N0YXJ0OyBpdGVtICE9PSBudWxsOyBpdGVtID0gaXRlbS5yaWdodCkge1xuICAgICAgICAgIGlmIChpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkgJiYgIXRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5kZWxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgZGVsZXRlOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmRlbGV0ZSArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgZGVsZXRlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9IC8vIGVsc2Ugbm9wXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGluc2VydDogW10gfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AuaW5zZXJ0ID0gbGFzdE9wLmluc2VydC5jb25jYXQoaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIGFkZGVkLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLnJldGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyByZXRhaW46IDAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AucmV0YWluICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE9wICE9PSBudWxsICYmIGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2hhbmdlcylcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBhdGggZnJvbSB0aGlzIHR5cGUgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gYGNoaWxkYCBzaG91bGQgYmUgYWNjZXNzaWJsZSB2aWEgYHR5cGUuZ2V0KHBhdGhbMF0pLmdldChwYXRoWzFdKS4uYFxuICogICBjb25zdCBwYXRoID0gdHlwZS5nZXRQYXRoVG8oY2hpbGQpXG4gKiAgIC8vIGFzc3VtaW5nIGB0eXBlIGluc3RhbmNlb2YgWUFycmF5YFxuICogICBjb25zb2xlLmxvZyhwYXRoKSAvLyBtaWdodCBsb29rIGxpa2UgPT4gWzIsICdrZXkxJ11cbiAqICAgY2hpbGQgPT09IHR5cGUuZ2V0KHBhdGhbMF0pLmdldChwYXRoWzFdKVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gY2hpbGQgdGFyZ2V0XG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gUGF0aCB0byB0aGUgdGFyZ2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRQYXRoVG8gPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChjaGlsZC5faXRlbSAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gcGFyZW50KSB7XG4gICAgaWYgKGNoaWxkLl9pdGVtLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgLy8gcGFyZW50IGlzIG1hcC1pc2hcbiAgICAgIHBhdGgudW5zaGlmdChjaGlsZC5faXRlbS5wYXJlbnRTdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgYXJyYXktaXNoXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBsZXQgYyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpLl9zdGFydDtcbiAgICAgIHdoaWxlIChjICE9PSBjaGlsZC5faXRlbSAmJiBjICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghYy5kZWxldGVkKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBjLnJpZ2h0O1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpO1xuICB9XG4gIHJldHVybiBwYXRoXG59O1xuXG5jb25zdCBtYXhTZWFyY2hNYXJrZXIgPSA4MDtcblxuLyoqXG4gKiBBIHVuaXF1ZSB0aW1lc3RhbXAgdGhhdCBpZGVudGlmaWVzIGVhY2ggbWFya2VyLlxuICpcbiAqIFRpbWUgaXMgcmVsYXRpdmUsLi4gdGhpcyBpcyBtb3JlIGxpa2UgYW4gZXZlci1pbmNyZWFzaW5nIGNsb2NrLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXAgPSAwO1xuXG5jbGFzcyBBcnJheVNlYXJjaE1hcmtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW19IHBcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBjb25zdHJ1Y3RvciAocCwgaW5kZXgpIHtcbiAgICBwLm1hcmtlciA9IHRydWU7XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlTZWFyY2hNYXJrZXJ9IG1hcmtlclxuICovXG5jb25zdCByZWZyZXNoTWFya2VyVGltZXN0YW1wID0gbWFya2VyID0+IHsgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrOyB9O1xuXG4vKipcbiAqIFRoaXMgaXMgcmF0aGVyIGNvbXBsZXggc28gdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25seSB0aGluZyB0aGF0IHNob3VsZCBvdmVyd3JpdGUgYSBtYXJrZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG92ZXJ3cml0ZU1hcmtlciA9IChtYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIG1hcmtlci5wLm1hcmtlciA9IGZhbHNlO1xuICBtYXJrZXIucCA9IHA7XG4gIHAubWFya2VyID0gdHJ1ZTtcbiAgbWFya2VyLmluZGV4ID0gaW5kZXg7XG4gIG1hcmtlci50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtJdGVtfSBwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgbWFya1Bvc2l0aW9uID0gKHNlYXJjaE1hcmtlciwgcCwgaW5kZXgpID0+IHtcbiAgaWYgKHNlYXJjaE1hcmtlci5sZW5ndGggPj0gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gb3ZlcnJpZGUgb2xkZXN0IG1hcmtlciAod2UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgbW9yZSBvYmplY3RzKVxuICAgIGNvbnN0IG1hcmtlciA9IHNlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IGEudGltZXN0YW1wIDwgYi50aW1lc3RhbXAgPyBhIDogYik7XG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgaW5kZXgpO1xuICAgIHJldHVybiBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgbmV3IG1hcmtlclxuICAgIGNvbnN0IHBtID0gbmV3IEFycmF5U2VhcmNoTWFya2VyKHAsIGluZGV4KTtcbiAgICBzZWFyY2hNYXJrZXIucHVzaChwbSk7XG4gICAgcmV0dXJuIHBtXG4gIH1cbn07XG5cbi8qKlxuICogU2VhcmNoIG1hcmtlciBoZWxwIHVzIHRvIGZpbmQgcG9zaXRpb25zIGluIHRoZSBhc3NvY2lhdGl2ZSBhcnJheSBmYXN0ZXIuXG4gKlxuICogVGhleSBzcGVlZCB1cCB0aGUgcHJvY2VzcyBvZiBmaW5kaW5nIGEgcG9zaXRpb24gd2l0aG91dCBtdWNoIGJvb2trZWVwaW5nLlxuICpcbiAqIEEgbWF4aW11bSBvZiBgbWF4U2VhcmNoTWFya2VyYCBvYmplY3RzIGFyZSBjcmVhdGVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWx3YXlzIHJldHVybnMgYSByZWZyZXNoZWQgbWFya2VyICh1cGRhdGVkIHRpbWVzdGFtcClcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB5YXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBmaW5kTWFya2VyID0gKHlhcnJheSwgaW5kZXgpID0+IHtcbiAgaWYgKHlhcnJheS5fc3RhcnQgPT09IG51bGwgfHwgaW5kZXggPT09IDAgfHwgeWFycmF5Ll9zZWFyY2hNYXJrZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IG1hcmtlciA9IHlhcnJheS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9PT0gMCA/IG51bGwgOiB5YXJyYXkuX3NlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IGFicyhpbmRleCAtIGEuaW5kZXgpIDwgYWJzKGluZGV4IC0gYi5pbmRleCkgPyBhIDogYik7XG4gIGxldCBwID0geWFycmF5Ll9zdGFydDtcbiAgbGV0IHBpbmRleCA9IDA7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBwID0gbWFya2VyLnA7XG4gICAgcGluZGV4ID0gbWFya2VyLmluZGV4O1xuICAgIHJlZnJlc2hNYXJrZXJUaW1lc3RhbXAobWFya2VyKTsgLy8gd2UgdXNlZCBpdCwgd2UgbWlnaHQgbmVlZCB0byB1c2UgaXQgYWdhaW5cbiAgfVxuICAvLyBpdGVyYXRlIHRvIHJpZ2h0IGlmIHBvc3NpYmxlXG4gIHdoaWxlIChwLnJpZ2h0ICE9PSBudWxsICYmIHBpbmRleCA8IGluZGV4KSB7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IHBpbmRleCArIHAubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwaW5kZXggKz0gcC5sZW5ndGg7XG4gICAgfVxuICAgIHAgPSBwLnJpZ2h0O1xuICB9XG4gIC8vIGl0ZXJhdGUgdG8gbGVmdCBpZiBuZWNlc3NhcnkgKG1pZ2h0IGJlIHRoYXQgcGluZGV4ID4gaW5kZXgpXG4gIHdoaWxlIChwLmxlZnQgIT09IG51bGwgJiYgcGluZGV4ID4gaW5kZXgpIHtcbiAgICBwID0gcC5sZWZ0O1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgfVxuICB9XG4gIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgcCBjYW4ndCBiZSBtZXJnZWQgd2l0aCBsZWZ0LCBiZWNhdXNlIHRoYXQgd291bGQgc2NyZXcgdXAgZXZlcnl0aGluZ1xuICAvLyBpbiB0aGF0IGNhcyBqdXN0IHJldHVybiB3aGF0IHdlIGhhdmUgKGl0IGlzIG1vc3QgbGlrZWx5IHRoZSBiZXN0IG1hcmtlciBhbnl3YXkpXG4gIC8vIGl0ZXJhdGUgdG8gbGVmdCB1bnRpbCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnRcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwLmxlZnQuaWQuY2xpZW50ID09PSBwLmlkLmNsaWVudCAmJiBwLmxlZnQuaWQuY2xvY2sgKyBwLmxlZnQubGVuZ3RoID09PSBwLmlkLmNsb2NrKSB7XG4gICAgcCA9IHAubGVmdDtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgcGluZGV4IC09IHAubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8vIEB0b2RvIHJlbW92ZSFcbiAgLy8gYXNzdXJlIHBvc2l0aW9uXG4gIC8vIHtcbiAgLy8gICBsZXQgc3RhcnQgPSB5YXJyYXkuX3N0YXJ0XG4gIC8vICAgbGV0IHBvcyA9IDBcbiAgLy8gICB3aGlsZSAoc3RhcnQgIT09IHApIHtcbiAgLy8gICAgIGlmICghc3RhcnQuZGVsZXRlZCAmJiBzdGFydC5jb3VudGFibGUpIHtcbiAgLy8gICAgICAgcG9zICs9IHN0YXJ0Lmxlbmd0aFxuICAvLyAgICAgfVxuICAvLyAgICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodClcbiAgLy8gICB9XG4gIC8vICAgaWYgKHBvcyAhPT0gcGluZGV4KSB7XG4gIC8vICAgICBkZWJ1Z2dlclxuICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKCdHb3RjaGEgcG9zaXRpb24gZmFpbCEnKVxuICAvLyAgIH1cbiAgLy8gfVxuICAvLyBpZiAobWFya2VyKSB7XG4gIC8vICAgaWYgKHdpbmRvdy5sZW5ndGhlcyA9PSBudWxsKSB7XG4gIC8vICAgICB3aW5kb3cubGVuZ3RoZXMgPSBbXVxuICAvLyAgICAgd2luZG93LmdldExlbmd0aGVzID0gKCkgPT4gd2luZG93Lmxlbmd0aGVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAvLyAgIH1cbiAgLy8gICB3aW5kb3cubGVuZ3RoZXMucHVzaChtYXJrZXIuaW5kZXggLSBwaW5kZXgpXG4gIC8vICAgY29uc29sZS5sb2coJ2Rpc3RhbmNlJywgbWFya2VyLmluZGV4IC0gcGluZGV4LCAnbGVuJywgcCAmJiBwLnBhcmVudC5sZW5ndGgpXG4gIC8vIH1cbiAgaWYgKG1hcmtlciAhPT0gbnVsbCAmJiBhYnMobWFya2VyLmluZGV4IC0gcGluZGV4KSA8IC8qKiBAdHlwZSB7WVRleHR8WUFycmF5PGFueT59ICovIChwLnBhcmVudCkubGVuZ3RoIC8gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gYWRqdXN0IGV4aXN0aW5nIG1hcmtlclxuICAgIG92ZXJ3cml0ZU1hcmtlcihtYXJrZXIsIHAsIHBpbmRleCk7XG4gICAgcmV0dXJuIG1hcmtlclxuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBuZXcgbWFya2VyXG4gICAgcmV0dXJuIG1hcmtQb3NpdGlvbih5YXJyYXkuX3NlYXJjaE1hcmtlciwgcCwgcGluZGV4KVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBtYXJrZXJzIHdoZW4gYSBjaGFuZ2UgaGFwcGVuZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBkb2luZyBhIGRlbGV0aW9uIVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBJZiBpbnNlcnRpb24sIGxlbiBpcyBwb3NpdGl2ZS4gSWYgZGVsZXRpb24sIGxlbiBpcyBuZWdhdGl2ZS5cbiAqL1xuY29uc3QgdXBkYXRlTWFya2VyQ2hhbmdlcyA9IChzZWFyY2hNYXJrZXIsIGluZGV4LCBsZW4pID0+IHtcbiAgZm9yIChsZXQgaSA9IHNlYXJjaE1hcmtlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG0gPSBzZWFyY2hNYXJrZXJbaV07XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHAgPSBtLnA7XG4gICAgICBwLm1hcmtlciA9IGZhbHNlO1xuICAgICAgLy8gSWRlYWxseSB3ZSBqdXN0IHdhbnQgdG8gZG8gYSBzaW1wbGUgcG9zaXRpb24gY29tcGFyaXNvbiwgYnV0IHRoaXMgd2lsbCBvbmx5IHdvcmsgaWZcbiAgICAgIC8vIHNlYXJjaCBtYXJrZXJzIGRvbid0IHBvaW50IHRvIGRlbGV0ZWQgaXRlbXMgZm9yIGZvcm1hdHMuXG4gICAgICAvLyBJdGVyYXRlIG1hcmtlciB0byBwcmV2IHVuZGVsZXRlZCBjb3VudGFibGUgcG9zaXRpb24gc28gd2Uga25vdyB3aGF0IHRvIGRvIHdoZW4gdXBkYXRpbmcgYSBwb3NpdGlvblxuICAgICAgd2hpbGUgKHAgJiYgKHAuZGVsZXRlZCB8fCAhcC5jb3VudGFibGUpKSB7XG4gICAgICAgIHAgPSBwLmxlZnQ7XG4gICAgICAgIGlmIChwICYmICFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgICAgICAvLyBhZGp1c3QgcG9zaXRpb24uIHRoZSBsb29wIHNob3VsZCBicmVhayBub3dcbiAgICAgICAgICBtLmluZGV4IC09IHAubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocCA9PT0gbnVsbCB8fCBwLm1hcmtlciA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyByZW1vdmUgc2VhcmNoIG1hcmtlciBpZiB1cGRhdGVkIHBvc2l0aW9uIGlzIG51bGwgb3IgaWYgcG9zaXRpb24gaXMgYWxyZWFkeSBtYXJrZWRcbiAgICAgICAgc2VhcmNoTWFya2VyLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIG0ucCA9IHA7XG4gICAgICBwLm1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IG0uaW5kZXggfHwgKGxlbiA+IDAgJiYgaW5kZXggPT09IG0uaW5kZXgpKSB7IC8vIGEgc2ltcGxlIGluZGV4IDw9IG0uaW5kZXggY2hlY2sgd291bGQgYWN0dWFsbHkgc3VmZmljZVxuICAgICAgbS5pbmRleCA9IG1heChpbmRleCwgbS5pbmRleCArIGxlbik7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFjY3VtdWxhdGUgYWxsIChsaXN0KSBjaGlsZHJlbiBvZiBhIHR5cGUgYW5kIHJldHVybiB0aGVtIGFzIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHRcbiAqIEByZXR1cm4ge0FycmF5PEl0ZW0+fVxuICovXG5jb25zdCBnZXRUeXBlQ2hpbGRyZW4gPSB0ID0+IHtcbiAgbGV0IHMgPSB0Ll9zdGFydDtcbiAgY29uc3QgYXJyID0gW107XG4gIHdoaWxlIChzKSB7XG4gICAgYXJyLnB1c2gocyk7XG4gICAgcyA9IHMucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGFyclxufTtcblxuLyoqXG4gKiBDYWxsIGV2ZW50IGxpc3RlbmVycyB3aXRoIGFuIGV2ZW50LiBUaGlzIHdpbGwgYWxzbyBhZGQgYW4gZXZlbnQgdG8gYWxsXG4gKiBwYXJlbnRzIChmb3IgYC5vYnNlcnZlRGVlcGAgaGFuZGxlcnMpLlxuICpcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59IHR5cGVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0V2ZW50VHlwZX0gZXZlbnRcbiAqL1xuY29uc3QgY2FsbFR5cGVPYnNlcnZlcnMgPSAodHlwZSwgdHJhbnNhY3Rpb24sIGV2ZW50KSA9PiB7XG4gIGNvbnN0IGNoYW5nZWRUeXBlID0gdHlwZTtcbiAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZXRJZlVuZGVmaW5lZChjaGFuZ2VkUGFyZW50VHlwZXMsIHR5cGUsICgpID0+IFtdKS5wdXNoKGV2ZW50KTtcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0eXBlLl9pdGVtLnBhcmVudCk7XG4gIH1cbiAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyhjaGFuZ2VkVHlwZS5fZUgsIGV2ZW50LCB0cmFuc2FjdGlvbik7XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEFic3RyYWN0IFlqcyBUeXBlIGNsYXNzXG4gKi9cbmNsYXNzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLEl0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RG9jfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyPEV2ZW50VHlwZSxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fZUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAvKipcbiAgICAgKiBEZWVwIGV2ZW50IGhhbmRsZXJzXG4gICAgICogQHR5cGUge0V2ZW50SGFuZGxlcjxBcnJheTxZRXZlbnQ+LFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9kRUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxhbnk+fG51bGx9XG4gICAqL1xuICBnZXQgcGFyZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbSA/IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLl9pdGVtLnBhcmVudCkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICB0aGlzLmRvYyA9IHk7XG4gICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2RlcikgeyB9XG5cbiAgLyoqXG4gICAqIFRoZSBmaXJzdCBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgX2ZpcnN0ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZRXZlbnQgYW5kIGNhbGxzIGFsbCB0eXBlIG9ic2VydmVycy5cbiAgICogTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdGhpcy5fc2VhcmNoTWFya2VyKSB7XG4gICAgICB0aGlzLl9zZWFyY2hNYXJrZXIubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgb24gdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50VHlwZSwgVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmUgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgdGhpcyB0eXBlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXk8WUV2ZW50PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgb2JzZXJ2ZURlZXAgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICB1bm9ic2VydmUgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ+LFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICB1bm9ic2VydmVEZWVwIChmKSB7XG4gICAgcmVtb3ZlRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZEVILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgdG9KU09OICgpIHt9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RTbGljZSA9ICh0eXBlLCBzdGFydCwgZW5kKSA9PiB7XG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHR5cGUuX2xlbmd0aCArIHN0YXJ0O1xuICB9XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kID0gdHlwZS5fbGVuZ3RoICsgZW5kO1xuICB9XG4gIGxldCBsZW4gPSBlbmQgLSBzdGFydDtcbiAgY29uc3QgY3MgPSBbXTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwgJiYgbGVuID4gMCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGlmIChjLmxlbmd0aCA8PSBzdGFydCkge1xuICAgICAgICBzdGFydCAtPSBjLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGMubGVuZ3RoICYmIGxlbiA+IDA7IGkrKykge1xuICAgICAgICAgIGNzLnB1c2goY1tpXSk7XG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICByZXR1cm4gY3Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0VG9BcnJheSA9IHR5cGUgPT4ge1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICByZXR1cm4gY3Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCA9ICh0eXBlLCBzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiBpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICByZXR1cm4gY3Ncbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksbnVtYmVyLGFueSk6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0Rm9yRWFjaCA9ICh0eXBlLCBmKSA9PiB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYoY1tpXSwgaW5kZXgrKywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBDLFJcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQyxudW1iZXIsQWJzdHJhY3RUeXBlPGFueT4pOlJ9IGZcbiAqIEByZXR1cm4ge0FycmF5PFI+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RNYXAgPSAodHlwZSwgZikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAqL1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgdHlwZUxpc3RGb3JFYWNoKHR5cGUsIChjLCBpKSA9PiB7XG4gICAgcmVzdWx0LnB1c2goZihjLCBpLCB0eXBlKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IgPSB0eXBlID0+IHtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxhbnk+fG51bGx9XG4gICAqL1xuICBsZXQgY3VycmVudENvbnRlbnQgPSBudWxsO1xuICBsZXQgY3VycmVudENvbnRlbnRJbmRleCA9IDA7XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIG5leHQ6ICgpID0+IHtcbiAgICAgIC8vIGZpbmQgc29tZSBjb250ZW50XG4gICAgICBpZiAoY3VycmVudENvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgcmVhY2hlZCB0aGUgZW5kLCBubyBuZWVkIHRvIGNoZWNrIGN1cnJlbnRDb250ZW50LCBiZWNhdXNlIGl0IGRvZXMgbm90IGV4aXN0XG4gICAgICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGZvdW5kIG4sIHNvIHdlIGNhbiBzZXQgY3VycmVudENvbnRlbnRcbiAgICAgICAgY3VycmVudENvbnRlbnQgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpO1xuICAgICAgICBjdXJyZW50Q29udGVudEluZGV4ID0gMDtcbiAgICAgICAgbiA9IG4ucmlnaHQ7IC8vIHdlIHVzZWQgdGhlIGNvbnRlbnQgb2Ygbiwgbm93IGl0ZXJhdGUgdG8gbmV4dFxuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50Q29udGVudFtjdXJyZW50Q29udGVudEluZGV4KytdO1xuICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBlbXB0eSBjdXJyZW50Q29udGVudFxuICAgICAgaWYgKGN1cnJlbnRDb250ZW50Lmxlbmd0aCA8PSBjdXJyZW50Q29udGVudEluZGV4KSB7XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge2FueX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0R2V0ID0gKHR5cGUsIGluZGV4KSA9PiB7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIodHlwZSwgaW5kZXgpO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wO1xuICAgIGluZGV4IC09IG1hcmtlci5pbmRleDtcbiAgfVxuICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG4uY29udGVudC5nZXRDb250ZW50KClbaW5kZXhdXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtP30gcmVmZXJlbmNlSXRlbVxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55Pnxib29sZWFufG51bWJlcnxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlciA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCByZWZlcmVuY2VJdGVtLCBjb250ZW50KSA9PiB7XG4gIGxldCBsZWZ0ID0gcmVmZXJlbmNlSXRlbTtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IHJpZ2h0ID0gcmVmZXJlbmNlSXRlbSA9PT0gbnVsbCA/IHBhcmVudC5fc3RhcnQgOiByZWZlcmVuY2VJdGVtLnJpZ2h0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PE9iamVjdHxBcnJheTxhbnk+fG51bWJlcj59XG4gICAqL1xuICBsZXQganNvbkNvbnRlbnQgPSBbXTtcbiAgY29uc3QgcGFja0pzb25Db250ZW50ID0gKCkgPT4ge1xuICAgIGlmIChqc29uQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRBbnkoanNvbkNvbnRlbnQpKTtcbiAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIGpzb25Db250ZW50ID0gW107XG4gICAgfVxuICB9O1xuICBjb250ZW50LmZvckVhY2goYyA9PiB7XG4gICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBqc29uQ29udGVudC5wdXNoKGMpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGFja0pzb25Db250ZW50KCk7XG4gICAgICAgIHN3aXRjaCAoYy5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50QmluYXJ5KG5ldyBVaW50OEFycmF5KC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi8gKGMpKSkpO1xuICAgICAgICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIERvYzpcbiAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudERvYygvKiogQHR5cGUge0RvY30gKi8gKGMpKSk7XG4gICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRUeXBlKGMpKTtcbiAgICAgICAgICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZSBpbiBpbnNlcnQgb3BlcmF0aW9uJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHBhY2tKc29uQ29udGVudCgpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgY29udGVudCkgPT4ge1xuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGluZGV4LCBjb250ZW50Lmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbnVsbCwgY29udGVudClcbiAgfVxuICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gICAgLy8gd2UgbmVlZCB0byBpdGVyYXRlIG9uZSB0byB0aGUgbGVmdCBzbyB0aGF0IHRoZSBhbGdvcml0aG0gd29ya3NcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIEB0b2RvIHJlZmFjdG9yIHRoaXMgYXMgaXQgYWN0dWFsbHkgZG9lc24ndCBjb25zaWRlciBmb3JtYXRzXG4gICAgICBuID0gbi5wcmV2OyAvLyBpbXBvcnRhbnQhIGdldCB0aGUgbGVmdCB1bmRlbGV0ZWQgaXRlbSBzbyB0aGF0IHdlIGNhbiBhY3R1YWxseSBkZWNyZWFzZSBpbmRleFxuICAgICAgaW5kZXggKz0gKG4gJiYgbi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkgPyBuLmxlbmd0aCA6IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPD0gbi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgaW4tYmV0d2VlblxuICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCBjb250ZW50Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBuLCBjb250ZW50KVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0RGVsZXRlID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCBsZW5ndGgpID0+IHtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgeyByZXR1cm4gfVxuICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gbGVuZ3RoO1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHBhcmVudCwgaW5kZXgpO1xuICBsZXQgbiA9IHBhcmVudC5fc3RhcnQ7XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnA7XG4gICAgaW5kZXggLT0gbWFya2VyLmluZGV4O1xuICB9XG4gIC8vIGNvbXB1dGUgdGhlIGZpcnN0IGl0ZW0gdG8gYmUgZGVsZXRlZFxuICBmb3IgKDsgbiAhPT0gbnVsbCAmJiBpbmRleCA+IDA7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGluZGV4KSk7XG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gZGVsZXRlIGFsbCBpdGVtcyB1bnRpbCBkb25lXG4gIHdoaWxlIChsZW5ndGggPiAwICYmIG4gIT09IG51bGwpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCkge1xuICAgICAgaWYgKGxlbmd0aCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgbi5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgbGVuZ3RoIC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIHRocm93IGNyZWF0ZSQyKCdhcnJheSBsZW5ndGggZXhjZWVkZWQnKVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIC1zdGFydExlbmd0aCArIGxlbmd0aCAvKiBpbiBjYXNlIHdlIHJlbW92ZSB0aGUgYWJvdmUgZXhjZXB0aW9uICovKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwRGVsZXRlID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCBjID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICBjLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT59IHZhbHVlXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwU2V0ID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGtleSwgdmFsdWUpID0+IHtcbiAgY29uc3QgbGVmdCA9IHBhcmVudC5fbWFwLmdldChrZXkpIHx8IG51bGw7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGxldCBjb250ZW50O1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEJpbmFyeSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovICh2YWx1ZSkpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBEb2M6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudERvYygvKiogQHR5cGUge0RvY30gKi8gKHZhbHVlKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRUeXBlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCBudWxsLCBudWxsLCBwYXJlbnQsIGtleSwgY29udGVudCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldCA9IChwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCB2YWwgPSBwYXJlbnQuX21hcC5nZXQoa2V5KTtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmICF2YWwuZGVsZXRlZCA/IHZhbC5jb250ZW50LmdldENvbnRlbnQoKVt2YWwubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLE9iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWQ+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldEFsbCA9IChwYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fTtcbiAgcGFyZW50Ll9tYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICghdmFsdWUuZGVsZXRlZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWx1ZS5jb250ZW50LmdldENvbnRlbnQoKVt2YWx1ZS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBIYXMgPSAocGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXRTbmFwc2hvdCA9IChwYXJlbnQsIGtleSwgc25hcHNob3QpID0+IHtcbiAgbGV0IHYgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsO1xuICB3aGlsZSAodiAhPT0gbnVsbCAmJiAoIXNuYXBzaG90LnN2Lmhhcyh2LmlkLmNsaWVudCkgfHwgdi5pZC5jbG9jayA+PSAoc25hcHNob3Quc3YuZ2V0KHYuaWQuY2xpZW50KSB8fCAwKSkpIHtcbiAgICB2ID0gdi5sZWZ0O1xuICB9XG4gIHJldHVybiB2ICE9PSBudWxsICYmIGlzVmlzaWJsZSh2LCBzbmFwc2hvdCkgPyB2LmNvbnRlbnQuZ2V0Q29udGVudCgpW3YubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLEl0ZW0+fSBtYXBcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8QXJyYXk8YW55Pj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVNYXBJdGVyYXRvciA9IG1hcCA9PiBpdGVyYXRvckZpbHRlcihtYXAuZW50cmllcygpLCAvKiogQHBhcmFtIHthbnl9IGVudHJ5ICovIGVudHJ5ID0+ICFlbnRyeVsxXS5kZWxldGVkKTtcblxuLyoqXG4gKiBAbW9kdWxlIFlBcnJheVxuICovXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZQXJyYXlcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmNsYXNzIFlBcnJheUV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WUFycmF5PFQ+fSB5YXJyYXkgVGhlIGNoYW5nZWQgdHlwZVxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWFycmF5LCB0cmFuc2FjdGlvbikge1xuICAgIHN1cGVyKHlhcnJheSwgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBIHNoYXJlZCBBcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WUFycmF5RXZlbnQ8VD4+XG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8VD59XG4gKi9cbmNsYXNzIFlBcnJheSBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBZQXJyYXkgY29udGFpbmluZyB0aGUgc3BlY2lmaWVkIGl0ZW1zLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBpdGVtc1xuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBzdGF0aWMgZnJvbSAoaXRlbXMpIHtcbiAgICBjb25zdCBhID0gbmV3IFlBcnJheSgpO1xuICAgIGEucHVzaChpdGVtcyk7XG4gICAgcmV0dXJuIGFcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlBcnJheSgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBZQXJyYXkoKTtcbiAgICBhcnIuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChlbCA9PlxuICAgICAgZWwgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBlbC5jbG9uZSgpIDogZWxcbiAgICApKTtcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlbGltQ29udGVudCA9PT0gbnVsbCA/IHRoaXMuX2xlbmd0aCA6IHRoaXMuX3ByZWxpbUNvbnRlbnQubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZQXJyYXlFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKTtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlBcnJheUV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29udGVudC4gTm90IGp1c3QgYSBjb250ZW50XG4gICAqIG9iamVjdC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBcIndlaXJkbmVzc1wiIGlzIHRoYXQgaW5zZXJ0aW5nIHNldmVyYWwgZWxlbWVudHNcbiAgICogaXMgdmVyeSBlZmZpY2llbnQgd2hlbiBpdCBpcyBkb25lIGFzIGEgc2luZ2xlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHlhcnJheS5pbnNlcnQoMCwgWydhJ10pXG4gICAqICAvLyBJbnNlcnQgbnVtYmVycyAxLCAyIGF0IHBvc2l0aW9uIDFcbiAgICogIHlhcnJheS5pbnNlcnQoMSwgWzEsIDJdKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0LlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgY29udGVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKi9cbiAgcHVzaCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMubGVuZ3RoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgZWxlbWVudHMgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICBnZXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0R2V0KHRoaXMsIGluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdFRvQXJyYXkodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gYy50b0pTT04oKSA6IGMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5XG4gICAqIGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBULE1cbiAgICogQHBhcmFtIHtmdW5jdGlvbihULG51bWJlcixZQXJyYXk8VD4pOk19IGYgRnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBhbiBlbGVtZW50IG9mIHRoZSBuZXcgQXJyYXlcbiAgICogQHJldHVybiB7QXJyYXk8TT59IEEgbmV3IGFycmF5IHdpdGggZWFjaCBlbGVtZW50IGJlaW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgbWFwIChmKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0TWFwKHRoaXMsIC8qKiBAdHlwZSB7YW55fSAqLyAoZikpXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIG92ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlBcnJheVJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWUFycmF5ID0gZGVjb2RlciA9PiBuZXcgWUFycmF5KCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWU1hcC5cbiAqL1xuY2xhc3MgWU1hcEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WU1hcDxUPn0geW1hcCBUaGUgWUFycmF5IHRoYXQgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8YW55Pn0gc3VicyBUaGUga2V5cyB0aGF0IGNoYW5nZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeW1hcCwgdHJhbnNhY3Rpb24sIHN1YnMpIHtcbiAgICBzdXBlcih5bWFwLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5rZXlzQ2hhbmdlZCA9IHN1YnM7XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCBudW1iZXJ8c3RyaW5nfE9iamVjdHxBcnJheXxVaW50OEFycmF5XG4gKiBBIHNoYXJlZCBNYXAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlNYXBFdmVudDxUPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxUPn1cbiAqL1xuY2xhc3MgWU1hcCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlPHJlYWRvbmx5IFtzdHJpbmcsIGFueV0+PX0gZW50cmllcyAtIGFuIG9wdGlvbmFsIGl0ZXJhYmxlIHRvIGluaXRpYWxpemUgdGhlIFlNYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbnRyaWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuXG4gICAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoZW50cmllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7LyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZTWFwPFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZTWFwKCk7XG4gICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyB2YWx1ZS5jbG9uZSgpIDogdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlNYXBFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlNYXBFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3VicykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLFQ+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBjb25zdCB2ID0gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVtpdGVtLmxlbmd0aCAtIDFdO1xuICAgICAgICBtYXBba2V5XSA9IHYgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyB2LnRvSlNPTigpIDogdjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgWU1hcCAoY291bnQgb2Yga2V5L3ZhbHVlIHBhaXJzKVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIFsuLi5jcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApXS5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxzdHJpbmc+fVxuICAgKi9cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMF0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgdmFsdWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSXRlcmF0b3Igb2YgW2tleSwgdmFsdWVdIHBhaXJzXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAgICovXG4gIGVudHJpZXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiBbdlswXSwgdlsxXS5jb250ZW50LmdldENvbnRlbnQoKVt2WzFdLmxlbmd0aCAtIDFdXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gZXZlcnkga2V5LXZhbHVlIHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxzdHJpbmcsWU1hcDxUPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxUPn1cbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSB7fTtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBmKGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXSwga2V5LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhpcyBZTWFwXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKi9cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtUfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBrZXkpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBIYXModGhpcywga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZTWFwUmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZTWFwID0gZGVjb2RlciA9PiBuZXcgWU1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxBdHRycyA9IChhLCBiKSA9PiBhID09PSBiIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYiAmJiBlcXVhbEZsYXQoYSwgYikpO1xuXG5jbGFzcyBJdGVtVGV4dExpc3RQb3NpdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW18bnVsbH0gbGVmdFxuICAgKiBAcGFyYW0ge0l0ZW18bnVsbH0gcmlnaHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyZW50QXR0cmlidXRlc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlZnQsIHJpZ2h0LCBpbmRleCwgY3VycmVudEF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5jdXJyZW50QXR0cmlidXRlcyA9IGN1cnJlbnRBdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ubHkgY2FsbCB0aGlzIGlmIHlvdSBrbm93IHRoYXQgdGhpcy5yaWdodCBpcyBkZWZpbmVkXG4gICAqL1xuICBmb3J3YXJkICgpIHtcbiAgICBpZiAodGhpcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgdW5leHBlY3RlZENhc2UoKTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gdGhpcy5yaWdodC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCF0aGlzLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyh0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovICh0aGlzLnJpZ2h0LmNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0O1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnJpZ2h0LnJpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IHBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IHN0ZXBzIHRvIG1vdmUgZm9yd2FyZFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kTmV4dFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwb3MsIGNvdW50KSA9PiB7XG4gIHdoaWxlIChwb3MucmlnaHQgIT09IG51bGwgJiYgY291bnQgPiAwKSB7XG4gICAgc3dpdGNoIChwb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgIGlmICghcG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICBpZiAoY291bnQgPCBwb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByaWdodFxuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKHBvcy5yaWdodC5pZC5jbGllbnQsIHBvcy5yaWdodC5pZC5jbG9jayArIGNvdW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcy5pbmRleCArPSBwb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICAgIGNvdW50IC09IHBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCFwb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHBvcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAocG9zLnJpZ2h0LmNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICBwb3MubGVmdCA9IHBvcy5yaWdodDtcbiAgICBwb3MucmlnaHQgPSBwb3MucmlnaHQucmlnaHQ7XG4gICAgLy8gcG9zLmZvcndhcmQoKSAtIHdlIGRvbid0IGZvcndhcmQgYmVjYXVzZSB0aGF0IHdvdWxkIGhhbHZlIHRoZSBwZXJmb3JtYW5jZSBiZWNhdXNlIHdlIGFscmVhZHkgZG8gdGhlIGNoZWNrcyBhYm92ZVxuICB9XG4gIHJldHVybiBwb3Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtJdGVtVGV4dExpc3RQb3NpdGlvbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCkgPT4ge1xuICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KTtcbiAgaWYgKG1hcmtlcikge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihtYXJrZXIucC5sZWZ0LCBtYXJrZXIucCwgbWFya2VyLmluZGV4LCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXggLSBtYXJrZXIuaW5kZXgpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG51bGwsIHBhcmVudC5fc3RhcnQsIDAsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gZmluZE5leHRQb3NpdGlvbih0cmFuc2FjdGlvbiwgcG9zLCBpbmRleClcbiAgfVxufTtcblxuLyoqXG4gKiBOZWdhdGUgYXBwbGllZCBmb3JtYXRzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcykgPT4ge1xuICAvLyBjaGVjayBpZiB3ZSByZWFsbHkgbmVlZCB0byByZW1vdmUgYXR0cmlidXRlc1xuICB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJiAoXG4gICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgPT09IHRydWUgfHwgKFxuICAgICAgICBjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiZcbiAgICAgICAgZXF1YWxBdHRycyhuZWdhdGVkQXR0cmlidXRlcy5nZXQoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZSgvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLmtleSk7XG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGxldCBuZXh0Rm9ybWF0ID0gY3VyclBvcy5sZWZ0O1xuICBjb25zdCByaWdodCA9IGN1cnJQb3MucmlnaHQ7XG4gIG5lZ2F0ZWRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgbmV4dEZvcm1hdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIG5leHRGb3JtYXQsIG5leHRGb3JtYXQgJiYgbmV4dEZvcm1hdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpO1xuICAgIG5leHRGb3JtYXQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICBjdXJyUG9zLnJpZ2h0ID0gbmV4dEZvcm1hdDtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyZW50QXR0cmlidXRlc1xuICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBmb3JtYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzID0gKGN1cnJlbnRBdHRyaWJ1dGVzLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBmb3JtYXQ7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzID0gKGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gZ28gcmlnaHQgd2hpbGUgYXR0cmlidXRlc1tyaWdodC5rZXldID09PSByaWdodC52YWx1ZSAob3IgcmlnaHQgaXMgZGVsZXRlZClcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY3VyclBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCB8fCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGVxdWFsQXR0cnMoYXR0cmlidXRlc1soLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KSkua2V5XSB8fCBudWxsLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKSkpIDsgZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICogQHJldHVybiB7TWFwPHN0cmluZyxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgLy8gaW5zZXJ0IGZvcm1hdC1zdGFydCBpdGVtc1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdmFsID0gYXR0cmlidXRlc1trZXldO1xuICAgIGNvbnN0IGN1cnJlbnRWYWwgPSBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgaWYgKCFlcXVhbEF0dHJzKGN1cnJlbnRWYWwsIHZhbCkpIHtcbiAgICAgIC8vIHNhdmUgbmVnYXRlZCBhdHRyaWJ1dGUgKHNldCBudWxsIGlmIGN1cnJlbnRWYWwgdW5kZWZpbmVkKVxuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgY3VycmVudFZhbCk7XG4gICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBjdXJyUG9zO1xuICAgICAgY3VyclBvcy5yaWdodCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpO1xuICAgICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWdhdGVkQXR0cmlidXRlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICBpZiAoYXR0cmlidXRlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IG51bGw7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIC8vIGluc2VydCBjb250ZW50XG4gIGNvbnN0IGNvbnRlbnQgPSB0ZXh0LmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBuZXcgQ29udGVudFN0cmluZygvKiogQHR5cGUge3N0cmluZ30gKi8gKHRleHQpKSA6IG5ldyBDb250ZW50RW1iZWQodGV4dCk7XG4gIGxldCB7IGxlZnQsIHJpZ2h0LCBpbmRleCB9ID0gY3VyclBvcztcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgY29udGVudC5nZXRMZW5ndGgoKSk7XG4gIH1cbiAgcmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgY29udGVudCk7XG4gIHJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gIGN1cnJQb3MucmlnaHQgPSByaWdodDtcbiAgY3VyclBvcy5pbmRleCA9IGluZGV4O1xuICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZm9ybWF0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIC8vIGl0ZXJhdGUgdW50aWwgZmlyc3Qgbm9uLWZvcm1hdCBvciBudWxsIGlzIGZvdW5kXG4gIC8vIGRlbGV0ZSBhbGwgZm9ybWF0cyB3aXRoIGF0dHJpYnV0ZXNbZm9ybWF0LmtleV0gIT0gbnVsbFxuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KTtcbiAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKGF0dHIsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgIGlmIChsZW5ndGggPCBjdXJyUG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGN1cnJQb3MucmlnaHQuaWQuY2xpZW50LCBjdXJyUG9zLnJpZ2h0LmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCAtPSBjdXJyUG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICAvLyBRdWlsbCBqdXN0IGFzc3VtZXMgdGhhdCB0aGUgZWRpdG9yIHN0YXJ0cyB3aXRoIGEgbmV3bGluZSBhbmQgdGhhdCBpdCBhbHdheXNcbiAgLy8gZW5kcyB3aXRoIGEgbmV3bGluZS4gV2Ugb25seSBpbnNlcnQgdGhhdCBuZXdsaW5lIHdoZW4gYSBuZXcgbmV3bGluZSBpc1xuICAvLyBpbnNlcnRlZCAtIGkuZSB3aGVuIGxlbmd0aCBpcyBiaWdnZXIgdGhhbiB0eXBlLmxlbmd0aFxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGxldCBuZXdsaW5lcyA9ICcnO1xuICAgIGZvciAoOyBsZW5ndGggPiAwOyBsZW5ndGgtLSkge1xuICAgICAgbmV3bGluZXMgKz0gJ1xcbic7XG4gICAgfVxuICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBjdXJyUG9zLmxlZnQsIGN1cnJQb3MubGVmdCAmJiBjdXJyUG9zLmxlZnQubGFzdElkLCBjdXJyUG9zLnJpZ2h0LCBjdXJyUG9zLnJpZ2h0ICYmIGN1cnJQb3MucmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRTdHJpbmcobmV3bGluZXMpKTtcbiAgICBjdXJyUG9zLnJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgc3RyaW5nIGNvbnRlbnQgaGFzIGJlZW4gZGVsZXRlZCBpbiBvcmRlciB0b1xuICogY2xlYW4gdXAgZm9ybWF0dGluZyBJdGVtcy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtfSBzdGFydFxuICogQHBhcmFtIHtJdGVtfG51bGx9IGVuZCBleGNsdXNpdmUgZW5kLCBhdXRvbWF0aWNhbGx5IGl0ZXJhdGVzIHRvIHRoZSBuZXh0IENvbnRlbnQgSXRlbVxuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IHN0YXJ0QXR0cmlidXRlc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGVuZEF0dHJpYnV0ZXMgVGhpcyBhdHRyaWJ1dGUgaXMgbW9kaWZpZWQhXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgZm9ybWF0dGluZyBJdGVtcyBkZWxldGVkLlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjbGVhbnVwRm9ybWF0dGluZ0dhcCA9ICh0cmFuc2FjdGlvbiwgc3RhcnQsIGVuZCwgc3RhcnRBdHRyaWJ1dGVzLCBlbmRBdHRyaWJ1dGVzKSA9PiB7XG4gIHdoaWxlIChlbmQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRTdHJpbmcgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRFbWJlZCkge1xuICAgIGlmICghZW5kLmRlbGV0ZWQgJiYgZW5kLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGVuZEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KSk7XG4gICAgfVxuICAgIGVuZCA9IGVuZC5yaWdodDtcbiAgfVxuICBsZXQgY2xlYW51cHMgPSAwO1xuICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgIGlmICghc3RhcnQuZGVsZXRlZCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHN0YXJ0LmNvbnRlbnQ7XG4gICAgICBzd2l0Y2ggKGNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KTtcbiAgICAgICAgICBpZiAoKGVuZEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkgIT09IHZhbHVlIHx8IChzdGFydEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBFaXRoZXIgdGhpcyBmb3JtYXQgaXMgb3ZlcndyaXR0ZW4gb3IgaXQgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBhdHRyaWJ1dGUgYWxyZWFkeSBleGlzdGVkLlxuICAgICAgICAgICAgc3RhcnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNsZWFudXBzKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodCk7XG4gIH1cbiAgcmV0dXJuIGNsZWFudXBzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbmNvbnN0IGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIGl0ZW0pID0+IHtcbiAgLy8gaXRlcmF0ZSB1bnRpbCBpdGVtLnJpZ2h0IGlzIG51bGwgb3IgY29udGVudFxuICB3aGlsZSAoaXRlbSAmJiBpdGVtLnJpZ2h0ICYmIChpdGVtLnJpZ2h0LmRlbGV0ZWQgfHwgKGl0ZW0ucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciAhPT0gQ29udGVudFN0cmluZyAmJiBpdGVtLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRFbWJlZCkpKSB7XG4gICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gIH1cbiAgY29uc3QgYXR0cnMgPSBuZXcgU2V0KCk7XG4gIC8vIGl0ZXJhdGUgYmFjayB1bnRpbCBhIGNvbnRlbnQgaXRlbSBpcyBmb3VuZFxuICB3aGlsZSAoaXRlbSAmJiAoaXRlbS5kZWxldGVkIHx8IChpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgIT09IENvbnRlbnRTdHJpbmcgJiYgaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yICE9PSBDb250ZW50RW1iZWQpKSkge1xuICAgIGlmICghaXRlbS5kZWxldGVkICYmIGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgY29uc3Qga2V5ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KS5rZXk7XG4gICAgICBpZiAoYXR0cnMuaGFzKGtleSkpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGl0ZW0gPSBpdGVtLmxlZnQ7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBleHBlcmltZW50YWwgYW5kIHN1YmplY3QgdG8gY2hhbmdlIC8gYmUgcmVtb3ZlZC5cbiAqXG4gKiBJZGVhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgZnVuY3Rpb24gYXQgYWxsLiBGb3JtYXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGNsZWFuZWQgdXBcbiAqIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgZWFjaCBjaGFuZ2UuIFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdHdpY2Ugb3ZlciB0aGUgY29tcGxldGUgWVRleHQgdHlwZVxuICogYW5kIHJlbW92ZXMgdW5uZWNlc3NhcnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzLiBUaGlzIGlzIGFsc28gaGVscGZ1bCBmb3IgdGVzdGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdvbid0IGJlIGV4cG9ydGVkIGFueW1vcmUgYXMgc29vbiBhcyB0aGVyZSBpcyBjb25maWRlbmNlIHRoYXQgdGhlIFlUZXh0IHR5cGUgd29ya3MgYXMgaW50ZW5kZWQuXG4gKlxuICogQHBhcmFtIHtZVGV4dH0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfSBIb3cgbWFueSBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNsZWFuZWQgdXAuXG4gKi9cbmNvbnN0IGNsZWFudXBZVGV4dEZvcm1hdHRpbmcgPSB0eXBlID0+IHtcbiAgbGV0IHJlcyA9IDA7XG4gIHRyYW5zYWN0KC8qKiBAdHlwZSB7RG9jfSAqLyAodHlwZS5kb2MpLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodHlwZS5fc3RhcnQpO1xuICAgIGxldCBlbmQgPSB0eXBlLl9zdGFydDtcbiAgICBsZXQgc3RhcnRBdHRyaWJ1dGVzID0gY3JlYXRlKCk7XG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBjb3B5KHN0YXJ0QXR0cmlidXRlcyk7XG4gICAgd2hpbGUgKGVuZCkge1xuICAgICAgaWYgKGVuZC5kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICBzd2l0Y2ggKGVuZC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICAgIHJlcyArPSBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGVuZCwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBzdGFydEF0dHJpYnV0ZXMgPSBjb3B5KGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kID0gZW5kLnJpZ2h0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZGVsZXRlVGV4dCA9ICh0cmFuc2FjdGlvbiwgY3VyclBvcywgbGVuZ3RoKSA9PiB7XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gbGVuZ3RoO1xuICBjb25zdCBzdGFydEF0dHJzID0gY29weShjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc3RhcnQgPSBjdXJyUG9zLnJpZ2h0O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBpZiAoc3RhcnQpIHtcbiAgICBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnJQb3MucmlnaHQsIHN0YXJ0QXR0cnMsIGNvcHkoY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcykpO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICgvKiogQHR5cGUge0l0ZW19ICovIChjdXJyUG9zLmxlZnQgfHwgY3VyclBvcy5yaWdodCkucGFyZW50KTtcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gY3VyclBvc1xufTtcblxuLyoqXG4gKiBUaGUgUXVpbGwgRGVsdGEgZm9ybWF0IHJlcHJlc2VudHMgY2hhbmdlcyBvbiBhIHRleHQgZG9jdW1lbnQgd2l0aFxuICogZm9ybWF0dGluZyBpbmZvcm1hdGlvbi4gRm9yIG1vciBpbmZvcm1hdGlvbiB2aXNpdCB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX1cbiAqXG4gKiBAZXhhbXBsZVxuICogICB7XG4gKiAgICAgb3BzOiBbXG4gKiAgICAgICB7IGluc2VydDogJ0dhbmRhbGYnLCBhdHRyaWJ1dGVzOiB7IGJvbGQ6IHRydWUgfSB9LFxuICogICAgICAgeyBpbnNlcnQ6ICcgdGhlICcgfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnR3JleScsIGF0dHJpYnV0ZXM6IHsgY29sb3I6ICcjY2NjY2NjJyB9IH1cbiAqICAgICBdXG4gKiAgIH1cbiAqXG4gKi9cblxuLyoqXG4gICogQXR0cmlidXRlcyB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHNlbGVjdGlvbiBvZiB0ZXh0LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAgIHtcbiAgKiAgICAgYm9sZDogdHJ1ZSxcbiAgKiAgICAgZm9udC1zaXplOiAnNDBweCdcbiAgKiAgIH1cbiAgKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRBdHRyaWJ1dGVzXG4gICovXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVGV4dCB0eXBlLlxuICovXG5jbGFzcyBZVGV4dEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVRleHR9IHl0ZXh0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeXRleHQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5c0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgICAgICovXG4gICAgICBjb25zdCBjaGFuZ2VzID0ge1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICAgIGRlbHRhOiB0aGlzLmRlbHRhLFxuICAgICAgICBhZGRlZDogbmV3IFNldCgpLFxuICAgICAgICBkZWxldGVkOiBuZXcgU2V0KClcbiAgICAgIH07XG4gICAgICB0aGlzLl9jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodGhpcy5fY2hhbmdlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjaGFuZ2VzIGluIHRoZSBkZWx0YSBmb3JtYXQuXG4gICAqIEEge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9KSB0aGF0IHJlcHJlc2VudHMgdGhlIGNoYW5nZXMgb24gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLGFueT59Pn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IGRlbHRhICgpIHtcbiAgICBpZiAodGhpcy5fZGVsdGEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHkgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMudGFyZ2V0LmRvYyk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0PzpzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy50YXJnZXQuX3N0YXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZz99XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307IC8vIGNvdW50cyBhZGRlZCBvciByZW1vdmVkIG5ldyBhdHRyaWJ1dGVzIGZvciByZXRhaW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGluc2VydCA9ICcnO1xuICAgICAgICBsZXQgcmV0YWluID0gMDtcbiAgICAgICAgbGV0IGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgIGNvbnN0IGFkZE9wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IG9wO1xuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICBvcCA9IHsgZGVsZXRlOiBkZWxldGVMZW4gfTtcbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgb3AgPSB7IGluc2VydCB9O1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc2VydCA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ3JldGFpbic6XG4gICAgICAgICAgICAgICAgb3AgPSB7IHJldGFpbiB9O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXNba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluID0gMDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsdGEucHVzaChvcCk7XG4gICAgICAgICAgICBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGl0ZW0uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gLyoqIEB0eXBlIHtDb250ZW50RW1iZWR9ICovIChpdGVtLmNvbnRlbnQpLmVtYmVkO1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbnNlcnQgKz0gLyoqIEB0eXBlIHtDb250ZW50U3RyaW5nfSAqLyAoaXRlbS5jb250ZW50KS5zdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoY3VyVmFsLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcXVhbEF0dHJzKHZhbHVlLCAob2xkQXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gY3VyVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBhZGRPcCgpO1xuICAgICAgICB3aGlsZSAoZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcCA9IGRlbHRhW2RlbHRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0T3AucmV0YWluICE9PSB1bmRlZmluZWQgJiYgbGFzdE9wLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0YWluIGRlbHRhJ3MgaWYgdGhleSBkb24ndCBhc3NpZ24gYXR0cmlidXRlc1xuICAgICAgICAgICAgZGVsdGEucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2RlbHRhKVxuICB9XG59XG5cbi8qKlxuICogVHlwZSB0aGF0IHJlcHJlc2VudHMgdGV4dCB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyB0eXBlIHJlcGxhY2VzIHktcmljaHRleHQgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhYmxlIHRvIGhhbmRsZVxuICogYmxvY2sgZm9ybWF0cyAoZm9ybWF0IGluZm9ybWF0aW9uIG9uIGEgcGFyYWdyYXBoKSwgZW1iZWRzIChjb21wbGV4IGVsZW1lbnRzXG4gKiBsaWtlIHBpY3R1cmVzIGFuZCB2aWRlb3MpLCBhbmQgdGV4dCBmb3JtYXRzICgqKmJvbGQqKiwgKml0YWxpYyopLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZVGV4dEV2ZW50PlxuICovXG5jbGFzcyBZVGV4dCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ10gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIFlUZXh0LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGVuZGluZyBvcGVyYXRpb25zIG9uIHRoaXMgdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbigpOnZvaWQ+P31cbiAgICAgKi9cbiAgICB0aGlzLl9wZW5kaW5nID0gc3RyaW5nICE9PSB1bmRlZmluZWQgPyBbKCkgPT4gdGhpcy5pbnNlcnQoMCwgc3RyaW5nKV0gOiBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRoaXMgdGV4dCB0eXBlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSB5XG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykuZm9yRWFjaChmID0+IGYoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZyA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZVGV4dCgpO1xuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSk7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlUZXh0RXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgc3VwZXIuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgWVRleHRFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBldmVudCk7XG4gICAgLy8gSWYgYSByZW1vdGUgY2hhbmdlIGhhcHBlbmVkLCB3ZSB0cnkgdG8gY2xlYW51cCBwb3RlbnRpYWwgZm9ybWF0dGluZyBkdXBsaWNhdGVzLlxuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGFub3RoZXIgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZFxuICAgICAgbGV0IGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgYWZ0ZXJDbG9ja10gb2YgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYWZ0ZXJDbG9jayA9PT0gY2xvY2spIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0FycmF5PEl0ZW18R0M+fSAqLyAoZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpLCBjbG9jaywgYWZ0ZXJDbG9jaywgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQgJiYgLyoqIEB0eXBlIHtJdGVtfSAqLyAoaXRlbSkuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICAgICAgZm91bmRGb3JtYXR0aW5nSXRlbSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0gPT4ge1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MgfHwgZm91bmRGb3JtYXR0aW5nSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnBhcmVudCA9PT0gdGhpcyAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgICAgICAgIGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cmFuc2FjdChkb2MsICh0KSA9PiB7XG4gICAgICAgIGlmIChmb3VuZEZvcm1hdHRpbmdJdGVtKSB7XG4gICAgICAgICAgLy8gSWYgYSBmb3JtYXR0aW5nIGl0ZW0gd2FzIGluc2VydGVkLCB3ZSBzaW1wbHkgY2xlYW4gdGhlIHdob2xlIHR5cGUuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgY3VycmVudCBwb3NpdGlvbiBhbnl3YXkuXG4gICAgICAgICAgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBubyBmb3JtYXR0aW5nIGF0dHJpYnV0ZSB3YXMgaW5zZXJ0ZWQsIHdlIGNhbiBtYWtlIGR1ZSB3aXRoIGNvbnRleHRsZXNzXG4gICAgICAgICAgLy8gZm9ybWF0dGluZyBjbGVhbnVwcy5cbiAgICAgICAgICAvLyBDb250ZXh0bGVzczogaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgYWZmZWN0ZWQgcG9zaXRpb24uXG4gICAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHQsIHQuZGVsZXRlU2V0LCBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgY2xlYW51cENvbnRleHRsZXNzRm9ybWF0dGluZ0dhcCh0LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyO1xuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEge0BsaW5rIERlbHRhfSBvbiB0aGlzIHNoYXJlZCBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZGVsdGEgVGhlIGNoYW5nZXMgdG8gYXBwbHkgb24gdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIFtvcHRzXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNhbml0aXplXSBTYW5pdGl6ZSBpbnB1dCBkZWx0YS4gUmVtb3ZlcyBlbmRpbmcgbmV3bGluZXMgaWYgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFwcGx5RGVsdGEgKGRlbHRhLCB7IHNhbml0aXplID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJQb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgdGhpcy5fc3RhcnQsIDAsIG5ldyBNYXAoKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcCA9IGRlbHRhW2ldO1xuICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUXVpbGwgYXNzdW1lcyB0aGF0IHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIGFuIGVtcHR5IHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFlqcy9ZLlRleHQgYXNzdW1lcyB0aGF0IGl0IHN0YXJ0cyBlbXB0eS4gV2UgYWx3YXlzIGhpZGUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBuZXdsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBJZiB3ZSBvbWl0IHRoaXMgc3RlcCwgY2xpZW50cyB3aWxsIHNlZSBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHBhcmFncmFwaHMsIGJ1dCBub3RoaW5nIGJhZCB3aWxsIGhhcHBlbi5cbiAgICAgICAgICAgIGNvbnN0IGlucyA9ICghc2FuaXRpemUgJiYgdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgaSA9PT0gZGVsdGEubGVuZ3RoIC0gMSAmJiBjdXJyUG9zLnJpZ2h0ID09PSBudWxsICYmIG9wLmluc2VydC5zbGljZSgtMSkgPT09ICdcXG4nKSA/IG9wLmluc2VydC5zbGljZSgwLCAtMSkgOiBvcC5pbnNlcnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucyAhPT0gJ3N0cmluZycgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgaW5zLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLnJldGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBjdXJyUG9zLCBvcC5yZXRhaW4sIG9wLmF0dHJpYnV0ZXMgfHwge30pO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3AuZGVsZXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGN1cnJQb3MsIG9wLmRlbGV0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuYXBwbHlEZWx0YShkZWx0YSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAgICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBJRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9EZWx0YSAoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZXtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRvYyA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy5kb2MpO1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0O1xuICAgIGZ1bmN0aW9uIHBhY2tTdHIgKCkge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHBhY2sgc3RyIHdpdGggYXR0cmlidXRlcyB0byBvcHNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGxldCBhZGRBdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBhZGRBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3AgPSB7IGluc2VydDogc3RyIH07XG4gICAgICAgIGlmIChhZGRBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgb3BzLnB1c2gob3ApO1xuICAgICAgICBzdHIgPSAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc25hcHNob3RzIGFyZSBtZXJnZWQgYWdhaW4gYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCBzbyB3ZSBuZWVkIHRvIGtlZXAgdGhlXG4gICAgLy8gdHJhbnNhbGl2ZSB1bnRpbCB3ZSBhcmUgZG9uZVxuICAgIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2U25hcHNob3QpIHtcbiAgICAgICAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgcHJldlNuYXBzaG90KTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpIHx8IChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiBpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldCgneWNoYW5nZScpO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnN0YXRlICE9PSAncmVtb3ZlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCBuLmlkKSA6IHsgdHlwZTogJ3JlbW92ZWQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci5zdGF0ZSAhPT0gJ2FkZGVkJykge1xuICAgICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KCd5Y2hhbmdlJywgY29tcHV0ZVlDaGFuZ2UgPyBjb21wdXRlWUNoYW5nZSgnYWRkZWQnLCBuLmlkKSA6IHsgdHlwZTogJ2FkZGVkJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZGVsZXRlKCd5Y2hhbmdlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAgICAgIGluc2VydDogLyoqIEB0eXBlIHtDb250ZW50RW1iZWR9ICovIChuLmNvbnRlbnQpLmVtYmVkXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59ICovICh7fSk7XG4gICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChuLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgIH1cbiAgICAgIHBhY2tTdHIoKTtcbiAgICB9LCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKTtcbiAgICByZXR1cm4gb3BzXG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0IHRleHQgYXQgYSBnaXZlbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRvIGluc2VydCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxuICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBbYXR0cmlidXRlc10gT3B0aW9uYWxseSBkZWZpbmUgc29tZSBmb3JtYXR0aW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlIGluc2VydGVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dC5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpO1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHBvcy5jdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7IGF0dHJpYnV0ZXNba10gPSB2OyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIHRleHQsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydChpbmRleCwgdGV4dCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGVtYmVkIGF0IGEgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBlbWJlZCBhdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVtYmVkIFRoZSBPYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBlbWJlZC5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0RW1iZWQgKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgaWYgKGVtYmVkLmNvbnN0cnVjdG9yICE9PSBPYmplY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW1iZWQgbXVzdCBiZSBhbiBPYmplY3QnKVxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgZW1iZWQsIGF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRleHQgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgZGVsZXRlVGV4dCh0cmFuc2FjdGlvbiwgZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCksIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZGVsZXRlKGluZGV4LCBsZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBwcm9wZXJ0aWVzIHRvIGEgcmFuZ2Ugb2YgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCBmb3JtYXR0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byBhc3NpZ24gcHJvcGVydGllcyB0by5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9ybWF0IChpbmRleCwgbGVuZ3RoLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKHBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGZvcm1hdFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5mb3JtYXQoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHthbnl9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlkZW50aWZpZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgdmFsdWUuXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKHNuYXBzaG90KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBHZXRBbGwodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVRleHRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVRleHR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVRleHQgPSBkZWNvZGVyID0+IG5ldyBZVGV4dCgpO1xuXG4vKipcbiAqIEBtb2R1bGUgWVhtbFxuICovXG5cbi8qKlxuICogRGVmaW5lIHRoZSBlbGVtZW50cyB0byB3aGljaCBhIHNldCBvZiBDU1MgcXVlcmllcyBhcHBseS5cbiAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1NlbGVjdG9yc3xDU1NfU2VsZWN0b3JzfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHF1ZXJ5ID0gJy5jbGFzc1NlbGVjdG9yJ1xuICogICBxdWVyeSA9ICdub2RlU2VsZWN0b3InXG4gKiAgIHF1ZXJ5ID0gJyNpZFNlbGVjdG9yJ1xuICpcbiAqIEB0eXBlZGVmIHtzdHJpbmd9IENTU19TZWxlY3RvclxuICovXG5cbi8qKlxuICogRG9tIGZpbHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAY2FsbGJhY2sgZG9tRmlsdGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0ge01hcH0gYXR0cmlidXRlcyBUaGUgbWFwIG9mIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIERvbSBub2RlIGluIHRoZSBZWG1sRWxlbWVudC5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIGEgWVhtbEVsZW1lbnQgLyBZWG1sRnJhZ21lbnQgYW5kIGFcbiAqIHBvc2l0aW9uIHdpdGhpbiB0aGVtLlxuICpcbiAqIENhbiBiZSBjcmVhdGVkIHdpdGgge0BsaW5rIFlYbWxGcmFnbWVudCNjcmVhdGVUcmVlV2Fsa2VyfVxuICpcbiAqIEBwdWJsaWNcbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRWxlbWVudHxZWG1sSG9vaz59XG4gKi9cbmNsYXNzIFlYbWxUcmVlV2Fsa2VyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVhtbEZyYWdtZW50IHwgWVhtbEVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gW2ZdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocm9vdCwgZiA9ICgpID0+IHRydWUpIHtcbiAgICB0aGlzLl9maWx0ZXIgPSBmO1xuICAgIHRoaXMuX3Jvb3QgPSByb290O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAocm9vdC5fc3RhcnQpO1xuICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IHRydWU7XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmF0b3JSZXN1bHQ8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fSBUaGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBuZXh0ICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCBuID0gdGhpcy5fY3VycmVudE5vZGU7XG4gICAgbGV0IHR5cGUgPSBuICYmIG4uY29udGVudCAmJiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZTtcbiAgICBpZiAobiAhPT0gbnVsbCAmJiAoIXRoaXMuX2ZpcnN0Q2FsbCB8fCBuLmRlbGV0ZWQgfHwgIXRoaXMuX2ZpbHRlcih0eXBlKSkpIHsgLy8gaWYgZmlyc3QgY2FsbCwgd2UgY2hlY2sgaWYgd2UgY2FuIHVzZSB0aGUgZmlyc3QgaXRlbVxuICAgICAgZG8ge1xuICAgICAgICB0eXBlID0gLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGU7XG4gICAgICAgIGlmICghbi5kZWxldGVkICYmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRWxlbWVudCB8fCB0eXBlLmNvbnN0cnVjdG9yID09PSBZWG1sRnJhZ21lbnQpICYmIHR5cGUuX3N0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gd2FsayBkb3duIGluIHRoZSB0cmVlXG4gICAgICAgICAgbiA9IHR5cGUuX3N0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdhbGsgcmlnaHQgb3IgdXAgaW4gdGhlIHRyZWVcbiAgICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG4ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4ucGFyZW50ID09PSB0aGlzLl9yb290KSB7XG4gICAgICAgICAgICAgIG4gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbiA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChuLnBhcmVudCkuX2l0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuICE9PSBudWxsICYmIChuLmRlbGV0ZWQgfHwgIXRoaXMuX2ZpbHRlcigvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSkpXG4gICAgfVxuICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IGZhbHNlO1xuICAgIGlmIChuID09PSBudWxsKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH1cbiAgICB9XG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSBuO1xuICAgIHJldHVybiB7IHZhbHVlOiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZSwgZG9uZTogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGxpc3Qgb2Yge0BsaW5rIFlYbWxFbGVtZW50fS5hbmQge0BsaW5rIFlYbWxUZXh0fSB0eXBlcy5cbiAqIEEgWXhtbEZyYWdtZW50IGlzIHNpbWlsYXIgdG8gYSB7QGxpbmsgWVhtbEVsZW1lbnR9LCBidXQgaXQgZG9lcyBub3QgaGF2ZSBhXG4gKiBub2RlTmFtZSBhbmQgaXQgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLiBUaG91Z2ggaXQgY2FuIGJlIGJvdW5kIHRvIGEgRE9NXG4gKiBlbGVtZW50IC0gaW4gdGhpcyBjYXNlIHRoZSBhdHRyaWJ1dGVzIGFuZCB0aGUgbm9kZU5hbWUgYXJlIG5vdCBzaGFyZWQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlYbWxFdmVudD5cbiAqL1xuY2xhc3MgWVhtbEZyYWdtZW50IGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW107XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgZmlyc3RDaGlsZCAoKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLl9maXJzdDtcbiAgICByZXR1cm4gZmlyc3QgPyBmaXJzdC5jb250ZW50LmdldENvbnRlbnQoKVswXSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRoaXMuaW5zZXJ0KDAsIC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpKTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxGcmFnbWVudCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxGcmFnbWVudCgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgZWwudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlbGltQ29udGVudCA9PT0gbnVsbCA/IHRoaXMuX2xlbmd0aCA6IHRoaXMuX3ByZWxpbUNvbnRlbnQubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3VidHJlZSBvZiBjaGlsZE5vZGVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCB3YWxrZXIgPSBlbGVtLmNyZWF0ZVRyZWVXYWxrZXIoZG9tID0+IGRvbS5ub2RlTmFtZSA9PT0gJ2RpdicpXG4gICAqIGZvciAobGV0IG5vZGUgaW4gd2Fsa2VyKSB7XG4gICAqICAgLy8gYG5vZGVgIGlzIGEgZGl2IG5vZGVcbiAgICogICBub3Aobm9kZSlcbiAgICogfVxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFic3RyYWN0VHlwZTxhbnk+KTpib29sZWFufSBmaWx0ZXIgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgb24gZWFjaCBjaGlsZCBlbGVtZW50IGFuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJucyBhIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjaGlsZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHN1YnRyZWUuXG4gICAqIEByZXR1cm4ge1lYbWxUcmVlV2Fsa2VyfSBBIHN1YnRyZWUgYW5kIGEgcG9zaXRpb24gd2l0aGluIGl0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVUcmVlV2Fsa2VyIChmaWx0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxUcmVlV2Fsa2VyKHRoaXMsIGZpbHRlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBZWG1sRWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5LlxuICAgKiBTaW1pbGFyIHRvIERPTSdzIHtAbGluayBxdWVyeVNlbGVjdG9yfS5cbiAgICpcbiAgICogUXVlcnkgc3VwcG9ydDpcbiAgICogICAtIHRhZ25hbWVcbiAgICogVE9ETzpcbiAgICogICAtIGlkXG4gICAqICAgLSBhdHRyaWJ1dGVcbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW4uXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rfG51bGx9IFRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnkgb3IgbnVsbC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcXVlcnlTZWxlY3RvciAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IFlYbWxUcmVlV2Fsa2VyKHRoaXMsIGVsZW1lbnQgPT4gZWxlbWVudC5ub2RlTmFtZSAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IHF1ZXJ5KTtcbiAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXh0LnZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFlYbWxFbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBEb20ncyB7QGxpbmsgcXVlcnlTZWxlY3RvckFsbH0uXG4gICAqXG4gICAqIEB0b2RvIERvZXMgbm90IHlldCBzdXBwb3J0IGFsbCBxdWVyaWVzLiBDdXJyZW50bHkgb25seSBxdWVyeSBieSB0YWdOYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0NTU19TZWxlY3Rvcn0gcXVlcnkgVGhlIHF1ZXJ5IG9uIHRoZSBjaGlsZHJlblxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsPn0gVGhlIGVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhpcyBxdWVyeS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcXVlcnlTZWxlY3RvckFsbCAocXVlcnkpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnRvVXBwZXJDYXNlKCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSkpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZWG1sRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZWG1sRXZlbnQodGhpcywgcGFyZW50U3VicywgdHJhbnNhY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoaXMgWVhtbEZyYWdtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCB4bWwgPT4geG1sLnRvU3RyaW5nKCkpLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGZyYWdtZW50LCB0aGlzKTtcbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHhtbFR5cGUgPT4ge1xuICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKHhtbFR5cGUudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZyksIG51bGwpO1xuICAgIH0pO1xuICAgIHJldHVybiBmcmFnbWVudFxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0XG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgY29udGVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZSBfcHJlbGltQ29udGVudCBpcyBkZWZpbmVkIGJlY2F1c2UgdGhpcyBpcyBub3QgeWV0IGludGVncmF0ZWRcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHhtbC5pbnNlcnQoMCwgW25ldyBZLlhtbFRleHQoJ3RleHQnKV0pXG4gICAqXG4gICAqIEBwYXJhbSB7bnVsbHxJdGVtfFlYbWxFbGVtZW50fFlYbWxUZXh0fSByZWYgVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0XG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnRBZnRlciAocmVmLCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCByZWZJdGVtID0gKHJlZiAmJiByZWYgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpID8gcmVmLl9pdGVtIDogcmVmO1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHRoaXMsIHJlZkl0ZW0sIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBjID0gLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCk7XG4gICAgICBjb25zdCBpbmRleCA9IHJlZiA9PT0gbnVsbCA/IDAgOiBwYy5maW5kSW5kZXgoZWwgPT4gZWwgPT09IHJlZikgKyAxO1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmIHJlZiAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBjcmVhdGUkMignUmVmZXJlbmNlIGl0ZW0gbm90IGZvdW5kJylcbiAgICAgIH1cbiAgICAgIHBjLnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgZWxlbWVudHMgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoID0gMSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3REZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgbGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rPn1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdFRvQXJyYXkodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKi9cbiAgcHVzaCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMubGVuZ3RoLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBwcmVwcGVuZC5cbiAgICovXG4gIHVuc2hpZnQgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCgwLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fFlYbWxUZXh0fVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0eXBlTGlzdEdldCh0aGlzLCBpbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn1cbiAgICovXG4gIHNsaWNlIChzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEZyYWdtZW50UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sRnJhZ21lbnQgPSBkZWNvZGVyID0+IG5ldyBZWG1sRnJhZ21lbnQoKTtcblxuLyoqXG4gKiBBbiBZWG1sRWxlbWVudCBpbWl0YXRlcyB0aGUgYmVoYXZpb3Igb2YgYVxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fS5cbiAqXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBhdHRyaWJ1dGVzIChrZXkgdmFsdWUgcGFpcnMpXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBjaGlsZEVsZW1lbnRzIHRoYXQgbXVzdCBpbmhlcml0IGZyb20gWVhtbEVsZW1lbnRcbiAqL1xuY2xhc3MgWVhtbEVsZW1lbnQgZXh0ZW5kcyBZWG1sRnJhZ21lbnQge1xuICBjb25zdHJ1Y3RvciAobm9kZU5hbWUgPSAnVU5ERUZJTkVEJykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7KC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKSkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgZWwudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgWE1MIHNlcmlhbGl6YXRpb24gb2YgdGhpcyBZWG1sRWxlbWVudC5cbiAgICogVGhlIGF0dHJpYnV0ZXMgYXJlIG9yZGVyZWQgYnkgYXR0cmlidXRlLW5hbWUsIHNvIHlvdSBjYW4gZWFzaWx5IHVzZSB0aGlzXG4gICAqIG1ldGhvZCB0byBjb21wYXJlIFlYbWxFbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBjb25zdCBzdHJpbmdCdWlsZGVyID0gW107XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5zb3J0KCk7XG4gICAgY29uc3Qga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKGtleSArICc9XCInICsgYXR0cnNba2V5XSArICdcIicpO1xuICAgIH1cbiAgICBjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBjb25zdCBhdHRyc1N0cmluZyA9IHN0cmluZ0J1aWxkZXIubGVuZ3RoID4gMCA/ICcgJyArIHN0cmluZ0J1aWxkZXIuam9pbignICcpIDogJyc7XG4gICAgcmV0dXJuIGA8JHtub2RlTmFtZX0ke2F0dHJzU3RyaW5nfT4ke3N1cGVyLnRvU3RyaW5nKCl9PC8ke25vZGVOYW1lfT5gXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlVmFsdWUgVGhlIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5zZXQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGF0IGJlbG9uZ3MgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBxdWVyaWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBpbiBhIEpTT04gT2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKHNuYXBzaG90KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBHZXRBbGwodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW2hvb2tzPXt9XSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlLlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBkb20gPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGVOYW1lKTtcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICBkb20uc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB5eG1sID0+IHtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZCh5eG1sLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpKTtcbiAgICB9KTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihkb20sIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxFbGVtZW50UmVmSUQpO1xuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5ub2RlTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sRWxlbWVudCA9IGRlY29kZXIgPT4gbmV3IFlYbWxFbGVtZW50KGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBBbiBFdmVudCB0aGF0IGRlc2NyaWJlcyBjaGFuZ2VzIG9uIGEgWVhtbCBFbGVtZW50IG9yIFl4bWwgRnJhZ21lbnRcbiAqL1xuY2xhc3MgWVhtbEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEZyYWdtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvbiB3aGljaCB0aGUgZXZlbnQgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtTZXQ8c3RyaW5nfG51bGw+fSBzdWJzIFRoZSBzZXQgb2YgY2hhbmdlZCBhdHRyaWJ1dGVzLiBgbnVsbGAgaXMgaW5jbHVkZWQgaWYgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGNoaWxkIGxpc3QgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGggd2ljaCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgc3VicywgdHJhbnNhY3Rpb24pIHtcbiAgICBzdXBlcih0YXJnZXQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRlc0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBZb3UgY2FuIG1hbmFnZSBiaW5kaW5nIHRvIGEgY3VzdG9tIHR5cGUgd2l0aCBZWG1sSG9vay5cbiAqXG4gKiBAZXh0ZW5kcyB7WU1hcDxhbnk+fVxuICovXG5jbGFzcyBZWG1sSG9vayBleHRlbmRzIFlNYXAge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvb2tOYW1lIG5vZGVOYW1lIG9mIHRoZSBEb20gTm9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChob29rTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmhvb2tOYW1lID0gaG9va05hbWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBJdGVtIHdpdGggdGhlIHNhbWUgZWZmZWN0IGFzIHRoaXMgSXRlbSAod2l0aG91dCBwb3NpdGlvbiBlZmZlY3QpXG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxIb29rfVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxIb29rKHRoaXMuaG9va05hbWUpO1xuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgZWwuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgYW55Pn0gW2hvb2tzXSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGhvb2sgPSBob29rc1t0aGlzLmhvb2tOYW1lXTtcbiAgICBsZXQgZG9tO1xuICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvbSA9IGhvb2suY3JlYXRlRG9tKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuaG9va05hbWUpO1xuICAgIH1cbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLXlqcy1ob29rJywgdGhpcy5ob29rTmFtZSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sSG9va1JlZklEKTtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMuaG9va05hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxIb29rfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxIb29rID0gZGVjb2RlciA9PlxuICBuZXcgWVhtbEhvb2soZGVjb2Rlci5yZWFkS2V5KCkpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGV4dCBpbiBhIERvbSBFbGVtZW50LiBJbiB0aGUgZnV0dXJlIHRoaXMgdHlwZSB3aWxsIGFsc28gaGFuZGxlXG4gKiBzaW1wbGUgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBsaWtlIGJvbGQgYW5kIGl0YWxpYy5cbiAqL1xuY2xhc3MgWVhtbFRleHQgZXh0ZW5kcyBZVGV4dCB7XG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLm5leHQgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IHByZXZTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ucHJldiA6IG51bGw7XG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbFRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZWG1sVGV4dCgpO1xuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSk7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbFRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW2hvb2tzXSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlLlxuICAgKiBAcmV0dXJuIHtUZXh0fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy50b0RlbHRhKCkubWFwKGRlbHRhID0+IHtcbiAgICAgIGNvbnN0IG5lc3RlZE5vZGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG5vZGVOYW1lIGluIGRlbHRhLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV0pIHtcbiAgICAgICAgICBhdHRycy5wdXNoKHsga2V5LCB2YWx1ZTogZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV1ba2V5XSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3J0IGF0dHJpYnV0ZXMgdG8gZ2V0IGEgdW5pcXVlIG9yZGVyXG4gICAgICAgIGF0dHJzLnNvcnQoKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IDEpO1xuICAgICAgICBuZXN0ZWROb2Rlcy5wdXNoKHsgbm9kZU5hbWUsIGF0dHJzIH0pO1xuICAgICAgfVxuICAgICAgLy8gc29ydCBub2RlIG9yZGVyIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgbmVzdGVkTm9kZXMuc29ydCgoYSwgYikgPT4gYS5ub2RlTmFtZSA8IGIubm9kZU5hbWUgPyAtMSA6IDEpO1xuICAgICAgLy8gbm93IGNvbnZlcnQgdG8gZG9tIHN0cmluZ1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbmVzdGVkTm9kZXNbaV07XG4gICAgICAgIHN0ciArPSBgPCR7bm9kZS5ub2RlTmFtZX1gO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBhdHRyID0gbm9kZS5hdHRyc1tqXTtcbiAgICAgICAgICBzdHIgKz0gYCAke2F0dHIua2V5fT1cIiR7YXR0ci52YWx1ZX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICc+JztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBkZWx0YS5pbnNlcnQ7XG4gICAgICBmb3IgKGxldCBpID0gbmVzdGVkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3RyICs9IGA8LyR7bmVzdGVkTm9kZXNbaV0ubm9kZU5hbWV9PmA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfSkuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbFRleHRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbFRleHR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbFRleHQgPSBkZWNvZGVyID0+IG5ldyBZWG1sVGV4dCgpO1xuXG5jbGFzcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlbmd0aCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0aGlzIHN0cnVjdCB3aXRoIHRoZSBpdGVtIHRvIHRoZSByaWdodC5cbiAgICogVGhpcyBtZXRob2QgaXMgYWxyZWFkeSBhc3N1bWluZyB0aGF0IGB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggPT09IHRoaXMuaWQuY2xvY2tgLlxuICAgKiBBbHNvIHRoaXMgbWV0aG9kIGRvZXMgKm5vdCogcmVtb3ZlIHJpZ2h0IGZyb20gU3RydWN0U3RvcmUhXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdldGhlciB0aGlzIG1lcmdlZCB3aXRoIHJpZ2h0XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5jb2RpbmdSZWZcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQsIGVuY29kaW5nUmVmKSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cbn1cblxuY29uc3Qgc3RydWN0R0NSZWZOdW1iZXIgPSAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEdDIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlbGV0ZSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dDfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICB0aGlzLmlkLmNsb2NrICs9IG9mZnNldDtcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldDtcbiAgICB9XG4gICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVJbmZvKHN0cnVjdEdDUmVmTnVtYmVyKTtcbiAgICBlbmNvZGVyLndyaXRlTGVuKHRoaXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jbGFzcyBDb250ZW50QmluYXJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNvbnRlbnRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRCaW5hcnkodGhpcy5jb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QmluYXJ5fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlQnVmKHRoaXMuY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gM1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIgfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICovXG5jb25zdCByZWFkQ29udGVudEJpbmFyeSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRCaW5hcnkoZGVjb2Rlci5yZWFkQnVmKCkpO1xuXG5jbGFzcyBDb250ZW50RGVsZXRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVuKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4gLSBvZmZzZXQpO1xuICAgIHRoaXMubGVuID0gb2Zmc2V0O1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERlbGV0ZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5sZW4gKz0gcmlnaHQubGVuO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtLmlkLmNsaWVudCwgaXRlbS5pZC5jbG9jaywgdGhpcy5sZW4pO1xuICAgIGl0ZW0ubWFya0RlbGV0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbiAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMiB9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICovXG5jb25zdCByZWFkQ29udGVudERlbGV0ZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RGVsZXRlZChkZWNvZGVyLnJlYWRMZW4oKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudERvYyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgaWYgKGRvYy5faXRlbSkge1xuICAgICAgY29uc29sZS5lcnJvcignVGhpcyBkb2N1bWVudCB3YXMgYWxyZWFkeSBpbnRlZ3JhdGVkIGFzIGEgc3ViLWRvY3VtZW50LiBZb3Ugc2hvdWxkIGNyZWF0ZSBhIHNlY29uZCBpbnN0YW5jZSBpbnN0ZWFkIHdpdGggdGhlIHNhbWUgZ3VpZC4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY31cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIGlmICghZG9jLmdjKSB7XG4gICAgICBvcHRzLmdjID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkb2MuYXV0b0xvYWQpIHtcbiAgICAgIG9wdHMuYXV0b0xvYWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZG9jLm1ldGEgIT09IG51bGwpIHtcbiAgICAgIG9wdHMubWV0YSA9IGRvYy5tZXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5kb2NdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnREb2ModGhpcy5kb2MpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREb2N9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgLy8gdGhpcyBuZWVkcyB0byBiZSByZWZsZWN0ZWQgaW4gZG9jLmRlc3Ryb3kgYXMgd2VsbFxuICAgIHRoaXMuZG9jLl9pdGVtID0gaXRlbTtcbiAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuYWRkKHRoaXMuZG9jKTtcbiAgICBpZiAodGhpcy5kb2Muc2hvdWxkTG9hZCkge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0xvYWRlZC5hZGQodGhpcy5kb2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuaGFzKHRoaXMuZG9jKSkge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmRlbGV0ZSh0aGlzLmRvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzLmRvYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHsgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyh0aGlzLmRvYy5ndWlkKTtcbiAgICBlbmNvZGVyLndyaXRlQW55KHRoaXMub3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gOVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERvY31cbiAqL1xuY29uc3QgcmVhZENvbnRlbnREb2MgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RG9jKG5ldyBEb2MoeyBndWlkOiBkZWNvZGVyLnJlYWRTdHJpbmcoKSwgLi4uZGVjb2Rlci5yZWFkQW55KCkgfSkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRFbWJlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW1iZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbWJlZCkge1xuICAgIHRoaXMuZW1iZWQgPSBlbWJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5lbWJlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RW1iZWQodGhpcy5lbWJlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RW1iZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVKU09OKHRoaXMuZW1iZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDVcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRFbWJlZCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRFbWJlZChkZWNvZGVyLnJlYWRKU09OKCkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRGb3JtYXQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50Rm9ybWF0KHRoaXMua2V5LCB0aGlzLnZhbHVlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgbWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIEB0b2RvIHNlYXJjaG1hcmtlciBhcmUgY3VycmVudGx5IHVuc3VwcG9ydGVkIGZvciByaWNoIHRleHQgZG9jdW1lbnRzXG4gICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5fc2VhcmNoTWFya2VyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmtleSk7XG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy52YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNlxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50Rm9ybWF0ID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEZvcm1hdChkZWNvZGVyLnJlYWRTdHJpbmcoKSwgZGVjb2Rlci5yZWFkSlNPTigpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50SlNPTiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGFycikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEpTT059XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRKU09OKHRoaXMuYXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEpTT059XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRKU09OKHRoaXMuYXJyLnNsaWNlKG9mZnNldCkpO1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRKU09OfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycik7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5hcnIubGVuZ3RoO1xuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXTtcbiAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoYyA9PT0gdW5kZWZpbmVkID8gJ3VuZGVmaW5lZCcgOiBKU09OLnN0cmluZ2lmeShjKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICovXG5jb25zdCByZWFkQ29udGVudEpTT04gPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gIGNvbnN0IGNzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjID0gZGVjb2Rlci5yZWFkU3RyaW5nKCk7XG4gICAgaWYgKGMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzLnB1c2goSlNPTi5wYXJzZShjKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQ29udGVudEpTT04oY3MpXG59O1xuXG5jbGFzcyBDb250ZW50QW55IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QW55KHRoaXMuYXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudEFueSh0aGlzLmFyci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QW55fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycik7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5hcnIubGVuZ3RoO1xuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXTtcbiAgICAgIGVuY29kZXIud3JpdGVBbnkoYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICovXG5jb25zdCByZWFkQ29udGVudEFueSA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgY29uc3QgY3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNzLnB1c2goZGVjb2Rlci5yZWFkQW55KCkpO1xuICB9XG4gIHJldHVybiBuZXcgQ29udGVudEFueShjcylcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudFN0cmluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0ciA9IHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLnNwbGl0KCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0ci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAvLyBQcmV2ZW50IGVuY29kaW5nIGludmFsaWQgZG9jdW1lbnRzIGJlY2F1c2Ugb2Ygc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlyczogaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzI0OFxuICAgIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSB0aGlzLnN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDEpO1xuICAgIGlmIChmaXJzdENoYXJDb2RlID49IDB4RDgwMCAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxlZnQgc3BsaXQgaXMgdGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHV0ZjE2L3VjczIgcGFpci5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlycyBiZWNhdXNlIHRoaXMgbWF5IGxlYWQgdG8gaW52YWxpZCBkb2N1bWVudHMuXG4gICAgICAvLyBSZXBsYWNlIHRoZSBpbnZhbGlkIGNoYXJhY3RlciB3aXRoIGEgdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKO+/vSAvIFUrRkZGRClcbiAgICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0IC0gMSkgKyAn77+9JztcbiAgICAgIC8vIHJlcGxhY2UgcmlnaHQgYXMgd2VsbFxuICAgICAgcmlnaHQuc3RyID0gJ++/vScgKyByaWdodC5zdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudFN0cmluZ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLnN0ciArPSByaWdodC5zdHI7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyhvZmZzZXQgPT09IDAgPyB0aGlzLnN0ciA6IHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50U3RyaW5nID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFN0cmluZyhkZWNvZGVyLnJlYWRTdHJpbmcoKSk7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKFVwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMik6QWJzdHJhY3RUeXBlPGFueT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdHlwZVJlZnMgPSBbXG4gIHJlYWRZQXJyYXksXG4gIHJlYWRZTWFwLFxuICByZWFkWVRleHQsXG4gIHJlYWRZWG1sRWxlbWVudCxcbiAgcmVhZFlYbWxGcmFnbWVudCxcbiAgcmVhZFlYbWxIb29rLFxuICByZWFkWVhtbFRleHRcbl07XG5cbmNvbnN0IFlBcnJheVJlZklEID0gMDtcbmNvbnN0IFlNYXBSZWZJRCA9IDE7XG5jb25zdCBZVGV4dFJlZklEID0gMjtcbmNvbnN0IFlYbWxFbGVtZW50UmVmSUQgPSAzO1xuY29uc3QgWVhtbEZyYWdtZW50UmVmSUQgPSA0O1xuY29uc3QgWVhtbEhvb2tSZWZJRCA9IDU7XG5jb25zdCBZWG1sVGV4dFJlZklEID0gNjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxZRXZlbnQ+fSB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnR5cGVdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50VHlwZSh0aGlzLnR5cGUuX2NvcHkoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBtZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRUeXBlfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIHRoaXMudHlwZS5faW50ZWdyYXRlKHRyYW5zYWN0aW9uLmRvYywgaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnQ7XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoaXMgd2lsbCBiZSBnYydkIGxhdGVyIGFuZCB3ZSB3YW50IHRvIG1lcmdlIGl0IGlmIHBvc3NpYmxlXG4gICAgICAgIC8vIFdlIHRyeSB0byBtZXJnZSBhbGwgZGVsZXRlZCBpdGVtcyBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLFxuICAgICAgICAvLyBidXQgd2UgaGF2ZSBubyBrbm93bGVkZ2UgYWJvdXQgdGhhdCB0aGlzIG5lZWRzIHRvIGJlIG1lcmdlZFxuICAgICAgICAvLyBzaW5jZSBpdCBpcyBub3QgaW4gdHJhbnNhY3Rpb24uZHMuIEhlbmNlIHdlIGFkZCBpdCB0byB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5kZWxldGUodGhpcy50eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0O1xuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKTtcbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnR5cGUuX3N0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKC8qKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtICovIChpdGVtKSA9PiB7XG4gICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKTtcbiAgICAgICAgaXRlbSA9IGl0ZW0ubGVmdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnR5cGUuX21hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgdGhpcy50eXBlLl93cml0ZShlbmNvZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA3XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRUeXBlID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFR5cGUodHlwZVJlZnNbZGVjb2Rlci5yZWFkVHlwZVJlZigpXShkZWNvZGVyKSk7XG5cbi8qKlxuICogQHRvZG8gVGhpcyBzaG91bGQgcmV0dXJuIHNldmVyYWwgaXRlbXNcbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge3tpdGVtOkl0ZW0sIGRpZmY6bnVtYmVyfX1cbiAqL1xuY29uc3QgZm9sbG93UmVkb25lID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0lEfG51bGx9XG4gICAqL1xuICBsZXQgbmV4dElEID0gaWQ7XG4gIGxldCBkaWZmID0gMDtcbiAgbGV0IGl0ZW07XG4gIGRvIHtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIG5leHRJRCA9IGNyZWF0ZUlEKG5leHRJRC5jbGllbnQsIG5leHRJRC5jbG9jayArIGRpZmYpO1xuICAgIH1cbiAgICBpdGVtID0gZ2V0SXRlbShzdG9yZSwgbmV4dElEKTtcbiAgICBkaWZmID0gbmV4dElELmNsb2NrIC0gaXRlbS5pZC5jbG9jaztcbiAgICBuZXh0SUQgPSBpdGVtLnJlZG9uZTtcbiAgfSB3aGlsZSAobmV4dElEICE9PSBudWxsICYmIGl0ZW0gaW5zdGFuY2VvZiBJdGVtKVxuICByZXR1cm4ge1xuICAgIGl0ZW0sIGRpZmZcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCBuZWl0aGVyIGl0ZW0gbm9yIGFueSBvZiBpdHMgcGFyZW50cyBpcyBldmVyIGRlbGV0ZWQuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCBwZXJzaXN0IHdoZW4gc3RvcmluZyBpdCBpbnRvIGEgZGF0YWJhc2Ugb3Igd2hlblxuICogc2VuZGluZyBpdCB0byBvdGhlciBwZWVyc1xuICpcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBcbiAqL1xuY29uc3Qga2VlcEl0ZW0gPSAoaXRlbSwga2VlcCkgPT4ge1xuICB3aGlsZSAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtLmtlZXAgIT09IGtlZXApIHtcbiAgICBpdGVtLmtlZXAgPSBrZWVwO1xuICAgIGl0ZW0gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9pdGVtO1xuICB9XG59O1xuXG4vKipcbiAqIFNwbGl0IGxlZnRJdGVtIGludG8gdHdvIGl0ZW1zXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtfSBsZWZ0SXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzcGxpdEl0ZW0gPSAodHJhbnNhY3Rpb24sIGxlZnRJdGVtLCBkaWZmKSA9PiB7XG4gIC8vIGNyZWF0ZSByaWdodEl0ZW1cbiAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZDtcbiAgY29uc3QgcmlnaHRJdGVtID0gbmV3IEl0ZW0oXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLFxuICAgIGxlZnRJdGVtLFxuICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmIC0gMSksXG4gICAgbGVmdEl0ZW0ucmlnaHQsXG4gICAgbGVmdEl0ZW0ucmlnaHRPcmlnaW4sXG4gICAgbGVmdEl0ZW0ucGFyZW50LFxuICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICBsZWZ0SXRlbS5jb250ZW50LnNwbGljZShkaWZmKVxuICApO1xuICBpZiAobGVmdEl0ZW0uZGVsZXRlZCkge1xuICAgIHJpZ2h0SXRlbS5tYXJrRGVsZXRlZCgpO1xuICB9XG4gIGlmIChsZWZ0SXRlbS5rZWVwKSB7XG4gICAgcmlnaHRJdGVtLmtlZXAgPSB0cnVlO1xuICB9XG4gIGlmIChsZWZ0SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICByaWdodEl0ZW0ucmVkb25lID0gY3JlYXRlSUQobGVmdEl0ZW0ucmVkb25lLmNsaWVudCwgbGVmdEl0ZW0ucmVkb25lLmNsb2NrICsgZGlmZik7XG4gIH1cbiAgLy8gdXBkYXRlIGxlZnQgKGRvIG5vdCBzZXQgbGVmdEl0ZW0ucmlnaHRPcmlnaW4gYXMgaXQgd2lsbCBsZWFkIHRvIHByb2JsZW1zIHdoZW4gc3luY2luZylcbiAgbGVmdEl0ZW0ucmlnaHQgPSByaWdodEl0ZW07XG4gIC8vIHVwZGF0ZSByaWdodFxuICBpZiAocmlnaHRJdGVtLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJpZ2h0LmxlZnQgPSByaWdodEl0ZW07XG4gIH1cbiAgLy8gcmlnaHQgaXMgbW9yZSBzcGVjaWZpYy5cbiAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKHJpZ2h0SXRlbSk7XG4gIC8vIHVwZGF0ZSBwYXJlbnQuX21hcFxuICBpZiAocmlnaHRJdGVtLnBhcmVudFN1YiAhPT0gbnVsbCAmJiByaWdodEl0ZW0ucmlnaHQgPT09IG51bGwpIHtcbiAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRJdGVtLnBhcmVudCkuX21hcC5zZXQocmlnaHRJdGVtLnBhcmVudFN1YiwgcmlnaHRJdGVtKTtcbiAgfVxuICBsZWZ0SXRlbS5sZW5ndGggPSBkaWZmO1xuICByZXR1cm4gcmlnaHRJdGVtXG59O1xuXG4vKipcbiAqIFJlZG9lcyB0aGUgZWZmZWN0IG9mIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSBZanMgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U2V0PEl0ZW0+fSByZWRvaXRlbXNcbiAqXG4gKiBAcmV0dXJuIHtJdGVtfG51bGx9XG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcmVkb0l0ZW0gPSAodHJhbnNhY3Rpb24sIGl0ZW0sIHJlZG9pdGVtcykgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCBvd25DbGllbnRJRCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3QgcmVkb25lID0gaXRlbS5yZWRvbmU7XG4gIGlmIChyZWRvbmUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHJlZG9uZSlcbiAgfVxuICBsZXQgcGFyZW50SXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW07XG4gIC8qKlxuICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgKi9cbiAgbGV0IGxlZnQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgKi9cbiAgbGV0IHJpZ2h0O1xuICBpZiAoaXRlbS5wYXJlbnRTdWIgPT09IG51bGwpIHtcbiAgICAvLyBJcyBhbiBhcnJheSBpdGVtLiBJbnNlcnQgYXQgdGhlIG9sZCBwb3NpdGlvblxuICAgIGxlZnQgPSBpdGVtLmxlZnQ7XG4gICAgcmlnaHQgPSBpdGVtO1xuICB9IGVsc2Uge1xuICAgIC8vIElzIGEgbWFwIGl0ZW0uIEluc2VydCBhcyBjdXJyZW50IHZhbHVlXG4gICAgbGVmdCA9IGl0ZW07XG4gICAgd2hpbGUgKGxlZnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgIGxlZnQgPSBsZWZ0LnJpZ2h0O1xuICAgICAgaWYgKGxlZnQuaWQuY2xpZW50ICE9PSBvd25DbGllbnRJRCkge1xuICAgICAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gcmVkbyB0aGlzIGl0ZW0gYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBhXG4gICAgICAgIC8vIGNoYW5nZSBmcm9tIGFub3RoZXIgY2xpZW50XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBsZWZ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5fbWFwLmdldChpdGVtLnBhcmVudFN1YikpO1xuICAgIH1cbiAgICByaWdodCA9IG51bGw7XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoYXQgcGFyZW50IGlzIHJlZG9uZVxuICBpZiAocGFyZW50SXRlbSAhPT0gbnVsbCAmJiBwYXJlbnRJdGVtLmRlbGV0ZWQgPT09IHRydWUgJiYgcGFyZW50SXRlbS5yZWRvbmUgPT09IG51bGwpIHtcbiAgICAvLyB0cnkgdG8gdW5kbyBwYXJlbnQgaWYgaXQgd2lsbCBiZSB1bmRvbmUgYW55d2F5XG4gICAgaWYgKCFyZWRvaXRlbXMuaGFzKHBhcmVudEl0ZW0pIHx8IHJlZG9JdGVtKHRyYW5zYWN0aW9uLCBwYXJlbnRJdGVtLCByZWRvaXRlbXMpID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuICBpZiAocGFyZW50SXRlbSAhPT0gbnVsbCAmJiBwYXJlbnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHdoaWxlIChwYXJlbnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50SXRlbSA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBwYXJlbnRJdGVtLnJlZG9uZSk7XG4gICAgfVxuICAgIC8vIGZpbmQgbmV4dCBjbG9uZWRfcmVkbyBpdGVtc1xuICAgIHdoaWxlIChsZWZ0ICE9PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCBsZWZ0VHJhY2UgPSBsZWZ0O1xuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSAhPT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0VHJhY2UgPSBsZWZ0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBsZWZ0VHJhY2UucmVkb25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGxlZnRUcmFjZS5wYXJlbnQpLl9pdGVtID09PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIGxlZnQgPSBsZWZ0VHJhY2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBsZWZ0ID0gbGVmdC5sZWZ0O1xuICAgIH1cbiAgICB3aGlsZSAocmlnaHQgIT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHJpZ2h0VHJhY2UgPSByaWdodDtcbiAgICAgIC8vIHRyYWNlIHJlZG9uZSB1bnRpbCBwYXJlbnQgbWF0Y2hlc1xuICAgICAgd2hpbGUgKHJpZ2h0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0VHJhY2UucGFyZW50KS5faXRlbSAhPT0gcGFyZW50SXRlbSkge1xuICAgICAgICByaWdodFRyYWNlID0gcmlnaHRUcmFjZS5yZWRvbmUgPT09IG51bGwgPyBudWxsIDogZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHJpZ2h0VHJhY2UucmVkb25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgcmlnaHQgPSByaWdodFRyYWNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcmlnaHQgPSByaWdodC5yaWdodDtcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV4dENsb2NrID0gZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElEKTtcbiAgY29uc3QgbmV4dElkID0gY3JlYXRlSUQob3duQ2xpZW50SUQsIG5leHRDbG9jayk7XG4gIGNvbnN0IHJlZG9uZUl0ZW0gPSBuZXcgSXRlbShcbiAgICBuZXh0SWQsXG4gICAgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCxcbiAgICByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsXG4gICAgcGFyZW50SXRlbSA9PT0gbnVsbCA/IGl0ZW0ucGFyZW50IDogLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKHBhcmVudEl0ZW0uY29udGVudCkudHlwZSxcbiAgICBpdGVtLnBhcmVudFN1YixcbiAgICBpdGVtLmNvbnRlbnQuY29weSgpXG4gICk7XG4gIGl0ZW0ucmVkb25lID0gbmV4dElkO1xuICBrZWVwSXRlbShyZWRvbmVJdGVtLCB0cnVlKTtcbiAgcmVkb25lSXRlbS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICByZXR1cm4gcmVkb25lSXRlbVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gKi9cbmNsYXNzIEl0ZW0gZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSBvcmlnaW5cbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gcmlnaHRcbiAgICogQHBhcmFtIHtJRCB8IG51bGx9IHJpZ2h0T3JpZ2luXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH0gcGFyZW50IElzIGEgdHlwZSBpZiBpbnRlZ3JhdGVkLCBpcyBudWxsIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGNvcHkgcGFyZW50IGZyb20gbGVmdCBvciByaWdodCwgaXMgSUQgYmVmb3JlIGludGVncmF0aW9uIHRvIHNlYXJjaCBmb3IgaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGFyZW50U3ViXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250ZW50fSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlZnQsIG9yaWdpbiwgcmlnaHQsIHJpZ2h0T3JpZ2luLCBwYXJlbnQsIHBhcmVudFN1YiwgY29udGVudCkge1xuICAgIHN1cGVyKGlkLCBjb250ZW50LmdldExlbmd0aCgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgaXMgY3VycmVudGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodE9yaWdpbiA9IHJpZ2h0T3JpZ2luO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55PnxJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwYXJlbnQgcmVmZXJzIHRvIHRoaXMgaXRlbSB3aXRoIHNvbWUga2luZCBvZiBrZXkgKGUuZy4gWU1hcCwgdGhlXG4gICAgICoga2V5IGlzIHNwZWNpZmllZCBoZXJlLiBUaGUga2V5IGlzIHRoZW4gdXNlZCB0byByZWZlciB0byB0aGUgbGlzdCBpbiB3aGljaFxuICAgICAqIHRvIGluc2VydCB0aGlzIGl0ZW0uIElmIGBwYXJlbnRTdWIgPSBudWxsYCB0eXBlLl9zdGFydCBpcyB0aGUgbGlzdCBpblxuICAgICAqIHdoaWNoIHRvIGluc2VydCB0by4gT3RoZXJ3aXNlIGl0IGlzIGBwYXJlbnQuX21hcGAuXG4gICAgICogQHR5cGUge1N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB0eXBlJ3MgZWZmZWN0IGlzIHJldW5kb25lIHRoaXMgdHlwZSByZWZlcnMgdG8gdGhlIHR5cGUgdGhhdCB1bmRpZFxuICAgICAqIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZWRvbmUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdENvbnRlbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAvKipcbiAgICAgKiBiaXQxOiBrZWVwXG4gICAgICogYml0MjogY291bnRhYmxlXG4gICAgICogYml0MzogZGVsZXRlZFxuICAgICAqIGJpdDQ6IG1hcmsgLSBtYXJrIG5vZGUgYXMgZmFzdC1zZWFyY2gtbWFya2VyXG4gICAgICogQHR5cGUge251bWJlcn0gYnl0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHRoaXMuY29udGVudC5pc0NvdW50YWJsZSgpID8gQklUMiA6IDA7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB1c2VkIHRvIG1hcmsgdGhlIGl0ZW0gYXMgYW4gaW5kZXhlZCBmYXN0LXNlYXJjaCBtYXJrZXJcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzZXQgbWFya2VyIChpc01hcmtlZCkge1xuICAgIGlmICgoKHRoaXMuaW5mbyAmIEJJVDQpID4gMCkgIT09IGlzTWFya2VkKSB7XG4gICAgICB0aGlzLmluZm8gXj0gQklUNDtcbiAgICB9XG4gIH1cblxuICBnZXQgbWFya2VyICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIEJJVDQpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGRvIG5vdCBnYXJiYWdlIGNvbGxlY3QgdGhpcyBJdGVtLlxuICAgKi9cbiAgZ2V0IGtlZXAgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgQklUMSkgPiAwXG4gIH1cblxuICBzZXQga2VlcCAoZG9LZWVwKSB7XG4gICAgaWYgKHRoaXMua2VlcCAhPT0gZG9LZWVwKSB7XG4gICAgICB0aGlzLmluZm8gXj0gQklUMTtcbiAgICB9XG4gIH1cblxuICBnZXQgY291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIEJJVDIpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpdGVtIHdhcyBkZWxldGVkIG9yIG5vdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBCSVQzKSA+IDBcbiAgfVxuXG4gIHNldCBkZWxldGVkIChkb0RlbGV0ZSkge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQgIT09IGRvRGVsZXRlKSB7XG4gICAgICB0aGlzLmluZm8gXj0gQklUMztcbiAgICB9XG4gIH1cblxuICBtYXJrRGVsZXRlZCAoKSB7XG4gICAgdGhpcy5pbmZvIHw9IEJJVDM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjcmVhdG9yIGNsaWVudElEIG9mIHRoZSBtaXNzaW5nIG9wIG9yIGRlZmluZSBtaXNzaW5nIGl0ZW1zIGFuZCByZXR1cm4gbnVsbC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIGlmICh0aGlzLm9yaWdpbiAmJiB0aGlzLm9yaWdpbi5jbGllbnQgIT09IHRoaXMuaWQuY2xpZW50ICYmIHRoaXMub3JpZ2luLmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLm9yaWdpbi5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW4uY2xpZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnJpZ2h0T3JpZ2luICYmIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50ICE9PSB0aGlzLmlkLmNsaWVudCAmJiB0aGlzLnJpZ2h0T3JpZ2luLmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudFxuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY29uc3RydWN0b3IgPT09IElEICYmIHRoaXMuaWQuY2xpZW50ICE9PSB0aGlzLnBhcmVudC5jbGllbnQgJiYgdGhpcy5wYXJlbnQuY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMucGFyZW50LmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jbGllbnRcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGFsbCBtaXNzaW5nIGlkcywgbm93IGZpbmQgdGhlIGl0ZW1zXG5cbiAgICBpZiAodGhpcy5vcmlnaW4pIHtcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgc3RvcmUsIHRoaXMub3JpZ2luKTtcbiAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5sZWZ0Lmxhc3RJZDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmlnaHRPcmlnaW4pIHtcbiAgICAgIHRoaXMucmlnaHQgPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgdGhpcy5yaWdodE9yaWdpbik7XG4gICAgICB0aGlzLnJpZ2h0T3JpZ2luID0gdGhpcy5yaWdodC5pZDtcbiAgICB9XG4gICAgaWYgKCh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LmNvbnN0cnVjdG9yID09PSBHQykgfHwgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5jb25zdHJ1Y3RvciA9PT0gR0MpKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICAgIC8vIG9ubHkgc2V0IHBhcmVudCBpZiB0aGlzIHNob3VsZG4ndCBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5sZWZ0LnBhcmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLmxlZnQucGFyZW50U3ViO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMucmlnaHQucGFyZW50O1xuICAgICAgICB0aGlzLnBhcmVudFN1YiA9IHRoaXMucmlnaHQucGFyZW50U3ViO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICBjb25zdCBwYXJlbnRJdGVtID0gZ2V0SXRlbShzdG9yZSwgdGhpcy5wYXJlbnQpO1xuICAgICAgaWYgKHBhcmVudEl0ZW0uY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKHBhcmVudEl0ZW0uY29udGVudCkudHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXQ7XG4gICAgICB0aGlzLmxlZnQgPSBnZXRJdGVtQ2xlYW5FbmQodHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgY3JlYXRlSUQodGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2sgLSAxKSk7XG4gICAgICB0aGlzLm9yaWdpbiA9IHRoaXMubGVmdC5sYXN0SWQ7XG4gICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc3BsaWNlKG9mZnNldCk7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBpZiAoKCF0aGlzLmxlZnQgJiYgKCF0aGlzLnJpZ2h0IHx8IHRoaXMucmlnaHQubGVmdCAhPT0gbnVsbCkpIHx8ICh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LnJpZ2h0ICE9PSB0aGlzLnJpZ2h0KSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG87XG4gICAgICAgIC8vIHNldCBvIHRvIHRoZSBmaXJzdCBjb25mbGljdGluZyBpdGVtXG4gICAgICAgIGlmIChsZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IGxlZnQucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbDtcbiAgICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBvLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBvLmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB1c2Ugc29tZXRoaW5nIGxpa2UgRGVsZXRlU2V0IGhlcmUgKGEgdHJlZSBpbXBsZW1lbnRhdGlvbiB3b3VsZCBiZSBiZXN0KVxuICAgICAgICAvLyBAdG9kbyB1c2UgZ2xvYmFsIHNldCBkZWZpbml0aW9uc1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNvbmZsaWN0aW5nSXRlbXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaXRlbXNCZWZvcmVPcmlnaW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIExldCBjIGluIGNvbmZsaWN0aW5nSXRlbXMsIGIgaW4gaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgLy8gKioqe29yaWdpbn1iYmJie3RoaXN9e2MsYn17YyxifXtvfSoqKlxuICAgICAgICAvLyBOb3RlIHRoYXQgY29uZmxpY3RpbmdJdGVtcyBpcyBhIHN1YnNldCBvZiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBvICE9PSB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgaXRlbXNCZWZvcmVPcmlnaW4uYWRkKG8pO1xuICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuYWRkKG8pO1xuICAgICAgICAgIGlmIChjb21wYXJlSURzKHRoaXMub3JpZ2luLCBvLm9yaWdpbikpIHtcbiAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgaWYgKG8uaWQuY2xpZW50IDwgdGhpcy5pZC5jbGllbnQpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IG87XG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29tcGFyZUlEcyh0aGlzLnJpZ2h0T3JpZ2luLCBvLnJpZ2h0T3JpZ2luKSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGFuZCBvIGFyZSBjb25mbGljdGluZyBhbmQgcG9pbnQgdG8gdGhlIHNhbWUgaW50ZWdyYXRpb24gcG9pbnRzLiBUaGUgaWQgZGVjaWRlcyB3aGljaCBpdGVtIGNvbWVzIGZpcnN0LlxuICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIHRvIHRoZSBsZWZ0IG9mIG8sIHdlIGNhbiBicmVhayBoZXJlXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9IC8vIGVsc2UsIG8gbWlnaHQgYmUgaW50ZWdyYXRlZCBiZWZvcmUgYW4gaXRlbSB0aGF0IHRoaXMgY29uZmxpY3RzIHdpdGguIElmIHNvLCB3ZSB3aWxsIGZpbmQgaXQgaW4gdGhlIG5leHQgaXRlcmF0aW9uc1xuICAgICAgICAgIH0gZWxzZSBpZiAoby5vcmlnaW4gIT09IG51bGwgJiYgaXRlbXNCZWZvcmVPcmlnaW4uaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7IC8vIHVzZSBnZXRJdGVtIGluc3RlYWQgb2YgZ2V0SXRlbUNsZWFuRW5kIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCAvIG5lZWQgdG8gc3BsaXQgaXRlbXMuXG4gICAgICAgICAgICAvLyBjYXNlIDJcbiAgICAgICAgICAgIGlmICghY29uZmxpY3RpbmdJdGVtcy5oYXMoZ2V0SXRlbSh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIG8ub3JpZ2luKSkpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IG87XG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgbyA9IG8ucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICAgIC8vIHJlY29ubmVjdCBsZWZ0L3JpZ2h0ICsgdXBkYXRlIHBhcmVudCBtYXAvc3RhcnQgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5sZWZ0LnJpZ2h0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHRoaXMubGVmdC5yaWdodCA9IHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcjtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgciA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5nZXQodGhpcy5wYXJlbnRTdWIpIHx8IG51bGw7XG4gICAgICAgICAgd2hpbGUgKHIgIT09IG51bGwgJiYgci5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByID0gci5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnRcbiAgICAgICAgICA7LyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnQgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmlnaHQgPSByO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gc2V0IGFzIGN1cnJlbnQgcGFyZW50IHZhbHVlIGlmIHJpZ2h0ID09PSBudWxsIGFuZCB0aGlzIGlzIHBhcmVudFN1YlxuICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuc2V0KHRoaXMucGFyZW50U3ViLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGN1cnJlbnQgYXR0cmlidXRlIHZhbHVlIG9mIHBhcmVudC4gZGVsZXRlIHJpZ2h0XG4gICAgICAgICAgdGhpcy5sZWZ0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFkanVzdCBsZW5ndGggb2YgcGFyZW50XG4gICAgICBpZiAodGhpcy5wYXJlbnRTdWIgPT09IG51bGwgJiYgdGhpcy5jb3VudGFibGUgJiYgIXRoaXMuZGVsZXRlZCkge1xuICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9sZW5ndGggKz0gdGhpcy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBhZGRTdHJ1Y3QodHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0aGlzKTtcbiAgICAgIHRoaXMuY29udGVudC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIHRoaXMpO1xuICAgICAgLy8gYWRkIHBhcmVudCB0byB0cmFuc2FjdGlvbi5jaGFuZ2VkXG4gICAgICBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCksIHRoaXMucGFyZW50U3ViKTtcbiAgICAgIGlmICgoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5faXRlbSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtLmRlbGV0ZWQpIHx8ICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCAmJiB0aGlzLnJpZ2h0ICE9PSBudWxsKSkge1xuICAgICAgICAvLyBkZWxldGUgaWYgcGFyZW50IGlzIGRlbGV0ZWQgb3IgaWYgdGhpcyBpcyBub3QgdGhlIGN1cnJlbnQgYXR0cmlidXRlIHZhbHVlIG9mIHBhcmVudFxuICAgICAgICB0aGlzLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBpcyBub3QgZGVmaW5lZC4gSW50ZWdyYXRlIEdDIHN0cnVjdCBpbnN0ZWFkXG4gICAgICBuZXcgR0ModGhpcy5pZCwgdGhpcy5sZW5ndGgpLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IG5leHQgKCkge1xuICAgIGxldCBuID0gdGhpcy5yaWdodDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gblxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZXZpb3VzIG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBwcmV2ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMubGVmdDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGxhc3QgY29udGVudCBhZGRyZXNzIG9mIHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBsYXN0SWQgKCkge1xuICAgIC8vIGFsbG9jYXRpbmcgaWRzIGlzIHByZXR0eSBjb3N0bHkgYmVjYXVzZSBvZiB0aGUgYW1vdW50IG9mIGlkcyBjcmVhdGVkLCBzbyB3ZSB0cnkgdG8gcmV1c2Ugd2hlbmV2ZXIgcG9zc2libGVcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgPyB0aGlzLmlkIDogY3JlYXRlSUQodGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIG1lcmdlIHR3byBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29uc3RydWN0b3IgJiZcbiAgICAgIGNvbXBhcmVJRHMocmlnaHQub3JpZ2luLCB0aGlzLmxhc3RJZCkgJiZcbiAgICAgIHRoaXMucmlnaHQgPT09IHJpZ2h0ICYmXG4gICAgICBjb21wYXJlSURzKHRoaXMucmlnaHRPcmlnaW4sIHJpZ2h0LnJpZ2h0T3JpZ2luKSAmJlxuICAgICAgdGhpcy5pZC5jbGllbnQgPT09IHJpZ2h0LmlkLmNsaWVudCAmJlxuICAgICAgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSByaWdodC5pZC5jbG9jayAmJlxuICAgICAgdGhpcy5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmXG4gICAgICB0aGlzLnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgcmlnaHQucmVkb25lID09PSBudWxsICYmXG4gICAgICB0aGlzLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgJiZcbiAgICAgIHRoaXMuY29udGVudC5tZXJnZVdpdGgocmlnaHQuY29udGVudClcbiAgICApIHtcbiAgICAgIGlmIChyaWdodC5rZWVwKSB7XG4gICAgICAgIHRoaXMua2VlcCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KTtcbiAgICAgIC8vIGFkanVzdCB0aGUgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMuY291bnRhYmxlICYmIHRoaXMucGFyZW50U3ViID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5fbGVuZ3RoIC09IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXJrRGVsZXRlZCgpO1xuICAgICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCB0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jaywgdGhpcy5sZW5ndGgpO1xuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBwYXJlbnQsIHRoaXMucGFyZW50U3ViKTtcbiAgICAgIHRoaXMuY29udGVudC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmVudEdDZFxuICAgKi9cbiAgZ2MgKHN0b3JlLCBwYXJlbnRHQ2QpIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhyb3cgdW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQuZ2Moc3RvcmUpO1xuICAgIGlmIChwYXJlbnRHQ2QpIHtcbiAgICAgIHJlcGxhY2VTdHJ1Y3Qoc3RvcmUsIHRoaXMsIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb2Zmc2V0ID4gMCA/IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgb2Zmc2V0IC0gMSkgOiB0aGlzLm9yaWdpbjtcbiAgICBjb25zdCByaWdodE9yaWdpbiA9IHRoaXMucmlnaHRPcmlnaW47XG4gICAgY29uc3QgcGFyZW50U3ViID0gdGhpcy5wYXJlbnRTdWI7XG4gICAgY29uc3QgaW5mbyA9ICh0aGlzLmNvbnRlbnQuZ2V0UmVmKCkgJiBCSVRTNSkgfFxuICAgICAgKG9yaWdpbiA9PT0gbnVsbCA/IDAgOiBCSVQ4KSB8IC8vIG9yaWdpbiBpcyBkZWZpbmVkXG4gICAgICAocmlnaHRPcmlnaW4gPT09IG51bGwgPyAwIDogQklUNykgfCAvLyByaWdodCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHBhcmVudFN1YiA9PT0gbnVsbCA/IDAgOiBCSVQ2KTsgLy8gcGFyZW50U3ViIGlzIG5vbi1udWxsXG4gICAgZW5jb2Rlci53cml0ZUluZm8oaW5mbyk7XG4gICAgaWYgKG9yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChvcmlnaW4pO1xuICAgIH1cbiAgICBpZiAocmlnaHRPcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVSaWdodElEKHJpZ2h0T3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCAmJiByaWdodE9yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnQuX2l0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXJlbnRJdGVtID0gcGFyZW50Ll9pdGVtO1xuICAgICAgICBpZiAocGFyZW50SXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIHBhcmVudCB0eXBlIG9uIHkuX21hcFxuICAgICAgICAgIC8vIGZpbmQgdGhlIGNvcnJlY3Qga2V5XG4gICAgICAgICAgY29uc3QgeWtleSA9IGZpbmRSb290VHlwZUtleShwYXJlbnQpO1xuICAgICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKHRydWUpOyAvLyB3cml0ZSBwYXJlbnRZS2V5XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyh5a2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSk7IC8vIHdyaXRlIHBhcmVudCBpZFxuICAgICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50SXRlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHsgLy8gdGhpcyBlZGdlIGNhc2Ugd2FzIGFkZGVkIGJ5IGRpZmZlcmVudGlhbCB1cGRhdGVzXG4gICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKHRydWUpOyAvLyB3cml0ZSBwYXJlbnRZS2V5XG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcocGFyZW50KTtcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSk7IC8vIHdyaXRlIHBhcmVudCBpZFxuICAgICAgICBlbmNvZGVyLndyaXRlTGVmdElEKHBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmV4cGVjdGVkQ2FzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudFN1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGVudC53cml0ZShlbmNvZGVyLCBvZmZzZXQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvXG4gKi9cbmNvbnN0IHJlYWRJdGVtQ29udGVudCA9IChkZWNvZGVyLCBpbmZvKSA9PiBjb250ZW50UmVmc1tpbmZvICYgQklUUzVdKGRlY29kZXIpO1xuXG4vKipcbiAqIEEgbG9va3VwIG1hcCBmb3IgcmVhZGluZyBJdGVtIGNvbnRlbnQuXG4gKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKFVwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMik6QWJzdHJhY3RDb250ZW50Pn1cbiAqL1xuY29uc3QgY29udGVudFJlZnMgPSBbXG4gICgpID0+IHsgdW5leHBlY3RlZENhc2UoKTsgfSwgLy8gR0MgaXMgbm90IEl0ZW1Db250ZW50XG4gIHJlYWRDb250ZW50RGVsZXRlZCwgLy8gMVxuICByZWFkQ29udGVudEpTT04sIC8vIDJcbiAgcmVhZENvbnRlbnRCaW5hcnksIC8vIDNcbiAgcmVhZENvbnRlbnRTdHJpbmcsIC8vIDRcbiAgcmVhZENvbnRlbnRFbWJlZCwgLy8gNVxuICByZWFkQ29udGVudEZvcm1hdCwgLy8gNlxuICByZWFkQ29udGVudFR5cGUsIC8vIDdcbiAgcmVhZENvbnRlbnRBbnksIC8vIDhcbiAgcmVhZENvbnRlbnREb2MsIC8vIDlcbiAgKCkgPT4geyB1bmV4cGVjdGVkQ2FzZSgpOyB9IC8vIDEwIC0gU2tpcCBpcyBub3QgSXRlbUNvbnRlbnRcbl07XG5cbmNvbnN0IHN0cnVjdFNraXBSZWZOdW1iZXIgPSAxMDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTa2lwIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlbGV0ZSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NraXB9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCBzdHJ1Y3RzIGNhbm5vdCBiZSBpbnRlZ3JhdGVkXG4gICAgdW5leHBlY3RlZENhc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUluZm8oc3RydWN0U2tpcFJlZk51bWJlcik7XG4gICAgLy8gd3JpdGUgYXMgVmFyVWludCBiZWNhdXNlIFNraXBzIGNhbid0IG1ha2UgdXNlIG9mIHByZWRpY3RhYmxlIGxlbmd0aC1lbmNvZGluZ1xuICAgIHdyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCB0aGlzLmxlbmd0aCAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0IHsgQWJzdHJhY3RDb25uZWN0b3IsIEFic3RyYWN0U3RydWN0LCBBYnN0cmFjdFR5cGUsIFlBcnJheSBhcyBBcnJheSwgQ29udGVudEFueSwgQ29udGVudEJpbmFyeSwgQ29udGVudERlbGV0ZWQsIENvbnRlbnRFbWJlZCwgQ29udGVudEZvcm1hdCwgQ29udGVudEpTT04sIENvbnRlbnRTdHJpbmcsIENvbnRlbnRUeXBlLCBEb2MsIEdDLCBJRCwgSXRlbSwgWU1hcCBhcyBNYXAsIFBlcm1hbmVudFVzZXJEYXRhLCBSZWxhdGl2ZVBvc2l0aW9uLCBTbmFwc2hvdCwgWVRleHQgYXMgVGV4dCwgVHJhbnNhY3Rpb24sIFVuZG9NYW5hZ2VyLCBZWG1sRWxlbWVudCBhcyBYbWxFbGVtZW50LCBZWG1sRnJhZ21lbnQgYXMgWG1sRnJhZ21lbnQsIFlYbWxIb29rIGFzIFhtbEhvb2ssIFlYbWxUZXh0IGFzIFhtbFRleHQsIFlBcnJheUV2ZW50LCBZRXZlbnQsIFlNYXBFdmVudCwgWVRleHRFdmVudCwgWVhtbEV2ZW50LCBhcHBseVVwZGF0ZSwgYXBwbHlVcGRhdGVWMiwgY29tcGFyZUlEcywgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zLCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24sIGNyZWF0ZURlbGV0ZVNldCwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLCBjcmVhdGVEb2NGcm9tU25hcHNob3QsIGNyZWF0ZUlELCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04sIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4LCBjcmVhdGVTbmFwc2hvdCwgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiwgZGVjb2RlU25hcHNob3QsIGRlY29kZVNuYXBzaG90VjIsIGRlY29kZVN0YXRlVmVjdG9yLCBkaWZmVXBkYXRlLCBkaWZmVXBkYXRlVjIsIGVtcHR5U25hcHNob3QsIGVuY29kZVJlbGF0aXZlUG9zaXRpb24sIGVuY29kZVNuYXBzaG90LCBlbmNvZGVTbmFwc2hvdFYyLCBlbmNvZGVTdGF0ZUFzVXBkYXRlLCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIsIGVuY29kZVN0YXRlVmVjdG9yLCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUsIGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyLCBlcXVhbFNuYXBzaG90cywgZmluZFJvb3RUeXBlS2V5LCBnZXRJdGVtLCBnZXRTdGF0ZSwgZ2V0VHlwZUNoaWxkcmVuLCBpc0RlbGV0ZWQsIGlzUGFyZW50T2YsIGl0ZXJhdGVEZWxldGVkU3RydWN0cywgbG9nVHlwZSwgbG9nVXBkYXRlLCBsb2dVcGRhdGVWMiwgbWVyZ2VVcGRhdGVzLCBtZXJnZVVwZGF0ZXNWMiwgcGFyc2VVcGRhdGVNZXRhLCBwYXJzZVVwZGF0ZU1ldGFWMiwgcmVhZFVwZGF0ZSwgcmVhZFVwZGF0ZVYyLCByZWxhdGl2ZVBvc2l0aW9uVG9KU09OLCBzbmFwc2hvdCwgdHJhbnNhY3QsIHRyeUdjLCB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCwgdHlwZU1hcEdldFNuYXBzaG90IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD15anMubWpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/yjs/dist/yjs.mjs\n")}},__webpack_module_cache__={};function __webpack_require__(n){var t=__webpack_module_cache__[n];if(void 0!==t)return t.exports;var e=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(e.exports,e,e.exports,__webpack_require__),e.exports}__webpack_require__.n=n=>{var t=n&&n.__esModule?()=>n.default:()=>n;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{var n;__webpack_require__.g.importScripts&&(n=__webpack_require__.g.location+"");var t=__webpack_require__.g.document;if(!n&&t&&(t.currentScript&&(n=t.currentScript.src),!n)){var e=t.getElementsByTagName("script");e.length&&(n=e[e.length-1].src)}if(!n)throw new Error("Automatic publicPath is not supported in this browser");n=n.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),__webpack_require__.p=n})();var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));